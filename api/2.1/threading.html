<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Threading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">2.1.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('threading.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Threading </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ThreadingInitializing">Initializing</a><ul><li class="level2"><a href="#ThreadingInitializingNumberOfThreads">Ideal number of threads</a></li>
<li class="level2"><a href="#ThreadingInitializingCullingMethod">More info about InstancingThreadedCullingMethod</a></li>
</ul>
</li>
<li class="level1"><a href="#ThreadingInOgre">What tasks are threaded in Ogre</a></li>
<li class="level1"><a href="#ThreadingCustomTasks">Using Ogre&#39;s threading system for custom tasks</a></li>
<li class="level1"><a href="#ThreadSafetySceneNodes">Thread safety of SceneNodes</a></li>
</ul>
</div>
<div class="textblock"><p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 uses synchronous threading for some of its operations. This means the main thread wakes up the worker threads, and waits for all worker threads to finish. It also means users don't have to be worried that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using CPU cores while the application is outside a <code>renderOneFrame</code> call.</p>
<h1><a class="anchor" id="ThreadingInitializing"></a>
Initializing</h1>
<p>The number of worker threads must be provided by the user when creating the SceneManager:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> numThreads = 4;</div><div class="line">InstancingTheadedCullingMethod</div><div class="line">        threadedCullingMethod = <a class="code" href="group___scene.html#ggafdd170d87744deec0ca8dd1730797be7a2af3eec2c36adea6197588fe5b768361">INSTANCING_CULLING_THREADED</a>;</div><div class="line"></div><div class="line">mSceneMgr = mRoot-&gt;createSceneManager( <a class="code" href="group___scene.html#gga7383602bd480d43b80c626969b9af914a0af8f844019e52fe112e9a946a919fcd">ST_GENERIC</a>,numThreads,</div><div class="line">                                       threadedCullingMethod,</div><div class="line">                                       <span class="stringliteral">&quot;ExampleSMInstance&quot;</span> );</div></div><!-- fragment --><p>The other threading parameter besides the number of threads, is the threading strategy used for Instancing, which can be single threaded or multithreaded.</p>
<h2><a class="anchor" id="ThreadingInitializingNumberOfThreads"></a>
Ideal number of threads</h2>
<p>The threading model is synchronous, and meant to be used for tasks that take roughly the same amount of time in each thread (which is a very important assumption!). The ideal number of worker threads is the number of logical cores exposed by the CPU (excluding hyperthreading cores).</p>
<p>Spawning more threads than cores will oversubscribe the system and won't run faster. In fact it should only slow it down.</p>
<p>If you plan to use a whole core for your own computations that will run in parallel while renderOneFrame is working (i.e. one thread for physics) and take a significant cpu time from that core; then in this case the ideal number of threads becomes number_of_logical_cores â€“ 1</p>
<p>Whether increasing the number of threads to include hyperthreading cores improves performance or not remains to be tested.</p>
<h2><a class="anchor" id="ThreadingInitializingCullingMethod"></a>
More info about InstancingThreadedCullingMethod</h2>
<p>There are two Instancing techniques that perform culling of their own:</p>
<ul>
<li>HW Basic</li>
<li>HW VTF</li>
</ul>
<p>Frustum culling is highly parallelizable &amp; scalable. However, we first cull InstanceBatches &amp; regular entities, then ask the culled InstanceBatches to perform their culling to the InstancedEntities they own.</p>
<p>This results performance boost for skipping large amounts of instanced entities when the whole batch isn't visible. However, this also means threading frustum culling of instanced entities got harder.</p>
<p>There were four possible approaches:</p>
<ul>
<li>Ask all existing batches to frustum cull. Then use only the ones we want. Sheer brute force. Scales very well with cores, but sacrifices performance unnecessary when only a few batches are visible. This approach is not taken by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>.</li>
<li>Sync every time an InstanceBatchHW or InstanceBatchHW_VTF tries to frustum cull to delegate the job on worker threads. Considering there could be hundreds of InstanceBatches, this would cause a huge amount of thread synchronization overhead &amp; context switches. This approach is not taken by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>.</li>
<li>Each thread after having culled all InstancedBatches &amp; Entities, will parse the culled list to ask all MovableObjects to perform culling of their own. Entities will ignore this call (however they add to a small overhead for traversing them and calling a virtual function) while InstanceBatchHW &amp; InstanceBatchHW_VTF will perform their own culling from within the multiple threads. This approach scales well with cores and only visible batches. However load balancing may be an issue for certain scenes: eg. an InstanceBatch with 5000 InstancedEntities in one thread, while the other three threads get one InstanceBatch each with 50 InstancedEntities. The first thread will have considerably more work to do than the other three. This approach is a good balance when compared to the first two. <b>This is the approach taken by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> when INSTANCING_CULLING_THREADED is on</b></li>
<li>Don't multithread instanced entitites' frustum culling. Only the InstanceBatch &amp; Entity's frustum culling will be threaded. <b>This is what happens when INSTANCING_CULLING_SINGLE is on</b>.</li>
</ul>
<p>Whether INSTANCING_CULLING_THREADED improves or degrades performance depends highly on your scene.</p>
<p>When to use INSTANCING_CULLING_SINGLETHREAD?</p>
<p>If your scene doesn't use HW Basic or HW VTF instancing techniques, or you have very few Instanced entities compared to the amount of regular Entities.</p>
<p>Turning threading on, you'll be wasting your time traversing the list from multiple threads in search of InstanceBatchHW &amp; InstanceBatchHW_VTF</p>
<p>When to use INSTANCING_CULLING_THREADED?</p>
<p>If your scene makes intensive use of HW Basic and/or HW VTF instancing techniques. Note that threaded culling is performed in SCENE_STATIC instances too. The most advantage is seen when the instances per batch is very high and when doing many PASS_SCENE, which require frustum culling multiple times per frame (eg. pssm shadows, multiple light sources with shadows, very advanced compositing, etc)</p>
<p>Note that unlike the number of threads, you can switch between methods at any time at runtime.</p>
<h1><a class="anchor" id="ThreadingInOgre"></a>
What tasks are threaded in Ogre</h1>
<p>The following tasks are partitioned into multiple threads:</p>
<ul>
<li><b>Frustum culling:</b> The pool of all visible Entities, InstanceBatches, etc are frustum culled in multiple threads and added to a culled list, one per thread. When all threads are done, the main thread collects the results from all lists.</li>
<li><b>Culling the receiver's box:</b> Very specific to shadow nodes. When a render_scene pass uses (for example) render queues 4 to 8, but the shadow node users render queues 0 to 8; the shadow node needs receiver's aabb data from RQs 0 to 3; which aren't available. It is very similar to frustum culling; except that the cull list isn't produced, only the aabb is calculated. Since aabb merges are associative: <div class="image">
<object type="image/svg+xml" data="aabb_merge.svg">aabb_merge.svg</object>
</div>
 we can join the results from all threads after they're done. In fact, we even exploit this associative property to process them using SIMD.</li>
<li>Node transform updates: Updating all scene nodes' derived position and orientation by inheriting from their parent's derived position &amp; orientation. We have to wait for every parent level depth due to data dependencies.</li>
<li>Updating all bounds: Updating the World AABB by applying the node's transform to the local aabbs. The World AABB is needed for correct frustum culling, among other things.</li>
<li>Frustum culling instanced entities: <a href="#5.1.1.More info about InstancingThreadedCullingMethod|outline">See previous section</a>.</li>
</ul>
<h1><a class="anchor" id="ThreadingCustomTasks"></a>
Using Ogre's threading system for custom tasks</h1>
<p>While often users may want to user their own threading system; it is possible to ask <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to process their own task using its worker threads. Users need to inherit from <code>UniformScalableTask</code> and call <code>SceneManager::executeUserScalableTask</code>.</p>
<p>The following example prints a message to the console from the multipler worker threads:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_ogre_uniform_scalable_task_8h.html">Threading/OgreUniformScalableTask.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyThreadedTask : <span class="keyword">public</span> <a class="code" href="class_ogre_1_1_uniform_scalable_task.html">Ogre::UniformScalableTask</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_ogre_1_1_uniform_scalable_task.html#ad338932c0cd004166628573d83cf260f">execute</a>( <span class="keywordtype">size_t</span> threadId, <span class="keywordtype">size_t</span> numThreads )</div><div class="line">    {</div><div class="line">        printf( <span class="stringliteral">&quot;Hello world from thread %i&quot;</span>,threadId );</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// assumes Ogre is initialized and sceneMgr is a valid ptr</span></div><div class="line">    <a class="code" href="class_ogre_1_1_scene_manager.html">Ogre::SceneManager</a> *sceneMgr;</div><div class="line"></div><div class="line">    MyThreadedTask myThreadedTask;</div><div class="line">    sceneMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a040241bad11b74f5ba8971fb146f8c6d">executeUserScalableTask</a>( myThreadedTask,<span class="keyword">true</span> );</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Parameter <code>threadId</code> is guaranteed to be in range [0; numThreads) while parameter <code>numThreads</code> is the total number of worker threads spawned by that SceneManager.</p>
<p><code>executeUserScalableTask</code> will block until all threads are done. If you do not wish to block; you can pass false to the second argument and then call <code>waitForPendingUserScalableTask</code> to block until done:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// assumes Ogre is intialized and sceneMgr is a valid ptr</span></div><div class="line">    SceneManager *sceneMgr;</div><div class="line"></div><div class="line">    MyThreadedTask myThreadedTask;</div><div class="line">    sceneMgr-&gt;executeUserScalableTask( myThreadedTask, <span class="keyword">false</span> );</div><div class="line"></div><div class="line">    doSomeWork();</div><div class="line">    printf( <span class="stringliteral">&quot;I am going to sleep now&quot;</span> );</div><div class="line"></div><div class="line">    sceneMgr-&gt;waitForPendingUserScalableTask();</div><div class="line"></div><div class="line">    printf( <span class="stringliteral">&quot;All worker threads finished. Resuming execution of main thread&quot;</span> );</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><blockquote class="doxtable">
<p>Attention!</p>
<p>You <b>must</b> call <em>waitForPendingUserScalableTask</em> after calling <em>executeUserScalableTask</em>( myThreadedTask, false ) before <em>executeUserScalableTask</em> can be called again. Otherwise deadlocks are bound to happen and <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes no integrity checks. Queuing or scheduling of multiples tasks is not supported. This system is for synchronous multithreading, not for asynchronous tasks. </p>
</blockquote>
<h1><a class="anchor" id="ThreadSafetySceneNodes"></a>
Thread safety of SceneNodes</h1>
<p>In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x; SceneNodes weren't thread safe at all, not even <code>setPosition</code> or <code>_getDerivedPosition</code>.</p>
<p>In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.x, the following <b>operations are not thread safe</b>:</p>
<ul>
<li><b>Creating or destroying nodes/entities</b>. Don't create a SceneNode while there are scene nodes being used in other threads. It can screw the unique ID and their assignment into the global vector we use to keep track of created nodes. Furthermore The node's memory manager may ran out of memory in its pool and reconstruct the Transform's SoA pointers (it's similar to how <code>std::vector</code> invalidates all iterators when resizing). If that happens, all SceneNodes will be in an inconsistent state. Inversely, if too many nodes have been removed, the manager may decide it's time for a cleanup, in which case many SceneNodes can become in an inconsistent state until the cleanup finishes. How large the pool reserve is can be tweaked, and how often the manager performs can also be tweaked (<code>NodeMemoryManager</code>), though. If the user knows what he's doing the race condition might be possible to avoid. Note other SceneManager implementations may have to fulfill their own needs and introduce race conditions of their own we can't predict.</li>
<li><b>Changing parent / child relationships</b>. Attaching/detaching a node from another one causes its SoA memory to migrate to a different node memory manager, which can trigger a cleanup and/or one of the managers rans out of memory and has to reconstruct.</li>
<li><b>Calling _getDerivedPositionUpdated &amp; Co (all functions that end in "Updated")</b>. These functions will update the derived transforms all way up to the ultimate parent (i.e. root). However in SIMD builds, these updates are performed on 4 nodes at a time (the actual number is not 4, but rather depends on <code>ARRAY_PACKED_REALS</code>). Calling this function could only be thread safe if all all four nodes are in the same thread AND their parents are also on the same thread (parents may not share the same block, thus worst case scenario <code>4 * 4 = 16</code> parent nodes have to be in the same thread, not to mention their parents too <code>4 * 4 * 4 = 64</code>) AND the children of these parents are not calling <code>_getDerivedPositionUpdated</code> too from a different thread.</li>
</ul>
<p>The following operations are thread-safe:</p>
<ul>
<li><b>Calling getPosition &amp; Co (getOrientation, getScale, getInheritOrientation, etc), _getDerivedPosition &amp; Co (_getDerivedOrientation, etc)</b> unless you're calling <code>getPosition</code> and <code>setPosition</code> to the same Node from different threads.</li>
<li><b>Calling setPosition, setOrientation, setScale</b>. Note on SIMD builds, 4 Nodes can easily share the same 64 byte line, thus it is advisable that all 4 Nodes to be sent to the same thread to reduce the number of false cache sharing performance hits. Calling setPosition to the same Node from different threads is not supported.</li>
<li><b>Calling _setDerivedPosition, _setDerivedOrientation, _setDerivedScale</b> (which assumes the derived transforms are up to date)</li>
</ul>
<p>With <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0; it is now possible to transfer the position &amp; orientation from a physics engine to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Scene Nodes using a parallel for. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x limitations forced this update to be done in a single thread. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
