<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::SceneManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">2.1.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_scene_manager.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_ogre_1_1_scene_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::SceneManager Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___core.html">Core</a> &#124; <a class="el" href="group___component.html">Component</a> &raquo; <a class="el" href="group___scene.html">Scene</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Manages the organisation and rendering of a 'scene' i.e.  
 <a href="class_ogre_1_1_scene_manager.html#details">More...</a></p>

<p><code>#include &lt;OgreSceneManager.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::SceneManager:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_scene_manager__inherit__graph.svg" width="216" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager_1_1_listener.html">Listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that allows listening in on the various stages of <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> processing, so that custom behaviour can be implemented from outside.  <a href="class_ogre_1_1_scene_manager_1_1_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_scene_manager_1_1_render_context.html">RenderContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_scene_manager_1_1_sky_box_gen_parameters.html">SkyBoxGenParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_scene_manager_1_1_sky_dome_gen_parameters.html">SkyDomeGenParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_scene_manager_1_1_sky_plane_gen_parameters.html">SkyPlaneGenParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3a720414f68274bb9c5026911e27135d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_map_iterator.html">MapIterator</a>&lt; AnimationList &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a3a720414f68274bb9c5026911e27135d">AnimationIterator</a></td></tr>
<tr class="separator:a3a720414f68274bb9c5026911e27135d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460e50da4b97d1beaef1a64bfa039928"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt; CameraList &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a460e50da4b97d1beaef1a64bfa039928">CameraIterator</a></td></tr>
<tr class="separator:a460e50da4b97d1beaef1a64bfa039928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51db39cc4fa15b28086a1793d42fc827"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a51db39cc4fa15b28086a1793d42fc827">IlluminationRenderStage</a> { <a class="el" href="class_ogre_1_1_scene_manager.html#a51db39cc4fa15b28086a1793d42fc827a8fd3e7fb8fab382a9d29e6e081ae556a">IRS_NONE</a>, 
<a class="el" href="class_ogre_1_1_scene_manager.html#a51db39cc4fa15b28086a1793d42fc827a8f99da7404ae8c16199dde8d34367b1a">IRS_RENDER_TO_TEXTURE</a>
 }</td></tr>
<tr class="memdesc:a51db39cc4fa15b28086a1793d42fc827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the stage of rendering when performing complex illumination.  <a href="class_ogre_1_1_scene_manager.html#a51db39cc4fa15b28086a1793d42fc827">More...</a><br /></td></tr>
<tr class="separator:a51db39cc4fa15b28086a1793d42fc827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5348867645ff727d1ca25dd89795376"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_scene_manager.html#a6d8f5f81e262b6347f5066da27d6fe70">MovableObjectVec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#af5348867645ff727d1ca25dd89795376">MovableObjectIterator</a></td></tr>
<tr class="separator:af5348867645ff727d1ca25dd89795376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8f5f81e262b6347f5066da27d6fe70"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a6d8f5f81e262b6347f5066da27d6fe70">MovableObjectVec</a></td></tr>
<tr class="separator:a6d8f5f81e262b6347f5066da27d6fe70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c2ff4f6c76f7fe0a8eae76f2a84cbf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ab4c2ff4f6c76f7fe0a8eae76f2a84cbf">PrefabType</a> { <a class="el" href="class_ogre_1_1_scene_manager.html#ab4c2ff4f6c76f7fe0a8eae76f2a84cbfaf0fb654fb98508a564c17d3d5b2feee3">PT_PLANE</a>, 
<a class="el" href="class_ogre_1_1_scene_manager.html#ab4c2ff4f6c76f7fe0a8eae76f2a84cbfa25b0181d24b783ab75da2520305d292a">PT_CUBE</a>, 
<a class="el" href="class_ogre_1_1_scene_manager.html#ab4c2ff4f6c76f7fe0a8eae76f2a84cbfa0f94148c2cfe190f3ea04374af220eba">PT_SPHERE</a>
 }</td></tr>
<tr class="memdesc:ab4c2ff4f6c76f7fe0a8eae76f2a84cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefab shapes available without loading a model.  <a href="class_ogre_1_1_scene_manager.html#ab4c2ff4f6c76f7fe0a8eae76f2a84cbf">More...</a><br /></td></tr>
<tr class="separator:ab4c2ff4f6c76f7fe0a8eae76f2a84cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f87c38314b272fff95da3065f3740ee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a8f87c38314b272fff95da3065f3740ee">SceneNodeList</a></td></tr>
<tr class="separator:a8f87c38314b272fff95da3065f3740ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae779d9309751113de23917f12af69bbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae779d9309751113de23917f12af69bbf">SceneManager</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;instanceName, size_t numWorkerThreads, <a class="el" href="group___scene.html#gafdd170d87744deec0ca8dd1730797be7">InstancingThreadedCullingMethod</a> threadedCullingMethod)</td></tr>
<tr class="memdesc:ae779d9309751113de23917f12af69bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ae779d9309751113de23917f12af69bbf">More...</a><br /></td></tr>
<tr class="separator:ae779d9309751113de23917f12af69bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8b9108b44339a321bc69b25a0c0a1a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a6c8b9108b44339a321bc69b25a0c0a1a">~SceneManager</a> ()</td></tr>
<tr class="memdesc:a6c8b9108b44339a321bc69b25a0c0a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#a6c8b9108b44339a321bc69b25a0c0a1a">More...</a><br /></td></tr>
<tr class="separator:a6c8b9108b44339a321bc69b25a0c0a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0b98113bf8c46fc2413f09326b9c9e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9f0b98113bf8c46fc2413f09326b9c9e">_addAutotrackingSceneNode</a> (<a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *source, <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *target, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;offset, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;localDirection)</td></tr>
<tr class="memdesc:a9f0b98113bf8c46fc2413f09326b9c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for notifying the manager that a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> is autotracking.  <a href="#a9f0b98113bf8c46fc2413f09326b9c9e">More...</a><br /></td></tr>
<tr class="separator:a9f0b98113bf8c46fc2413f09326b9c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4134b90be26b23aff4dc05ae89840862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a4134b90be26b23aff4dc05ae89840862">_addCompositorTexture</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a> *texs)</td></tr>
<tr class="memdesc:a4134b90be26b23aff4dc05ae89840862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by Compositor, tells of which compositor textures active, so Materials can access them.  <a href="#a4134b90be26b23aff4dc05ae89840862">More...</a><br /></td></tr>
<tr class="separator:a4134b90be26b23aff4dc05ae89840862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9c54dae09ee2532723cb2d5632be24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9a9c54dae09ee2532723cb2d5632be24">_addWireAabb</a> (<a class="el" href="class_ogre_1_1_wire_aabb.html">WireAabb</a> *wireAabb)</td></tr>
<tr class="separator:a9a9c54dae09ee2532723cb2d5632be24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58019e4c5104af4fe19d483fb1deec91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a58019e4c5104af4fe19d483fb1deec91">_applySceneAnimations</a> (void)</td></tr>
<tr class="memdesc:a58019e4c5104af4fe19d483fb1deec91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for applying animations to scene nodes.  <a href="#a58019e4c5104af4fe19d483fb1deec91">More...</a><br /></td></tr>
<tr class="separator:a58019e4c5104af4fe19d483fb1deec91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7806fd7b6e943c67d80f23de0b3b518"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#af7806fd7b6e943c67d80f23de0b3b518">_areRenderStateChangesSuppressed</a> (void) const</td></tr>
<tr class="memdesc:af7806fd7b6e943c67d80f23de0b3b518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are render state changes suppressed?  <a href="#af7806fd7b6e943c67d80f23de0b3b518">More...</a><br /></td></tr>
<tr class="separator:af7806fd7b6e943c67d80f23de0b3b518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245b17763b78ee37c0c281209c43cefd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a245b17763b78ee37c0c281209c43cefd">_calculateCurrentCastersBox</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> viewportVisibilityMask, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> firstRq, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> lastRq) const</td></tr>
<tr class="separator:a245b17763b78ee37c0c281209c43cefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eced0cf629b0e1d9dcdc9dc91d9fe7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a44eced0cf629b0e1d9dcdc9dc91d9fe7">_createSceneNode</a> (<a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *parent, <a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a> *nodeMemoryManager)</td></tr>
<tr class="separator:a44eced0cf629b0e1d9dcdc9dc91d9fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390dbb45459db4b8666ce4952a8d7353"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_tag_point.html">TagPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a390dbb45459db4b8666ce4952a8d7353">_createTagPoint</a> (<a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *parent, <a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a> *nodeMemoryManager)</td></tr>
<tr class="memdesc:a390dbb45459db4b8666ce4952a8d7353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't call this function directly.  <a href="#a390dbb45459db4b8666ce4952a8d7353">More...</a><br /></td></tr>
<tr class="separator:a390dbb45459db4b8666ce4952a8d7353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c44b63c286856417261e165cca88296"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a4c44b63c286856417261e165cca88296">_cullPhase01</a> (<a class="el" href="class_ogre_1_1_camera.html">Camera</a> *camera, const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *lodCamera, <a class="el" href="class_ogre_1_1_viewport.html">Viewport</a> *vp, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> firstRq, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> lastRq)</td></tr>
<tr class="memdesc:a4c44b63c286856417261e165cca88296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the frustum culling that will later be needed by _renderPhase02.  <a href="#a4c44b63c286856417261e165cca88296">More...</a><br /></td></tr>
<tr class="separator:a4c44b63c286856417261e165cca88296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8061e52306ec97f0a5039e1f0cf79d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ac8061e52306ec97f0a5039e1f0cf79d3">_frameEnded</a> (void)</td></tr>
<tr class="memdesc:ac8061e52306ec97f0a5039e1f0cf79d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the frame has fully ended (ALL passes have been executed to all RTTs)  <a href="#ac8061e52306ec97f0a5039e1f0cf79d3">More...</a><br /></td></tr>
<tr class="separator:ac8061e52306ec97f0a5039e1f0cf79d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0762e122fb47a25ffde29b5ae8969a41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_forward_plus_base.html">ForwardPlusBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a0762e122fb47a25ffde29b5ae8969a41">_getActivePassForwardPlus</a> (void)</td></tr>
<tr class="separator:a0762e122fb47a25ffde29b5ae8969a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981ad410d5a077bb64938685e10fcee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a981ad410d5a077bb64938685e10fcee0">_getCombinedVisibilityMask</a> (void) const</td></tr>
<tr class="memdesc:a981ad410d5a077bb64938685e10fcee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for getting the combination between the global visibility mask and the per-viewport visibility mask.  <a href="#a981ad410d5a077bb64938685e10fcee0">More...</a><br /></td></tr>
<tr class="separator:a981ad410d5a077bb64938685e10fcee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa36e203e1ba3eeab880e4c51a51efae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_manager.html#a51db39cc4fa15b28086a1793d42fc827">IlluminationRenderStage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aaa36e203e1ba3eeab880e4c51a51efae">_getCurrentRenderStage</a> () const</td></tr>
<tr class="separator:aaa36e203e1ba3eeab880e4c51a51efae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd7c70305104c508f85f339e423e973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a1cd7c70305104c508f85f339e423e973">_getEntityMemoryManager</a> (<a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType)</td></tr>
<tr class="memdesc:a1cd7c70305104c508f85f339e423e973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the main entity memory manager.  <a href="#a1cd7c70305104c508f85f339e423e973">More...</a><br /></td></tr>
<tr class="separator:a1cd7c70305104c508f85f339e423e973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90fc3ef537c55399c6680d84d26edaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae90fc3ef537c55399c6680d84d26edaf">_getLightMemoryManager</a> (void)</td></tr>
<tr class="separator:ae90fc3ef537c55399c6680d84d26edaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad732f23cbf6537f5919d347932fa542"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aad732f23cbf6537f5919d347932fa542">_getNodeMemoryManager</a> (<a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType)</td></tr>
<tr class="separator:aad732f23cbf6537f5919d347932fa542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ec4470160bb92356ae647f70fa9add"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa9ec4470160bb92356ae647f70fa9add">_getTagPointNodeMemoryManager</a> (void)</td></tr>
<tr class="separator:aa9ec4470160bb92356ae647f70fa9add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27460861e2dd924d914ec21987993b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___scene.html#ga21ffab3c275854b773dcd9efeba9152c">VisibleObjectsPerThreadArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa27460861e2dd924d914ec21987993b4">_getTmpVisibleObjectsList</a> ()</td></tr>
<tr class="memdesc:aa27460861e2dd924d914ec21987993b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">mTmpVisibleObjects  <a href="#aa27460861e2dd924d914ec21987993b4">More...</a><br /></td></tr>
<tr class="separator:aa27460861e2dd924d914ec21987993b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e39912a34617ffa0455f859ec438c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a72e39912a34617ffa0455f859ec438c3">_handleLodEvents</a> ()</td></tr>
<tr class="memdesc:a72e39912a34617ffa0455f859ec438c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle LOD events.  <a href="#a72e39912a34617ffa0455f859ec438c3">More...</a><br /></td></tr>
<tr class="separator:a72e39912a34617ffa0455f859ec438c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac631d25ab65e821544835bfa1b507fc2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ac631d25ab65e821544835bfa1b507fc2">_markGpuParamsDirty</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> mask)</td></tr>
<tr class="memdesc:ac631d25ab65e821544835bfa1b507fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to allow you to mark gpu parameters as dirty, causing them to be updated according to the mask that you set when updateGpuProgramParameters is next called.  <a href="#ac631d25ab65e821544835bfa1b507fc2">More...</a><br /></td></tr>
<tr class="separator:ac631d25ab65e821544835bfa1b507fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272d1a76e7854e51f824f0099a4910cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a272d1a76e7854e51f824f0099a4910cf">_notifyEntityMaterialLodChanged</a> (<a class="el" href="struct_ogre_1_1_entity_material_lod_changed_event.html">EntityMaterialLodChangedEvent</a> &amp;evt)</td></tr>
<tr class="memdesc:a272d1a76e7854e51f824f0099a4910cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify that an entity material LOD change event has occurred.  <a href="#a272d1a76e7854e51f824f0099a4910cf">More...</a><br /></td></tr>
<tr class="separator:a272d1a76e7854e51f824f0099a4910cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a84e6426cad7dfd721fb5fccd9976c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ad0a84e6426cad7dfd721fb5fccd9976c">_notifyEntityMeshLodChanged</a> (<a class="el" href="struct_ogre_1_1_entity_mesh_lod_changed_event.html">EntityMeshLodChangedEvent</a> &amp;evt)</td></tr>
<tr class="memdesc:ad0a84e6426cad7dfd721fb5fccd9976c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify that an entity mesh LOD change event has occurred.  <a href="#ad0a84e6426cad7dfd721fb5fccd9976c">More...</a><br /></td></tr>
<tr class="separator:ad0a84e6426cad7dfd721fb5fccd9976c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b6a7748dc4273fd6c160fb162c544f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae4b6a7748dc4273fd6c160fb162c544f">_notifyMovableObjectLodChanged</a> (<a class="el" href="struct_ogre_1_1_movable_object_lod_changed_event.html">MovableObjectLodChangedEvent</a> &amp;evt)</td></tr>
<tr class="memdesc:ae4b6a7748dc4273fd6c160fb162c544f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify that a movable object LOD change event has occurred.  <a href="#ae4b6a7748dc4273fd6c160fb162c544f">More...</a><br /></td></tr>
<tr class="separator:ae4b6a7748dc4273fd6c160fb162c544f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2392e8d6a6849a4fa1839a085733a695"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_ogre_1_1_scene_manager_1_1_render_context.html">RenderContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a2392e8d6a6849a4fa1839a085733a695">_pauseRendering</a> ()</td></tr>
<tr class="memdesc:a2392e8d6a6849a4fa1839a085733a695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause rendering of the frame.  <a href="#a2392e8d6a6849a4fa1839a085733a695">More...</a><br /></td></tr>
<tr class="separator:a2392e8d6a6849a4fa1839a085733a695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f817bd7ceae5bb1601b9b838eaff80"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a85f817bd7ceae5bb1601b9b838eaff80">_queueSkiesForRendering</a> (<a class="el" href="class_ogre_1_1_camera.html">Camera</a> *cam)</td></tr>
<tr class="memdesc:a85f817bd7ceae5bb1601b9b838eaff80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for queueing the sky objects with the params as previously set through setSkyBox, setSkyPlane and setSkyDome.  <a href="#a85f817bd7ceae5bb1601b9b838eaff80">More...</a><br /></td></tr>
<tr class="separator:a85f817bd7ceae5bb1601b9b838eaff80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75673d9890a711b6de478ddab53d1aa9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a75673d9890a711b6de478ddab53d1aa9">_removeAutotrackingSceneNode</a> (<a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *source)</td></tr>
<tr class="separator:a75673d9890a711b6de478ddab53d1aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351700ac72df07006c59e1aa07dded7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a351700ac72df07006c59e1aa07dded7c">_removeCompositorTextures</a> (size_t from)</td></tr>
<tr class="memdesc:a351700ac72df07006c59e1aa07dded7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all compositor textures from 'from' to end.  <a href="#a351700ac72df07006c59e1aa07dded7c">More...</a><br /></td></tr>
<tr class="separator:a351700ac72df07006c59e1aa07dded7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadb06373ea8f59dc573bfd1d8e03713"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#adadb06373ea8f59dc573bfd1d8e03713">_removeWireAabb</a> (<a class="el" href="class_ogre_1_1_wire_aabb.html">WireAabb</a> *wireAabb)</td></tr>
<tr class="separator:adadb06373ea8f59dc573bfd1d8e03713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92635a6112f5f1215c2bc2e59003127"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae92635a6112f5f1215c2bc2e59003127">_renderPhase02</a> (<a class="el" href="class_ogre_1_1_camera.html">Camera</a> *camera, const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *lodCamera, <a class="el" href="class_ogre_1_1_viewport.html">Viewport</a> *vp, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> firstRq, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> lastRq, bool includeOverlays)</td></tr>
<tr class="memdesc:ae92635a6112f5f1215c2bc2e59003127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prompts the class to send its contents to the renderer.  <a href="#ae92635a6112f5f1215c2bc2e59003127">More...</a><br /></td></tr>
<tr class="separator:ae92635a6112f5f1215c2bc2e59003127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32663cfb04485c2643a24a1240240c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae32663cfb04485c2643a24a1240240c2">_renderSingleObject</a> (<a class="el" href="class_ogre_1_1_renderable.html">Renderable</a> *pRend, const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *pMovableObject, bool casterPass, bool dualParaboloid)</td></tr>
<tr class="separator:ae32663cfb04485c2643a24a1240240c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f763bb92fef8b1238e2272889ba58d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a27f763bb92fef8b1238e2272889ba58d">_resumeRendering</a> (<a class="el" href="struct_ogre_1_1_scene_manager_1_1_render_context.html">RenderContext</a> *context)</td></tr>
<tr class="memdesc:a27f763bb92fef8b1238e2272889ba58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume rendering of the frame.  <a href="#a27f763bb92fef8b1238e2272889ba58d">More...</a><br /></td></tr>
<tr class="separator:a27f763bb92fef8b1238e2272889ba58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418bc67069b6ed65fd862f3efaa6a0d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a418bc67069b6ed65fd862f3efaa6a0d9">_setCameraInProgress</a> (<a class="el" href="class_ogre_1_1_camera.html">Camera</a> *camera)</td></tr>
<tr class="separator:a418bc67069b6ed65fd862f3efaa6a0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0e6b3f96d0740a12ccba7c829e394f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#afa0e6b3f96d0740a12ccba7c829e394f">_setCompositorTarget</a> (const <a class="el" href="struct_ogre_1_1_compositor_texture.html">CompositorTexture</a> &amp;compoTarget)</td></tr>
<tr class="memdesc:afa0e6b3f96d0740a12ccba7c829e394f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compositor we are currently writing to.  <a href="#afa0e6b3f96d0740a12ccba7c829e394f">More...</a><br /></td></tr>
<tr class="separator:afa0e6b3f96d0740a12ccba7c829e394f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd809e69cbbc4b565a27b8edef98ad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#acdd809e69cbbc4b565a27b8edef98ad1">_setCurrentCompositorPass</a> (<a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *pass)</td></tr>
<tr class="separator:acdd809e69cbbc4b565a27b8edef98ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f751eb7bce6624985c304f878d51d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a77f751eb7bce6624985c304f878d51d9">_setCurrentRenderStage</a> (<a class="el" href="class_ogre_1_1_scene_manager.html#a51db39cc4fa15b28086a1793d42fc827">IlluminationRenderStage</a> stage)</td></tr>
<tr class="separator:a77f751eb7bce6624985c304f878d51d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae333535bc17cb63a4500d4301b7270a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae333535bc17cb63a4500d4301b7270a0">_setCurrentShadowNode</a> (<a class="el" href="class_ogre_1_1_compositor_shadow_node.html">CompositorShadowNode</a> *shadowNode, bool isReused)</td></tr>
<tr class="separator:ae333535bc17cb63a4500d4301b7270a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20c0ee49a853145d3350e6e32c59f32"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ab20c0ee49a853145d3350e6e32c59f32">_setDestinationRenderSystem</a> (<a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *sys)</td></tr>
<tr class="memdesc:ab20c0ee49a853145d3350e6e32c59f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the scene manager of its destination render system.  <a href="#ab20c0ee49a853145d3350e6e32c59f32">More...</a><br /></td></tr>
<tr class="separator:ab20c0ee49a853145d3350e6e32c59f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507d273b53104fb5b8c835bc0c7ce73a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a507d273b53104fb5b8c835bc0c7ce73a">_setForwardPlusEnabledInPass</a> (bool bEnable)</td></tr>
<tr class="memdesc:a507d273b53104fb5b8c835bc0c7ce73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use.  <a href="#a507d273b53104fb5b8c835bc0c7ce73a">More...</a><br /></td></tr>
<tr class="separator:a507d273b53104fb5b8c835bc0c7ce73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa484c6a44eaae0ec7ce646b51d6dc8c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa484c6a44eaae0ec7ce646b51d6dc8c3">_setLightCullingVisibility</a> (<a class="el" href="class_ogre_1_1_camera.html">Camera</a> *camera, bool collectLights, bool isCubemap)</td></tr>
<tr class="memdesc:aa484c6a44eaae0ec7ce646b51d6dc8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_ogre_1_1_camera.html#ae458966f06b60f6bc658ae8606e77b9e" title="When a camera is created via SceneManager::createCamera, there are two additional parameters...">Camera::setLightCullingVisibility</a>.  <a href="#aa484c6a44eaae0ec7ce646b51d6dc8c3">More...</a><br /></td></tr>
<tr class="separator:aa484c6a44eaae0ec7ce646b51d6dc8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c4733279dbd3bc63a6b0f7f8b3ce26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ad8c4733279dbd3bc63a6b0f7f8b3ce26">_setPrePassMode</a> (<a class="el" href="group___general.html#ga63b5ab6176b81463bbdd0e260b751d2e">PrePassMode</a> mode, const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a> *prepassTextures, const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a> *prepassDepthTexture, const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a> *ssrTexture)</td></tr>
<tr class="memdesc:ad8c4733279dbd3bc63a6b0f7f8b3ce26"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use.  <a href="#ad8c4733279dbd3bc63a6b0f7f8b3ce26">More...</a><br /></td></tr>
<tr class="separator:ad8c4733279dbd3bc63a6b0f7f8b3ce26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f180b2925e6a9c674c62e058812f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae66f180b2925e6a9c674c62e058812f6">_setSkyBox</a> (bool enable, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> renderQueue, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> distance=5000, const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;orientation=<a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>
<tr class="memdesc:ae66f180b2925e6a9c674c62e058812f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables / disables a 'sky box' i.e.  <a href="#ae66f180b2925e6a9c674c62e058812f6">More...</a><br /></td></tr>
<tr class="separator:ae66f180b2925e6a9c674c62e058812f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87f1a79eca331be85091d3fda822f1d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa87f1a79eca331be85091d3fda822f1d">_setSkyDome</a> (bool enable, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> renderQueue, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> curvature=10, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> tiling=8, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> distance=4000, const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;orientation=<a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>, int xsegments=16, int ysegments=16, int ysegments_keep=-1, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>
<tr class="memdesc:aa87f1a79eca331be85091d3fda822f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables / disables a 'sky dome' i.e.  <a href="#aa87f1a79eca331be85091d3fda822f1d">More...</a><br /></td></tr>
<tr class="separator:aa87f1a79eca331be85091d3fda822f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf94cda8c24ed07cc048a463cfbd9750"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#acf94cda8c24ed07cc048a463cfbd9750">_setSkyPlane</a> (bool enable, const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;plane, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> renderQueue, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> scale=1000, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> tiling=10, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> bow=0, int xsegments=1, int ysegments=1, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>
<tr class="memdesc:acf94cda8c24ed07cc048a463cfbd9750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables / disables a 'sky plane' i.e.  <a href="#acf94cda8c24ed07cc048a463cfbd9750">More...</a><br /></td></tr>
<tr class="separator:acf94cda8c24ed07cc048a463cfbd9750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e6d992a1176c83872afa56ab07bbc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a24e6d992a1176c83872afa56ab07bbc2">_setViewport</a> (<a class="el" href="class_ogre_1_1_viewport.html">Viewport</a> *vp)</td></tr>
<tr class="separator:a24e6d992a1176c83872afa56ab07bbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6753ea2b52715774b7fdd59da232917a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a6753ea2b52715774b7fdd59da232917a">_suppressRenderStateChanges</a> (bool suppress)</td></tr>
<tr class="memdesc:a6753ea2b52715774b7fdd59da232917a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates to the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> whether it should suppress changing the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API. ">RenderSystem</a> states when rendering objects.  <a href="#a6753ea2b52715774b7fdd59da232917a">More...</a><br /></td></tr>
<tr class="separator:a6753ea2b52715774b7fdd59da232917a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9959c0abe638bebd7ad2a30abc23ca2e"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9959c0abe638bebd7ad2a30abc23ca2e">_updateWorkerThread</a> (<a class="el" href="class_ogre_1_1_thread_handle.html">ThreadHandle</a> *threadHandle)</td></tr>
<tr class="memdesc:a9959c0abe638bebd7ad2a30abc23ca2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from the worker thread, polls to process frustum culling requests when a sync is performed.  <a href="#a9959c0abe638bebd7ad2a30abc23ca2e">More...</a><br /></td></tr>
<tr class="separator:a9959c0abe638bebd7ad2a30abc23ca2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b54e34b6a8e72d4c1456bda016731ad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a6b54e34b6a8e72d4c1456bda016731ad">addListener</a> (<a class="el" href="class_ogre_1_1_scene_manager_1_1_listener.html">Listener</a> *s)</td></tr>
<tr class="memdesc:a6b54e34b6a8e72d4c1456bda016731ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a listener which will get called back on scene manager events.  <a href="#a6b54e34b6a8e72d4c1456bda016731ad">More...</a><br /></td></tr>
<tr class="separator:a6b54e34b6a8e72d4c1456bda016731ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac761cb112de51be26c54609de3c83a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a2ac761cb112de51be26c54609de3c83a">addLodListener</a> (<a class="el" href="class_ogre_1_1_lod_listener.html">LodListener</a> *listener)</td></tr>
<tr class="memdesc:a2ac761cb112de51be26c54609de3c83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a level of detail listener.  <a href="#a2ac761cb112de51be26c54609de3c83a">More...</a><br /></td></tr>
<tr class="separator:a2ac761cb112de51be26c54609de3c83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73819442f7f3540f52431064e6b1a97"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ab73819442f7f3540f52431064e6b1a97">addRenderObjectListener</a> (<a class="el" href="class_ogre_1_1_render_object_listener.html">RenderObjectListener</a> *newListener)</td></tr>
<tr class="memdesc:ab73819442f7f3540f52431064e6b1a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new Render Object <a class="el" href="class_ogre_1_1_scene_manager_1_1_listener.html" title="Class that allows listening in on the various stages of SceneManager processing, so that custom behav...">Listener</a> which will be notified when rendering an object.  <a href="#ab73819442f7f3540f52431064e6b1a97">More...</a><br /></td></tr>
<tr class="separator:ab73819442f7f3540f52431064e6b1a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60242c5d130f884cd605d3393186df6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae60242c5d130f884cd605d3393186df6">addRenderQueueListener</a> (<a class="el" href="class_ogre_1_1_render_queue_listener.html">RenderQueueListener</a> *newListener)</td></tr>
<tr class="memdesc:ae60242c5d130f884cd605d3393186df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new <a class="el" href="class_ogre_1_1_render_queue_listener.html" title="Abstract interface which classes must implement if they wish to receive events from the render queue...">RenderQueueListener</a> which will be notified when render queues are processed.  <a href="#ae60242c5d130f884cd605d3393186df6">More...</a><br /></td></tr>
<tr class="separator:ae60242c5d130f884cd605d3393186df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1200037971723674d993871980e0516a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a1200037971723674d993871980e0516a">clearFrameData</a> (void)</td></tr>
<tr class="memdesc:a1200037971723674d993871980e0516a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears temporary buffers and other data that needs to live every frame.  <a href="#a1200037971723674d993871980e0516a">More...</a><br /></td></tr>
<tr class="separator:a1200037971723674d993871980e0516a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ba0aad5090ed0a8ff5e9c3d24fa924"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a01ba0aad5090ed0a8ff5e9c3d24fa924">clearScene</a> (bool deleteIndestructibleToo, bool reattachCameras=true)</td></tr>
<tr class="memdesc:a01ba0aad5090ed0a8ff5e9c3d24fa924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc.  <a href="#a01ba0aad5090ed0a8ff5e9c3d24fa924">More...</a><br /></td></tr>
<tr class="separator:a01ba0aad5090ed0a8ff5e9c3d24fa924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb1523180fcc65b6093b6330725c823"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_axis_aligned_box_scene_query.html">AxisAlignedBoxSceneQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a2cb1523180fcc65b6093b6330725c823">createAABBQuery</a> (const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;box, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> mask=<a class="el" href="class_ogre_1_1_scene_manager.html#a6c140ffaced93a2b854e5c519c8fb568">QUERY_ENTITY_DEFAULT_MASK</a>)</td></tr>
<tr class="memdesc:a2cb1523180fcc65b6093b6330725c823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="class_ogre_1_1_axis_aligned_box_scene_query.html" title="Specialises the SceneQuery class for querying within an axis aligned box. ">AxisAlignedBoxSceneQuery</a> for this scene manager.  <a href="#a2cb1523180fcc65b6093b6330725c823">More...</a><br /></td></tr>
<tr class="separator:a2cb1523180fcc65b6093b6330725c823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c534bbbff4ffa2c11bbc94a49a34a4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_animation.html">v1::Animation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ab1c534bbbff4ffa2c11bbc94a49a34a4">createAnimation</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> length)</td></tr>
<tr class="memdesc:ab1c534bbbff4ffa2c11bbc94a49a34a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an animation which can be used to animate scene nodes.  <a href="#ab1c534bbbff4ffa2c11bbc94a49a34a4">More...</a><br /></td></tr>
<tr class="separator:ab1c534bbbff4ffa2c11bbc94a49a34a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645918264d13f0fd8e403e7e4554ac89"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_animation_state.html">v1::AnimationState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a645918264d13f0fd8e403e7e4554ac89">createAnimationState</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;animName)</td></tr>
<tr class="memdesc:a645918264d13f0fd8e403e7e4554ac89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an AnimationState object for managing application of animations.  <a href="#a645918264d13f0fd8e403e7e4554ac89">More...</a><br /></td></tr>
<tr class="separator:a645918264d13f0fd8e403e7e4554ac89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed1f8508aab6937936e59131d37b015"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_billboard_chain.html">v1::BillboardChain</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a7ed1f8508aab6937936e59131d37b015">createBillboardChain</a> ()</td></tr>
<tr class="memdesc:a7ed1f8508aab6937936e59131d37b015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a BillboardChain, an object which you can use to render a linked chain of billboards.  <a href="#a7ed1f8508aab6937936e59131d37b015">More...</a><br /></td></tr>
<tr class="separator:a7ed1f8508aab6937936e59131d37b015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab332bde9a27fd34aebe523565f2c901e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_billboard_set.html">v1::BillboardSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ab332bde9a27fd34aebe523565f2c901e">createBillboardSet</a> (unsigned int poolSize=20)</td></tr>
<tr class="memdesc:ab332bde9a27fd34aebe523565f2c901e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new BillboardSet for use with this scene manager.  <a href="#ab332bde9a27fd34aebe523565f2c901e">More...</a><br /></td></tr>
<tr class="separator:ab332bde9a27fd34aebe523565f2c901e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b123ba8766b15be93d40663f55513b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#af0b123ba8766b15be93d40663f55513b">createCamera</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, bool notShadowCaster=true, bool forCubemapping=false)</td></tr>
<tr class="memdesc:af0b123ba8766b15be93d40663f55513b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a camera to be managed by this scene manager.  <a href="#af0b123ba8766b15be93d40663f55513b">More...</a><br /></td></tr>
<tr class="separator:af0b123ba8766b15be93d40663f55513b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998341d53edde24071ab556372d2bee9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_entity.html">v1::Entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a998341d53edde24071ab556372d2bee9">createEntity</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;meshName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="class_ogre_1_1_resource_group_manager.html#a70da3137e703c147b98fbfbbebfbf023">ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME</a>, <a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType=<a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a>)</td></tr>
<tr class="memdesc:a998341d53edde24071ab556372d2bee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Entity (instance of a discrete mesh).  <a href="#a998341d53edde24071ab556372d2bee9">More...</a><br /></td></tr>
<tr class="separator:a998341d53edde24071ab556372d2bee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ccdf9af7ecb7b43ebcd020b01bec48"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_entity.html">v1::Entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a74ccdf9af7ecb7b43ebcd020b01bec48">createEntity</a> (const <a class="el" href="namespace_ogre_1_1v1.html#a500ac3b30068793f1dda3f0627c5cf67">v1::MeshPtr</a> &amp;pMesh, <a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType=<a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a>)</td></tr>
<tr class="memdesc:a74ccdf9af7ecb7b43ebcd020b01bec48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Entity (instance of a discrete mesh).  <a href="#a74ccdf9af7ecb7b43ebcd020b01bec48">More...</a><br /></td></tr>
<tr class="separator:a74ccdf9af7ecb7b43ebcd020b01bec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214f1928e9b08968f21cf06f0abec196"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_entity.html">v1::Entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a214f1928e9b08968f21cf06f0abec196">createEntity</a> (<a class="el" href="class_ogre_1_1_scene_manager.html#ab4c2ff4f6c76f7fe0a8eae76f2a84cbf">PrefabType</a> ptype, <a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType=<a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a>)</td></tr>
<tr class="memdesc:a214f1928e9b08968f21cf06f0abec196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Entity (instance of a discrete mesh) from a range of prefab shapes.  <a href="#a214f1928e9b08968f21cf06f0abec196">More...</a><br /></td></tr>
<tr class="separator:a214f1928e9b08968f21cf06f0abec196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae880429854291015a41b9a1f9a00ff6f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">v1::InstancedEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae880429854291015a41b9a1f9a00ff6f">createInstancedEntity</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;managerName)</td></tr>
<tr class="memdesc:ae880429854291015a41b9a1f9a00ff6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an InstancedEntity based on an existing InstanceManager (.  <a href="#ae880429854291015a41b9a1f9a00ff6f">More...</a><br /></td></tr>
<tr class="separator:ae880429854291015a41b9a1f9a00ff6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f741f55a905b4cb1dbae7d90ffa543b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">v1::InstanceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a8f741f55a905b4cb1dbae7d90ffa543b">createInstanceManager</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;customName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;meshName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName, <a class="el" href="group___scene.html#ga7fdc1f95714df3401447297dd6385e9c">v1::InstanceManager::InstancingTechnique</a> technique, size_t numInstancesPerBatch, <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> flags=0, unsigned short subMeshIdx=0)</td></tr>
<tr class="memdesc:a8f741f55a905b4cb1dbae7d90ffa543b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an InstanceManager interface to create &amp; manipulate instanced entities You need to call this function at least once before start calling createInstancedEntity to build up an instance based on the given mesh.  <a href="#a8f741f55a905b4cb1dbae7d90ffa543b">More...</a><br /></td></tr>
<tr class="separator:a8f741f55a905b4cb1dbae7d90ffa543b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7058a41df70af9d57a5f9174bdb75b8b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_intersection_scene_query.html">IntersectionSceneQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a7058a41df70af9d57a5f9174bdb75b8b">createIntersectionQuery</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> mask=<a class="el" href="class_ogre_1_1_scene_manager.html#a6c140ffaced93a2b854e5c519c8fb568">QUERY_ENTITY_DEFAULT_MASK</a>)</td></tr>
<tr class="memdesc:a7058a41df70af9d57a5f9174bdb75b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="class_ogre_1_1_intersection_scene_query.html" title="Separate SceneQuery class to query for pairs of objects which are possibly intersecting one another...">IntersectionSceneQuery</a> for this scene manager.  <a href="#a7058a41df70af9d57a5f9174bdb75b8b">More...</a><br /></td></tr>
<tr class="separator:a7058a41df70af9d57a5f9174bdb75b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d7c00f7f1bc53433920fdf1ab65420"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a41d7c00f7f1bc53433920fdf1ab65420">createItem</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;meshName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="class_ogre_1_1_resource_group_manager.html#a70da3137e703c147b98fbfbbebfbf023">ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME</a>, <a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType=<a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a>)</td></tr>
<tr class="memdesc:a41d7c00f7f1bc53433920fdf1ab65420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_ogre_1_1_item.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Item</a> (instance of a discrete mesh).  <a href="#a41d7c00f7f1bc53433920fdf1ab65420">More...</a><br /></td></tr>
<tr class="separator:a41d7c00f7f1bc53433920fdf1ab65420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a0ad552583d76f602fa08b06ec88ae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#af2a0ad552583d76f602fa08b06ec88ae">createItem</a> (const <a class="el" href="namespace_ogre.html#a5c4c0c56ea9f824c49e331f6fad33ddb">MeshPtr</a> &amp;pMesh, <a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType=<a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a>)</td></tr>
<tr class="memdesc:af2a0ad552583d76f602fa08b06ec88ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_ogre_1_1_item.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Item</a> (instance of a discrete mesh).  <a href="#af2a0ad552583d76f602fa08b06ec88ae">More...</a><br /></td></tr>
<tr class="separator:af2a0ad552583d76f602fa08b06ec88ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417bdd216730a8d171c3184b0d49c32e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_light.html">Light</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a417bdd216730a8d171c3184b0d49c32e">createLight</a> ()</td></tr>
<tr class="memdesc:a417bdd216730a8d171c3184b0d49c32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a light for use in the scene.  <a href="#a417bdd216730a8d171c3184b0d49c32e">More...</a><br /></td></tr>
<tr class="separator:a417bdd216730a8d171c3184b0d49c32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62cca9c1e6141d806ad1536acdbb812"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_manual_object.html">ManualObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae62cca9c1e6141d806ad1536acdbb812">createManualObject</a> (<a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType=<a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a>)</td></tr>
<tr class="memdesc:ae62cca9c1e6141d806ad1536acdbb812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="class_ogre_1_1_manual_object.html">ManualObject</a>, an object which you populate with geometry manually through a GL immediate-mode style interface.  <a href="#ae62cca9c1e6141d806ad1536acdbb812">More...</a><br /></td></tr>
<tr class="separator:ae62cca9c1e6141d806ad1536acdbb812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacb4d0155d88f559516027c8d7c2c67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aaacb4d0155d88f559516027c8d7c2c67">createMovableObject</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName, <a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *objectMemMgr, const <a class="el" href="group___general.html#gadccb207c184efc0a6fb2a00ab6320d19">NameValuePairList</a> *params=0)</td></tr>
<tr class="memdesc:aaacb4d0155d88f559516027c8d7c2c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a movable object of the type specified without a name.  <a href="#aaacb4d0155d88f559516027c8d7c2c67">More...</a><br /></td></tr>
<tr class="separator:aaacb4d0155d88f559516027c8d7c2c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4ee617b2e251f10cea239e31407e69"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_particle_system.html">ParticleSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a1a4ee617b2e251f10cea239e31407e69">createParticleSystem</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;templateName)</td></tr>
<tr class="memdesc:a1a4ee617b2e251f10cea239e31407e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a particle system based on a template.  <a href="#a1a4ee617b2e251f10cea239e31407e69">More...</a><br /></td></tr>
<tr class="separator:a1a4ee617b2e251f10cea239e31407e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d79919af93bf827cf8185930dd2a5f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_particle_system.html">ParticleSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa0d79919af93bf827cf8185930dd2a5f">createParticleSystem</a> (size_t quota=500, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>
<tr class="memdesc:aa0d79919af93bf827cf8185930dd2a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a blank particle system.  <a href="#aa0d79919af93bf827cf8185930dd2a5f">More...</a><br /></td></tr>
<tr class="separator:aa0d79919af93bf827cf8185930dd2a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd010182f634fc54dd00af2d5e59fb4e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_plane_bounded_volume_list_scene_query.html">PlaneBoundedVolumeListSceneQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#acd010182f634fc54dd00af2d5e59fb4e">createPlaneBoundedVolumeQuery</a> (const <a class="el" href="group___math.html#ga6253a1300d656ba28342fe58260d0e71">PlaneBoundedVolumeList</a> &amp;volumes, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> mask=<a class="el" href="class_ogre_1_1_scene_manager.html#a6c140ffaced93a2b854e5c519c8fb568">QUERY_ENTITY_DEFAULT_MASK</a>)</td></tr>
<tr class="memdesc:acd010182f634fc54dd00af2d5e59fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_ogre_1_1_plane_bounded_volume_list_scene_query.html" title="Specialises the SceneQuery class for querying within a plane-bounded volume. ">PlaneBoundedVolumeListSceneQuery</a> for this scene manager.  <a href="#acd010182f634fc54dd00af2d5e59fb4e">More...</a><br /></td></tr>
<tr class="separator:acd010182f634fc54dd00af2d5e59fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3166eafec7c9234170371b4dcf66552d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_ray_scene_query.html">RaySceneQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a3166eafec7c9234170371b4dcf66552d">createRayQuery</a> (const <a class="el" href="class_ogre_1_1_ray.html">Ray</a> &amp;ray, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> mask=<a class="el" href="class_ogre_1_1_scene_manager.html#a6c140ffaced93a2b854e5c519c8fb568">QUERY_ENTITY_DEFAULT_MASK</a>)</td></tr>
<tr class="memdesc:a3166eafec7c9234170371b4dcf66552d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_ogre_1_1_ray_scene_query.html" title="Specialises the SceneQuery class for querying along a ray. ">RaySceneQuery</a> for this scene manager.  <a href="#a3166eafec7c9234170371b4dcf66552d">More...</a><br /></td></tr>
<tr class="separator:a3166eafec7c9234170371b4dcf66552d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422b04adfc9476736b02667d02161dec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_rectangle2_d.html">v1::Rectangle2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a422b04adfc9476736b02667d02161dec">createRectangle2D</a> (bool bQuad, <a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType=<a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a284ea1c4b2ae53f2aefbaeabd6a27da8">SCENE_STATIC</a>)</td></tr>
<tr class="memdesc:a422b04adfc9476736b02667d02161dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 2D rectangle that can be displayed for screen space effects or showing a basic GUI.  <a href="#a422b04adfc9476736b02667d02161dec">More...</a><br /></td></tr>
<tr class="separator:a422b04adfc9476736b02667d02161dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a989e4040a897a224cc62ad39d97ed4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_ribbon_trail.html">v1::RibbonTrail</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9a989e4040a897a224cc62ad39d97ed4">createRibbonTrail</a> ()</td></tr>
<tr class="memdesc:a9a989e4040a897a224cc62ad39d97ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a RibbonTrail, an object which you can use to render a linked chain of billboards which follows one or more nodes.  <a href="#a9a989e4040a897a224cc62ad39d97ed4">More...</a><br /></td></tr>
<tr class="separator:a9a989e4040a897a224cc62ad39d97ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a28f0f0da21cfaf01ccf1cf0fb2d75"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a25a28f0f0da21cfaf01ccf1cf0fb2d75">createSceneNode</a> (<a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType=<a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a>)</td></tr>
<tr class="memdesc:a25a28f0f0da21cfaf01ccf1cf0fb2d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>.  <a href="#a25a28f0f0da21cfaf01ccf1cf0fb2d75">More...</a><br /></td></tr>
<tr class="separator:a25a28f0f0da21cfaf01ccf1cf0fb2d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ad8f1fbd3d8848365214ba3ee4ff43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_skeleton_instance.html">SkeletonInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa6ad8f1fbd3d8848365214ba3ee4ff43">createSkeletonInstance</a> (const <a class="el" href="class_ogre_1_1_skeleton_def.html">SkeletonDef</a> *skeletonDef)</td></tr>
<tr class="memdesc:aa6ad8f1fbd3d8848365214ba3ee4ff43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of a skeleton based on the given definition.  <a href="#aa6ad8f1fbd3d8848365214ba3ee4ff43">More...</a><br /></td></tr>
<tr class="separator:aa6ad8f1fbd3d8848365214ba3ee4ff43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae273d6ac6a5b99742c18a14cb12dc711"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_sphere_scene_query.html">SphereSceneQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae273d6ac6a5b99742c18a14cb12dc711">createSphereQuery</a> (const <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> &amp;sphere, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> mask=<a class="el" href="class_ogre_1_1_scene_manager.html#a6c140ffaced93a2b854e5c519c8fb568">QUERY_ENTITY_DEFAULT_MASK</a>)</td></tr>
<tr class="memdesc:ae273d6ac6a5b99742c18a14cb12dc711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_ogre_1_1_sphere_scene_query.html" title="Specialises the SceneQuery class for querying within a sphere. ">SphereSceneQuery</a> for this scene manager.  <a href="#ae273d6ac6a5b99742c18a14cb12dc711">More...</a><br /></td></tr>
<tr class="separator:ae273d6ac6a5b99742c18a14cb12dc711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf755994a585d5a411e6dac32e936ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_static_geometry.html">v1::StaticGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#abdf755994a585d5a411e6dac32e936ea">createStaticGeometry</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:abdf755994a585d5a411e6dac32e936ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a StaticGeometry instance suitable for use with this <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#abdf755994a585d5a411e6dac32e936ea">More...</a><br /></td></tr>
<tr class="separator:abdf755994a585d5a411e6dac32e936ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c342dac5ec4958dc235b1aa90005743"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_tag_point.html">TagPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a6c342dac5ec4958dc235b1aa90005743">createTagPoint</a> (void)</td></tr>
<tr class="memdesc:a6c342dac5ec4958dc235b1aa90005743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_ogre_1_1_tag_point.html" title="TagPoints are like SceneNodes, that can be children of a Bone. ">TagPoint</a> that can be used like a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>, or be used to be attached to a <a class="el" href="class_ogre_1_1_bone.html" title="Class representing a Bone in the join hierarchy of a skeleton. ">Bone</a>.  <a href="#a6c342dac5ec4958dc235b1aa90005743">More...</a><br /></td></tr>
<tr class="separator:a6c342dac5ec4958dc235b1aa90005743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dad9b5bf588edc85237b2dca9a03cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_wire_aabb.html">WireAabb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae5dad9b5bf588edc85237b2dca9a03cf">createWireAabb</a> (void)</td></tr>
<tr class="memdesc:ae5dad9b5bf588edc85237b2dca9a03cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_ogre_1_1_wire_aabb.html" title="Helper class to display the Aabb of a MovableObject as lines. ">WireAabb</a>.  <a href="#ae5dad9b5bf588edc85237b2dca9a03cf">More...</a><br /></td></tr>
<tr class="separator:ae5dad9b5bf588edc85237b2dca9a03cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b975559cf03c869e70fdcbe38c07ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a97b975559cf03c869e70fdcbe38c07ce">cullLights</a> (<a class="el" href="class_ogre_1_1_camera.html">Camera</a> *camera, <a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbc">Light::LightTypes</a> startType, <a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbc">Light::LightTypes</a> endType, <a class="el" href="group___general.html#gae68d52abf76f574fcde6eb0f89eb128f">LightArray</a> &amp;outLights)</td></tr>
<tr class="separator:a97b975559cf03c869e70fdcbe38c07ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019a31618f2285f79be2b414488c04c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a019a31618f2285f79be2b414488c04c3">destroyAllAnimations</a> (void)</td></tr>
<tr class="memdesc:a019a31618f2285f79be2b414488c04c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all animations created using this <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#a019a31618f2285f79be2b414488c04c3">More...</a><br /></td></tr>
<tr class="separator:a019a31618f2285f79be2b414488c04c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60a84672be1f532323cdb5dbfdc2c66"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa60a84672be1f532323cdb5dbfdc2c66">destroyAllAnimationStates</a> (void)</td></tr>
<tr class="memdesc:aa60a84672be1f532323cdb5dbfdc2c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all animation states created using this <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#aa60a84672be1f532323cdb5dbfdc2c66">More...</a><br /></td></tr>
<tr class="separator:aa60a84672be1f532323cdb5dbfdc2c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c01b8c2d82759fb875089c93df491a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a2c01b8c2d82759fb875089c93df491a4">destroyAllBillboardChains</a> (void)</td></tr>
<tr class="memdesc:a2c01b8c2d82759fb875089c93df491a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys all BillboardChains from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#a2c01b8c2d82759fb875089c93df491a4">More...</a><br /></td></tr>
<tr class="separator:a2c01b8c2d82759fb875089c93df491a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62742f3922523e75b72f6e8303fea251"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a62742f3922523e75b72f6e8303fea251">destroyAllBillboardSets</a> (void)</td></tr>
<tr class="memdesc:a62742f3922523e75b72f6e8303fea251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys all BillboardSets.  <a href="#a62742f3922523e75b72f6e8303fea251">More...</a><br /></td></tr>
<tr class="separator:a62742f3922523e75b72f6e8303fea251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb93862284e7443b94eaabdef21564a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9cb93862284e7443b94eaabdef21564a">destroyAllCameras</a> (void)</td></tr>
<tr class="memdesc:a9cb93862284e7443b94eaabdef21564a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes (and destroys) all cameras from the scene.  <a href="#a9cb93862284e7443b94eaabdef21564a">More...</a><br /></td></tr>
<tr class="separator:a9cb93862284e7443b94eaabdef21564a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a77be68ccbfc90e2e1aed04340db4dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a1a77be68ccbfc90e2e1aed04340db4dc">destroyAllEntities</a> (void)</td></tr>
<tr class="memdesc:a1a77be68ccbfc90e2e1aed04340db4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys all Entities.  <a href="#a1a77be68ccbfc90e2e1aed04340db4dc">More...</a><br /></td></tr>
<tr class="separator:a1a77be68ccbfc90e2e1aed04340db4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b116e020a220d8275508252f704ed6d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a2b116e020a220d8275508252f704ed6d">destroyAllInstanceManagers</a> (void)</td></tr>
<tr class="separator:a2b116e020a220d8275508252f704ed6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f632314554702973089c54ba815d68"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a20f632314554702973089c54ba815d68">destroyAllItems</a> (void)</td></tr>
<tr class="memdesc:a20f632314554702973089c54ba815d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys all Items.  <a href="#a20f632314554702973089c54ba815d68">More...</a><br /></td></tr>
<tr class="separator:a20f632314554702973089c54ba815d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723da9119c26f5022e3a2818611e9aa0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a723da9119c26f5022e3a2818611e9aa0">destroyAllLights</a> (void)</td></tr>
<tr class="memdesc:a723da9119c26f5022e3a2818611e9aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and destroys all lights in the scene.  <a href="#a723da9119c26f5022e3a2818611e9aa0">More...</a><br /></td></tr>
<tr class="separator:a723da9119c26f5022e3a2818611e9aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e151b6d94feb6648b8c817ba485238"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ab3e151b6d94feb6648b8c817ba485238">destroyAllManualObjects</a> (void)</td></tr>
<tr class="memdesc:ab3e151b6d94feb6648b8c817ba485238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys all ManualObjects from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#ab3e151b6d94feb6648b8c817ba485238">More...</a><br /></td></tr>
<tr class="separator:ab3e151b6d94feb6648b8c817ba485238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af985062a80dbc20d8fe523be166ecca6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#af985062a80dbc20d8fe523be166ecca6">destroyAllMovableObjects</a> (void)</td></tr>
<tr class="memdesc:af985062a80dbc20d8fe523be166ecca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all MovableObjects.  <a href="#af985062a80dbc20d8fe523be166ecca6">More...</a><br /></td></tr>
<tr class="separator:af985062a80dbc20d8fe523be166ecca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aca5477f30dd55321a101f25c6a5ee2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a8aca5477f30dd55321a101f25c6a5ee2">destroyAllMovableObjectsByType</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName)</td></tr>
<tr class="memdesc:a8aca5477f30dd55321a101f25c6a5ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all MovableObjects of a given type.  <a href="#a8aca5477f30dd55321a101f25c6a5ee2">More...</a><br /></td></tr>
<tr class="separator:a8aca5477f30dd55321a101f25c6a5ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dbd81cd9867b1032e02e1780b6eb49"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a98dbd81cd9867b1032e02e1780b6eb49">destroyAllParticleSystems</a> (void)</td></tr>
<tr class="memdesc:a98dbd81cd9867b1032e02e1780b6eb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys all ParticleSystems from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#a98dbd81cd9867b1032e02e1780b6eb49">More...</a><br /></td></tr>
<tr class="separator:a98dbd81cd9867b1032e02e1780b6eb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2673459d64d17f47b1aec0920f8e899"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ab2673459d64d17f47b1aec0920f8e899">destroyAllRectangle2D</a> (void)</td></tr>
<tr class="memdesc:ab2673459d64d17f47b1aec0920f8e899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys all Rectangle2D.  <a href="#ab2673459d64d17f47b1aec0920f8e899">More...</a><br /></td></tr>
<tr class="separator:ab2673459d64d17f47b1aec0920f8e899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e41109a26094ffe128beb5b6898f95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a12e41109a26094ffe128beb5b6898f95">destroyAllRibbonTrails</a> (void)</td></tr>
<tr class="memdesc:a12e41109a26094ffe128beb5b6898f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys all RibbonTrails from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#a12e41109a26094ffe128beb5b6898f95">More...</a><br /></td></tr>
<tr class="separator:a12e41109a26094ffe128beb5b6898f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f54ea048af80532212c8f60bea95d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a64f54ea048af80532212c8f60bea95d6">destroyAllStaticGeometry</a> (void)</td></tr>
<tr class="memdesc:a64f54ea048af80532212c8f60bea95d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove &amp; destroy all StaticGeometry instances.  <a href="#a64f54ea048af80532212c8f60bea95d6">More...</a><br /></td></tr>
<tr class="separator:a64f54ea048af80532212c8f60bea95d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ee4d81b2354710cbcb8462992d93b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a75ee4d81b2354710cbcb8462992d93b2">destroyAllWireAabbs</a> (void)</td></tr>
<tr class="memdesc:a75ee4d81b2354710cbcb8462992d93b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys all WireAabbs.  <a href="#a75ee4d81b2354710cbcb8462992d93b2">More...</a><br /></td></tr>
<tr class="separator:a75ee4d81b2354710cbcb8462992d93b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac4e76d36c8f059d7389bf1233563b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a7ac4e76d36c8f059d7389bf1233563b5">destroyAnimation</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:a7ac4e76d36c8f059d7389bf1233563b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an Animation.  <a href="#a7ac4e76d36c8f059d7389bf1233563b5">More...</a><br /></td></tr>
<tr class="separator:a7ac4e76d36c8f059d7389bf1233563b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a3f58bff113aaac870c18741f7cd76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a22a3f58bff113aaac870c18741f7cd76">destroyAnimationState</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:a22a3f58bff113aaac870c18741f7cd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an AnimationState.  <a href="#a22a3f58bff113aaac870c18741f7cd76">More...</a><br /></td></tr>
<tr class="separator:a22a3f58bff113aaac870c18741f7cd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570a5bfc2b2285cf38974dc82db416c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a570a5bfc2b2285cf38974dc82db416c9">destroyBillboardChain</a> (<a class="el" href="class_ogre_1_1v1_1_1_billboard_chain.html">v1::BillboardChain</a> *obj)</td></tr>
<tr class="memdesc:a570a5bfc2b2285cf38974dc82db416c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys a BillboardChain from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#a570a5bfc2b2285cf38974dc82db416c9">More...</a><br /></td></tr>
<tr class="separator:a570a5bfc2b2285cf38974dc82db416c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46af31e3f0a9a4c88eb755b9af885d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#af46af31e3f0a9a4c88eb755b9af885d4">destroyBillboardSet</a> (<a class="el" href="class_ogre_1_1v1_1_1_billboard_set.html">v1::BillboardSet</a> *<a class="el" href="struct_ogre_1_1set.html">set</a>)</td></tr>
<tr class="memdesc:af46af31e3f0a9a4c88eb755b9af885d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys an BillboardSet from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#af46af31e3f0a9a4c88eb755b9af885d4">More...</a><br /></td></tr>
<tr class="separator:af46af31e3f0a9a4c88eb755b9af885d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac58e45f8b6b6826c81933f02a45046"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#acac58e45f8b6b6826c81933f02a45046">destroyCamera</a> (<a class="el" href="class_ogre_1_1_camera.html">Camera</a> *cam)</td></tr>
<tr class="memdesc:acac58e45f8b6b6826c81933f02a45046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a camera from the scene.  <a href="#acac58e45f8b6b6826c81933f02a45046">More...</a><br /></td></tr>
<tr class="separator:acac58e45f8b6b6826c81933f02a45046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9238b475a6419e858877bc05de3c3e50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9238b475a6419e858877bc05de3c3e50">destroyEntity</a> (<a class="el" href="class_ogre_1_1v1_1_1_entity.html">v1::Entity</a> *ent)</td></tr>
<tr class="memdesc:a9238b475a6419e858877bc05de3c3e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys an Entity from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#a9238b475a6419e858877bc05de3c3e50">More...</a><br /></td></tr>
<tr class="separator:a9238b475a6419e858877bc05de3c3e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9885037b207114e9eaa5153ae196bcb7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9885037b207114e9eaa5153ae196bcb7">destroyInstancedEntity</a> (<a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">v1::InstancedEntity</a> *instancedEntity)</td></tr>
<tr class="memdesc:a9885037b207114e9eaa5153ae196bcb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an InstancedEntity,.  <a href="#a9885037b207114e9eaa5153ae196bcb7">More...</a><br /></td></tr>
<tr class="separator:a9885037b207114e9eaa5153ae196bcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a62b928086e749184853098a231d7e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a1a62b928086e749184853098a231d7e3">destroyInstanceManager</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name)</td></tr>
<tr class="memdesc:a1a62b928086e749184853098a231d7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an InstanceManager <b>if</b> it was created with <a class="el" href="class_ogre_1_1_scene_manager.html#a8f741f55a905b4cb1dbae7d90ffa543b" title="Creates an InstanceManager interface to create &amp; manipulate instanced entities You need to call this ...">createInstanceManager()</a>  <a href="#a1a62b928086e749184853098a231d7e3">More...</a><br /></td></tr>
<tr class="separator:a1a62b928086e749184853098a231d7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498b32af3242a5717ea5c192713689fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a498b32af3242a5717ea5c192713689fb">destroyInstanceManager</a> (<a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">v1::InstanceManager</a> *instanceManager)</td></tr>
<tr class="separator:a498b32af3242a5717ea5c192713689fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd090b454acb46a228428ec42fc0dfd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a5fd090b454acb46a228428ec42fc0dfd">destroyItem</a> (<a class="el" href="class_ogre_1_1_item.html">Item</a> *item)</td></tr>
<tr class="memdesc:a5fd090b454acb46a228428ec42fc0dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys an <a class="el" href="class_ogre_1_1_item.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Item</a> from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#a5fd090b454acb46a228428ec42fc0dfd">More...</a><br /></td></tr>
<tr class="separator:a5fd090b454acb46a228428ec42fc0dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce173aa89e849bda564f4e6e3be6402"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#acce173aa89e849bda564f4e6e3be6402">destroyLight</a> (<a class="el" href="class_ogre_1_1_light.html">Light</a> *light)</td></tr>
<tr class="memdesc:acce173aa89e849bda564f4e6e3be6402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the light from the scene and destroys it based on a pointer.  <a href="#acce173aa89e849bda564f4e6e3be6402">More...</a><br /></td></tr>
<tr class="separator:acce173aa89e849bda564f4e6e3be6402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d15c3ac882f78f0001d9d007f403be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a75d15c3ac882f78f0001d9d007f403be">destroyManualObject</a> (<a class="el" href="class_ogre_1_1_manual_object.html">ManualObject</a> *obj)</td></tr>
<tr class="memdesc:a75d15c3ac882f78f0001d9d007f403be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys a <a class="el" href="class_ogre_1_1_manual_object.html">ManualObject</a> from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#a75d15c3ac882f78f0001d9d007f403be">More...</a><br /></td></tr>
<tr class="separator:a75d15c3ac882f78f0001d9d007f403be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487bf8d2930ebdade5d3ca34c8c6d34e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a487bf8d2930ebdade5d3ca34c8c6d34e">destroyMovableObject</a> (<a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *m, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName)</td></tr>
<tr class="memdesc:a487bf8d2930ebdade5d3ca34c8c6d34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> with the name specified, of the type specified.  <a href="#a487bf8d2930ebdade5d3ca34c8c6d34e">More...</a><br /></td></tr>
<tr class="separator:a487bf8d2930ebdade5d3ca34c8c6d34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a135e382bac33ecd42f946713e2f38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a32a135e382bac33ecd42f946713e2f38">destroyMovableObject</a> (<a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *m)</td></tr>
<tr class="memdesc:a32a135e382bac33ecd42f946713e2f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a>.  <a href="#a32a135e382bac33ecd42f946713e2f38">More...</a><br /></td></tr>
<tr class="separator:a32a135e382bac33ecd42f946713e2f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde401fcf3796e3e2beb8c7603648f07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#abde401fcf3796e3e2beb8c7603648f07">destroyParticleSystem</a> (<a class="el" href="class_ogre_1_1_particle_system.html">ParticleSystem</a> *obj)</td></tr>
<tr class="memdesc:abde401fcf3796e3e2beb8c7603648f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys a <a class="el" href="class_ogre_1_1_particle_system.html" title="Class defining particle system based special effects. ">ParticleSystem</a> from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#abde401fcf3796e3e2beb8c7603648f07">More...</a><br /></td></tr>
<tr class="separator:abde401fcf3796e3e2beb8c7603648f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f7adf5f342c6808481fa922c8c62a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a08f7adf5f342c6808481fa922c8c62a0">destroyQuery</a> (<a class="el" href="class_ogre_1_1_scene_query.html">SceneQuery</a> *query)</td></tr>
<tr class="memdesc:a08f7adf5f342c6808481fa922c8c62a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a scene query of any type.  <a href="#a08f7adf5f342c6808481fa922c8c62a0">More...</a><br /></td></tr>
<tr class="separator:a08f7adf5f342c6808481fa922c8c62a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88b9456ae744c56b69c626597f9938c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae88b9456ae744c56b69c626597f9938c">destroyRectangle2D</a> (<a class="el" href="class_ogre_1_1v1_1_1_rectangle2_d.html">v1::Rectangle2D</a> *rect)</td></tr>
<tr class="memdesc:ae88b9456ae744c56b69c626597f9938c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys an Entity from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#ae88b9456ae744c56b69c626597f9938c">More...</a><br /></td></tr>
<tr class="separator:ae88b9456ae744c56b69c626597f9938c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3559e67959d2e5d8ddf10b9e0556e93a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a3559e67959d2e5d8ddf10b9e0556e93a">destroyRibbonTrail</a> (<a class="el" href="class_ogre_1_1v1_1_1_ribbon_trail.html">v1::RibbonTrail</a> *obj)</td></tr>
<tr class="memdesc:a3559e67959d2e5d8ddf10b9e0556e93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys a RibbonTrail from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#a3559e67959d2e5d8ddf10b9e0556e93a">More...</a><br /></td></tr>
<tr class="separator:a3559e67959d2e5d8ddf10b9e0556e93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa613e5ffb08b95a90644a61ac10c9b5c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa613e5ffb08b95a90644a61ac10c9b5c">destroySceneNode</a> (<a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *sn)</td></tr>
<tr class="memdesc:aa613e5ffb08b95a90644a61ac10c9b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>.  <a href="#aa613e5ffb08b95a90644a61ac10c9b5c">More...</a><br /></td></tr>
<tr class="separator:aa613e5ffb08b95a90644a61ac10c9b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911db15a672db3ebb4837840ed2c5bf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a911db15a672db3ebb4837840ed2c5bf0">destroySkeletonInstance</a> (<a class="el" href="class_ogre_1_1_skeleton_instance.html">SkeletonInstance</a> *skeletonInstance)</td></tr>
<tr class="memdesc:a911db15a672db3ebb4837840ed2c5bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an instance of a skeleton created with .  <a href="#a911db15a672db3ebb4837840ed2c5bf0">More...</a><br /></td></tr>
<tr class="separator:a911db15a672db3ebb4837840ed2c5bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95c77b37c0da0b469b955aac98c46bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ad95c77b37c0da0b469b955aac98c46bf">destroyStaticGeometry</a> (<a class="el" href="class_ogre_1_1v1_1_1_static_geometry.html">v1::StaticGeometry</a> *geom)</td></tr>
<tr class="memdesc:ad95c77b37c0da0b469b955aac98c46bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove &amp; destroy a StaticGeometry instance.  <a href="#ad95c77b37c0da0b469b955aac98c46bf">More...</a><br /></td></tr>
<tr class="separator:ad95c77b37c0da0b469b955aac98c46bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f180b40f4bf55669f9842fe922a003"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae4f180b40f4bf55669f9842fe922a003">destroyStaticGeometry</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:ae4f180b40f4bf55669f9842fe922a003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove &amp; destroy a StaticGeometry instance.  <a href="#ae4f180b40f4bf55669f9842fe922a003">More...</a><br /></td></tr>
<tr class="separator:ae4f180b40f4bf55669f9842fe922a003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12bb6b0b9cf79cf8aaa1f454cea9116"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa12bb6b0b9cf79cf8aaa1f454cea9116">destroyWireAabb</a> (<a class="el" href="class_ogre_1_1_wire_aabb.html">WireAabb</a> *wireAabb)</td></tr>
<tr class="memdesc:aa12bb6b0b9cf79cf8aaa1f454cea9116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes &amp; destroys an <a class="el" href="class_ogre_1_1_wire_aabb.html" title="Helper class to display the Aabb of a MovableObject as lines. ">WireAabb</a> from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#aa12bb6b0b9cf79cf8aaa1f454cea9116">More...</a><br /></td></tr>
<tr class="separator:aa12bb6b0b9cf79cf8aaa1f454cea9116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1257fd328d54908eeb45398b3191f92b"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a1257fd328d54908eeb45398b3191f92b">estimateWorldGeometry</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename)</td></tr>
<tr class="memdesc:a1257fd328d54908eeb45398b3191f92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the number of loading stages required to load the named world geometry.  <a href="#a1257fd328d54908eeb45398b3191f92b">More...</a><br /></td></tr>
<tr class="separator:a1257fd328d54908eeb45398b3191f92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf303a6b80c95fabfae679f0a9898f7"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#abdf303a6b80c95fabfae679f0a9898f7">estimateWorldGeometry</a> (<a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;stream, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>)</td></tr>
<tr class="memdesc:abdf303a6b80c95fabfae679f0a9898f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the number of loading stages required to load the named world geometry.  <a href="#abdf303a6b80c95fabfae679f0a9898f7">More...</a><br /></td></tr>
<tr class="separator:abdf303a6b80c95fabfae679f0a9898f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040241bad11b74f5ba8971fb146f8c6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a040241bad11b74f5ba8971fb146f8c6d">executeUserScalableTask</a> (<a class="el" href="class_ogre_1_1_uniform_scalable_task.html">UniformScalableTask</a> *task, bool bBlock)</td></tr>
<tr class="memdesc:a040241bad11b74f5ba8971fb146f8c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes a user-defined <a class="el" href="class_ogre_1_1_uniform_scalable_task.html" title="A uniform task is a highly parallelizable task that can be divided in many threads where all threads ...">UniformScalableTask</a> in the worker threads spawned by <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#a040241bad11b74f5ba8971fb146f8c6d">More...</a><br /></td></tr>
<tr class="separator:a040241bad11b74f5ba8971fb146f8c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c55f5e97c66261de71c979db64f6355"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a1c55f5e97c66261de71c979db64f6355">extractAllMovableObjectsByType</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName)</td></tr>
<tr class="memdesc:a1c55f5e97c66261de71c979db64f6355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract all injected MovableObjects of a given type.  <a href="#a1c55f5e97c66261de71c979db64f6355">More...</a><br /></td></tr>
<tr class="separator:a1c55f5e97c66261de71c979db64f6355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874431ce04c34fa6dcbdb2ed1420b168"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a874431ce04c34fa6dcbdb2ed1420b168">extractMovableObject</a> (<a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *m)</td></tr>
<tr class="memdesc:a874431ce04c34fa6dcbdb2ed1420b168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a previously injected <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a>.  <a href="#a874431ce04c34fa6dcbdb2ed1420b168">More...</a><br /></td></tr>
<tr class="separator:a874431ce04c34fa6dcbdb2ed1420b168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a761b7c1518ca6723ad4d08d8a335a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#af2a761b7c1518ca6723ad4d08d8a335a">findCamera</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name) const</td></tr>
<tr class="memdesc:af2a761b7c1518ca6723ad4d08d8a335a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the camera with the given name.  <a href="#af2a761b7c1518ca6723ad4d08d8a335a">More...</a><br /></td></tr>
<tr class="separator:af2a761b7c1518ca6723ad4d08d8a335a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e080c31630734fd937b3d3580a2f62"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae4e080c31630734fd937b3d3580a2f62">findCameraNoThrow</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name) const</td></tr>
<tr class="memdesc:ae4e080c31630734fd937b3d3580a2f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the camera with the given name.  <a href="#ae4e080c31630734fd937b3d3580a2f62">More...</a><br /></td></tr>
<tr class="separator:ae4e080c31630734fd937b3d3580a2f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab6a83be3e4045890ed16dd80023ea7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_scene_manager.html#a6d8f5f81e262b6347f5066da27d6fe70">MovableObjectVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#adab6a83be3e4045890ed16dd80023ea7">findMovableObjects</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;type, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:adab6a83be3e4045890ed16dd80023ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all the movable objects with the type and name passed as parameters.  <a href="#adab6a83be3e4045890ed16dd80023ea7">More...</a><br /></td></tr>
<tr class="separator:adab6a83be3e4045890ed16dd80023ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca3e6a51e42c0f7383f7d92c4a79377"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> <a class="el" href="class_ogre_1_1_scene_manager.html#a8f87c38314b272fff95da3065f3740ee">SceneNodeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#adca3e6a51e42c0f7383f7d92c4a79377">findSceneNodes</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const</td></tr>
<tr class="memdesc:adca3e6a51e42c0f7383f7d92c4a79377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all the scene nodes with the name passed as parameter.  <a href="#adca3e6a51e42c0f7383f7d92c4a79377">More...</a><br /></td></tr>
<tr class="separator:adca3e6a51e42c0f7383f7d92c4a79377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bace1d8ae2c3c14bd0df22efee3ea8a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a2bace1d8ae2c3c14bd0df22efee3ea8a">getAmbientLightHemisphereDir</a> (void) const</td></tr>
<tr class="separator:a2bace1d8ae2c3c14bd0df22efee3ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71383d1aee19d8783ee75c4705a7fcc3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a71383d1aee19d8783ee75c4705a7fcc3">getAmbientLightLowerHemisphere</a> (void) const</td></tr>
<tr class="separator:a71383d1aee19d8783ee75c4705a7fcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d8c6cff1677375a7a84c345534947f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ab8d8c6cff1677375a7a84c345534947f">getAmbientLightUpperHemisphere</a> (void) const</td></tr>
<tr class="memdesc:ab8d8c6cff1677375a7a84c345534947f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ambient light level to be used for the scene.  <a href="#ab8d8c6cff1677375a7a84c345534947f">More...</a><br /></td></tr>
<tr class="separator:ab8d8c6cff1677375a7a84c345534947f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3f8d93657ec9107bfeb014f1454915"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_animation.html">v1::Animation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a5c3f8d93657ec9107bfeb014f1454915">getAnimation</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const</td></tr>
<tr class="memdesc:a5c3f8d93657ec9107bfeb014f1454915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up an Animation object previously created with createAnimation.  <a href="#a5c3f8d93657ec9107bfeb014f1454915">More...</a><br /></td></tr>
<tr class="separator:a5c3f8d93657ec9107bfeb014f1454915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28450738168fe330709ad0d090df6b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_manager.html#a3a720414f68274bb9c5026911e27135d">AnimationIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ab28450738168fe330709ad0d090df6b5">getAnimationIterator</a> (void)</td></tr>
<tr class="memdesc:ab28450738168fe330709ad0d090df6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a specialised <a class="el" href="class_ogre_1_1_map_iterator.html" title="Concrete IteratorWrapper for nonconst access to the underlying key-value container. ">MapIterator</a> over all animations in the scene.  <a href="#ab28450738168fe330709ad0d090df6b5">More...</a><br /></td></tr>
<tr class="separator:ab28450738168fe330709ad0d090df6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d61667202240702c7279b675439505"><td class="memItemLeft" align="right" valign="top">const AnimationList &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ab3d61667202240702c7279b675439505">getAnimations</a> () const</td></tr>
<tr class="memdesc:ab3d61667202240702c7279b675439505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const version of the animation list.  <a href="#ab3d61667202240702c7279b675439505">More...</a><br /></td></tr>
<tr class="separator:ab3d61667202240702c7279b675439505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a63fccbae507c458bb08e24f8950480"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_animation_state.html">v1::AnimationState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a6a63fccbae507c458bb08e24f8950480">getAnimationState</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;animName) const</td></tr>
<tr class="memdesc:a6a63fccbae507c458bb08e24f8950480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves animation state as previously created using createAnimationState.  <a href="#a6a63fccbae507c458bb08e24f8950480">More...</a><br /></td></tr>
<tr class="separator:a6a63fccbae507c458bb08e24f8950480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48fb79e236cd76927d9e92f51a82fdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___animation.html#ga6c8619d12ac269631ef4f400ea2e2ba3">v1::AnimationStateIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa48fb79e236cd76927d9e92f51a82fdf">getAnimationStateIterator</a> (void)</td></tr>
<tr class="memdesc:aa48fb79e236cd76927d9e92f51a82fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a specialised <a class="el" href="class_ogre_1_1_map_iterator.html" title="Concrete IteratorWrapper for nonconst access to the underlying key-value container. ">MapIterator</a> over all animation states in the scene.  <a href="#aa48fb79e236cd76927d9e92f51a82fdf">More...</a><br /></td></tr>
<tr class="separator:aa48fb79e236cd76927d9e92f51a82fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988b713015b950c917724215a2c42e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a988b713015b950c917724215a2c42e82">getCameraInProgress</a> (void) const</td></tr>
<tr class="memdesc:a988b713015b950c917724215a2c42e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current camera being rendered (advanced use only, only valid during viewport update.  <a href="#a988b713015b950c917724215a2c42e82">More...</a><br /></td></tr>
<tr class="separator:a988b713015b950c917724215a2c42e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d7d29cc4bc8ee4cbe40d16a984291c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_manager.html#a460e50da4b97d1beaef1a64bfa039928">CameraIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a02d7d29cc4bc8ee4cbe40d16a984291c">getCameraIterator</a> (void)</td></tr>
<tr class="memdesc:a02d7d29cc4bc8ee4cbe40d16a984291c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a specialised <a class="el" href="class_ogre_1_1_map_iterator.html" title="Concrete IteratorWrapper for nonconst access to the underlying key-value container. ">MapIterator</a> over all cameras in the scene.  <a href="#a02d7d29cc4bc8ee4cbe40d16a984291c">More...</a><br /></td></tr>
<tr class="separator:a02d7d29cc4bc8ee4cbe40d16a984291c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf26160d2d9a4a9ebf61d0ba8cbffcfb"><td class="memItemLeft" align="right" valign="top">const CameraList &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#acf26160d2d9a4a9ebf61d0ba8cbffcfb">getCameras</a> () const</td></tr>
<tr class="memdesc:acf26160d2d9a4a9ebf61d0ba8cbffcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const version of the camera list.  <a href="#acf26160d2d9a4a9ebf61d0ba8cbffcfb">More...</a><br /></td></tr>
<tr class="separator:acf26160d2d9a4a9ebf61d0ba8cbffcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a20f12d329ce8eab8287a66437e4458"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_compositor_texture.html">CompositorTexture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a5a20f12d329ce8eab8287a66437e4458">getCompositorTarget</a> (void) const</td></tr>
<tr class="memdesc:a5a20f12d329ce8eab8287a66437e4458"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compositor we are currently writing to.  <a href="#a5a20f12d329ce8eab8287a66437e4458">More...</a><br /></td></tr>
<tr class="separator:a5a20f12d329ce8eab8287a66437e4458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dd87bb59ef8f5214808878637e6947"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#ga5b2773dd5ab4626bf794ee82b5f822e8">CompositorTextureVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a38dd87bb59ef8f5214808878637e6947">getCompositorTextures</a> (void) const</td></tr>
<tr class="separator:a38dd87bb59ef8f5214808878637e6947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89af25c747e890f3ad89193ce93041a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ad89af25c747e890f3ad89193ce93041a">getCurrentCastersBox</a> (void) const</td></tr>
<tr class="memdesc:ad89af25c747e890f3ad89193ce93041a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a55280f3dbe04abff8b8970b57fd79807" title="mCastersBox ">CompositorShadowNode::getCastersBox</a>  <a href="#ad89af25c747e890f3ad89193ce93041a">More...</a><br /></td></tr>
<tr class="separator:ad89af25c747e890f3ad89193ce93041a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b4a09ace966c642deea6c42b95ff69"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a70b4a09ace966c642deea6c42b95ff69">getCurrentCompositorPass</a> (void) const</td></tr>
<tr class="memdesc:a70b4a09ace966c642deea6c42b95ff69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: May be null.  <a href="#a70b4a09ace966c642deea6c42b95ff69">More...</a><br /></td></tr>
<tr class="separator:a70b4a09ace966c642deea6c42b95ff69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589923c70280db49a00bd7af8375cee9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a589923c70280db49a00bd7af8375cee9">getCurrentPrePassDepthTexture</a> (void) const</td></tr>
<tr class="separator:a589923c70280db49a00bd7af8375cee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa622bd9607691def94c1954c5ca90be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga63b5ab6176b81463bbdd0e260b751d2e">PrePassMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa622bd9607691def94c1954c5ca90be6">getCurrentPrePassMode</a> (void) const</td></tr>
<tr class="separator:aa622bd9607691def94c1954c5ca90be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb4f6d880ab38ac07ac9dc7aee2903a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#acdb4f6d880ab38ac07ac9dc7aee2903a">getCurrentPrePassTextures</a> (void) const</td></tr>
<tr class="separator:acdb4f6d880ab38ac07ac9dc7aee2903a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb82e7fbe30e6ee417b1dc63da8ae115"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html">CompositorShadowNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#adb82e7fbe30e6ee417b1dc63da8ae115">getCurrentShadowNode</a> (void) const</td></tr>
<tr class="separator:adb82e7fbe30e6ee417b1dc63da8ae115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba901c3141f61f0592de2d5a69f1318"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#adba901c3141f61f0592de2d5a69f1318">getCurrentSsrTexture</a> (void) const</td></tr>
<tr class="separator:adba901c3141f61f0592de2d5a69f1318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14da2ba967b9b85d69780c5a295f3836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_viewport.html">Viewport</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a14da2ba967b9b85d69780c5a295f3836">getCurrentViewport</a> (void) const</td></tr>
<tr class="memdesc:a14da2ba967b9b85d69780c5a295f3836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current viewport being rendered (advanced use only, only valid during viewport update.  <a href="#a14da2ba967b9b85d69780c5a295f3836">More...</a><br /></td></tr>
<tr class="separator:a14da2ba967b9b85d69780c5a295f3836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ed3c081ae69e90569fd0c2727a34df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa5ed3c081ae69e90569fd0c2727a34df">getDestinationRenderSystem</a> ()</td></tr>
<tr class="memdesc:aa5ed3c081ae69e90569fd0c2727a34df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rendersystem subclass to which the output of this Scene Manager gets sent.  <a href="#aa5ed3c081ae69e90569fd0c2727a34df">More...</a><br /></td></tr>
<tr class="separator:aa5ed3c081ae69e90569fd0c2727a34df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fec5de5b1af8423dbdae70fa1d18954"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a0fec5de5b1af8423dbdae70fa1d18954">getDisplaySceneNodes</a> (void) const</td></tr>
<tr class="memdesc:a0fec5de5b1af8423dbdae70fa1d18954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all scene nodes axis are to be displayed.  <a href="#a0fec5de5b1af8423dbdae70fa1d18954">More...</a><br /></td></tr>
<tr class="separator:a0fec5de5b1af8423dbdae70fa1d18954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0919a8c9d6034f9f8b9afef7117135e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ab0919a8c9d6034f9f8b9afef7117135e">getDummySceneNode</a> (void) const</td></tr>
<tr class="memdesc:ab0919a8c9d6034f9f8b9afef7117135e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlike mNodeMemoryManager-&gt;_getDummyNode(), this dummy node is fully allocated, which makes it possible to actually attach objects to this dummy, while we guarantee the dummy won't change its transform.  <a href="#ab0919a8c9d6034f9f8b9afef7117135e">More...</a><br /></td></tr>
<tr class="separator:ab0919a8c9d6034f9f8b9afef7117135e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7d7f344e528eea2e99481247de72c7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a3d7d7f344e528eea2e99481247de72c7">getFindVisibleObjects</a> (void)</td></tr>
<tr class="memdesc:a3d7d7f344e528eea2e99481247de72c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> should search for visible objects, or whether they are being manually handled.  <a href="#a3d7d7f344e528eea2e99481247de72c7">More...</a><br /></td></tr>
<tr class="separator:a3d7d7f344e528eea2e99481247de72c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac981c1e86936cdf189150d6dabeb8f4f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ac981c1e86936cdf189150d6dabeb8f4f">getFlipCullingOnNegativeScale</a> () const</td></tr>
<tr class="memdesc:ac981c1e86936cdf189150d6dabeb8f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether to automatically flip the culling mode on objects whenever they are negatively scaled.  <a href="#ac981c1e86936cdf189150d6dabeb8f4f">More...</a><br /></td></tr>
<tr class="separator:ac981c1e86936cdf189150d6dabeb8f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e45431d08a9b243dd561e13889cf32"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#af9e45431d08a9b243dd561e13889cf32">getFogColour</a> (void) const</td></tr>
<tr class="memdesc:af9e45431d08a9b243dd561e13889cf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog colour for the scene.  <a href="#af9e45431d08a9b243dd561e13889cf32">More...</a><br /></td></tr>
<tr class="separator:af9e45431d08a9b243dd561e13889cf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cb60fdad7cb792c6897f6a75f5a71a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a12cb60fdad7cb792c6897f6a75f5a71a">getFogDensity</a> (void) const</td></tr>
<tr class="memdesc:a12cb60fdad7cb792c6897f6a75f5a71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog density for the scene.  <a href="#a12cb60fdad7cb792c6897f6a75f5a71a">More...</a><br /></td></tr>
<tr class="separator:a12cb60fdad7cb792c6897f6a75f5a71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52eb95b1241a0ba0468287a22bd3fd8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa52eb95b1241a0ba0468287a22bd3fd8">getFogEnd</a> (void) const</td></tr>
<tr class="memdesc:aa52eb95b1241a0ba0468287a22bd3fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog end distance for the scene.  <a href="#aa52eb95b1241a0ba0468287a22bd3fd8">More...</a><br /></td></tr>
<tr class="separator:aa52eb95b1241a0ba0468287a22bd3fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860a3c04b9b0db60a78f08743a104a94"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___general.html#ga83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a860a3c04b9b0db60a78f08743a104a94">getFogMode</a> (void) const</td></tr>
<tr class="memdesc:a860a3c04b9b0db60a78f08743a104a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog mode for the scene.  <a href="#a860a3c04b9b0db60a78f08743a104a94">More...</a><br /></td></tr>
<tr class="separator:a860a3c04b9b0db60a78f08743a104a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfa98c914fe6e6f67a21fe144bd281d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#adcfa98c914fe6e6f67a21fe144bd281d">getFogStart</a> (void) const</td></tr>
<tr class="memdesc:adcfa98c914fe6e6f67a21fe144bd281d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog start distance for the scene.  <a href="#adcfa98c914fe6e6f67a21fe144bd281d">More...</a><br /></td></tr>
<tr class="separator:adcfa98c914fe6e6f67a21fe144bd281d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c5d8b2de0d61c371d551f3650246d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_forward_plus_base.html">ForwardPlusBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ac2c5d8b2de0d61c371d551f3650246d1">getForwardPlus</a> (void)</td></tr>
<tr class="separator:ac2c5d8b2de0d61c371d551f3650246d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce6c279340a1bc24d978f2fa26345f7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_light_list_info.html">LightListInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a5ce6c279340a1bc24d978f2fa26345f7">getGlobalLightList</a> (void) const</td></tr>
<tr class="separator:a5ce6c279340a1bc24d978f2fa26345f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e3cda33cf8d29c33a5c5c2777ca393"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">v1::InstanceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae9e3cda33cf8d29c33a5c5c2777ca393">getInstanceManager</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name) const</td></tr>
<tr class="memdesc:ae9e3cda33cf8d29c33a5c5c2777ca393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an existing InstanceManager by it's name.  <a href="#ae9e3cda33cf8d29c33a5c5c2777ca393">More...</a><br /></td></tr>
<tr class="separator:ae9e3cda33cf8d29c33a5c5c2777ca393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffa8b3f07c5295c3c6ca06df99899f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___scene.html#gafdd170d87744deec0ca8dd1730797be7">InstancingThreadedCullingMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a1ffa8b3f07c5295c3c6ca06df99899f7">getInstancingThreadedCullingMethod</a> () const</td></tr>
<tr class="separator:a1ffa8b3f07c5295c3c6ca06df99899f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d3193c52302229da41688946065dc7"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group___math.html#gae00d718daa48567f6c010aad9d6dd92c">PlaneList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a94d3193c52302229da41688946065dc7">getLightClippingPlanes</a> (const <a class="el" href="class_ogre_1_1_light.html">Light</a> *l)</td></tr>
<tr class="memdesc:a94d3193c52302229da41688946065dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a set of clipping planes for a given light.  <a href="#a94d3193c52302229da41688946065dc7">More...</a><br /></td></tr>
<tr class="separator:a94d3193c52302229da41688946065dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5674d3ac7f0eefac585c234b14359f9f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group___general.html#ga3e1c672c1d342ffb4f122f44e342bc90">RealRect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a5674d3ac7f0eefac585c234b14359f9f">getLightScissorRect</a> (const <a class="el" href="class_ogre_1_1_light.html">Light</a> *l, const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *cam)</td></tr>
<tr class="memdesc:a5674d3ac7f0eefac585c234b14359f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a scissor rectangle for a given light and camera.  <a href="#a5674d3ac7f0eefac585c234b14359f9f">More...</a><br /></td></tr>
<tr class="separator:a5674d3ac7f0eefac585c234b14359f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3f378c66d1266970320d8fb04278b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a7c3f378c66d1266970320d8fb04278b0">getMinMaxDepthRange</a> (const <a class="el" href="class_ogre_1_1_frustum.html">Frustum</a> *shadowMapCamera, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;outMin, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;outMax) const</td></tr>
<tr class="memdesc:a7c3f378c66d1266970320d8fb04278b0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#afc7297ac09456ceff0056a7a0d03f88c" title="Outputs the min &amp; max depth range for the given camera. ">CompositorShadowNode::getMinMaxDepthRange</a>  <a href="#a7c3f378c66d1266970320d8fb04278b0">More...</a><br /></td></tr>
<tr class="separator:a7c3f378c66d1266970320d8fb04278b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19c32fbc0adc0fa28d8e6c26d9800cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_scene_manager.html#af5348867645ff727d1ca25dd89795376">MovableObjectIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#af19c32fbc0adc0fa28d8e6c26d9800cb">getMovableObjectIterator</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName)</td></tr>
<tr class="memdesc:af19c32fbc0adc0fa28d8e6c26d9800cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator over all MovableObect instances of a given type.  <a href="#af19c32fbc0adc0fa28d8e6c26d9800cb">More...</a><br /></td></tr>
<tr class="separator:af19c32fbc0adc0fa28d8e6c26d9800cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7164acf31d5275397f2ea4f6ea3de5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aaa7164acf31d5275397f2ea4f6ea3de5">getName</a> (void) const</td></tr>
<tr class="memdesc:aaa7164acf31d5275397f2ea4f6ea3de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the instance name of this <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="#aaa7164acf31d5275397f2ea4f6ea3de5">More...</a><br /></td></tr>
<tr class="separator:aaa7164acf31d5275397f2ea4f6ea3de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b9ac37458ce1911947e1c077187fec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#af8b9ac37458ce1911947e1c077187fec">getNumCompositorTextures</a> (void) const</td></tr>
<tr class="memdesc:af8b9ac37458ce1911947e1c077187fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of currently active compositor textures.  <a href="#af8b9ac37458ce1911947e1c077187fec">More...</a><br /></td></tr>
<tr class="separator:af8b9ac37458ce1911947e1c077187fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77f781212b22679a816ca60c132bdfd"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ac77f781212b22679a816ca60c132bdfd">getNumInstancesPerBatch</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;meshName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="group___scene.html#ga7fdc1f95714df3401447297dd6385e9c">v1::InstanceManager::InstancingTechnique</a> technique, size_t numInstancesPerBatch, <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> flags=0, unsigned short subMeshIdx=0)</td></tr>
<tr class="separator:ac77f781212b22679a816ca60c132bdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac962924e49d9686471e3e639177129"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a4ac962924e49d9686471e3e639177129">getNumWorkerThreads</a> () const</td></tr>
<tr class="separator:a4ac962924e49d9686471e3e639177129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea53a860f373185f5a46239f579a361"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a2ea53a860f373185f5a46239f579a361">getOption</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;strKey, void *pDestValue)</td></tr>
<tr class="memdesc:a2ea53a860f373185f5a46239f579a361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for getting the value of an implementation-specific Scene Manager option.  <a href="#a2ea53a860f373185f5a46239f579a361">More...</a><br /></td></tr>
<tr class="separator:a2ea53a860f373185f5a46239f579a361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8ff6b5c19eb9eeef9d5a6c9fca9fe8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a7c8ff6b5c19eb9eeef9d5a6c9fca9fe8">getOptionKeys</a> (<a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;refKeys)</td></tr>
<tr class="memdesc:a7c8ff6b5c19eb9eeef9d5a6c9fca9fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for getting all the implementation-specific options of the scene manager.  <a href="#a7c8ff6b5c19eb9eeef9d5a6c9fca9fe8">More...</a><br /></td></tr>
<tr class="separator:a7c8ff6b5c19eb9eeef9d5a6c9fca9fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae291393bc0c5bd48a8c6e79742180c93"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae291393bc0c5bd48a8c6e79742180c93">getOptionValues</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;strKey, <a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;refValueList)</td></tr>
<tr class="memdesc:ae291393bc0c5bd48a8c6e79742180c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for getting all possible values for a specific option.  <a href="#ae291393bc0c5bd48a8c6e79742180c93">More...</a><br /></td></tr>
<tr class="separator:ae291393bc0c5bd48a8c6e79742180c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045cc6cee9d3db9c59d0e14523368eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a045cc6cee9d3db9c59d0e14523368eb8">getRelativeOrigin</a> (void) const</td></tr>
<tr class="memdesc:a045cc6cee9d3db9c59d0e14523368eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current relative origin. (Only when non-permanent)  <a href="#a045cc6cee9d3db9c59d0e14523368eb8">More...</a><br /></td></tr>
<tr class="separator:a045cc6cee9d3db9c59d0e14523368eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a366754506c37891718b5ebec86934d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a0a366754506c37891718b5ebec86934d">getRenderQueue</a> (void) const</td></tr>
<tr class="memdesc:a0a366754506c37891718b5ebec86934d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_ogre_1_1_render_queue.html" title="Enumeration of queue groups, by which the application may group queued renderables so that they are r...">RenderQueue</a>.  <a href="#a0a366754506c37891718b5ebec86934d">More...</a><br /></td></tr>
<tr class="separator:a0a366754506c37891718b5ebec86934d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8190fcdb503203cb3cdc8050ac658c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a8c8190fcdb503203cb3cdc8050ac658c">getRootSceneNode</a> (<a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType=<a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a>)</td></tr>
<tr class="memdesc:a8c8190fcdb503203cb3cdc8050ac658c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> at the root of the scene hierarchy.  <a href="#a8c8190fcdb503203cb3cdc8050ac658c">More...</a><br /></td></tr>
<tr class="separator:a8c8190fcdb503203cb3cdc8050ac658c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b80df48045f3dea1b1ef1c700a3d20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a44b80df48045f3dea1b1ef1c700a3d20">getSceneNode</a> (<a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> id)</td></tr>
<tr class="memdesc:a44b80df48045f3dea1b1ef1c700a3d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> based on it's ID from the scene graph.  <a href="#a44b80df48045f3dea1b1ef1c700a3d20">More...</a><br /></td></tr>
<tr class="separator:a44b80df48045f3dea1b1ef1c700a3d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a10930e4d1a622010259e98c8c4106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> const <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa7a10930e4d1a622010259e98c8c4106">getSceneNode</a> (<a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> id) const</td></tr>
<tr class="separator:aa7a10930e4d1a622010259e98c8c4106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c260af8c99d9086876c969ab3aab112"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a3c260af8c99d9086876c969ab3aab112">getShadowColour</a> (void) const</td></tr>
<tr class="memdesc:a3c260af8c99d9086876c969ab3aab112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the colour used to modulate areas in shadow.  <a href="#a3c260af8c99d9086876c969ab3aab112">More...</a><br /></td></tr>
<tr class="separator:a3c260af8c99d9086876c969ab3aab112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8d7b3656c9bdc0910eede3707ee0f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a4c8d7b3656c9bdc0910eede3707ee0f5">getShadowDirectionalLightExtrusionDistance</a> (void) const</td></tr>
<tr class="memdesc:a4c8d7b3656c9bdc0910eede3707ee0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the distance a shadow volume is extruded for a directional light.  <a href="#a4c8d7b3656c9bdc0910eede3707ee0f5">More...</a><br /></td></tr>
<tr class="separator:a4c8d7b3656c9bdc0910eede3707ee0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f92eed233e8131c28b93a1a8d144c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a70f92eed233e8131c28b93a1a8d144c1">getShadowDirLightTextureOffset</a> (void) const</td></tr>
<tr class="memdesc:a70f92eed233e8131c28b93a1a8d144c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space.  <a href="#a70f92eed233e8131c28b93a1a8d144c1">More...</a><br /></td></tr>
<tr class="separator:a70f92eed233e8131c28b93a1a8d144c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db2b873fe3a9a4db5c824f813efbcae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9db2b873fe3a9a4db5c824f813efbcae">getShadowFarDistance</a> (void) const</td></tr>
<tr class="memdesc:a9db2b873fe3a9a4db5c824f813efbcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default maximum distance away from the camera that shadows will be visible.  <a href="#a9db2b873fe3a9a4db5c824f813efbcae">More...</a><br /></td></tr>
<tr class="separator:a9db2b873fe3a9a4db5c824f813efbcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcf0e82479037779758261648b5e6d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aadcf0e82479037779758261648b5e6d7">getShadowFarDistanceSquared</a> (void) const</td></tr>
<tr class="separator:aadcf0e82479037779758261648b5e6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6008c82cd40e85f1b1c38d7929ec2ba"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa6008c82cd40e85f1b1c38d7929ec2ba">getShowBoundingBoxes</a> () const</td></tr>
<tr class="memdesc:aa6008c82cd40e85f1b1c38d7929ec2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if all bounding boxes of scene nodes are to be displayed.  <a href="#aa6008c82cd40e85f1b1c38d7929ec2ba">More...</a><br /></td></tr>
<tr class="separator:aa6008c82cd40e85f1b1c38d7929ec2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b7a808ad2105cce6435b1136ce32c9"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_ogre_1_1_scene_manager_1_1_sky_box_gen_parameters.html">SkyBoxGenParameters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae0b7a808ad2105cce6435b1136ce32c9">getSkyBoxGenParameters</a> (void) const</td></tr>
<tr class="memdesc:ae0b7a808ad2105cce6435b1136ce32c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters used to generate the current SkyBox, if any.  <a href="#ae0b7a808ad2105cce6435b1136ce32c9">More...</a><br /></td></tr>
<tr class="separator:ae0b7a808ad2105cce6435b1136ce32c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987ab43f9f3718b51e435a6ceda9097d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a987ab43f9f3718b51e435a6ceda9097d">getSkyBoxNode</a> (void) const</td></tr>
<tr class="memdesc:a987ab43f9f3718b51e435a6ceda9097d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the skybox node, if enabled.  <a href="#a987ab43f9f3718b51e435a6ceda9097d">More...</a><br /></td></tr>
<tr class="separator:a987ab43f9f3718b51e435a6ceda9097d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888cbcb18e7fc8d471da026686e6dfca"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_ogre_1_1_scene_manager_1_1_sky_dome_gen_parameters.html">SkyDomeGenParameters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a888cbcb18e7fc8d471da026686e6dfca">getSkyDomeGenParameters</a> (void) const</td></tr>
<tr class="memdesc:a888cbcb18e7fc8d471da026686e6dfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters used to generate the current SkyDome, if any.  <a href="#a888cbcb18e7fc8d471da026686e6dfca">More...</a><br /></td></tr>
<tr class="separator:a888cbcb18e7fc8d471da026686e6dfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea64fa75fbb1d2ada36b784f9397eb50"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aea64fa75fbb1d2ada36b784f9397eb50">getSkyDomeNode</a> (void) const</td></tr>
<tr class="memdesc:aea64fa75fbb1d2ada36b784f9397eb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sky dome node, if enabled.  <a href="#aea64fa75fbb1d2ada36b784f9397eb50">More...</a><br /></td></tr>
<tr class="separator:aea64fa75fbb1d2ada36b784f9397eb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f600105fe20680b0b90fae9ac28faa"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_ogre_1_1_scene_manager_1_1_sky_plane_gen_parameters.html">SkyPlaneGenParameters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae3f600105fe20680b0b90fae9ac28faa">getSkyPlaneGenParameters</a> (void) const</td></tr>
<tr class="memdesc:ae3f600105fe20680b0b90fae9ac28faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters used to construct the SkyPlane, if any.  <a href="#ae3f600105fe20680b0b90fae9ac28faa">More...</a><br /></td></tr>
<tr class="separator:ae3f600105fe20680b0b90fae9ac28faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e119c2fdae37bd3710078e43d3763d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae5e119c2fdae37bd3710078e43d3763d">getSkyPlaneNode</a> (void) const</td></tr>
<tr class="memdesc:ae5e119c2fdae37bd3710078e43d3763d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sky plane node, if enabled.  <a href="#ae5e119c2fdae37bd3710078e43d3763d">More...</a><br /></td></tr>
<tr class="separator:ae5e119c2fdae37bd3710078e43d3763d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd97aab1507157df4eaf0f6b844bb4c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1v1_1_1_static_geometry.html">v1::StaticGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a3dd97aab1507157df4eaf0f6b844bb4c">getStaticGeometry</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const</td></tr>
<tr class="memdesc:a3dd97aab1507157df4eaf0f6b844bb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a previously created StaticGeometry instance.  <a href="#a3dd97aab1507157df4eaf0f6b844bb4c">More...</a><br /></td></tr>
<tr class="separator:a3dd97aab1507157df4eaf0f6b844bb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6fe27d7a9500aafbe9325c21985801"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_ogre_1_1_view_point.html">ViewPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#add6fe27d7a9500aafbe9325c21985801">getSuggestedViewpoint</a> (bool random=false)</td></tr>
<tr class="memdesc:add6fe27d7a9500aafbe9325c21985801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> to provide a suggested viewpoint from which the scene should be viewed.  <a href="#add6fe27d7a9500aafbe9325c21985801">More...</a><br /></td></tr>
<tr class="separator:add6fe27d7a9500aafbe9325c21985801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46690a40b65fd0e7e89752e1e36be727"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a46690a40b65fd0e7e89752e1e36be727">getTypeName</a> (void) const =0</td></tr>
<tr class="memdesc:a46690a40b65fd0e7e89752e1e36be727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the type name of this scene manager.  <a href="#a46690a40b65fd0e7e89752e1e36be727">More...</a><br /></td></tr>
<tr class="separator:a46690a40b65fd0e7e89752e1e36be727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da39851ae801a1a561a2dc8a269532b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a0da39851ae801a1a561a2dc8a269532b">getVisibilityMask</a> (void) const</td></tr>
<tr class="memdesc:a0da39851ae801a1a561a2dc8a269532b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible.  <a href="#a0da39851ae801a1a561a2dc8a269532b">More...</a><br /></td></tr>
<tr class="separator:a0da39851ae801a1a561a2dc8a269532b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689e655688df190c38eb3437c7a8e94e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a689e655688df190c38eb3437c7a8e94e">hasAnimation</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const</td></tr>
<tr class="memdesc:a689e655688df190c38eb3437c7a8e94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an animation with the given name exists.  <a href="#a689e655688df190c38eb3437c7a8e94e">More...</a><br /></td></tr>
<tr class="separator:a689e655688df190c38eb3437c7a8e94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa968418639b742f299cf6cb553aa73"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#affa968418639b742f299cf6cb553aa73">hasAnimationState</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const</td></tr>
<tr class="memdesc:affa968418639b742f299cf6cb553aa73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an animation state with the given name exists.  <a href="#affa968418639b742f299cf6cb553aa73">More...</a><br /></td></tr>
<tr class="separator:affa968418639b742f299cf6cb553aa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d994816fefb71453799cdc6135f5995"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a0d994816fefb71453799cdc6135f5995">hasInstanceManager</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> managerName) const</td></tr>
<tr class="memdesc:a0d994816fefb71453799cdc6135f5995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an InstanceManager with the given name exists.  <a href="#a0d994816fefb71453799cdc6135f5995">More...</a><br /></td></tr>
<tr class="separator:a0d994816fefb71453799cdc6135f5995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bf05431cd6901c4b2fc9c89a42de67"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a17bf05431cd6901c4b2fc9c89a42de67">hasMovableObject</a> (<a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *m)</td></tr>
<tr class="memdesc:a17bf05431cd6901c4b2fc9c89a42de67"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Returns if this <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> contains the specified <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a>  <a href="#a17bf05431cd6901c4b2fc9c89a42de67">More...</a><br /></td></tr>
<tr class="separator:a17bf05431cd6901c4b2fc9c89a42de67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9731d50869bd17fd55dfbf0f54db78"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a6c9731d50869bd17fd55dfbf0f54db78">hasOption</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;strKey) const</td></tr>
<tr class="memdesc:a6c9731d50869bd17fd55dfbf0f54db78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for verifying whether the scene manager has an implementation-specific option.  <a href="#a6c9731d50869bd17fd55dfbf0f54db78">More...</a><br /></td></tr>
<tr class="separator:a6c9731d50869bd17fd55dfbf0f54db78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a9e2d2738ef22c23a72f5c214d19c8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a16a9e2d2738ef22c23a72f5c214d19c8">hasStaticGeometry</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const</td></tr>
<tr class="memdesc:a16a9e2d2738ef22c23a72f5c214d19c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a static geometry instance with the given name exists.  <a href="#a16a9e2d2738ef22c23a72f5c214d19c8">More...</a><br /></td></tr>
<tr class="separator:a16a9e2d2738ef22c23a72f5c214d19c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13eb691a7bdd67e17a402dee98c4b5f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#af13eb691a7bdd67e17a402dee98c4b5f">injectMovableObject</a> (<a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *m)</td></tr>
<tr class="memdesc:af13eb691a7bdd67e17a402dee98c4b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject a <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instance created externally.  <a href="#af13eb691a7bdd67e17a402dee98c4b5f">More...</a><br /></td></tr>
<tr class="separator:af13eb691a7bdd67e17a402dee98c4b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8f7e94f73720dc0f94bc34610543fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a2d8f7e94f73720dc0f94bc34610543fa">isCurrentShadowNodeReused</a> (void) const</td></tr>
<tr class="separator:a2d8f7e94f73720dc0f94bc34610543fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a77e6deae28a8fdc8068e3dd063419"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a64a77e6deae28a8fdc8068e3dd063419">isLateMaterialResolving</a> () const</td></tr>
<tr class="memdesc:a64a77e6deae28a8fdc8068e3dd063419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether using late material resolving or not.  <a href="#a64a77e6deae28a8fdc8068e3dd063419">More...</a><br /></td></tr>
<tr class="separator:a64a77e6deae28a8fdc8068e3dd063419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9055498d95c80a1290ae70ee932290e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ae9055498d95c80a1290ae70ee932290e">isSkyBoxEnabled</a> (void) const</td></tr>
<tr class="memdesc:ae9055498d95c80a1290ae70ee932290e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a skybox is enabled.  <a href="#ae9055498d95c80a1290ae70ee932290e">More...</a><br /></td></tr>
<tr class="separator:ae9055498d95c80a1290ae70ee932290e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00d89b4d8a646501355447b71a40ad1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ac00d89b4d8a646501355447b71a40ad1">isSkyDomeEnabled</a> (void) const</td></tr>
<tr class="memdesc:ac00d89b4d8a646501355447b71a40ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a skydome is enabled.  <a href="#ac00d89b4d8a646501355447b71a40ad1">More...</a><br /></td></tr>
<tr class="separator:ac00d89b4d8a646501355447b71a40ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd6b70a3a504fabc07d75706ea1e71f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#acdd6b70a3a504fabc07d75706ea1e71f">isSkyPlaneEnabled</a> (void) const</td></tr>
<tr class="memdesc:acdd6b70a3a504fabc07d75706ea1e71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a key plane is enabled.  <a href="#acdd6b70a3a504fabc07d75706ea1e71f">More...</a><br /></td></tr>
<tr class="separator:acdd6b70a3a504fabc07d75706ea1e71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cefefe52f0a24f5df51d8edc36df25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a09cefefe52f0a24f5df51d8edc36df25">notifyStaticAabbDirty</a> (<a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *movableObject)</td></tr>
<tr class="memdesc:a09cefefe52f0a24f5df51d8edc36df25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies that the given <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> is dirty (i.e.  <a href="#a09cefefe52f0a24f5df51d8edc36df25">More...</a><br /></td></tr>
<tr class="separator:a09cefefe52f0a24f5df51d8edc36df25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464c4d6f1f2761d8d3b715df0591b96a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a464c4d6f1f2761d8d3b715df0591b96a">notifyStaticDirty</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a464c4d6f1f2761d8d3b715df0591b96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies that the given <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> is dirty (i.e.  <a href="#a464c4d6f1f2761d8d3b715df0591b96a">More...</a><br /></td></tr>
<tr class="separator:a464c4d6f1f2761d8d3b715df0591b96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b10b7fef2893e75acc083415df70446"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9b10b7fef2893e75acc083415df70446">OGRE_MUTEX</a> (sceneGraphMutex)</td></tr>
<tr class="memdesc:a9b10b7fef2893e75acc083415df70446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to protect the scene graph from simultaneous access from multiple threads.  <a href="#a9b10b7fef2893e75acc083415df70446">More...</a><br /></td></tr>
<tr class="separator:a9b10b7fef2893e75acc083415df70446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b197ca3a38da17e2eb1531a645fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a421b197ca3a38da17e2eb1531a645fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="#a421b197ca3a38da17e2eb1531a645fa2">More...</a><br /></td></tr>
<tr class="separator:a421b197ca3a38da17e2eb1531a645fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78a921e54419be677839cdf15d1f0b8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:ab78a921e54419be677839cdf15d1f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="#ab78a921e54419be677839cdf15d1f0b8">More...</a><br /></td></tr>
<tr class="separator:ab78a921e54419be677839cdf15d1f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be37baef81876985aa1071ad5acc6dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a4be37baef81876985aa1071ad5acc6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="#a4be37baef81876985aa1071ad5acc6dd">More...</a><br /></td></tr>
<tr class="separator:a4be37baef81876985aa1071ad5acc6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2943846ba6a2b5824a12857139cf5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:afa2943846ba6a2b5824a12857139cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ceb87944e7ba077e4c6ed8db8acf4cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a5ceb87944e7ba077e4c6ed8db8acf4cc">prepareWorldGeometry</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename)</td></tr>
<tr class="memdesc:a5ceb87944e7ba077e4c6ed8db8acf4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the source of the 'world' geometry, i.e.  <a href="#a5ceb87944e7ba077e4c6ed8db8acf4cc">More...</a><br /></td></tr>
<tr class="separator:a5ceb87944e7ba077e4c6ed8db8acf4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9633390826daf0fb2c7a8a43abe4f01"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ad9633390826daf0fb2c7a8a43abe4f01">prepareWorldGeometry</a> (<a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;stream, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>)</td></tr>
<tr class="memdesc:ad9633390826daf0fb2c7a8a43abe4f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the source of the 'world' geometry, i.e.  <a href="#ad9633390826daf0fb2c7a8a43abe4f01">More...</a><br /></td></tr>
<tr class="separator:ad9633390826daf0fb2c7a8a43abe4f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff41e7ad0baa4f0aa50f4b3e7048d63"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aaff41e7ad0baa4f0aa50f4b3e7048d63">registerSceneNodeListener</a> (<a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *sceneNode)</td></tr>
<tr class="memdesc:aaff41e7ad0baa4f0aa50f4b3e7048d63"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> listeners need to be registered with us so that they can be successfully called when calling updateAllTransforms.  <a href="#aaff41e7ad0baa4f0aa50f4b3e7048d63">More...</a><br /></td></tr>
<tr class="separator:aaff41e7ad0baa4f0aa50f4b3e7048d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4437b11b78eae8f5db205aa89c0235ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a4437b11b78eae8f5db205aa89c0235ee">removeListener</a> (<a class="el" href="class_ogre_1_1_scene_manager_1_1_listener.html">Listener</a> *s)</td></tr>
<tr class="memdesc:a4437b11b78eae8f5db205aa89c0235ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a listener.  <a href="#a4437b11b78eae8f5db205aa89c0235ee">More...</a><br /></td></tr>
<tr class="separator:a4437b11b78eae8f5db205aa89c0235ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cc1bb36997b722fc60efc7903f3760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a25cc1bb36997b722fc60efc7903f3760">removeLodListener</a> (<a class="el" href="class_ogre_1_1_lod_listener.html">LodListener</a> *listener)</td></tr>
<tr class="memdesc:a25cc1bb36997b722fc60efc7903f3760"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Remove a level of detail listener.  <a href="#a25cc1bb36997b722fc60efc7903f3760">More...</a><br /></td></tr>
<tr class="separator:a25cc1bb36997b722fc60efc7903f3760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a482e0a9f78109a5a467ddd6c16082b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a2a482e0a9f78109a5a467ddd6c16082b">removeRenderObjectListener</a> (<a class="el" href="class_ogre_1_1_render_object_listener.html">RenderObjectListener</a> *delListener)</td></tr>
<tr class="memdesc:a2a482e0a9f78109a5a467ddd6c16082b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a listener previously added with addRenderObjectListener.  <a href="#a2a482e0a9f78109a5a467ddd6c16082b">More...</a><br /></td></tr>
<tr class="separator:a2a482e0a9f78109a5a467ddd6c16082b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190471ba7a61111d576a1e8ca9862706"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a190471ba7a61111d576a1e8ca9862706">removeRenderQueueListener</a> (<a class="el" href="class_ogre_1_1_render_queue_listener.html">RenderQueueListener</a> *delListener)</td></tr>
<tr class="memdesc:a190471ba7a61111d576a1e8ca9862706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a listener previously added with addRenderQueueListener.  <a href="#a190471ba7a61111d576a1e8ca9862706">More...</a><br /></td></tr>
<tr class="separator:a190471ba7a61111d576a1e8ca9862706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cd9aa2c4dee4eec9eb07ce1372fb52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a56cd9aa2c4dee4eec9eb07ce1372fb52">setAmbientLight</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;upperHemisphere, const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;lowerHemisphere, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;hemisphereDir, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> envmapScale=1.0f)</td></tr>
<tr class="memdesc:a56cd9aa2c4dee4eec9eb07ce1372fb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ambient light level to be used for the scene.  <a href="#a56cd9aa2c4dee4eec9eb07ce1372fb52">More...</a><br /></td></tr>
<tr class="separator:a56cd9aa2c4dee4eec9eb07ce1372fb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c5cbc33b0f498ed01670289e87584c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a46c5cbc33b0f498ed01670289e87584c">setDisplaySceneNodes</a> (bool display)</td></tr>
<tr class="memdesc:a46c5cbc33b0f498ed01670289e87584c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> whether it should render the SceneNodes which make up the scene as well as the objects in the scene.  <a href="#a46c5cbc33b0f498ed01670289e87584c">More...</a><br /></td></tr>
<tr class="separator:a46c5cbc33b0f498ed01670289e87584c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c8414da02aec3e3f98acd013917ed2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a04c8414da02aec3e3f98acd013917ed2">setFindVisibleObjects</a> (bool find)</td></tr>
<tr class="memdesc:a04c8414da02aec3e3f98acd013917ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> should search for visible objects, or whether they are being manually handled.  <a href="#a04c8414da02aec3e3f98acd013917ed2">More...</a><br /></td></tr>
<tr class="separator:a04c8414da02aec3e3f98acd013917ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4d997503b651187f2e129cd5eeb7ad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a2a4d997503b651187f2e129cd5eeb7ad">setFlipCullingOnNegativeScale</a> (bool n)</td></tr>
<tr class="memdesc:a2a4d997503b651187f2e129cd5eeb7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether to automatically flip the culling mode on objects whenever they are negatively scaled.  <a href="#a2a4d997503b651187f2e129cd5eeb7ad">More...</a><br /></td></tr>
<tr class="separator:a2a4d997503b651187f2e129cd5eeb7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab804195c05873da617dcd16198a63d1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ab804195c05873da617dcd16198a63d1c">setFog</a> (<a class="el" href="group___general.html#ga83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a> mode=<a class="el" href="group___general.html#gga83edeb2e5d33a3ca8f15834ba40020baab7793a21880052c0214d4cc040992310">FOG_NONE</a>, const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;colour=<a class="el" href="class_ogre_1_1_colour_value.html#a8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a>, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> expDensity=0.001, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearStart=0.0, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearEnd=1.0)</td></tr>
<tr class="memdesc:ab804195c05873da617dcd16198a63d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fogging mode applied to the scene.  <a href="#ab804195c05873da617dcd16198a63d1c">More...</a><br /></td></tr>
<tr class="separator:ab804195c05873da617dcd16198a63d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4cbdad7664b8747f1929dbec29c046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a7b4cbdad7664b8747f1929dbec29c046">setForward3D</a> (bool bEnable, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> width, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> height, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> numSlices, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> lightsPerCell, float minDistance, float maxDistance)</td></tr>
<tr class="memdesc:a7b4cbdad7664b8747f1929dbec29c046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the <a class="el" href="class_ogre_1_1_forward3_d.html" title="Forward3D. ">Forward3D</a> implementation for using many non-shadowed lights in the scene.  <a href="#a7b4cbdad7664b8747f1929dbec29c046">More...</a><br /></td></tr>
<tr class="separator:a7b4cbdad7664b8747f1929dbec29c046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854fc565dca2ee633ad55c75235ad293"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a854fc565dca2ee633ad55c75235ad293">setForwardClustered</a> (bool bEnable, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> width, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> height, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> numSlices, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> lightsPerCell, float minDistance, float maxDistance)</td></tr>
<tr class="separator:a854fc565dca2ee633ad55c75235ad293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c1371039d40e139a37b2b174538978"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a86c1371039d40e139a37b2b174538978">setLateMaterialResolving</a> (bool isLate)</td></tr>
<tr class="memdesc:a86c1371039d40e139a37b2b174538978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether to use late material resolving or not.  <a href="#a86c1371039d40e139a37b2b174538978">More...</a><br /></td></tr>
<tr class="separator:a86c1371039d40e139a37b2b174538978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f3ddda75dcf75d5c5176446b3316a8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a34f3ddda75dcf75d5c5176446b3316a8">setOption</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;strKey, const void *pValue)</td></tr>
<tr class="memdesc:a34f3ddda75dcf75d5c5176446b3316a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for setting a specific option of the Scene Manager.  <a href="#a34f3ddda75dcf75d5c5176446b3316a8">More...</a><br /></td></tr>
<tr class="separator:a34f3ddda75dcf75d5c5176446b3316a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee0d5d307652b51bc7a405907a85368"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a3ee0d5d307652b51bc7a405907a85368">setRelativeOrigin</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;relativeOrigin, bool bPermanent)</td></tr>
<tr class="memdesc:a3ee0d5d307652b51bc7a405907a85368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether to use relative offset co-ordinates when rendering, ie offset to subtract to the camera, lights &amp; objects.  <a href="#a3ee0d5d307652b51bc7a405907a85368">More...</a><br /></td></tr>
<tr class="separator:a3ee0d5d307652b51bc7a405907a85368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ab6139696f9ef50d8abea0528e85b4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ad8ab6139696f9ef50d8abea0528e85b4">setShadowColour</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;colour)</td></tr>
<tr class="memdesc:ad8ab6139696f9ef50d8abea0528e85b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the colour used to modulate areas in shadow.  <a href="#ad8ab6139696f9ef50d8abea0528e85b4">More...</a><br /></td></tr>
<tr class="separator:ad8ab6139696f9ef50d8abea0528e85b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d220fa31bf0d95ad65558936c71a194"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9d220fa31bf0d95ad65558936c71a194">setShadowDirectionalLightExtrusionDistance</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> dist)</td></tr>
<tr class="memdesc:a9d220fa31bf0d95ad65558936c71a194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the distance a shadow volume is extruded for a directional light.  <a href="#a9d220fa31bf0d95ad65558936c71a194">More...</a><br /></td></tr>
<tr class="separator:a9d220fa31bf0d95ad65558936c71a194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893663f55c2b4a29467cff25b9b1b3f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a893663f55c2b4a29467cff25b9b1b3f4">setShadowDirLightTextureOffset</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> offset)</td></tr>
<tr class="memdesc:a893663f55c2b4a29467cff25b9b1b3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space.  <a href="#a893663f55c2b4a29467cff25b9b1b3f4">More...</a><br /></td></tr>
<tr class="separator:a893663f55c2b4a29467cff25b9b1b3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e593d05e2f892b8fc3bfca917a75fef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a0e593d05e2f892b8fc3bfca917a75fef">setShadowFarDistance</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> distance)</td></tr>
<tr class="memdesc:a0e593d05e2f892b8fc3bfca917a75fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default maximum distance away from the camera that shadows will be visible.  <a href="#a0e593d05e2f892b8fc3bfca917a75fef">More...</a><br /></td></tr>
<tr class="separator:a0e593d05e2f892b8fc3bfca917a75fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0cde141313583e65561abdfae6a0ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9f0cde141313583e65561abdfae6a0ec">setShadowTextureCasterMaterial</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:a9f0cde141313583e65561abdfae6a0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default material to use for rendering shadow casters.  <a href="#a9f0cde141313583e65561abdfae6a0ec">More...</a><br /></td></tr>
<tr class="separator:a9f0cde141313583e65561abdfae6a0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237a09e65919b808473c543fb886723f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a237a09e65919b808473c543fb886723f">setShadowTextureFadeEnd</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fadeEnd)</td></tr>
<tr class="memdesc:a237a09e65919b808473c543fb886723f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the proportional distance at which texture shadows finish to fading out.  <a href="#a237a09e65919b808473c543fb886723f">More...</a><br /></td></tr>
<tr class="separator:a237a09e65919b808473c543fb886723f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fa019aa4efbc6943842efcf5f38078"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a72fa019aa4efbc6943842efcf5f38078">setShadowTextureFadeStart</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fadeStart)</td></tr>
<tr class="memdesc:a72fa019aa4efbc6943842efcf5f38078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the proportional distance at which texture shadows begin to fade out.  <a href="#a72fa019aa4efbc6943842efcf5f38078">More...</a><br /></td></tr>
<tr class="separator:a72fa019aa4efbc6943842efcf5f38078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af419fca38294bef65224162b3ad4af36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#af419fca38294bef65224162b3ad4af36">setSkyBox</a> (bool enable, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> distance=5000, bool drawFirst=true, const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;orientation=<a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>
<tr class="memdesc:af419fca38294bef65224162b3ad4af36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables / disables a 'sky box' i.e.  <a href="#af419fca38294bef65224162b3ad4af36">More...</a><br /></td></tr>
<tr class="separator:af419fca38294bef65224162b3ad4af36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ba1fc585a224a834ffe2624db23e57"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ad8ba1fc585a224a834ffe2624db23e57">setSkyBoxEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:ad8ba1fc585a224a834ffe2624db23e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables / disables a 'sky box'.  <a href="#ad8ba1fc585a224a834ffe2624db23e57">More...</a><br /></td></tr>
<tr class="separator:ad8ba1fc585a224a834ffe2624db23e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add758e3fa5df1291df9ff98b2594d35b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#add758e3fa5df1291df9ff98b2594d35b">setSkyDome</a> (bool enable, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> curvature=10, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> tiling=8, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> distance=4000, bool drawFirst=true, const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;orientation=<a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>, int xsegments=16, int ysegments=16, int ysegments_keep=-1, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>
<tr class="memdesc:add758e3fa5df1291df9ff98b2594d35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables / disables a 'sky dome' i.e.  <a href="#add758e3fa5df1291df9ff98b2594d35b">More...</a><br /></td></tr>
<tr class="separator:add758e3fa5df1291df9ff98b2594d35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a692ae852b41cf6e7e8ac647d2660f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a50a692ae852b41cf6e7e8ac647d2660f">setSkyDomeEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:a50a692ae852b41cf6e7e8ac647d2660f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables / disables a 'sky dome'.  <a href="#a50a692ae852b41cf6e7e8ac647d2660f">More...</a><br /></td></tr>
<tr class="separator:a50a692ae852b41cf6e7e8ac647d2660f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9395e50574b0d0c343036cf816c2bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a7f9395e50574b0d0c343036cf816c2bf">setSkyPlane</a> (bool enable, const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;plane, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> scale=1000, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> tiling=10, bool drawFirst=true, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> bow=0, int xsegments=1, int ysegments=1, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>
<tr class="memdesc:a7f9395e50574b0d0c343036cf816c2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables / disables a 'sky plane' i.e.  <a href="#a7f9395e50574b0d0c343036cf816c2bf">More...</a><br /></td></tr>
<tr class="separator:a7f9395e50574b0d0c343036cf816c2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213f0aaaf1341fe090e66968c8907f44"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a213f0aaaf1341fe090e66968c8907f44">setSkyPlaneEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:a213f0aaaf1341fe090e66968c8907f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables / disables a 'sky plane'.  <a href="#a213f0aaaf1341fe090e66968c8907f44">More...</a><br /></td></tr>
<tr class="separator:a213f0aaaf1341fe090e66968c8907f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5e69ee25b1e34eadd088d7d58ef02d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a7c5e69ee25b1e34eadd088d7d58ef02d">setVisibilityMask</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> vmask)</td></tr>
<tr class="memdesc:a7c5e69ee25b1e34eadd088d7d58ef02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible.  <a href="#a7c5e69ee25b1e34eadd088d7d58ef02d">More...</a><br /></td></tr>
<tr class="separator:a7c5e69ee25b1e34eadd088d7d58ef02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb0fdfbd1f61aa4d3d6e1f4625e1f9c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#accb0fdfbd1f61aa4d3d6e1f4625e1f9c">setWorldGeometry</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename)</td></tr>
<tr class="memdesc:accb0fdfbd1f61aa4d3d6e1f4625e1f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the source of the 'world' geometry, i.e.  <a href="#accb0fdfbd1f61aa4d3d6e1f4625e1f9c">More...</a><br /></td></tr>
<tr class="separator:accb0fdfbd1f61aa4d3d6e1f4625e1f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7ebcecf64452f59211f45d4ec33576"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9b7ebcecf64452f59211f45d4ec33576">setWorldGeometry</a> (<a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;stream, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>)</td></tr>
<tr class="memdesc:a9b7ebcecf64452f59211f45d4ec33576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the source of the 'world' geometry, i.e.  <a href="#a9b7ebcecf64452f59211f45d4ec33576">More...</a><br /></td></tr>
<tr class="separator:a9b7ebcecf64452f59211f45d4ec33576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487859007d68fe9f261aea1645252563"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a487859007d68fe9f261aea1645252563">showBoundingBoxes</a> (bool bShow)</td></tr>
<tr class="memdesc:a487859007d68fe9f261aea1645252563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows all bounding boxes of scene nodes to be displayed.  <a href="#a487859007d68fe9f261aea1645252563">More...</a><br /></td></tr>
<tr class="separator:a487859007d68fe9f261aea1645252563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac660da6d88e53b19c0062884705222ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#ac660da6d88e53b19c0062884705222ca">unregisterSceneNodeListener</a> (<a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *sceneNode)</td></tr>
<tr class="memdesc:ac660da6d88e53b19c0062884705222ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a registered node for listening.  <a href="#ac660da6d88e53b19c0062884705222ca">More...</a><br /></td></tr>
<tr class="separator:ac660da6d88e53b19c0062884705222ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393dbe126bfaaf7f5aa4712a84d3facd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a393dbe126bfaaf7f5aa4712a84d3facd">updateAllAnimations</a> ()</td></tr>
<tr class="memdesc:a393dbe126bfaaf7f5aa4712a84d3facd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates all skeletal animations in the scene.  <a href="#a393dbe126bfaaf7f5aa4712a84d3facd">More...</a><br /></td></tr>
<tr class="separator:a393dbe126bfaaf7f5aa4712a84d3facd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de4ecb4955dcf164cfeb69c457716ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a5de4ecb4955dcf164cfeb69c457716ee">updateAllBounds</a> (const ObjectMemoryManagerVec &amp;objectMemManager)</td></tr>
<tr class="memdesc:a5de4ecb4955dcf164cfeb69c457716ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the world aabbs from all entities in the scene.  <a href="#a5de4ecb4955dcf164cfeb69c457716ee">More...</a><br /></td></tr>
<tr class="separator:a5de4ecb4955dcf164cfeb69c457716ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ce1584abf7edd2896e7f7c0d0bd629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a77ce1584abf7edd2896e7f7c0d0bd629">updateAllLods</a> (const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *lodCamera, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> lodBias, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> firstRq, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> lastRq)</td></tr>
<tr class="memdesc:a77ce1584abf7edd2896e7f7c0d0bd629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the Lod values of all objects relative to the given camera.  <a href="#a77ce1584abf7edd2896e7f7c0d0bd629">More...</a><br /></td></tr>
<tr class="separator:a77ce1584abf7edd2896e7f7c0d0bd629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99abd1ab437720f0b1056080736b164"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#aa99abd1ab437720f0b1056080736b164">updateAllTagPoints</a> (void)</td></tr>
<tr class="memdesc:aa99abd1ab437720f0b1056080736b164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates all TagPoints, both TagPoints that are children of bones, and TagPoints that are children of other TagPoints.  <a href="#aa99abd1ab437720f0b1056080736b164">More...</a><br /></td></tr>
<tr class="separator:aa99abd1ab437720f0b1056080736b164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f59ebdfaadbe33f713d754737041654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a1f59ebdfaadbe33f713d754737041654">updateAllTransforms</a> ()</td></tr>
<tr class="memdesc:a1f59ebdfaadbe33f713d754737041654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the derived transforms of all nodes in the scene.  <a href="#a1f59ebdfaadbe33f713d754737041654">More...</a><br /></td></tr>
<tr class="separator:a1f59ebdfaadbe33f713d754737041654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbd2750082529aed2375531a4d5d9cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a3cbd2750082529aed2375531a4d5d9cd">updateSceneGraph</a> ()</td></tr>
<tr class="memdesc:a3cbd2750082529aed2375531a4d5d9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the scene: Perform high level culling, <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> transforms and entity animations.  <a href="#a3cbd2750082529aed2375531a4d5d9cd">More...</a><br /></td></tr>
<tr class="separator:a3cbd2750082529aed2375531a4d5d9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c832526246a71e73cd517bff928a64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a11c832526246a71e73cd517bff928a64">waitForPendingUserScalableTask</a> ()</td></tr>
<tr class="memdesc:a11c832526246a71e73cd517bff928a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until the the task from processUserScalableTask finishes.  <a href="#a11c832526246a71e73cd517bff928a64">More...</a><br /></td></tr>
<tr class="separator:a11c832526246a71e73cd517bff928a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6c140ffaced93a2b854e5c519c8fb568"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a6c140ffaced93a2b854e5c519c8fb568">QUERY_ENTITY_DEFAULT_MASK</a></td></tr>
<tr class="memdesc:a6c140ffaced93a2b854e5c519c8fb568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default query mask for entities.  <a href="#a6c140ffaced93a2b854e5c519c8fb568">More...</a><br /></td></tr>
<tr class="separator:a6c140ffaced93a2b854e5c519c8fb568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6617d4f358cbe1d72edd06b7a8ad62bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a6617d4f358cbe1d72edd06b7a8ad62bd">QUERY_FRUSTUM_DEFAULT_MASK</a></td></tr>
<tr class="memdesc:a6617d4f358cbe1d72edd06b7a8ad62bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default query mask for frusta and cameras.  <a href="#a6617d4f358cbe1d72edd06b7a8ad62bd">More...</a><br /></td></tr>
<tr class="separator:a6617d4f358cbe1d72edd06b7a8ad62bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412b439c03cb282ee205498d9b00220e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a412b439c03cb282ee205498d9b00220e">QUERY_FX_DEFAULT_MASK</a></td></tr>
<tr class="memdesc:a412b439c03cb282ee205498d9b00220e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default query mask for effects like billboardsets / particle systems.  <a href="#a412b439c03cb282ee205498d9b00220e">More...</a><br /></td></tr>
<tr class="separator:a412b439c03cb282ee205498d9b00220e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2789c7eea005fd7c63b3ee3b850617"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a9d2789c7eea005fd7c63b3ee3b850617">QUERY_LIGHT_DEFAULT_MASK</a></td></tr>
<tr class="memdesc:a9d2789c7eea005fd7c63b3ee3b850617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default query mask for lights.  <a href="#a9d2789c7eea005fd7c63b3ee3b850617">More...</a><br /></td></tr>
<tr class="separator:a9d2789c7eea005fd7c63b3ee3b850617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09844d40f3b7404e591224b814067e63"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html#a09844d40f3b7404e591224b814067e63">QUERY_STATICGEOMETRY_DEFAULT_MASK</a></td></tr>
<tr class="memdesc:a09844d40f3b7404e591224b814067e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default query mask for StaticGeometry.  <a href="#a09844d40f3b7404e591224b814067e63">More...</a><br /></td></tr>
<tr class="separator:a09844d40f3b7404e591224b814067e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manages the organisation and rendering of a 'scene' i.e. </p>
<p>a collection of objects and potentially world geometry. </p><dl class="section remark"><dt>Remarks</dt><dd>This class defines the interface and the basic behaviour of a 'Scene Manager'. A <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> organises the culling and rendering of the scene, in conjunction with the <a class="el" href="class_ogre_1_1_render_queue.html" title="Enumeration of queue groups, by which the application may group queued renderables so that they are r...">RenderQueue</a>. This class is designed to be extended through subclassing in order to provide more specialised scene organisation structures for particular needs. The default <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> culls based on a hierarchy of node bounding boxes, other implementations can use an octree (</dd></dl>
<dl class="section see"><dt>See also</dt><dd>OctreeSceneManager), a BSP tree (</dd>
<dd>
BspSceneManager), and many other options. New <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> implementations can be added at runtime by plugins, see <a class="el" href="class_ogre_1_1_scene_manager_enumerator.html" title="Enumerates the SceneManager classes available to applications. ">SceneManagerEnumerator</a> for the interfaces for adding new <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> types. </dd></dl>
<dl class="section user"><dt></dt><dd>There is a distinction between 'objects' (which subclass <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a>, and are movable, discrete objects in the world), and 'world geometry', which is large, generally static geometry. World geometry tends to influence the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> organisational structure (e.g. lots of indoor static geometry might result in a spatial tree structure) and as such world geometry is generally tied to a given <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> implementation, whilst <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instances can be used with any <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. Subclasses are free to define world geometry however they please. </dd></dl>
<dl class="section user"><dt></dt><dd>Multiple <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> instances can exist at one time, each one with a distinct scene. Which <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> is used to render a scene is dependent on the <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Camera</a>, which will always call back the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> which created it to render the scene. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3a720414f68274bb9c5026911e27135d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a720414f68274bb9c5026911e27135d">&#9670;&nbsp;</a></span>AnimationIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_map_iterator.html">MapIterator</a>&lt;AnimationList&gt; <a class="el" href="class_ogre_1_1_scene_manager.html#a3a720414f68274bb9c5026911e27135d">Ogre::SceneManager::AnimationIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a460e50da4b97d1beaef1a64bfa039928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460e50da4b97d1beaef1a64bfa039928">&#9670;&nbsp;</a></span>CameraIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt;CameraList&gt; <a class="el" href="class_ogre_1_1_scene_manager.html#a460e50da4b97d1beaef1a64bfa039928">Ogre::SceneManager::CameraIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5348867645ff727d1ca25dd89795376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5348867645ff727d1ca25dd89795376">&#9670;&nbsp;</a></span>MovableObjectIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_scene_manager.html#a6d8f5f81e262b6347f5066da27d6fe70">MovableObjectVec</a>&gt; <a class="el" href="class_ogre_1_1_scene_manager.html#af5348867645ff727d1ca25dd89795376">Ogre::SceneManager::MovableObjectIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d8f5f81e262b6347f5066da27d6fe70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8f5f81e262b6347f5066da27d6fe70">&#9670;&nbsp;</a></span>MovableObjectVec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a>*&gt;::type <a class="el" href="class_ogre_1_1_scene_manager.html#a6d8f5f81e262b6347f5066da27d6fe70">Ogre::SceneManager::MovableObjectVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f87c38314b272fff95da3065f3740ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f87c38314b272fff95da3065f3740ee">&#9670;&nbsp;</a></span>SceneNodeList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>*&gt;::type <a class="el" href="class_ogre_1_1_scene_manager.html#a8f87c38314b272fff95da3065f3740ee">Ogre::SceneManager::SceneNodeList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a51db39cc4fa15b28086a1793d42fc827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51db39cc4fa15b28086a1793d42fc827">&#9670;&nbsp;</a></span>IlluminationRenderStage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_scene_manager.html#a51db39cc4fa15b28086a1793d42fc827">Ogre::SceneManager::IlluminationRenderStage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes the stage of rendering when performing complex illumination. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a51db39cc4fa15b28086a1793d42fc827a8fd3e7fb8fab382a9d29e6e081ae556a"></a>IRS_NONE&#160;</td><td class="fielddoc"><p>No special illumination stage. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51db39cc4fa15b28086a1793d42fc827a8f99da7404ae8c16199dde8d34367b1a"></a>IRS_RENDER_TO_TEXTURE&#160;</td><td class="fielddoc"><p>Render to texture stage, used for texture based shadows. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab4c2ff4f6c76f7fe0a8eae76f2a84cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c2ff4f6c76f7fe0a8eae76f2a84cbf">&#9670;&nbsp;</a></span>PrefabType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_scene_manager.html#ab4c2ff4f6c76f7fe0a8eae76f2a84cbf">Ogre::SceneManager::PrefabType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefab shapes available without loading a model. </p>
<dl class="section note"><dt>Note</dt><dd>Minimal implementation at present. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab4c2ff4f6c76f7fe0a8eae76f2a84cbfaf0fb654fb98508a564c17d3d5b2feee3"></a>PT_PLANE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab4c2ff4f6c76f7fe0a8eae76f2a84cbfa25b0181d24b783ab75da2520305d292a"></a>PT_CUBE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab4c2ff4f6c76f7fe0a8eae76f2a84cbfa0f94148c2cfe190f3ea04374af220eba"></a>PT_SPHERE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae779d9309751113de23917f12af69bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae779d9309751113de23917f12af69bbf">&#9670;&nbsp;</a></span>SceneManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::SceneManager::SceneManager </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>instanceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numWorkerThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___scene.html#gafdd170d87744deec0ca8dd1730797be7">InstancingThreadedCullingMethod</a>&#160;</td>
          <td class="paramname"><em>threadedCullingMethod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a6c8b9108b44339a321bc69b25a0c0a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8b9108b44339a321bc69b25a0c0a1a">&#9670;&nbsp;</a></span>~SceneManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::SceneManager::~SceneManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9f0b98113bf8c46fc2413f09326b9c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0b98113bf8c46fc2413f09326b9c9e">&#9670;&nbsp;</a></span>_addAutotrackingSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_addAutotrackingSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method for notifying the manager that a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> is autotracking. </p>

</div>
</div>
<a id="a4134b90be26b23aff4dc05ae89840862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4134b90be26b23aff4dc05ae89840862">&#9670;&nbsp;</a></span>_addCompositorTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_addCompositorTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a> *&#160;</td>
          <td class="paramname"><em>texs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used by Compositor, tells of which compositor textures active, so Materials can access them. </p>
<p>If MRT, there could be more than one </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the texture(s) as referenced in the compositor (may not be the texture's real name in case it's just one) </td></tr>
    <tr><td class="paramname">tex</td><td>The actual texture(s) associated with that name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a9c54dae09ee2532723cb2d5632be24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9c54dae09ee2532723cb2d5632be24">&#9670;&nbsp;</a></span>_addWireAabb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_addWireAabb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_wire_aabb.html">WireAabb</a> *&#160;</td>
          <td class="paramname"><em>wireAabb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58019e4c5104af4fe19d483fb1deec91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58019e4c5104af4fe19d483fb1deec91">&#9670;&nbsp;</a></span>_applySceneAnimations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_applySceneAnimations </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method for applying animations to scene nodes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Uses the internally stored AnimationState objects to apply animation to SceneNodes. </dd></dl>

</div>
</div>
<a id="af7806fd7b6e943c67d80f23de0b3b518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7806fd7b6e943c67d80f23de0b3b518">&#9670;&nbsp;</a></span>_areRenderStateChangesSuppressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::_areRenderStateChangesSuppressed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are render state changes suppressed? </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a6753ea2b52715774b7fdd59da232917a" title="Indicates to the SceneManager whether it should suppress changing the RenderSystem states when render...">_suppressRenderStateChanges</a> </dd></dl>

</div>
</div>
<a id="a245b17763b78ee37c0c281209c43cefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245b17763b78ee37c0c281209c43cefd">&#9670;&nbsp;</a></span>_calculateCurrentCastersBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> Ogre::SceneManager::_calculateCurrentCastersBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>viewportVisibilityMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>firstRq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>lastRq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44eced0cf629b0e1d9dcdc9dc91d9fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44eced0cf629b0e1d9dcdc9dc91d9fe7">&#9670;&nbsp;</a></span>_createSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneManager::_createSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>nodeMemoryManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a25a28f0f0da21cfaf01ccf1cf0fb2d75" title="Creates an instance of a SceneNode. ">createSceneNode</a>. This functions exists to satisfy </dd>
<dd>
SceneNode::createChildImpl Don't call this function directly </dd></dl>
<dl class="section user"><dt></dt><dd>Parent to the scene node we're creating. </dd></dl>

</div>
</div>
<a id="a390dbb45459db4b8666ce4952a8d7353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390dbb45459db4b8666ce4952a8d7353">&#9670;&nbsp;</a></span>_createTagPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_tag_point.html">TagPoint</a>* Ogre::SceneManager::_createTagPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>nodeMemoryManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Don't call this function directly. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_tag_point.html#a790b5f3c260a3a487b90f8d6875228eb">TagPoint::createChildTagPoint</a> </dd></dl>

</div>
</div>
<a id="a4c44b63c286856417261e165cca88296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c44b63c286856417261e165cca88296">&#9670;&nbsp;</a></span>_cullPhase01()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_cullPhase01 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_viewport.html">Viewport</a> *&#160;</td>
          <td class="paramname"><em>vp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>firstRq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>lastRq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the frustum culling that will later be needed by _renderPhase02. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="class_ogre_1_1_compositor_shadow_node.html" title="Shadow Nodes are special nodes (not to be confused with. ">CompositorShadowNode</a> to understand why rendering is split in two phases </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera</td><td>Pointer to a camera from whose viewpoint the scene is to be rendered. </td></tr>
    <tr><td class="paramname">vp</td><td>The target viewport </td></tr>
    <tr><td class="paramname">firstRq</td><td>first render queue ID to render (gets clamped if too big) </td></tr>
    <tr><td class="paramname">lastRq</td><td>last render queue ID to render (gets clamped if too big) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8061e52306ec97f0a5039e1f0cf79d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8061e52306ec97f0a5039e1f0cf79d3">&#9670;&nbsp;</a></span>_frameEnded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_frameEnded </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when the frame has fully ended (ALL passes have been executed to all RTTs) </p>

</div>
</div>
<a id="a0762e122fb47a25ffde29b5ae8969a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0762e122fb47a25ffde29b5ae8969a41">&#9670;&nbsp;</a></span>_getActivePassForwardPlus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_forward_plus_base.html">ForwardPlusBase</a>* Ogre::SceneManager::_getActivePassForwardPlus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a981ad410d5a077bb64938685e10fcee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981ad410d5a077bb64938685e10fcee0">&#9670;&nbsp;</a></span>_getCombinedVisibilityMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::SceneManager::_getCombinedVisibilityMask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for getting the combination between the global visibility mask and the per-viewport visibility mask. </p>

</div>
</div>
<a id="aaa36e203e1ba3eeab880e4c51a51efae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa36e203e1ba3eeab880e4c51a51efae">&#9670;&nbsp;</a></span>_getCurrentRenderStage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_manager.html#a51db39cc4fa15b28086a1793d42fc827">IlluminationRenderStage</a> Ogre::SceneManager::_getCurrentRenderStage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cd7c70305104c508f85f339e423e973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd7c70305104c508f85f339e423e973">&#9670;&nbsp;</a></span>_getEntityMemoryManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a>&amp; Ogre::SceneManager::_getEntityMemoryManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the main entity memory manager. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Some Scene Managers may have more than one memory manager (e.g. one per octant in an Octree implementation). At end of scene graph update the scene manager may move the object created with the main memory manager into another another one. </dd></dl>

</div>
</div>
<a id="ae90fc3ef537c55399c6680d84d26edaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90fc3ef537c55399c6680d84d26edaf">&#9670;&nbsp;</a></span>_getLightMemoryManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a>&amp; Ogre::SceneManager::_getLightMemoryManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad732f23cbf6537f5919d347932fa542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad732f23cbf6537f5919d347932fa542">&#9670;&nbsp;</a></span>_getNodeMemoryManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a>&amp; Ogre::SceneManager::_getNodeMemoryManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9ec4470160bb92356ae647f70fa9add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ec4470160bb92356ae647f70fa9add">&#9670;&nbsp;</a></span>_getTagPointNodeMemoryManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a>&amp; Ogre::SceneManager::_getTagPointNodeMemoryManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa27460861e2dd924d914ec21987993b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27460861e2dd924d914ec21987993b4">&#9670;&nbsp;</a></span>_getTmpVisibleObjectsList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___scene.html#ga21ffab3c275854b773dcd9efeba9152c">VisibleObjectsPerThreadArray</a>&amp; Ogre::SceneManager::_getTmpVisibleObjectsList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mTmpVisibleObjects </p>

</div>
</div>
<a id="a72e39912a34617ffa0455f859ec438c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e39912a34617ffa0455f859ec438c3">&#9670;&nbsp;</a></span>_handleLodEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_handleLodEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle LOD events. </p>

</div>
</div>
<a id="ac631d25ab65e821544835bfa1b507fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac631d25ab65e821544835bfa1b507fc2">&#9670;&nbsp;</a></span>_markGpuParamsDirty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_markGpuParamsDirty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to allow you to mark gpu parameters as dirty, causing them to be updated according to the mask that you set when updateGpuProgramParameters is next called. </p>
<p>Only really useful if you're controlling parameter state in inner rendering loop callbacks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Some combination of GpuParamVariability which is bitwise OR'ed with the current dirty state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a272d1a76e7854e51f824f0099a4910cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272d1a76e7854e51f824f0099a4910cf">&#9670;&nbsp;</a></span>_notifyEntityMaterialLodChanged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_notifyEntityMaterialLodChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_entity_material_lod_changed_event.html">EntityMaterialLodChangedEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>evt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify that an entity material LOD change event has occurred. </p>

</div>
</div>
<a id="ad0a84e6426cad7dfd721fb5fccd9976c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a84e6426cad7dfd721fb5fccd9976c">&#9670;&nbsp;</a></span>_notifyEntityMeshLodChanged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_notifyEntityMeshLodChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_entity_mesh_lod_changed_event.html">EntityMeshLodChangedEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>evt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify that an entity mesh LOD change event has occurred. </p>

</div>
</div>
<a id="ae4b6a7748dc4273fd6c160fb162c544f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b6a7748dc4273fd6c160fb162c544f">&#9670;&nbsp;</a></span>_notifyMovableObjectLodChanged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_notifyMovableObjectLodChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_movable_object_lod_changed_event.html">MovableObjectLodChangedEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>evt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify that a movable object LOD change event has occurred. </p>

</div>
</div>
<a id="a2392e8d6a6849a4fa1839a085733a695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2392e8d6a6849a4fa1839a085733a695">&#9670;&nbsp;</a></span>_pauseRendering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_ogre_1_1_scene_manager_1_1_render_context.html">RenderContext</a>* Ogre::SceneManager::_pauseRendering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pause rendering of the frame. </p>
<p>This has to be called when inside a renderScene call (Usually using a listener of some sort) </p>

</div>
</div>
<a id="a85f817bd7ceae5bb1601b9b838eaff80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f817bd7ceae5bb1601b9b838eaff80">&#9670;&nbsp;</a></span>_queueSkiesForRendering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_queueSkiesForRendering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>cam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method for queueing the sky objects with the params as previously set through setSkyBox, setSkyPlane and setSkyDome. </p>

</div>
</div>
<a id="a75673d9890a711b6de478ddab53d1aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75673d9890a711b6de478ddab53d1aa9">&#9670;&nbsp;</a></span>_removeAutotrackingSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_removeAutotrackingSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a351700ac72df07006c59e1aa07dded7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351700ac72df07006c59e1aa07dded7c">&#9670;&nbsp;</a></span>_removeCompositorTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_removeCompositorTextures </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all compositor textures from 'from' to end. </p>

</div>
</div>
<a id="adadb06373ea8f59dc573bfd1d8e03713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadb06373ea8f59dc573bfd1d8e03713">&#9670;&nbsp;</a></span>_removeWireAabb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_removeWireAabb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_wire_aabb.html">WireAabb</a> *&#160;</td>
          <td class="paramname"><em>wireAabb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae92635a6112f5f1215c2bc2e59003127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92635a6112f5f1215c2bc2e59003127">&#9670;&nbsp;</a></span>_renderPhase02()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_renderPhase02 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_viewport.html">Viewport</a> *&#160;</td>
          <td class="paramname"><em>vp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>firstRq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>lastRq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeOverlays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prompts the class to send its contents to the renderer. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method prompts the scene manager to send the contents of the scene it manages to the rendering pipeline. You must have called _cullPhase01 before calling this function. Note that this method is not normally called directly by the user application; it is called automatically by the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> rendering loop. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera</td><td>Pointer to a camera from whose viewpoint the scene is to be rendered. </td></tr>
    <tr><td class="paramname">lodCamera</td><td>Pointer to a camera from whose LOD calculations will be based upon. Can't be null; can be equal to . </td></tr>
    <tr><td class="paramname">vp</td><td>The target viewport </td></tr>
    <tr><td class="paramname">firstRq</td><td>first render queue ID to render (gets clamped if too big) </td></tr>
    <tr><td class="paramname">lastRq</td><td>last render queue ID to render (gets clamped if too big) </td></tr>
    <tr><td class="paramname">includeOverlays</td><td>Whether or not overlay objects should be rendered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae32663cfb04485c2643a24a1240240c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32663cfb04485c2643a24a1240240c2">&#9670;&nbsp;</a></span>_renderSingleObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_renderSingleObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_renderable.html">Renderable</a> *&#160;</td>
          <td class="paramname"><em>pRend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>pMovableObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dualParaboloid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27f763bb92fef8b1238e2272889ba58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f763bb92fef8b1238e2272889ba58d">&#9670;&nbsp;</a></span>_resumeRendering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_resumeRendering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_scene_manager_1_1_render_context.html">RenderContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resume rendering of the frame. </p>
<p>This has to be called after a _pauseRendering call </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The rendring context, as returned by the _pauseRendering call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a418bc67069b6ed65fd862f3efaa6a0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418bc67069b6ed65fd862f3efaa6a0d9">&#9670;&nbsp;</a></span>_setCameraInProgress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_setCameraInProgress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa0e6b3f96d0740a12ccba7c829e394f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0e6b3f96d0740a12ccba7c829e394f">&#9670;&nbsp;</a></span>_setCompositorTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_setCompositorTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_compositor_texture.html">CompositorTexture</a> &amp;&#160;</td>
          <td class="paramname"><em>compoTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The compositor we are currently writing to. </p>

</div>
</div>
<a id="acdd809e69cbbc4b565a27b8edef98ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd809e69cbbc4b565a27b8edef98ad1">&#9670;&nbsp;</a></span>_setCurrentCompositorPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_setCurrentCompositorPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *&#160;</td>
          <td class="paramname"><em>pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77f751eb7bce6624985c304f878d51d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f751eb7bce6624985c304f878d51d9">&#9670;&nbsp;</a></span>_setCurrentRenderStage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_setCurrentRenderStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html#a51db39cc4fa15b28086a1793d42fc827">IlluminationRenderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae333535bc17cb63a4500d4301b7270a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae333535bc17cb63a4500d4301b7270a0">&#9670;&nbsp;</a></span>_setCurrentShadowNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_setCurrentShadowNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html">CompositorShadowNode</a> *&#160;</td>
          <td class="paramname"><em>shadowNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab20c0ee49a853145d3350e6e32c59f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20c0ee49a853145d3350e6e32c59f32">&#9670;&nbsp;</a></span>_setDestinationRenderSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_setDestinationRenderSystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td>
          <td class="paramname"><em>sys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the scene manager of its destination render system. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Called automatically by RenderSystem::addSceneManager this method simply notifies the manager of the render system to which its output must be directed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sys</td><td>Pointer to the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API. ">RenderSystem</a> subclass to be used as a render target. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a507d273b53104fb5b8c835bc0c7ce73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507d273b53104fb5b8c835bc0c7ce73a">&#9670;&nbsp;</a></span>_setForwardPlusEnabledInPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_setForwardPlusEnabledInPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For internal use. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_pass_scene_def.html#acf1c9d830639cb9fed39ce667d7daf64" title="Enable ForwardPlus during the pass (if Forward3D or ForwardClustered systems were created)...">CompositorPassSceneDef::mEnableForwardPlus</a> </dd></dl>

</div>
</div>
<a id="aa484c6a44eaae0ec7ce646b51d6dc8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa484c6a44eaae0ec7ce646b51d6dc8c3">&#9670;&nbsp;</a></span>_setLightCullingVisibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_setLightCullingVisibility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>collectLights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCubemap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_ogre_1_1_camera.html#ae458966f06b60f6bc658ae8606e77b9e" title="When a camera is created via SceneManager::createCamera, there are two additional parameters...">Camera::setLightCullingVisibility</a>. </p>

</div>
</div>
<a id="ad8c4733279dbd3bc63a6b0f7f8b3ce26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c4733279dbd3bc63a6b0f7f8b3ce26">&#9670;&nbsp;</a></span>_setPrePassMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_setPrePassMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga63b5ab6176b81463bbdd0e260b751d2e">PrePassMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a> *&#160;</td>
          <td class="paramname"><em>prepassTextures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a> *&#160;</td>
          <td class="paramname"><em>prepassDepthTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a> *&#160;</td>
          <td class="paramname"><em>ssrTexture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For internal use. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_pass_scene_def.html#ac2ec0baf73405179bb379e9916aafd98" title="This is a depth pre-pass. ">CompositorPassSceneDef::mPrePassMode</a> </dd></dl>

</div>
</div>
<a id="ae66f180b2925e6a9c674c62e058812f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f180b2925e6a9c674c62e058812f6">&#9670;&nbsp;</a></span>_setSkyBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_setSkyBox </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>renderQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>distance</em> = <code>5000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables / disables a 'sky box' i.e. </p>
<p>a 6-sided box at constant distance from the camera representing the sky. </p><dl class="section remark"><dt>Remarks</dt><dd>You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> as the <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Camera</a> too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). </dd></dl>
<dl class="section user"><dt></dt><dd>The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> class for more information. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable the skybox, false to disable it </td></tr>
    <tr><td class="paramname">materialName</td><td>The name of the material the box will use </td></tr>
    <tr><td class="paramname">distance</td><td>Distance in world coorinates from the camera to each plane of the box. The default is normally OK. </td></tr>
    <tr><td class="paramname">renderQueue</td><td>The render queue to use when rendering this object </td></tr>
    <tr><td class="paramname">orientation</td><td>Optional parameter to specify the orientation of the box. By default the 'top' of the box is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </td></tr>
    <tr><td class="paramname">groupName</td><td>The name of the resource group to which to assign the plane mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa87f1a79eca331be85091d3fda822f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87f1a79eca331be85091d3fda822f1d">&#9670;&nbsp;</a></span>_setSkyDome()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_setSkyDome </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>renderQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>curvature</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>tiling</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>distance</em> = <code>4000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsegments</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysegments</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysegments_keep</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables / disables a 'sky dome' i.e. </p>
<p>an illusion of a curved sky. </p><dl class="section remark"><dt>Remarks</dt><dd>A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. </dd></dl>
<dl class="section user"><dt></dt><dd>Sky domes work well with 2D repeating textures like clouds. You can change the apparent 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable the skydome, false to disable it </td></tr>
    <tr><td class="paramname">materialName</td><td>The name of the material the dome will use </td></tr>
    <tr><td class="paramname">curvature</td><td>The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </td></tr>
    <tr><td class="paramname">tiling</td><td>How many times to tile the texture(s) across the dome. </td></tr>
    <tr><td class="paramname">distance</td><td>Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </td></tr>
    <tr><td class="paramname">renderQueue</td><td>The render queue to use when rendering this object </td></tr>
    <tr><td class="paramname">orientation</td><td>Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </td></tr>
    <tr><td class="paramname">groupName</td><td>The name of the resource group to which to assign the plane mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf94cda8c24ed07cc048a463cfbd9750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf94cda8c24ed07cc048a463cfbd9750">&#9670;&nbsp;</a></span>_setSkyPlane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_setSkyPlane </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>renderQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>tiling</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>bow</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsegments</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysegments</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables / disables a 'sky plane' i.e. </p>
<p>a plane at constant distance from the camera representing the sky. </p><dl class="section remark"><dt>Remarks</dt><dd>You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> as the <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Camera</a> too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>To apply scaling, scrolls etc to the sky texture(s) you should use the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> class methods. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable the plane, false to disable it </td></tr>
    <tr><td class="paramname">plane</td><td>Details of the plane, i.e. it's normal and it's distance from the camera. </td></tr>
    <tr><td class="paramname">materialName</td><td>The name of the material the plane will use </td></tr>
    <tr><td class="paramname">scale</td><td>The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </td></tr>
    <tr><td class="paramname">tiling</td><td>How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> texture coordinate transformation methods. </td></tr>
    <tr><td class="paramname">renderQueue</td><td>The render queue to use when rendering this object </td></tr>
    <tr><td class="paramname">bow</td><td>If zero, the plane will be completely flat (like previous versions. If above zero, the plane will be curved, allowing the sky to appear below camera level. Curved sky planes are simular to skydomes, but are more compatible with fog. </td></tr>
    <tr><td class="paramname">xsegments,ysegments</td><td>Determines the number of segments the plane will have to it. This is most important when you are bowing the plane, but may also be useful if you need tessellation on the plane to perform per-vertex effects. </td></tr>
    <tr><td class="paramname">groupName</td><td>The name of the resource group to which to assign the plane mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24e6d992a1176c83872afa56ab07bbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e6d992a1176c83872afa56ab07bbc2">&#9670;&nbsp;</a></span>_setViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::_setViewport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_viewport.html">Viewport</a> *&#160;</td>
          <td class="paramname"><em>vp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6753ea2b52715774b7fdd59da232917a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6753ea2b52715774b7fdd59da232917a">&#9670;&nbsp;</a></span>_suppressRenderStateChanges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_suppressRenderStateChanges </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suppress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates to the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> whether it should suppress changing the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API. ">RenderSystem</a> states when rendering objects. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method allows you to tell the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> not to change any <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API. ">RenderSystem</a> state until you tell it to. This method is only intended for advanced use, don't use it if you're unsure of the effect. The only RenderSystems calls made are to set the world matrix for each object (note - view an projection matrices are NOT SET - they are under your control) and to render the object; it is up to the caller to do everything else, including enabling any vertex / fragment programs and updating their parameter state, and binding parameters to the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API. ">RenderSystem</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this implicitly disables shadow processing since no shadows can be rendered without changing state. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suppress</td><td>If true, no <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API. ">RenderSystem</a> state changes will be issued until this method is called again with a parameter of false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9959c0abe638bebd7ad2a30abc23ca2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9959c0abe638bebd7ad2a30abc23ca2e">&#9670;&nbsp;</a></span>_updateWorkerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Ogre::SceneManager::_updateWorkerThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>threadHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called from the worker thread, polls to process frustum culling requests when a sync is performed. </p>

</div>
</div>
<a id="a6b54e34b6a8e72d4c1456bda016731ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b54e34b6a8e72d4c1456bda016731ad">&#9670;&nbsp;</a></span>addListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::addListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager_1_1_listener.html">Listener</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a listener which will get called back on scene manager events. </p>

</div>
</div>
<a id="a2ac761cb112de51be26c54609de3c83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac761cb112de51be26c54609de3c83a">&#9670;&nbsp;</a></span>addLodListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::addLodListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_lod_listener.html">LodListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a level of detail listener. </p>

</div>
</div>
<a id="ab73819442f7f3540f52431064e6b1a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73819442f7f3540f52431064e6b1a97">&#9670;&nbsp;</a></span>addRenderObjectListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::addRenderObjectListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_object_listener.html">RenderObjectListener</a> *&#160;</td>
          <td class="paramname"><em>newListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a new Render Object <a class="el" href="class_ogre_1_1_scene_manager_1_1_listener.html" title="Class that allows listening in on the various stages of SceneManager processing, so that custom behav...">Listener</a> which will be notified when rendering an object. </p>

</div>
</div>
<a id="ae60242c5d130f884cd605d3393186df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60242c5d130f884cd605d3393186df6">&#9670;&nbsp;</a></span>addRenderQueueListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::addRenderQueueListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_queue_listener.html">RenderQueueListener</a> *&#160;</td>
          <td class="paramname"><em>newListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a new <a class="el" href="class_ogre_1_1_render_queue_listener.html" title="Abstract interface which classes must implement if they wish to receive events from the render queue...">RenderQueueListener</a> which will be notified when render queues are processed. </p>

</div>
</div>
<a id="a1200037971723674d993871980e0516a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1200037971723674d993871980e0516a">&#9670;&nbsp;</a></span>clearFrameData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::clearFrameData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears temporary buffers and other data that needs to live every frame. </p>

</div>
</div>
<a id="a01ba0aad5090ed0a8ff5e9c3d24fa924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ba0aad5090ed0a8ff5e9c3d24fa924">&#9670;&nbsp;</a></span>clearScene()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::clearScene </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteIndestructibleToo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reattachCameras</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc. </p>
<p>Cameras are not deleted at this stage since they are still referenced by viewports, which are not destroyed during this process. </p><dl class="section remark"><dt>Remarks</dt><dd>When an indestructible <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> has a destructible parent, the parent will be destroyed and thus the former <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> will be parent-less, i.e. be at the same level as root. Note that parent-less SceneNodes can still render to the scene (this behavior is different from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deleteIndestructibleToo</td><td>If a node is marked as indestructible, it won't be deleted unless deleteIndestructibleToo is marked as true. Note that some <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> compoenents mark some of their objects as internal to prevent them from becoming dangling pointers.</td></tr>
  </table>
  </dd>
</dl>
<p>If you don't know what to put here, set it to false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reattachCameras</td><td>When true, all Cameras that have no parent node after clearing will be reattached to the root node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cb1523180fcc65b6093b6330725c823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb1523180fcc65b6093b6330725c823">&#9670;&nbsp;</a></span>createAABBQuery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_axis_aligned_box_scene_query.html">AxisAlignedBoxSceneQuery</a>* Ogre::SceneManager::createAABBQuery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="class_ogre_1_1_scene_manager.html#a6c140ffaced93a2b854e5c519c8fb568">QUERY_ENTITY_DEFAULT_MASK</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="class_ogre_1_1_axis_aligned_box_scene_query.html" title="Specialises the SceneQuery class for querying within an axis aligned box. ">AxisAlignedBoxSceneQuery</a> for this scene manager. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method creates a new instance of a query object for this scene manager, for an axis aligned box region. See <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> and <a class="el" href="class_ogre_1_1_axis_aligned_box_scene_query.html" title="Specialises the SceneQuery class for querying within an axis aligned box. ">AxisAlignedBoxSceneQuery</a> for full details. </dd></dl>
<dl class="section user"><dt></dt><dd>The instance returned from this method must be destroyed by calling <a class="el" href="class_ogre_1_1_scene_manager.html#a08f7adf5f342c6808481fa922c8c62a0" title="Destroys a scene query of any type. ">SceneManager::destroyQuery</a> when it is no longer required. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td>Details of the box which describes the region for this query. </td></tr>
    <tr><td class="paramname">mask</td><td>The query mask to apply to this query; can be used to filter out certain objects; see <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1c534bbbff4ffa2c11bbc94a49a34a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c534bbbff4ffa2c11bbc94a49a34a4">&#9670;&nbsp;</a></span>createAnimation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_animation.html">v1::Animation</a>* Ogre::SceneManager::createAnimation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an animation which can be used to animate scene nodes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>An animation is a collection of 'tracks' which over time change the position / orientation of <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> objects. In this case, the animation will likely have tracks to modify the position / orientation of <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> objects, e.g. to make objects move along a path. </dd></dl>
<dl class="section user"><dt></dt><dd>You don't need to use an Animation object to move objects around - you can do it yourself using the methods of the <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> in your <a class="el" href="class_ogre_1_1_frame_listener.html" title="A interface class defining a listener which can be used to receive notifications of frame events...">FrameListener</a> class. However, when you need relatively complex scripted animation, this is the class to use since it will interpolate between keyframes for you and generally make the whole process easier to manage. </dd></dl>
<dl class="section user"><dt></dt><dd>A single animation can affect multiple <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> objects (each AnimationTrack affects a single <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a>). In addition, through animation blending a single <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> can be affected by multiple animations, athough this is more useful when performing skeletal animation (see Skeleton::createAnimation). </dd></dl>
<dl class="section user"><dt></dt><dd>Note that whilst it uses the same classes, the animations created here are kept separate from the skeletal animations of meshes (each Skeleton owns those animations). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the animation, must be unique within this <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </td></tr>
    <tr><td class="paramname">length</td><td>The total length of the animation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a645918264d13f0fd8e403e7e4554ac89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645918264d13f0fd8e403e7e4554ac89">&#9670;&nbsp;</a></span>createAnimationState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_animation_state.html">v1::AnimationState</a>* Ogre::SceneManager::createAnimationState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>animName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an AnimationState object for managing application of animations. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You can create Animation objects for animating <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> obejcts using the createAnimation method. However, in order to actually apply those animations you have to call methods on <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> and Animation in a particular order (namely Node::resetToInitialState and Animation::apply). To make this easier and to help track the current time position of animations, the AnimationState object is provided. So if you don't want to control animation application manually, call this method, update the returned object as you like every frame and let <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> apply the animation state for you. </dd></dl>
<dl class="section user"><dt></dt><dd>Remember, AnimationState objects are disabled by default at creation time. Turn them on when you want them using their setEnabled method. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that any <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> affected by this automatic animation will have it's state reset to it's initial position before application of the animation. Unless specifically modified using Node::setInitialState the <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> assumes it's initial state is at the origin. If you want the base state of the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> to be elsewhere, make your changes to the node using the standard transform methods, then call setInitialState to 'bake' this reference position into the node. </dd></dl>
<dl class="section user"><dt></dt><dd>If the target of your animation is to be a generic <a class="el" href="class_ogre_1_1_animable_value.html" title="Defines an object property which is animable, i.e. ">AnimableValue</a>, you should ensure that it has a base value set (unlike nodes this has no default). </dd></dl>
<dl class="section see"><dt>See also</dt><dd>AnimableValue::setAsBaseValue. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">animName</td><td>The name of an animation created already with createAnimation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ed1f8508aab6937936e59131d37b015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed1f8508aab6937936e59131d37b015">&#9670;&nbsp;</a></span>createBillboardChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_billboard_chain.html">v1::BillboardChain</a>* Ogre::SceneManager::createBillboardChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a BillboardChain, an object which you can use to render a linked chain of billboards. </p>

</div>
</div>
<a id="ab332bde9a27fd34aebe523565f2c901e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab332bde9a27fd34aebe523565f2c901e">&#9670;&nbsp;</a></span>createBillboardSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_billboard_set.html">v1::BillboardSet</a>* Ogre::SceneManager::createBillboardSet </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>poolSize</em> = <code>20</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new BillboardSet for use with this scene manager. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method creates a new BillboardSet which is registered with the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> will destroy this object when it shuts down or when the <a class="el" href="class_ogre_1_1_scene_manager.html#a01ba0aad5090ed0a8ff5e9c3d24fa924" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc...">SceneManager::clearScene</a> method is called, so the caller does not have to worry about destroying this object (in fact, it definitely should not do this). </dd></dl>
<dl class="section user"><dt></dt><dd>See the BillboardSet documentations for full details of the returned class. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poolSize</td><td>The initial size of the pool of billboards (see BillboardSet for more information) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>BillboardSet </dd></dl>

</div>
</div>
<a id="af0b123ba8766b15be93d40663f55513b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b123ba8766b15be93d40663f55513b">&#9670;&nbsp;</a></span>createCamera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_camera.html">Camera</a>* Ogre::SceneManager::createCamera </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notShadowCaster</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forCubemapping</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a camera to be managed by this scene manager. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This camera is automatically added to the scene by being attached to the <a class="el" href="class_ogre_1_1_root.html" title="The root class of the Ogre system. ">Root</a> Scene <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> before returning. If you want to use your own <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> for this camera, you'll have to detach it first (can be done via camera-&gt;detachFromParent();) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name to give the new camera. Must be unique. </td></tr>
    <tr><td class="paramname">notShadowCaster</td><td>True if this camera should be considered when creating the global light list of culled lights against all cameras. For example, cameras used for shadow mapping shouldn't be taken into account (set to false) </td></tr>
    <tr><td class="paramname">forCubemapping</td><td>True this camera will be used at least once in one of its passes as a cubemap (thus having to change the orientation but not position mid-rendering) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a998341d53edde24071ab556372d2bee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998341d53edde24071ab556372d2bee9">&#9670;&nbsp;</a></span>createEntity() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_entity.html">v1::Entity</a>* Ogre::SceneManager::createEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>meshName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a70da3137e703c147b98fbfbbebfbf023">ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em> = <code><a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an Entity (instance of a discrete mesh). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshName</td><td>The name of the <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a> it is to be based on (e.g. 'knot.oof'). The mesh will be loaded if it is not already. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74ccdf9af7ecb7b43ebcd020b01bec48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ccdf9af7ecb7b43ebcd020b01bec48">&#9670;&nbsp;</a></span>createEntity() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_entity.html">v1::Entity</a>* Ogre::SceneManager::createEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre_1_1v1.html#a500ac3b30068793f1dda3f0627c5cf67">v1::MeshPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>pMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em> = <code><a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an Entity (instance of a discrete mesh). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMesh</td><td>The pointer to the <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a> it is to be based on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a214f1928e9b08968f21cf06f0abec196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214f1928e9b08968f21cf06f0abec196">&#9670;&nbsp;</a></span>createEntity() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_entity.html">v1::Entity</a>* Ogre::SceneManager::createEntity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html#ab4c2ff4f6c76f7fe0a8eae76f2a84cbf">PrefabType</a>&#160;</td>
          <td class="paramname"><em>ptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em> = <code><a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an Entity (instance of a discrete mesh) from a range of prefab shapes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptype</td><td>The prefab type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae880429854291015a41b9a1f9a00ff6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae880429854291015a41b9a1f9a00ff6f">&#9670;&nbsp;</a></span>createInstancedEntity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">v1::InstancedEntity</a>* Ogre::SceneManager::createInstancedEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>managerName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an InstancedEntity based on an existing InstanceManager (. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a8f741f55a905b4cb1dbae7d90ffa543b" title="Creates an InstanceManager interface to create &amp; manipulate instanced entities You need to call this ...">createInstanceManager</a>) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Return value may be null if the InstanceManger technique isn't supported Try to keep the number of entities with different materials <b>to a minimum</b> For more information </dd></dl>
<dl class="section see"><dt>See also</dt><dd>InstancedManager </dd>
<dd>
InstancedBatch, </dd>
<dd>
InstancedEntity Alternatively you can call InstancedManager::createInstanceEntity using the returned pointer from <a class="el" href="class_ogre_1_1_scene_manager.html#a8f741f55a905b4cb1dbae7d90ffa543b" title="Creates an InstanceManager interface to create &amp; manipulate instanced entities You need to call this ...">createInstanceManager</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">materialName</td><td><a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a> name </td></tr>
    <tr><td class="paramname">managerName</td><td>Name of the instance manager </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An InstancedEntity ready to be attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> </dd></dl>

</div>
</div>
<a id="a8f741f55a905b4cb1dbae7d90ffa543b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f741f55a905b4cb1dbae7d90ffa543b">&#9670;&nbsp;</a></span>createInstanceManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">v1::InstanceManager</a>* Ogre::SceneManager::createInstanceManager </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>customName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>meshName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___scene.html#ga7fdc1f95714df3401447297dd6385e9c">v1::InstanceManager::InstancingTechnique</a>&#160;</td>
          <td class="paramname"><em>technique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numInstancesPerBatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>subMeshIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an InstanceManager interface to create &amp; manipulate instanced entities You need to call this function at least once before start calling createInstancedEntity to build up an instance based on the given mesh. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Instancing is a way of batching up geometry into a much more efficient form, but with some limitations, and still be able to move &amp; animate it. Please </dd></dl>
<dl class="section see"><dt>See also</dt><dd>InstanceManager class documentation for full information. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">customName</td><td>Custom name for referencing. Must be unique </td></tr>
    <tr><td class="paramname">meshName</td><td>The mesh name the instances will be based upon </td></tr>
    <tr><td class="paramname">groupName</td><td>The resource name where the mesh lives </td></tr>
    <tr><td class="paramname">technique</td><td><a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material. ">Technique</a> to use, which may be shader based, or hardware based. </td></tr>
    <tr><td class="paramname">numInstancesPerBatch</td><td>Suggested number of instances per batch. The actual number may end up being lower if the technique doesn't support having so many. It can't be zero </td></tr>
    <tr><td class="paramname">flags</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___general.html#ga4921efc65b347efe08a6d4992af069e2" title="Flags for the Instance Manager when calculating ideal number of instances per batch. ">InstanceManagerFlags</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subMeshIdx</td><td>InstanceManager only supports using one submesh from the base mesh. This parameter says which submesh to pick (must be &lt;= <a class="el" href="class_ogre_1_1_mesh.html#a7f3cbac6ea5202bc53ba58e50a5ad138" title="Gets the number of sub meshes which comprise this mesh. ">Mesh::getNumSubMeshes()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new InstanceManager instance </dd></dl>

</div>
</div>
<a id="a7058a41df70af9d57a5f9174bdb75b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7058a41df70af9d57a5f9174bdb75b8b">&#9670;&nbsp;</a></span>createIntersectionQuery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_intersection_scene_query.html">IntersectionSceneQuery</a>* Ogre::SceneManager::createIntersectionQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="class_ogre_1_1_scene_manager.html#a6c140ffaced93a2b854e5c519c8fb568">QUERY_ENTITY_DEFAULT_MASK</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="class_ogre_1_1_intersection_scene_query.html" title="Separate SceneQuery class to query for pairs of objects which are possibly intersecting one another...">IntersectionSceneQuery</a> for this scene manager. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method creates a new instance of a query object for locating intersecting objects. See <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> and <a class="el" href="class_ogre_1_1_intersection_scene_query.html" title="Separate SceneQuery class to query for pairs of objects which are possibly intersecting one another...">IntersectionSceneQuery</a> for full details. </dd></dl>
<dl class="section user"><dt></dt><dd>The instance returned from this method must be destroyed by calling <a class="el" href="class_ogre_1_1_scene_manager.html#a08f7adf5f342c6808481fa922c8c62a0" title="Destroys a scene query of any type. ">SceneManager::destroyQuery</a> when it is no longer required. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The query mask to apply to this query; can be used to filter out certain objects; see <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41d7c00f7f1bc53433920fdf1ab65420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d7c00f7f1bc53433920fdf1ab65420">&#9670;&nbsp;</a></span>createItem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_item.html">Item</a>* Ogre::SceneManager::createItem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>meshName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a70da3137e703c147b98fbfbbebfbf023">ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em> = <code><a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="class_ogre_1_1_item.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Item</a> (instance of a discrete mesh). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshName</td><td>The name of the <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a> it is to be based on (e.g. 'knot.oof'). The mesh will be loaded if it is not already. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2a0ad552583d76f602fa08b06ec88ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a0ad552583d76f602fa08b06ec88ae">&#9670;&nbsp;</a></span>createItem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_item.html">Item</a>* Ogre::SceneManager::createItem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a5c4c0c56ea9f824c49e331f6fad33ddb">MeshPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>pMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em> = <code><a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="class_ogre_1_1_item.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Item</a> (instance of a discrete mesh). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMesh</td><td>The pointer to the <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a> it is to be based on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a417bdd216730a8d171c3184b0d49c32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417bdd216730a8d171c3184b0d49c32e">&#9670;&nbsp;</a></span>createLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_light.html">Light</a>* Ogre::SceneManager::createLight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a light for use in the scene. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The direction and position of a light is managed via the scene node it is attached to. Make sure that you have attached the light to a scene node (<a class="el" href="class_ogre_1_1_scene_node.html#afc15c981be15167edc61d7d4453a089d" title="Adds an instance of a scene object to this node. ">SceneNode::attachObject</a>) before* calling <a class="el" href="class_ogre_1_1_light.html#a1659111f4eb55f3b3227e87c8bfce8d9" title="Sets the direction in which a light points. ">Light::setDirection</a> or Light::setPosition. </dd></dl>

</div>
</div>
<a id="ae62cca9c1e6141d806ad1536acdbb812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62cca9c1e6141d806ad1536acdbb812">&#9670;&nbsp;</a></span>createManualObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_manual_object.html">ManualObject</a>* Ogre::SceneManager::createManualObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em> = <code><a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="class_ogre_1_1_manual_object.html">ManualObject</a>, an object which you populate with geometry manually through a GL immediate-mode style interface. </p>

</div>
</div>
<a id="aaacb4d0155d88f559516027c8d7c2c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacb4d0155d88f559516027c8d7c2c67">&#9670;&nbsp;</a></span>createMovableObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a>* Ogre::SceneManager::createMovableObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>objectMemMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___general.html#gadccb207c184efc0a6fb2a00ab6320d19">NameValuePairList</a> *&#160;</td>
          <td class="paramname"><em>params</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a movable object of the type specified without a name. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is the generalised form of <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> creation where you can create a <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> of any specialised type generically, including any new types registered using plugins. The name is generated automatically. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeName</td><td>The type of object to create </td></tr>
    <tr><td class="paramname">objectMemMgr</td><td>Memory Manager that will hold <a class="el" href="struct_ogre_1_1_object_data.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays) ...">ObjectData</a> data. </td></tr>
    <tr><td class="paramname">params</td><td>Optional name/value pair list to give extra parameters to the created object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a4ee617b2e251f10cea239e31407e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4ee617b2e251f10cea239e31407e69">&#9670;&nbsp;</a></span>createParticleSystem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_particle_system.html">ParticleSystem</a>* Ogre::SceneManager::createParticleSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>templateName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a particle system based on a template. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method creates a new <a class="el" href="class_ogre_1_1_particle_system.html" title="Class defining particle system based special effects. ">ParticleSystem</a> instance based on the named template (defined through <a class="el" href="class_ogre_1_1_particle_system_manager.html#ac3b4d8e5717c7eb97a06ed0585709ce5" title="Create a new particle system template. ">ParticleSystemManager::createTemplate</a>) and returns a pointer to the caller. The caller should not delete this object, it will be freed at system shutdown, or can be released earlier using the destroyParticleSystem method. </dd></dl>
<dl class="section user"><dt></dt><dd>Each system created from a template takes the template's settings at the time of creation, but is completely separate from the template from there on. </dd></dl>
<dl class="section user"><dt></dt><dd>Creating a particle system does not make it a part of the scene. As with other <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> subclasses, a <a class="el" href="class_ogre_1_1_particle_system.html" title="Class defining particle system based special effects. ">ParticleSystem</a> is not rendered until it is attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>. </dd></dl>
<dl class="section user"><dt></dt><dd>This is probably the more useful particle system creation method since it does not require manual setup of the system. Note that the initial quota is based on the template but may be changed later. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">templateName</td><td>The name of the template to base the new instance on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0d79919af93bf827cf8185930dd2a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d79919af93bf827cf8185930dd2a5f">&#9670;&nbsp;</a></span>createParticleSystem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_particle_system.html">ParticleSystem</a>* Ogre::SceneManager::createParticleSystem </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>quota</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a blank particle system. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method creates a new, blank <a class="el" href="class_ogre_1_1_particle_system.html" title="Class defining particle system based special effects. ">ParticleSystem</a> instance and returns a pointer to it. The caller should not delete this object, it will be freed at system shutdown, or can be released earlier using the destroyParticleSystem method. </dd></dl>
<dl class="section user"><dt></dt><dd>The instance returned from this method won't actually do anything because on creation a particle system has no emitters. The caller should manipulate the instance through it's <a class="el" href="class_ogre_1_1_particle_system.html" title="Class defining particle system based special effects. ">ParticleSystem</a> methods to actually create a real particle effect. </dd></dl>
<dl class="section user"><dt></dt><dd>Creating a particle system does not make it a part of the scene. As with other <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> subclasses, a <a class="el" href="class_ogre_1_1_particle_system.html" title="Class defining particle system based special effects. ">ParticleSystem</a> is not rendered until it is attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quota</td><td>The maximum number of particles to allow in this system. </td></tr>
    <tr><td class="paramname">resourceGroup</td><td>The resource group which will be used to load dependent resources </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd010182f634fc54dd00af2d5e59fb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd010182f634fc54dd00af2d5e59fb4e">&#9670;&nbsp;</a></span>createPlaneBoundedVolumeQuery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_plane_bounded_volume_list_scene_query.html">PlaneBoundedVolumeListSceneQuery</a>* Ogre::SceneManager::createPlaneBoundedVolumeQuery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___math.html#ga6253a1300d656ba28342fe58260d0e71">PlaneBoundedVolumeList</a> &amp;&#160;</td>
          <td class="paramname"><em>volumes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="class_ogre_1_1_scene_manager.html#a6c140ffaced93a2b854e5c519c8fb568">QUERY_ENTITY_DEFAULT_MASK</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_ogre_1_1_plane_bounded_volume_list_scene_query.html" title="Specialises the SceneQuery class for querying within a plane-bounded volume. ">PlaneBoundedVolumeListSceneQuery</a> for this scene manager. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method creates a new instance of a query object for this scene manager, for a region enclosed by a set of planes (normals pointing inwards). See <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> and <a class="el" href="class_ogre_1_1_plane_bounded_volume_list_scene_query.html" title="Specialises the SceneQuery class for querying within a plane-bounded volume. ">PlaneBoundedVolumeListSceneQuery</a> for full details. </dd></dl>
<dl class="section user"><dt></dt><dd>The instance returned from this method must be destroyed by calling <a class="el" href="class_ogre_1_1_scene_manager.html#a08f7adf5f342c6808481fa922c8c62a0" title="Destroys a scene query of any type. ">SceneManager::destroyQuery</a> when it is no longer required. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volumes</td><td>Details of the volumes which describe the region for this query. </td></tr>
    <tr><td class="paramname">mask</td><td>The query mask to apply to this query; can be used to filter out certain objects; see <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3166eafec7c9234170371b4dcf66552d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3166eafec7c9234170371b4dcf66552d">&#9670;&nbsp;</a></span>createRayQuery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_ray_scene_query.html">RaySceneQuery</a>* Ogre::SceneManager::createRayQuery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="class_ogre_1_1_scene_manager.html#a6c140ffaced93a2b854e5c519c8fb568">QUERY_ENTITY_DEFAULT_MASK</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_ogre_1_1_ray_scene_query.html" title="Specialises the SceneQuery class for querying along a ray. ">RaySceneQuery</a> for this scene manager. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method creates a new instance of a query object for this scene manager, looking for objects which fall along a ray. See <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> and <a class="el" href="class_ogre_1_1_ray_scene_query.html" title="Specialises the SceneQuery class for querying along a ray. ">RaySceneQuery</a> for full details. </dd></dl>
<dl class="section user"><dt></dt><dd>The instance returned from this method must be destroyed by calling <a class="el" href="class_ogre_1_1_scene_manager.html#a08f7adf5f342c6808481fa922c8c62a0" title="Destroys a scene query of any type. ">SceneManager::destroyQuery</a> when it is no longer required. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray</td><td>Details of the ray which describes the region for this query. </td></tr>
    <tr><td class="paramname">mask</td><td>The query mask to apply to this query; can be used to filter out certain objects; see <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a422b04adfc9476736b02667d02161dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422b04adfc9476736b02667d02161dec">&#9670;&nbsp;</a></span>createRectangle2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_rectangle2_d.html">v1::Rectangle2D</a>* Ogre::SceneManager::createRectangle2D </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bQuad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em> = <code><a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a284ea1c4b2ae53f2aefbaeabd6a27da8">SCENE_STATIC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a 2D rectangle that can be displayed for screen space effects or showing a basic GUI. </p>
<p>Notice that due to engine's requirements, you need to attach this object to a scene node in order to be rendered correctly. </p><dl class="section user"><dt></dt><dd>You can use the <a class="el" href="class_ogre_1_1_root.html" title="The root class of the Ogre system. ">Root</a> scene node. However if you're planning on also using setRelativeOrigin, beware that this would break the permanent setting and you should then use a dummy scene node for your rectangles. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The Rectangle2D will request to use identity view and projection matrices, but only low level materials will honour that request. PBS shaders will ignore it (thus the rectangle will be drawn in 3D space) and other <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;. ">Hlms</a> types may work differently and you'll have to check its documentation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bQuad</td><td>When true, the rectangle is drawn with two triangles. When false, it is drawn as a single oversized triangle. Full screen triangles are faster than quads, but will only work correctly if they cover the entire screen, or are aided by scissor tests to clip the borders. </td></tr>
    <tr><td class="paramname">sceneType</td><td>Whether you will be moving the Rectangle2D's scene node around. Unless you're planning to use this Rectangle2D for 3D purposes, it is highly recomended that you use SCENE_STATIC (you can safely use SCENE_STATIC and change Rectangle2D::setCorners and Rectangle2D::setNormal every frame). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Rectangle2D. </dd></dl>

</div>
</div>
<a id="a9a989e4040a897a224cc62ad39d97ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a989e4040a897a224cc62ad39d97ed4">&#9670;&nbsp;</a></span>createRibbonTrail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_ribbon_trail.html">v1::RibbonTrail</a>* Ogre::SceneManager::createRibbonTrail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a RibbonTrail, an object which you can use to render a linked chain of billboards which follows one or more nodes. </p>

</div>
</div>
<a id="a25a28f0f0da21cfaf01ccf1cf0fb2d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a28f0f0da21cfaf01ccf1cf0fb2d75">&#9670;&nbsp;</a></span>createSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneManager::createSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em> = <code><a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an instance of a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that this does not add the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> to the scene hierarchy. This method is for convenience, since it allows an instance to be created for which the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> is responsible for allocating and releasing memory, which is convenient in complex scenes. </dd></dl>
<dl class="section user"><dt></dt><dd>To include the returned <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> in the scene, use the addChild method of the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> which is to be it's parent. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that this method takes no parameters, and the node created is unnamed (it is actually given a generated name, which you can retrieve if you want). If you wish to create a node with a specific name, call the alternative method which takes a name parameter.  sceneType Dynamic if this node is to be updated frequently. Static if you don't plan to be updating this node in a long time (performance optimization). </dd></dl>

</div>
</div>
<a id="aa6ad8f1fbd3d8848365214ba3ee4ff43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ad8f1fbd3d8848365214ba3ee4ff43">&#9670;&nbsp;</a></span>createSkeletonInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_skeleton_instance.html">SkeletonInstance</a>* Ogre::SceneManager::createSkeletonInstance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_skeleton_def.html">SkeletonDef</a> *&#160;</td>
          <td class="paramname"><em>skeletonDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of a skeleton based on the given definition. </p>

</div>
</div>
<a id="ae273d6ac6a5b99742c18a14cb12dc711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae273d6ac6a5b99742c18a14cb12dc711">&#9670;&nbsp;</a></span>createSphereQuery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_sphere_scene_query.html">SphereSceneQuery</a>* Ogre::SceneManager::createSphereQuery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="class_ogre_1_1_scene_manager.html#a6c140ffaced93a2b854e5c519c8fb568">QUERY_ENTITY_DEFAULT_MASK</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_ogre_1_1_sphere_scene_query.html" title="Specialises the SceneQuery class for querying within a sphere. ">SphereSceneQuery</a> for this scene manager. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method creates a new instance of a query object for this scene manager, for a spherical region. See <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> and <a class="el" href="class_ogre_1_1_sphere_scene_query.html" title="Specialises the SceneQuery class for querying within a sphere. ">SphereSceneQuery</a> for full details. </dd></dl>
<dl class="section user"><dt></dt><dd>The instance returned from this method must be destroyed by calling <a class="el" href="class_ogre_1_1_scene_manager.html#a08f7adf5f342c6808481fa922c8c62a0" title="Destroys a scene query of any type. ">SceneManager::destroyQuery</a> when it is no longer required. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sphere</td><td>Details of the sphere which describes the region for this query. </td></tr>
    <tr><td class="paramname">mask</td><td>The query mask to apply to this query; can be used to filter out certain objects; see <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdf755994a585d5a411e6dac32e936ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf755994a585d5a411e6dac32e936ea">&#9670;&nbsp;</a></span>createStaticGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_static_geometry.html">v1::StaticGeometry</a>* Ogre::SceneManager::createStaticGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a StaticGeometry instance suitable for use with this <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>StaticGeometry is a way of batching up geometry into a more efficient form at the expense of being able to move it. Please read the StaticGeometry class documentation for full information. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to give the new object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new StaticGeometry instance </dd></dl>

</div>
</div>
<a id="a6c342dac5ec4958dc235b1aa90005743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c342dac5ec4958dc235b1aa90005743">&#9670;&nbsp;</a></span>createTagPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_tag_point.html">TagPoint</a>* Ogre::SceneManager::createTagPoint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_ogre_1_1_tag_point.html" title="TagPoints are like SceneNodes, that can be children of a Bone. ">TagPoint</a> that can be used like a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>, or be used to be attached to a <a class="el" href="class_ogre_1_1_bone.html" title="Class representing a Bone in the join hierarchy of a skeleton. ">Bone</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_bone.html#a554e67467b3894cc2531ec8ff9fdcb2f" title="Makes the TagPoint child of this Bone. ">Bone::addTagPoint</a> </dd></dl>

</div>
</div>
<a id="ae5dad9b5bf588edc85237b2dca9a03cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5dad9b5bf588edc85237b2dca9a03cf">&#9670;&nbsp;</a></span>createWireAabb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_wire_aabb.html">WireAabb</a>* Ogre::SceneManager::createWireAabb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="class_ogre_1_1_wire_aabb.html" title="Helper class to display the Aabb of a MovableObject as lines. ">WireAabb</a>. </p>

</div>
</div>
<a id="a97b975559cf03c869e70fdcbe38c07ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b975559cf03c869e70fdcbe38c07ce">&#9670;&nbsp;</a></span>cullLights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::cullLights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbc">Light::LightTypes</a>&#160;</td>
          <td class="paramname"><em>startType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbc">Light::LightTypes</a>&#160;</td>
          <td class="paramname"><em>endType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#gae68d52abf76f574fcde6eb0f89eb128f">LightArray</a> &amp;&#160;</td>
          <td class="paramname"><em>outLights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a019a31618f2285f79be2b414488c04c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019a31618f2285f79be2b414488c04c3">&#9670;&nbsp;</a></span>destroyAllAnimations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllAnimations </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all animations created using this <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="aa60a84672be1f532323cdb5dbfdc2c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60a84672be1f532323cdb5dbfdc2c66">&#9670;&nbsp;</a></span>destroyAllAnimationStates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllAnimationStates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all animation states created using this <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="a2c01b8c2d82759fb875089c93df491a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c01b8c2d82759fb875089c93df491a4">&#9670;&nbsp;</a></span>destroyAllBillboardChains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllBillboardChains </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys all BillboardChains from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="a62742f3922523e75b72f6e8303fea251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62742f3922523e75b72f6e8303fea251">&#9670;&nbsp;</a></span>destroyAllBillboardSets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllBillboardSets </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys all BillboardSets. </p>
<dl class="section warning"><dt>Warning</dt><dd>Again, use caution since no BillboardSet must be referred to elsewhere e.g. attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> otherwise a crash is likely. Use clearScene if you are unsure (it clears <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> entries too.) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a01ba0aad5090ed0a8ff5e9c3d24fa924" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc...">SceneManager::clearScene</a> </dd></dl>

</div>
</div>
<a id="a9cb93862284e7443b94eaabdef21564a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb93862284e7443b94eaabdef21564a">&#9670;&nbsp;</a></span>destroyAllCameras()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllCameras </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes (and destroys) all cameras from the scene. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Some cameras are internal created to dealing with texture shadow, or compositor nodes. They aren't supposed to be destroyed outside. So, while you are using texture shadow, don't call this method. </dd></dl>

</div>
</div>
<a id="a1a77be68ccbfc90e2e1aed04340db4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a77be68ccbfc90e2e1aed04340db4dc">&#9670;&nbsp;</a></span>destroyAllEntities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllEntities </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys all Entities. </p>
<dl class="section warning"><dt>Warning</dt><dd>Again, use caution since no Entity must be referred to elsewhere e.g. attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> otherwise a crash is likely. Use clearScene if you are unsure (it clears <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> entries too.) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a01ba0aad5090ed0a8ff5e9c3d24fa924" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc...">SceneManager::clearScene</a> </dd></dl>

</div>
</div>
<a id="a2b116e020a220d8275508252f704ed6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b116e020a220d8275508252f704ed6d">&#9670;&nbsp;</a></span>destroyAllInstanceManagers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllInstanceManagers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a20f632314554702973089c54ba815d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f632314554702973089c54ba815d68">&#9670;&nbsp;</a></span>destroyAllItems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllItems </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys all Items. </p>

</div>
</div>
<a id="a723da9119c26f5022e3a2818611e9aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723da9119c26f5022e3a2818611e9aa0">&#9670;&nbsp;</a></span>destroyAllLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllLights </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes and destroys all lights in the scene. </p>

</div>
</div>
<a id="ab3e151b6d94feb6648b8c817ba485238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e151b6d94feb6648b8c817ba485238">&#9670;&nbsp;</a></span>destroyAllManualObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllManualObjects </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys all ManualObjects from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="af985062a80dbc20d8fe523be166ecca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af985062a80dbc20d8fe523be166ecca6">&#9670;&nbsp;</a></span>destroyAllMovableObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllMovableObjects </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy all MovableObjects. </p>

</div>
</div>
<a id="a8aca5477f30dd55321a101f25c6a5ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aca5477f30dd55321a101f25c6a5ee2">&#9670;&nbsp;</a></span>destroyAllMovableObjectsByType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllMovableObjectsByType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy all MovableObjects of a given type. </p>

</div>
</div>
<a id="a98dbd81cd9867b1032e02e1780b6eb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98dbd81cd9867b1032e02e1780b6eb49">&#9670;&nbsp;</a></span>destroyAllParticleSystems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllParticleSystems </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys all ParticleSystems from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="ab2673459d64d17f47b1aec0920f8e899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2673459d64d17f47b1aec0920f8e899">&#9670;&nbsp;</a></span>destroyAllRectangle2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllRectangle2D </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys all Rectangle2D. </p>
<dl class="section warning"><dt>Warning</dt><dd>Again, use caution since no Rectangle2D must be referred to elsewhere otherwise a crash is likely. Use clearScene if you are unsure (it clears <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> entries too.) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a01ba0aad5090ed0a8ff5e9c3d24fa924" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc...">SceneManager::clearScene</a> </dd></dl>

</div>
</div>
<a id="a12e41109a26094ffe128beb5b6898f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e41109a26094ffe128beb5b6898f95">&#9670;&nbsp;</a></span>destroyAllRibbonTrails()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllRibbonTrails </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys all RibbonTrails from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="a64f54ea048af80532212c8f60bea95d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f54ea048af80532212c8f60bea95d6">&#9670;&nbsp;</a></span>destroyAllStaticGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllStaticGeometry </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove &amp; destroy all StaticGeometry instances. </p>

</div>
</div>
<a id="a75ee4d81b2354710cbcb8462992d93b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ee4d81b2354710cbcb8462992d93b2">&#9670;&nbsp;</a></span>destroyAllWireAabbs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllWireAabbs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys all WireAabbs. </p>

</div>
</div>
<a id="a7ac4e76d36c8f059d7389bf1233563b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac4e76d36c8f059d7389bf1233563b5">&#9670;&nbsp;</a></span>destroyAnimation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAnimation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys an Animation. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You should ensure that none of your code is referencing this animation objects since the memory will be freed. </dd></dl>

</div>
</div>
<a id="a22a3f58bff113aaac870c18741f7cd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a3f58bff113aaac870c18741f7cd76">&#9670;&nbsp;</a></span>destroyAnimationState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAnimationState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys an AnimationState. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You should ensure that none of your code is referencing this animation state object since the memory will be freed. </dd></dl>

</div>
</div>
<a id="a570a5bfc2b2285cf38974dc82db416c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570a5bfc2b2285cf38974dc82db416c9">&#9670;&nbsp;</a></span>destroyBillboardChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyBillboardChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_billboard_chain.html">v1::BillboardChain</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys a BillboardChain from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="af46af31e3f0a9a4c88eb755b9af885d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46af31e3f0a9a4c88eb755b9af885d4">&#9670;&nbsp;</a></span>destroyBillboardSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyBillboardSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_billboard_set.html">v1::BillboardSet</a> *&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys an BillboardSet from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Must only be done if the BillboardSet is not attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>. It may be safer to wait to clear the whole scene. If you are unsure, use clearScene. </dd></dl>

</div>
</div>
<a id="acac58e45f8b6b6826c81933f02a45046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac58e45f8b6b6826c81933f02a45046">&#9670;&nbsp;</a></span>destroyCamera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyCamera </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>cam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a camera from the scene. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method removes a previously added camera from the scene. The camera is deleted so the caller must ensure no references to it's previous instance (e.g. in a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>) are used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cam</td><td>Pointer to the camera to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9238b475a6419e858877bc05de3c3e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9238b475a6419e858877bc05de3c3e50">&#9670;&nbsp;</a></span>destroyEntity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyEntity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_entity.html">v1::Entity</a> *&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys an Entity from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Must only be done if the Entity is not attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>. It may be safer to wait to clear the whole scene if you are unsure use clearScene. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a01ba0aad5090ed0a8ff5e9c3d24fa924" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc...">SceneManager::clearScene</a> </dd></dl>

</div>
</div>
<a id="a9885037b207114e9eaa5153ae196bcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9885037b207114e9eaa5153ae196bcb7">&#9670;&nbsp;</a></span>destroyInstancedEntity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyInstancedEntity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">v1::InstancedEntity</a> *&#160;</td>
          <td class="paramname"><em>instancedEntity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an InstancedEntity,. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#ae880429854291015a41b9a1f9a00ff6f" title="Creates an InstancedEntity based on an existing InstanceManager (. ">SceneManager::createInstancedEntity</a> &amp; </dd>
<dd>
InstanceBatch::removeInstancedEntity </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instancedEntity</td><td>Instance to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a62b928086e749184853098a231d7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a62b928086e749184853098a231d7e3">&#9670;&nbsp;</a></span>destroyInstanceManager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyInstanceManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys an InstanceManager <b>if</b> it was created with <a class="el" href="class_ogre_1_1_scene_manager.html#a8f741f55a905b4cb1dbae7d90ffa543b" title="Creates an InstanceManager interface to create &amp; manipulate instanced entities You need to call this ...">createInstanceManager()</a> </p>
<dl class="section remark"><dt>Remarks</dt><dd>Be sure you don't have any InstancedEntity referenced somewhere which was created with this manager, since it will become a dangling pointer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the manager to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a498b32af3242a5717ea5c192713689fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498b32af3242a5717ea5c192713689fb">&#9670;&nbsp;</a></span>destroyInstanceManager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyInstanceManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">v1::InstanceManager</a> *&#160;</td>
          <td class="paramname"><em>instanceManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fd090b454acb46a228428ec42fc0dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd090b454acb46a228428ec42fc0dfd">&#9670;&nbsp;</a></span>destroyItem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyItem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys an <a class="el" href="class_ogre_1_1_item.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Item</a> from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="acce173aa89e849bda564f4e6e3be6402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce173aa89e849bda564f4e6e3be6402">&#9670;&nbsp;</a></span>destroyLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyLight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_light.html">Light</a> *&#160;</td>
          <td class="paramname"><em>light</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the light from the scene and destroys it based on a pointer. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type. ">Any</a> pointers held to this light after calling this method will be invalid. </dd></dl>

</div>
</div>
<a id="a75d15c3ac882f78f0001d9d007f403be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d15c3ac882f78f0001d9d007f403be">&#9670;&nbsp;</a></span>destroyManualObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyManualObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_manual_object.html">ManualObject</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys a <a class="el" href="class_ogre_1_1_manual_object.html">ManualObject</a> from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="a487bf8d2930ebdade5d3ca34c8c6d34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487bf8d2930ebdade5d3ca34c8c6d34e">&#9670;&nbsp;</a></span>destroyMovableObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyMovableObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> with the name specified, of the type specified. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> will automatically detach itself from any nodes on destruction. </dd></dl>

</div>
</div>
<a id="a32a135e382bac33ecd42f946713e2f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a135e382bac33ecd42f946713e2f38">&#9670;&nbsp;</a></span>destroyMovableObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyMovableObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> will automatically detach itself from any nodes on destruction. </dd></dl>

</div>
</div>
<a id="abde401fcf3796e3e2beb8c7603648f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde401fcf3796e3e2beb8c7603648f07">&#9670;&nbsp;</a></span>destroyParticleSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyParticleSystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_particle_system.html">ParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys a <a class="el" href="class_ogre_1_1_particle_system.html" title="Class defining particle system based special effects. ">ParticleSystem</a> from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="a08f7adf5f342c6808481fa922c8c62a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f7adf5f342c6808481fa922c8c62a0">&#9670;&nbsp;</a></span>destroyQuery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_query.html">SceneQuery</a> *&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a scene query of any type. </p>

</div>
</div>
<a id="ae88b9456ae744c56b69c626597f9938c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88b9456ae744c56b69c626597f9938c">&#9670;&nbsp;</a></span>destroyRectangle2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyRectangle2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_rectangle2_d.html">v1::Rectangle2D</a> *&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys an Entity from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>It may be safer to wait to clear the whole scene if you are unsure use clearScene. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a01ba0aad5090ed0a8ff5e9c3d24fa924" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc...">SceneManager::clearScene</a> </dd></dl>

</div>
</div>
<a id="a3559e67959d2e5d8ddf10b9e0556e93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3559e67959d2e5d8ddf10b9e0556e93a">&#9670;&nbsp;</a></span>destroyRibbonTrail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyRibbonTrail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_ribbon_trail.html">v1::RibbonTrail</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys a RibbonTrail from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="aa613e5ffb08b95a90644a61ac10c9b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa613e5ffb08b95a90644a61ac10c9b5c">&#9670;&nbsp;</a></span>destroySceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroySceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td>
          <td class="paramname"><em>sn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This allows you to physically delete an individual <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> if you want to. Note that this is not normally recommended, it's better to allow <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> to delete the nodes when the scene is cleared. </dd></dl>

</div>
</div>
<a id="a911db15a672db3ebb4837840ed2c5bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911db15a672db3ebb4837840ed2c5bf0">&#9670;&nbsp;</a></span>destroySkeletonInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::destroySkeletonInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_skeleton_instance.html">SkeletonInstance</a> *&#160;</td>
          <td class="paramname"><em>skeletonInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an instance of a skeleton created with . </p>

</div>
</div>
<a id="ad95c77b37c0da0b469b955aac98c46bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95c77b37c0da0b469b955aac98c46bf">&#9670;&nbsp;</a></span>destroyStaticGeometry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyStaticGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_static_geometry.html">v1::StaticGeometry</a> *&#160;</td>
          <td class="paramname"><em>geom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove &amp; destroy a StaticGeometry instance. </p>

</div>
</div>
<a id="ae4f180b40f4bf55669f9842fe922a003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f180b40f4bf55669f9842fe922a003">&#9670;&nbsp;</a></span>destroyStaticGeometry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyStaticGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove &amp; destroy a StaticGeometry instance. </p>

</div>
</div>
<a id="aa12bb6b0b9cf79cf8aaa1f454cea9116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12bb6b0b9cf79cf8aaa1f454cea9116">&#9670;&nbsp;</a></span>destroyWireAabb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyWireAabb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_wire_aabb.html">WireAabb</a> *&#160;</td>
          <td class="paramname"><em>wireAabb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes &amp; destroys an <a class="el" href="class_ogre_1_1_wire_aabb.html" title="Helper class to display the Aabb of a MovableObject as lines. ">WireAabb</a> from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="a1257fd328d54908eeb45398b3191f92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1257fd328d54908eeb45398b3191f92b">&#9670;&nbsp;</a></span>estimateWorldGeometry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::SceneManager::estimateWorldGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimate the number of loading stages required to load the named world geometry. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method should be overridden by SceneManagers that provide custom world geometry that can take some time to load. They should return from this method a count of the number of stages of progress they can report on whilst loading. During real loading (setWorldGeometry), they should call ResourceGroupManager::_notifyWorldGeometryProgress exactly that number of times when loading the geometry for real. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default is to return 0, ie to not report progress. </dd></dl>

</div>
</div>
<a id="abdf303a6b80c95fabfae679f0a9898f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf303a6b80c95fabfae679f0a9898f7">&#9670;&nbsp;</a></span>estimateWorldGeometry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::SceneManager::estimateWorldGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimate the number of loading stages required to load the named world geometry. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Operates just like the version of this method which takes a filename, but operates on a stream instead. Note that since the stream is updated, you'll need to reset the stream or reopen it when it comes to loading it for real. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Data stream containing data to load </td></tr>
    <tr><td class="paramname">typeName</td><td>String identifying the type of world geometry contained in the stream - not required if this manager only supports one type of world geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a040241bad11b74f5ba8971fb146f8c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040241bad11b74f5ba8971fb146f8c6d">&#9670;&nbsp;</a></span>executeUserScalableTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::executeUserScalableTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_uniform_scalable_task.html">UniformScalableTask</a> *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes a user-defined <a class="el" href="class_ogre_1_1_uniform_scalable_task.html" title="A uniform task is a highly parallelizable task that can be divided in many threads where all threads ...">UniformScalableTask</a> in the worker threads spawned by <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If 'bBlock' is false, it is user responsibility to call waitForPendingUserScalableTask before the next call to either processUserScalableTask or renderOneFrame. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Task to perform. Pointer must be valid at least until the task is finished </td></tr>
    <tr><td class="paramname">bBlock</td><td>True if you want the function to block until the task is done. False if you want to do something in between, in this case you MUST call waitForPendingUserScalableTask later. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c55f5e97c66261de71c979db64f6355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c55f5e97c66261de71c979db64f6355">&#9670;&nbsp;</a></span>extractAllMovableObjectsByType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::extractAllMovableObjectsByType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract all injected MovableObjects of a given type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Essentially this does the same as destroyAllMovableObjectsByType, but only removes the instances from the internal lists, it does not attempt to destroy them. </dd></dl>

</div>
</div>
<a id="a874431ce04c34fa6dcbdb2ed1420b168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874431ce04c34fa6dcbdb2ed1420b168">&#9670;&nbsp;</a></span>extractMovableObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::extractMovableObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a previously injected <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Essentially this does the same as destroyMovableObject, but only removes the instance from the internal lists, it does not attempt to destroy it. </dd></dl>

</div>
</div>
<a id="af2a761b7c1518ca6723ad4d08d8a335a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a761b7c1518ca6723ad4d08d8a335a">&#9670;&nbsp;</a></span>findCamera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_camera.html">Camera</a>* Ogre::SceneManager::findCamera </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the camera with the given name. </p>
<p>Throws if not found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Hash of the name of the camera to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Camera</a> pointer </dd></dl>

</div>
</div>
<a id="ae4e080c31630734fd937b3d3580a2f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e080c31630734fd937b3d3580a2f62">&#9670;&nbsp;</a></span>findCameraNoThrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_camera.html">Camera</a>* Ogre::SceneManager::findCameraNoThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the camera with the given name. </p>
<p>Returns null pointer if not found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Hash of the name of the camera to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Camera</a> pointer. Null if not found. </dd></dl>

</div>
</div>
<a id="adab6a83be3e4045890ed16dd80023ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab6a83be3e4045890ed16dd80023ea7">&#9670;&nbsp;</a></span>findMovableObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_scene_manager.html#a6d8f5f81e262b6347f5066da27d6fe70">MovableObjectVec</a> Ogre::SceneManager::findMovableObjects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all the movable objects with the type and name passed as parameters. </p>

</div>
</div>
<a id="adca3e6a51e42c0f7383f7d92c4a79377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca3e6a51e42c0f7383f7d92c4a79377">&#9670;&nbsp;</a></span>findSceneNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> <a class="el" href="class_ogre_1_1_scene_manager.html#a8f87c38314b272fff95da3065f3740ee">SceneNodeList</a> Ogre::SceneManager::findSceneNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all the scene nodes with the name passed as parameter. </p>

</div>
</div>
<a id="a2bace1d8ae2c3c14bd0df22efee3ea8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bace1d8ae2c3c14bd0df22efee3ea8a">&#9670;&nbsp;</a></span>getAmbientLightHemisphereDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&amp; Ogre::SceneManager::getAmbientLightHemisphereDir </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71383d1aee19d8783ee75c4705a7fcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71383d1aee19d8783ee75c4705a7fcc3">&#9670;&nbsp;</a></span>getAmbientLightLowerHemisphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::SceneManager::getAmbientLightLowerHemisphere </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8d8c6cff1677375a7a84c345534947f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d8c6cff1677375a7a84c345534947f">&#9670;&nbsp;</a></span>getAmbientLightUpperHemisphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::SceneManager::getAmbientLightUpperHemisphere </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ambient light level to be used for the scene. </p>

</div>
</div>
<a id="a5c3f8d93657ec9107bfeb014f1454915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3f8d93657ec9107bfeb014f1454915">&#9670;&nbsp;</a></span>getAnimation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_animation.html">v1::Animation</a>* Ogre::SceneManager::getAnimation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Looks up an Animation object previously created with createAnimation. </p>
<dl class="section note"><dt>Note</dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div>
<a id="ab28450738168fe330709ad0d090df6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28450738168fe330709ad0d090df6b5">&#9670;&nbsp;</a></span>getAnimationIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_manager.html#a3a720414f68274bb9c5026911e27135d">AnimationIterator</a> Ogre::SceneManager::getAnimationIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a specialised <a class="el" href="class_ogre_1_1_map_iterator.html" title="Concrete IteratorWrapper for nonconst access to the underlying key-value container. ">MapIterator</a> over all animations in the scene. </p>

</div>
</div>
<a id="ab3d61667202240702c7279b675439505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d61667202240702c7279b675439505">&#9670;&nbsp;</a></span>getAnimations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const AnimationList&amp; Ogre::SceneManager::getAnimations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const version of the animation list. </p>

</div>
</div>
<a id="a6a63fccbae507c458bb08e24f8950480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a63fccbae507c458bb08e24f8950480">&#9670;&nbsp;</a></span>getAnimationState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_animation_state.html">v1::AnimationState</a>* Ogre::SceneManager::getAnimationState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>animName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves animation state as previously created using createAnimationState. </p>
<dl class="section note"><dt>Note</dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div>
<a id="aa48fb79e236cd76927d9e92f51a82fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48fb79e236cd76927d9e92f51a82fdf">&#9670;&nbsp;</a></span>getAnimationStateIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___animation.html#ga6c8619d12ac269631ef4f400ea2e2ba3">v1::AnimationStateIterator</a> Ogre::SceneManager::getAnimationStateIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a specialised <a class="el" href="class_ogre_1_1_map_iterator.html" title="Concrete IteratorWrapper for nonconst access to the underlying key-value container. ">MapIterator</a> over all animation states in the scene. </p>

</div>
</div>
<a id="a988b713015b950c917724215a2c42e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988b713015b950c917724215a2c42e82">&#9670;&nbsp;</a></span>getCameraInProgress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_camera.html">Camera</a>* Ogre::SceneManager::getCameraInProgress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current camera being rendered (advanced use only, only valid during viewport update. </p>

</div>
</div>
<a id="a02d7d29cc4bc8ee4cbe40d16a984291c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d7d29cc4bc8ee4cbe40d16a984291c">&#9670;&nbsp;</a></span>getCameraIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_manager.html#a460e50da4b97d1beaef1a64bfa039928">CameraIterator</a> Ogre::SceneManager::getCameraIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a specialised <a class="el" href="class_ogre_1_1_map_iterator.html" title="Concrete IteratorWrapper for nonconst access to the underlying key-value container. ">MapIterator</a> over all cameras in the scene. </p>

</div>
</div>
<a id="acf26160d2d9a4a9ebf61d0ba8cbffcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf26160d2d9a4a9ebf61d0ba8cbffcfb">&#9670;&nbsp;</a></span>getCameras()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CameraList&amp; Ogre::SceneManager::getCameras </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const version of the camera list. </p>

</div>
</div>
<a id="a5a20f12d329ce8eab8287a66437e4458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a20f12d329ce8eab8287a66437e4458">&#9670;&nbsp;</a></span>getCompositorTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_compositor_texture.html">CompositorTexture</a>&amp; Ogre::SceneManager::getCompositorTarget </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The compositor we are currently writing to. </p>

</div>
</div>
<a id="a38dd87bb59ef8f5214808878637e6947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dd87bb59ef8f5214808878637e6947">&#9670;&nbsp;</a></span>getCompositorTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___effects.html#ga5b2773dd5ab4626bf794ee82b5f822e8">CompositorTextureVec</a>&amp; Ogre::SceneManager::getCompositorTextures </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_pass_def.html#aa9377ca6479c21df519128eb6142b169">CompositorPassDef::mExposedTextures</a> for the textures that are available in the current compositor pass. The compositor script keyword is "expose". </dd></dl>

</div>
</div>
<a id="ad89af25c747e890f3ad89193ce93041a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89af25c747e890f3ad89193ce93041a">&#9670;&nbsp;</a></span>getCurrentCastersBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>&amp; Ogre::SceneManager::getCurrentCastersBox </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a55280f3dbe04abff8b8970b57fd79807" title="mCastersBox ">CompositorShadowNode::getCastersBox</a> </p>
<dl class="section remark"><dt>Remarks</dt><dd>Returns a null box if no active shadow node. </dd></dl>

</div>
</div>
<a id="a70b4a09ace966c642deea6c42b95ff69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b4a09ace966c642deea6c42b95ff69">&#9670;&nbsp;</a></span>getCurrentCompositorPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a>* Ogre::SceneManager::getCurrentCompositorPass </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note: May be null. </p>

</div>
</div>
<a id="a589923c70280db49a00bd7af8375cee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589923c70280db49a00bd7af8375cee9">&#9670;&nbsp;</a></span>getCurrentPrePassDepthTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a>* Ogre::SceneManager::getCurrentPrePassDepthTexture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa622bd9607691def94c1954c5ca90be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa622bd9607691def94c1954c5ca90be6">&#9670;&nbsp;</a></span>getCurrentPrePassMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga63b5ab6176b81463bbdd0e260b751d2e">PrePassMode</a> Ogre::SceneManager::getCurrentPrePassMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acdb4f6d880ab38ac07ac9dc7aee2903a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb4f6d880ab38ac07ac9dc7aee2903a">&#9670;&nbsp;</a></span>getCurrentPrePassTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a>* Ogre::SceneManager::getCurrentPrePassTextures </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb82e7fbe30e6ee417b1dc63da8ae115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb82e7fbe30e6ee417b1dc63da8ae115">&#9670;&nbsp;</a></span>getCurrentShadowNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html">CompositorShadowNode</a>* Ogre::SceneManager::getCurrentShadowNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adba901c3141f61f0592de2d5a69f1318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba901c3141f61f0592de2d5a69f1318">&#9670;&nbsp;</a></span>getCurrentSsrTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___effects.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a>* Ogre::SceneManager::getCurrentSsrTexture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14da2ba967b9b85d69780c5a295f3836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14da2ba967b9b85d69780c5a295f3836">&#9670;&nbsp;</a></span>getCurrentViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_viewport.html">Viewport</a>* Ogre::SceneManager::getCurrentViewport </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current viewport being rendered (advanced use only, only valid during viewport update. </p>

</div>
</div>
<a id="aa5ed3c081ae69e90569fd0c2727a34df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ed3c081ae69e90569fd0c2727a34df">&#9670;&nbsp;</a></span>getDestinationRenderSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a>* Ogre::SceneManager::getDestinationRenderSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the rendersystem subclass to which the output of this Scene Manager gets sent. </p>

</div>
</div>
<a id="a0fec5de5b1af8423dbdae70fa1d18954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fec5de5b1af8423dbdae70fa1d18954">&#9670;&nbsp;</a></span>getDisplaySceneNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getDisplaySceneNodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all scene nodes axis are to be displayed. </p>

</div>
</div>
<a id="ab0919a8c9d6034f9f8b9afef7117135e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0919a8c9d6034f9f8b9afef7117135e">&#9670;&nbsp;</a></span>getDummySceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneManager::getDummySceneNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlike mNodeMemoryManager-&gt;_getDummyNode(), this dummy node is fully allocated, which makes it possible to actually attach objects to this dummy, while we guarantee the dummy won't change its transform. </p>

</div>
</div>
<a id="a3d7d7f344e528eea2e99481247de72c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7d7f344e528eea2e99481247de72c7">&#9670;&nbsp;</a></span>getFindVisibleObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getFindVisibleObjects </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> should search for visible objects, or whether they are being manually handled. </p>

</div>
</div>
<a id="ac981c1e86936cdf189150d6dabeb8f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac981c1e86936cdf189150d6dabeb8f4f">&#9670;&nbsp;</a></span>getFlipCullingOnNegativeScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getFlipCullingOnNegativeScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether to automatically flip the culling mode on objects whenever they are negatively scaled. </p>

</div>
</div>
<a id="af9e45431d08a9b243dd561e13889cf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e45431d08a9b243dd561e13889cf32">&#9670;&nbsp;</a></span>getFogColour()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::SceneManager::getFogColour </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fog colour for the scene. </p>

</div>
</div>
<a id="a12cb60fdad7cb792c6897f6a75f5a71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cb60fdad7cb792c6897f6a75f5a71a">&#9670;&nbsp;</a></span>getFogDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getFogDensity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fog density for the scene. </p>

</div>
</div>
<a id="aa52eb95b1241a0ba0468287a22bd3fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52eb95b1241a0ba0468287a22bd3fd8">&#9670;&nbsp;</a></span>getFogEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getFogEnd </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fog end distance for the scene. </p>

</div>
</div>
<a id="a860a3c04b9b0db60a78f08743a104a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860a3c04b9b0db60a78f08743a104a94">&#9670;&nbsp;</a></span>getFogMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___general.html#ga83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a> Ogre::SceneManager::getFogMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fog mode for the scene. </p>

</div>
</div>
<a id="adcfa98c914fe6e6f67a21fe144bd281d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfa98c914fe6e6f67a21fe144bd281d">&#9670;&nbsp;</a></span>getFogStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getFogStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fog start distance for the scene. </p>

</div>
</div>
<a id="ac2c5d8b2de0d61c371d551f3650246d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c5d8b2de0d61c371d551f3650246d1">&#9670;&nbsp;</a></span>getForwardPlus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_forward_plus_base.html">ForwardPlusBase</a>* Ogre::SceneManager::getForwardPlus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ce6c279340a1bc24d978f2fa26345f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce6c279340a1bc24d978f2fa26345f7">&#9670;&nbsp;</a></span>getGlobalLightList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_light_list_info.html">LightListInfo</a>&amp; Ogre::SceneManager::getGlobalLightList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9e3cda33cf8d29c33a5c5c2777ca393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e3cda33cf8d29c33a5c5c2777ca393">&#9670;&nbsp;</a></span>getInstanceManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">v1::InstanceManager</a>* Ogre::SceneManager::getInstanceManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an existing InstanceManager by it's name. </p>
<dl class="section note"><dt>Note</dt><dd>Throws an exception if the named InstanceManager does not exist </dd></dl>

</div>
</div>
<a id="a1ffa8b3f07c5295c3c6ca06df99899f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffa8b3f07c5295c3c6ca06df99899f7">&#9670;&nbsp;</a></span>getInstancingThreadedCullingMethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___scene.html#gafdd170d87744deec0ca8dd1730797be7">InstancingThreadedCullingMethod</a> Ogre::SceneManager::getInstancingThreadedCullingMethod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94d3193c52302229da41688946065dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d3193c52302229da41688946065dc7">&#9670;&nbsp;</a></span>getLightClippingPlanes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group___math.html#gae00d718daa48567f6c010aad9d6dd92c">PlaneList</a>&amp; Ogre::SceneManager::getLightClippingPlanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_light.html">Light</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a set of clipping planes for a given light. </p>

</div>
</div>
<a id="a5674d3ac7f0eefac585c234b14359f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5674d3ac7f0eefac585c234b14359f9f">&#9670;&nbsp;</a></span>getLightScissorRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group___general.html#ga3e1c672c1d342ffb4f122f44e342bc90">RealRect</a>&amp; Ogre::SceneManager::getLightScissorRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_light.html">Light</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>cam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a scissor rectangle for a given light and camera. </p>

</div>
</div>
<a id="a7c3f378c66d1266970320d8fb04278b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3f378c66d1266970320d8fb04278b0">&#9670;&nbsp;</a></span>getMinMaxDepthRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::getMinMaxDepthRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_frustum.html">Frustum</a> *&#160;</td>
          <td class="paramname"><em>shadowMapCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>outMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>outMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#afc7297ac09456ceff0056a7a0d03f88c" title="Outputs the min &amp; max depth range for the given camera. ">CompositorShadowNode::getMinMaxDepthRange</a> </p>
<dl class="section remark"><dt>Remarks</dt><dd>Outputs 0 &amp; 100000 if no active shadow node or camera not found. </dd></dl>

</div>
</div>
<a id="af19c32fbc0adc0fa28d8e6c26d9800cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19c32fbc0adc0fa28d8e6c26d9800cb">&#9670;&nbsp;</a></span>getMovableObjectIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_scene_manager.html#af5348867645ff727d1ca25dd89795376">MovableObjectIterator</a> Ogre::SceneManager::getMovableObjectIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator over all MovableObect instances of a given type. </p>
<dl class="section note"><dt>Note</dt><dd>The iterator returned from this method is not thread safe, do not use this if you are creating or deleting objects of this type in another thread. </dd></dl>

</div>
</div>
<a id="aaa7164acf31d5275397f2ea4f6ea3de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7164acf31d5275397f2ea4f6ea3de5">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::SceneManager::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the instance name of this <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. </p>

</div>
</div>
<a id="af8b9ac37458ce1911947e1c077187fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b9ac37458ce1911947e1c077187fec">&#9670;&nbsp;</a></span>getNumCompositorTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::SceneManager::getNumCompositorTextures </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of currently active compositor textures. </p>

</div>
</div>
<a id="ac77f781212b22679a816ca60c132bdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77f781212b22679a816ca60c132bdfd">&#9670;&nbsp;</a></span>getNumInstancesPerBatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::SceneManager::getNumInstancesPerBatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>meshName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___scene.html#ga7fdc1f95714df3401447297dd6385e9c">v1::InstanceManager::InstancingTechnique</a>&#160;</td>
          <td class="paramname"><em>technique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numInstancesPerBatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>subMeshIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>InstanceManager::getMaxOrBestNumInstancesPerBatch </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you've already created an InstanceManager, you can call it's getMaxOrBestNumInstancesPerBatch() function directly. Another (not recommended) way to know if the technique is unsupported is by creating an InstanceManager and use createInstancedEntity, which will return null pointer. The input parameter "numInstancesPerBatch" is a suggested value when using IM_VTFBESTFIT flag (in that case it should be non-zero) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The ideal (or maximum, depending on flags) number of instances per batch for the given technique. Zero if technique is unsupported or errors were spotted </dd></dl>

</div>
</div>
<a id="a4ac962924e49d9686471e3e639177129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac962924e49d9686471e3e639177129">&#9670;&nbsp;</a></span>getNumWorkerThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::SceneManager::getNumWorkerThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ea53a860f373185f5a46239f579a361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea53a860f373185f5a46239f579a361">&#9670;&nbsp;</a></span>getOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>strKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDestValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for getting the value of an implementation-specific Scene Manager option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strKey</td><td>The name of the option </td></tr>
    <tr><td class="paramname">pDestValue</td><td>A pointer to a memory location where the value will be copied. Currently, the memory will be allocated by the scene manager, but this may change </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, true is returned and pDestValue points to the value of the given option. </dd></dl>
<dl class="section user"><dt></dt><dd>On failure, false is returned and pDestValue is set to NULL. </dd></dl>

</div>
</div>
<a id="a7c8ff6b5c19eb9eeef9d5a6c9fca9fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8ff6b5c19eb9eeef9d5a6c9fca9fe8">&#9670;&nbsp;</a></span>getOptionKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getOptionKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>refKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for getting all the implementation-specific options of the scene manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refKeys</td><td>A reference to a list that will be filled with all the available options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, true is returned. On failure, false is returned. </dd></dl>

</div>
</div>
<a id="ae291393bc0c5bd48a8c6e79742180c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae291393bc0c5bd48a8c6e79742180c93">&#9670;&nbsp;</a></span>getOptionValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getOptionValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>strKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>refValueList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for getting all possible values for a specific option. </p>
<p>When this list is too large (i.e. the option expects, for example, a float), the return value will be true, but the list will contain just one element whose size will be set to 0. Otherwise, the list will be filled with all the possible values the option can accept. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strKey</td><td>The name of the option to get the values for. </td></tr>
    <tr><td class="paramname">refValueList</td><td>A reference to a list that will be filled with the available values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success (the option exists), true is returned. </dd></dl>
<dl class="section user"><dt></dt><dd>On failure, false is returned. </dd></dl>

</div>
</div>
<a id="a045cc6cee9d3db9c59d0e14523368eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045cc6cee9d3db9c59d0e14523368eb8">&#9670;&nbsp;</a></span>getRelativeOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::SceneManager::getRelativeOrigin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current relative origin. (Only when non-permanent) </p>

</div>
</div>
<a id="a0a366754506c37891718b5ebec86934d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a366754506c37891718b5ebec86934d">&#9670;&nbsp;</a></span>getRenderQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a>* Ogre::SceneManager::getRenderQueue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_ogre_1_1_render_queue.html" title="Enumeration of queue groups, by which the application may group queued renderables so that they are r...">RenderQueue</a>. </p>

</div>
</div>
<a id="a8c8190fcdb503203cb3cdc8050ac658c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8190fcdb503203cb3cdc8050ac658c">&#9670;&nbsp;</a></span>getRootSceneNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneManager::getRootSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em> = <code><a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> at the root of the scene hierarchy. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The entire scene is held as a hierarchy of nodes, which allows things like relative transforms, general changes in rendering state etc (See the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> class for more info). In this basic <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> class, the application using <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is free to structure this hierarchy however it likes, since it has no real significance apart from making transforms relative to each node (more specialised subclasses will provide utility methods for building specific node structures e.g. loading a BSP tree). </dd></dl>
<dl class="section user"><dt></dt><dd>However, in all cases there is only ever one root node of the hierarchy, and this method returns a pointer to it. There is actually an extra <a class="el" href="class_ogre_1_1_root.html" title="The root class of the Ogre system. ">Root</a> <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> so that static objects can be attached to it. Note however, static nodes can be children of a dynamic root node. </dd></dl>

</div>
</div>
<a id="a44b80df48045f3dea1b1ef1c700a3d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b80df48045f3dea1b1ef1c700a3d20">&#9670;&nbsp;</a></span>getSceneNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneManager::getSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> based on it's ID from the scene graph. </p>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns null if the ID does not exist </dd>
<dd>
It is a linear search O(N), retrieves the first node found with that name (it's not unique) </dd></dl>

</div>
</div>
<a id="aa7a10930e4d1a622010259e98c8c4106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a10930e4d1a622010259e98c8c4106">&#9670;&nbsp;</a></span>getSceneNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> const <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneManager::getSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c260af8c99d9086876c969ab3aab112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c260af8c99d9086876c969ab3aab112">&#9670;&nbsp;</a></span>getShadowColour()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::SceneManager::getShadowColour </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the colour used to modulate areas in shadow. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is only applicable for shadow techniques which involve darkening the area in shadow, as opposed to masking out the light. This colour provided is used as a modulative value to darken the areas. </dd></dl>

</div>
</div>
<a id="a4c8d7b3656c9bdc0910eede3707ee0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8d7b3656c9bdc0910eede3707ee0f5">&#9670;&nbsp;</a></span>getShadowDirectionalLightExtrusionDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getShadowDirectionalLightExtrusionDistance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the distance a shadow volume is extruded for a directional light. </p>

</div>
</div>
<a id="a70f92eed233e8131c28b93a1a8d144c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f92eed233e8131c28b93a1a8d144c1">&#9670;&nbsp;</a></span>getShadowDirLightTextureOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getShadowDirLightTextureOffset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space. </p>

</div>
</div>
<a id="a9db2b873fe3a9a4db5c824f813efbcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db2b873fe3a9a4db5c824f813efbcae">&#9670;&nbsp;</a></span>getShadowFarDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getShadowFarDistance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the default maximum distance away from the camera that shadows will be visible. </p>

</div>
</div>
<a id="aadcf0e82479037779758261648b5e6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcf0e82479037779758261648b5e6d7">&#9670;&nbsp;</a></span>getShadowFarDistanceSquared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getShadowFarDistanceSquared </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6008c82cd40e85f1b1c38d7929ec2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6008c82cd40e85f1b1c38d7929ec2ba">&#9670;&nbsp;</a></span>getShowBoundingBoxes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getShowBoundingBoxes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if all bounding boxes of scene nodes are to be displayed. </p>

</div>
</div>
<a id="ae0b7a808ad2105cce6435b1136ce32c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b7a808ad2105cce6435b1136ce32c9">&#9670;&nbsp;</a></span>getSkyBoxGenParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_ogre_1_1_scene_manager_1_1_sky_box_gen_parameters.html">SkyBoxGenParameters</a>&amp; Ogre::SceneManager::getSkyBoxGenParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the parameters used to generate the current SkyBox, if any. </p>

</div>
</div>
<a id="a987ab43f9f3718b51e435a6ceda9097d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987ab43f9f3718b51e435a6ceda9097d">&#9670;&nbsp;</a></span>getSkyBoxNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneManager::getSkyBoxNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the skybox node, if enabled. </p>

</div>
</div>
<a id="a888cbcb18e7fc8d471da026686e6dfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888cbcb18e7fc8d471da026686e6dfca">&#9670;&nbsp;</a></span>getSkyDomeGenParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_ogre_1_1_scene_manager_1_1_sky_dome_gen_parameters.html">SkyDomeGenParameters</a>&amp; Ogre::SceneManager::getSkyDomeGenParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the parameters used to generate the current SkyDome, if any. </p>

</div>
</div>
<a id="aea64fa75fbb1d2ada36b784f9397eb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea64fa75fbb1d2ada36b784f9397eb50">&#9670;&nbsp;</a></span>getSkyDomeNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneManager::getSkyDomeNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sky dome node, if enabled. </p>

</div>
</div>
<a id="ae3f600105fe20680b0b90fae9ac28faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f600105fe20680b0b90fae9ac28faa">&#9670;&nbsp;</a></span>getSkyPlaneGenParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_ogre_1_1_scene_manager_1_1_sky_plane_gen_parameters.html">SkyPlaneGenParameters</a>&amp; Ogre::SceneManager::getSkyPlaneGenParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the parameters used to construct the SkyPlane, if any. </p>

</div>
</div>
<a id="ae5e119c2fdae37bd3710078e43d3763d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e119c2fdae37bd3710078e43d3763d">&#9670;&nbsp;</a></span>getSkyPlaneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneManager::getSkyPlaneNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sky plane node, if enabled. </p>

</div>
</div>
<a id="a3dd97aab1507157df4eaf0f6b844bb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd97aab1507157df4eaf0f6b844bb4c">&#9670;&nbsp;</a></span>getStaticGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1v1_1_1_static_geometry.html">v1::StaticGeometry</a>* Ogre::SceneManager::getStaticGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a previously created StaticGeometry instance. </p>
<dl class="section note"><dt>Note</dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div>
<a id="add6fe27d7a9500aafbe9325c21985801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6fe27d7a9500aafbe9325c21985801">&#9670;&nbsp;</a></span>getSuggestedViewpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_ogre_1_1_view_point.html">ViewPoint</a> Ogre::SceneManager::getSuggestedViewpoint </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>random</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asks the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> to provide a suggested viewpoint from which the scene should be viewed. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Typically this method returns the origin unless a) world geometry has been loaded using <a class="el" href="class_ogre_1_1_scene_manager.html#accb0fdfbd1f61aa4d3d6e1f4625e1f9c" title="Sets the source of the &#39;world&#39; geometry, i.e. ">SceneManager::setWorldGeometry</a> and b) that world geometry has suggested 'start' points. If there is more than one viewpoint which the scene manager can suggest, it will always suggest the first one unless the random parameter is true. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">random</td><td>If true, and there is more than one possible suggestion, a random one will be used. If false the same one will always be suggested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, true is returned. </dd></dl>
<dl class="section user"><dt></dt><dd>On failure, false is returned. </dd></dl>

</div>
</div>
<a id="a46690a40b65fd0e7e89752e1e36be727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46690a40b65fd0e7e89752e1e36be727">&#9670;&nbsp;</a></span>getTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::SceneManager::getTypeName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the type name of this scene manager. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method has to be implemented by subclasses. It should return the type name of this <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> which agrees with the type name of the <a class="el" href="class_ogre_1_1_scene_manager_factory.html" title="Class which will create instances of a given SceneManager. ">SceneManagerFactory</a> which created it. </dd></dl>

<p>Implemented in <a class="el" href="class_ogre_1_1_default_scene_manager.html#a1bba0dd3fda00d54b2c058a3b8e61cb2">Ogre::DefaultSceneManager</a>.</p>

</div>
</div>
<a id="a0da39851ae801a1a561a2dc8a269532b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da39851ae801a1a561a2dc8a269532b">&#9670;&nbsp;</a></span>getVisibilityMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::SceneManager::getVisibilityMask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible. </p>

</div>
</div>
<a id="a689e655688df190c38eb3437c7a8e94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689e655688df190c38eb3437c7a8e94e">&#9670;&nbsp;</a></span>hasAnimation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasAnimation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether an animation with the given name exists. </p>

</div>
</div>
<a id="affa968418639b742f299cf6cb553aa73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa968418639b742f299cf6cb553aa73">&#9670;&nbsp;</a></span>hasAnimationState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasAnimationState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether an animation state with the given name exists. </p>

</div>
</div>
<a id="a0d994816fefb71453799cdc6135f5995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d994816fefb71453799cdc6135f5995">&#9670;&nbsp;</a></span>hasInstanceManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasInstanceManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>managerName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether an InstanceManager with the given name exists. </p>

</div>
</div>
<a id="a17bf05431cd6901c4b2fc9c89a42de67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bf05431cd6901c4b2fc9c89a42de67">&#9670;&nbsp;</a></span>hasMovableObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasMovableObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
Returns if this <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> contains the specified <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> </p>

</div>
</div>
<a id="a6c9731d50869bd17fd55dfbf0f54db78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9731d50869bd17fd55dfbf0f54db78">&#9670;&nbsp;</a></span>hasOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>strKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for verifying whether the scene manager has an implementation-specific option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strKey</td><td>The name of the option to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the scene manager contains the given option, true is returned. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If it does not, false is returned. </dd></dl>

</div>
</div>
<a id="a16a9e2d2738ef22c23a72f5c214d19c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a9e2d2738ef22c23a72f5c214d19c8">&#9670;&nbsp;</a></span>hasStaticGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasStaticGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a static geometry instance with the given name exists. </p>

</div>
</div>
<a id="af13eb691a7bdd67e17a402dee98c4b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13eb691a7bdd67e17a402dee98c4b5f">&#9670;&nbsp;</a></span>injectMovableObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::injectMovableObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inject a <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instance created externally. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method 'injects' a <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instance created externally into the <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instance registry held in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>. You might want to use this if you have a <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> which you don't want to register a factory for; for example a <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> which cannot be generally constructed by clients. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is important that the <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> has a unique name for the type, and that its getMovableType() method returns a proper type name. </dd></dl>

</div>
</div>
<a id="a2d8f7e94f73720dc0f94bc34610543fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8f7e94f73720dc0f94bc34610543fa">&#9670;&nbsp;</a></span>isCurrentShadowNodeReused()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::SceneManager::isCurrentShadowNodeReused </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64a77e6deae28a8fdc8068e3dd063419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a77e6deae28a8fdc8068e3dd063419">&#9670;&nbsp;</a></span>isLateMaterialResolving()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isLateMaterialResolving </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether using late material resolving or not. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a86c1371039d40e139a37b2b174538978" title="Sets whether to use late material resolving or not. ">setLateMaterialResolving</a> </dd></dl>

</div>
</div>
<a id="ae9055498d95c80a1290ae70ee932290e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9055498d95c80a1290ae70ee932290e">&#9670;&nbsp;</a></span>isSkyBoxEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isSkyBoxEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether a skybox is enabled. </p>

</div>
</div>
<a id="ac00d89b4d8a646501355447b71a40ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00d89b4d8a646501355447b71a40ad1">&#9670;&nbsp;</a></span>isSkyDomeEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isSkyDomeEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether a skydome is enabled. </p>

</div>
</div>
<a id="acdd6b70a3a504fabc07d75706ea1e71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd6b70a3a504fabc07d75706ea1e71f">&#9670;&nbsp;</a></span>isSkyPlaneEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isSkyPlaneEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether a key plane is enabled. </p>

</div>
</div>
<a id="a09cefefe52f0a24f5df51d8edc36df25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09cefefe52f0a24f5df51d8edc36df25">&#9670;&nbsp;</a></span>notifyStaticAabbDirty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::notifyStaticAabbDirty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>movableObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies that the given <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> is dirty (i.e. </p>
<p>the AABBs have changed). Note that the parent SceneNodes of this/these objects are not updated and you will have to call </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a464c4d6f1f2761d8d3b715df0591b96a" title="Notifies that the given Node is dirty (i.e. ">notifyStaticDirty</a> on the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> if the position/rotation/scale have changed. </dd></dl>

</div>
</div>
<a id="a464c4d6f1f2761d8d3b715df0591b96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464c4d6f1f2761d8d3b715df0591b96a">&#9670;&nbsp;</a></span>notifyStaticDirty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::notifyStaticDirty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies that the given <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> is dirty (i.e. </p>
<p>the position, orientation and/or scale has changed). The call will cascade to all children of the input node. </p><dl class="section remark"><dt>Remarks</dt><dd>Implies a call to </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a09cefefe52f0a24f5df51d8edc36df25" title="Notifies that the given MovableObject is dirty (i.e. ">notifyStaticAabbDirty</a> if the node or any of its children has a <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> attached. </dd></dl>
<dl class="section user"><dt></dt><dd>Calling notifyStaticDirty( getRootSceneNode( SCENE_STATIC ) ) should flush the entire static system. It might be slower, but it is useful when you're witnessing artifacts after making changes to the static environment and don't know for sure which objects need to be updated. </dd></dl>

</div>
</div>
<a id="a9b10b7fef2893e75acc083415df70446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b10b7fef2893e75acc083415df70446">&#9670;&nbsp;</a></span>OGRE_MUTEX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::SceneManager::OGRE_MUTEX </td>
          <td>(</td>
          <td class="paramtype">sceneGraphMutex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutex to protect the scene graph from simultaneous access from multiple threads. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If you are updating the scene in a separate thread from the rendering thread, then you should lock this mutex before making any changes to the scene graph - that means creating, modifying or deleting a scene node, or attaching / detaching objects. It is <b>your</b> responsibility to take out this lock, the detail methods on the nodes will not do it for you (for the reasons discussed below). </dd></dl>
<dl class="section user"><dt></dt><dd>Note that locking this mutex will prevent the scene being rendered until it is unlocked again. Therefore you should do this sparingly. Try to create any objects you need separately and fully prepare them before doing all your scene graph work in one go, thus keeping this lock for the shortest time possible. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A single global lock is used rather than a per-node lock since it keeps the number of locks required during rendering down to a minimum. Obtaining a lock, even if there is no contention, is not free so for performance it is good to do it as little as possible. Since modifying the scene in a separate thread is a fairly rare occurrence (relative to rendering), it is better to keep the locking required during rendering lower than to make update locks more granular. </dd></dl>

</div>
</div>
<a id="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357fe4fb4849772b94baa4bf47c7ded">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c727e879a260c37b00ce5505fe8e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c727e879a260c37b00ce5505fe8e144">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46d4b0a597156d9ba5abc39d127792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46d4b0a597156d9ba5abc39d127792">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a86dde5483c053ca0f2a85bbfd6c">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595ea4c05da8aa987d3800e65d23355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595ea4c05da8aa987d3800e65d23355d">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a421b197ca3a38da17e2eb1531a645fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421b197ca3a38da17e2eb1531a645fa2">&#9670;&nbsp;</a></span>operator new() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a id="ac4bdf968b7b9af8a5239a27da73d5711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bdf968b7b9af8a5239a27da73d5711">&#9670;&nbsp;</a></span>operator new() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab78a921e54419be677839cdf15d1f0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78a921e54419be677839cdf15d1f0b8">&#9670;&nbsp;</a></span>operator new() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a id="a4be37baef81876985aa1071ad5acc6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be37baef81876985aa1071ad5acc6dd">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a id="afa2943846ba6a2b5824a12857139cf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2943846ba6a2b5824a12857139cf5e">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ceb87944e7ba077e4c6ed8db8acf4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ceb87944e7ba077e4c6ed8db8acf4cc">&#9670;&nbsp;</a></span>prepareWorldGeometry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::prepareWorldGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the source of the 'world' geometry, i.e. </p>
<p>the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. </p><dl class="section remark"><dt>Remarks</dt><dd>Depending on the type of <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> (subclasses will be specialised for particular world geometry types) you have requested via the <a class="el" href="class_ogre_1_1_root.html" title="The root class of the Ogre system. ">Root</a> or <a class="el" href="class_ogre_1_1_scene_manager_enumerator.html" title="Enumerates the SceneManager classes available to applications. ">SceneManagerEnumerator</a> classes, you can pass a filename to this method and it will attempt to load the world-level geometry for use. If you try to load an inappropriate type of world data an exception will be thrown. The default <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> cannot handle any sort of world geometry and so will always throw an exception. However subclasses like BspSceneManager can load particular types of world geometry e.g. "q3dm1.bsp". </dd></dl>

</div>
</div>
<a id="ad9633390826daf0fb2c7a8a43abe4f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9633390826daf0fb2c7a8a43abe4f01">&#9670;&nbsp;</a></span>prepareWorldGeometry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::prepareWorldGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the source of the 'world' geometry, i.e. </p>
<p>the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. </p><dl class="section remark"><dt>Remarks</dt><dd>Depending on the type of <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> (subclasses will be specialised for particular world geometry types) you have requested via the <a class="el" href="class_ogre_1_1_root.html" title="The root class of the Ogre system. ">Root</a> or <a class="el" href="class_ogre_1_1_scene_manager_enumerator.html" title="Enumerates the SceneManager classes available to applications. ">SceneManagerEnumerator</a> classes, you can pass a stream to this method and it will attempt to load the world-level geometry for use. If the manager can only handle one input format the typeName parameter is not required. The stream passed will be read (and it's state updated). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Data stream containing data to load </td></tr>
    <tr><td class="paramname">typeName</td><td>String identifying the type of world geometry contained in the stream - not required if this manager only supports one type of world geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaff41e7ad0baa4f0aa50f4b3e7048d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff41e7ad0baa4f0aa50f4b3e7048d63">&#9670;&nbsp;</a></span>registerSceneNodeListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::registerSceneNodeListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td>
          <td class="paramname"><em>sceneNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> listeners need to be registered with us so that they can be successfully called when calling updateAllTransforms. </p>
<p>updateAllTransforms </p>

</div>
</div>
<a id="a4437b11b78eae8f5db205aa89c0235ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4437b11b78eae8f5db205aa89c0235ee">&#9670;&nbsp;</a></span>removeListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::removeListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager_1_1_listener.html">Listener</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a listener. </p>

</div>
</div>
<a id="a25cc1bb36997b722fc60efc7903f3760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cc1bb36997b722fc60efc7903f3760">&#9670;&nbsp;</a></span>removeLodListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::removeLodListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_lod_listener.html">LodListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
Remove a level of detail listener. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Do not call from inside an <a class="el" href="class_ogre_1_1_lod_listener.html" title="A interface class defining a listener which can be used to receive notifications of LOD events...">LodListener</a> callback method. </dd></dl>

</div>
</div>
<a id="a2a482e0a9f78109a5a467ddd6c16082b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a482e0a9f78109a5a467ddd6c16082b">&#9670;&nbsp;</a></span>removeRenderObjectListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::removeRenderObjectListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_object_listener.html">RenderObjectListener</a> *&#160;</td>
          <td class="paramname"><em>delListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a listener previously added with addRenderObjectListener. </p>

</div>
</div>
<a id="a190471ba7a61111d576a1e8ca9862706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190471ba7a61111d576a1e8ca9862706">&#9670;&nbsp;</a></span>removeRenderQueueListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::removeRenderQueueListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_queue_listener.html">RenderQueueListener</a> *&#160;</td>
          <td class="paramname"><em>delListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a listener previously added with addRenderQueueListener. </p>

</div>
</div>
<a id="a56cd9aa2c4dee4eec9eb07ce1372fb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cd9aa2c4dee4eec9eb07ce1372fb52">&#9670;&nbsp;</a></span>setAmbientLight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::setAmbientLight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>upperHemisphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>lowerHemisphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>hemisphereDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>envmapScale</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the ambient light level to be used for the scene. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Ambient lighting is a cheap fake to compensate the lack of global illumination. Hemisphere ambient lighting will set the final ambient light to the following formula: float w = dot( objNormal, hemisphereDir ) * 0.5 + 0.5; finalAmbient = lerp( lowerHemisphere, upperHemisphere, w );</dd></dl>
<p>Setting upperHemisphere = lowerHemisphere is effectively a traditional fixed-colour ambient light. </p><dl class="section user"><dt></dt><dd>Tip: Set the upperHemisphere to a cold colour (e.g. blueish sky) and lowerHemisphere to a warm colour (e.g. sun-yellowish, orange) and the hemisphereDir in the opposite direction of your main directional light for a convincing look. </dd></dl>
<dl class="section user"><dt></dt><dd>By default the ambient light in the scene is <a class="el" href="class_ogre_1_1_colour_value.html#a7f8a06f2a9dd645417c36b560f496c1a">ColourValue::Black</a>, i.e. no ambient light. This means that any objects rendered with a <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a> which has lighting enabled (see Material::setLightingEnabled) will not be visible unless you have some dynamic lights in your scene. </dd></dl>
<dl class="section user"><dt></dt><dd>For compatibility reasons with legacy (e.g. low level materials) upperHemisphere's colour is the old ambient colour from 1.x</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperHemisphere</td><td>Ambient colour when the surface normal is close to hemisphereDir </td></tr>
    <tr><td class="paramname">lowerHemisphere</td><td>Ambient colour when the surface normal is pointing away from hemisphereDir </td></tr>
    <tr><td class="paramname">hemisphereDir</td><td>Hemisphere's direction reference to compare the surface normal to. The internal vector will be normalized. </td></tr>
    <tr><td class="paramname">envmapScale</td><td>Global scale to apply to all environment maps (for relevant <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;. ">Hlms</a> implementations, like PBS). The value will be stored in upperHemisphere.a Use 1.0 to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46c5cbc33b0f498ed01670289e87584c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c5cbc33b0f498ed01670289e87584c">&#9670;&nbsp;</a></span>setDisplaySceneNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setDisplaySceneNodes </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> whether it should render the SceneNodes which make up the scene as well as the objects in the scene. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is mainly for debugging purposes. If you set this to 'true', each node will be rendered as a set of 3 axes to allow you to easily see the orientation of the nodes. </dd></dl>

</div>
</div>
<a id="a04c8414da02aec3e3f98acd013917ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c8414da02aec3e3f98acd013917ed2">&#9670;&nbsp;</a></span>setFindVisibleObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setFindVisibleObjects </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>find</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> should search for visible objects, or whether they are being manually handled. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is an advanced function, you should not use this unless you know what you are doing. </dd></dl>

</div>
</div>
<a id="a2a4d997503b651187f2e129cd5eeb7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4d997503b651187f2e129cd5eeb7ad">&#9670;&nbsp;</a></span>setFlipCullingOnNegativeScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setFlipCullingOnNegativeScale </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether to automatically flip the culling mode on objects whenever they are negatively scaled. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Negativelyl scaling an object has the effect of flipping the triangles, so the culling mode should probably be inverted to deal with this. If you would prefer to manually manage this, set this option to 'false' and use different materials with Pass::setCullingMode set manually as needed. </dd></dl>

</div>
</div>
<a id="ab804195c05873da617dcd16198a63d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab804195c05873da617dcd16198a63d1c">&#9670;&nbsp;</a></span>setFog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::setFog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group___general.html#gga83edeb2e5d33a3ca8f15834ba40020baab7793a21880052c0214d4cc040992310">FOG_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>colour</em> = <code><a class="el" href="class_ogre_1_1_colour_value.html#a8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>expDensity</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>linearStart</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>linearEnd</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fogging mode applied to the scene. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method sets up the scene-wide fogging effect. These settings apply to all geometry rendered, UNLESS the material with which it is rendered has it's own fog settings (see <a class="el" href="class_ogre_1_1_material.html#a32937d27d1a0211a76d9ce8035a221ee" title="Sets the fogging mode applied to each pass. ">Material::setFog</a>). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </td></tr>
    <tr><td class="paramname">colour</td><td>The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </td></tr>
    <tr><td class="paramname">expDensity</td><td>The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 0.001. </td></tr>
    <tr><td class="paramname">linearStart</td><td>Distance in world units at which linear fog starts to encroach. Only applicable if mode is FOG_LINEAR. </td></tr>
    <tr><td class="paramname">linearEnd</td><td>Distance in world units at which linear fog becomes completely opaque. Only applicable if mode is FOG_LINEAR. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b4cbdad7664b8747f1929dbec29c046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4cbdad7664b8747f1929dbec29c046">&#9670;&nbsp;</a></span>setForward3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::setForward3D </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>numSlices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>lightsPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the <a class="el" href="class_ogre_1_1_forward3_d.html" title="Forward3D. ">Forward3D</a> implementation for using many non-shadowed lights in the scene. </p>
<p>See the <a class="el" href="class_ogre_1_1_forward3_d.html" title="Forward3D. ">Forward3D</a> sample for more information. </p><dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;. ">Hlms</a> implementation must support this feature in order to work. Calling this function can recreate resources (even if called multiple times with the same exact paramters). Don't do it often. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnable</td><td>True to enable it. False to disable it. </td></tr>
    <tr><td class="paramname">width</td><td>The width of the view-space grid. Recommended value is 4 unless numSlices is very small. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the view-space grid. Recommended value is 4 unless numSlices is very small. </td></tr>
    <tr><td class="paramname">numSlices</td><td>The number of slices. Each additional slice consumes much more memory. The width and height is doubled on each slice. It's like mipmapping but on reverse. </td></tr>
    <tr><td class="paramname">lightsPerCell</td><td>The maximum number of lights a cell in the grid can hold. </td></tr>
    <tr><td class="paramname">minDistance</td><td>Bias towards the camera for grid. </td></tr>
    <tr><td class="paramname">maxDistance</td><td>How far the grid array can go. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a854fc565dca2ee633ad55c75235ad293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854fc565dca2ee633ad55c75235ad293">&#9670;&nbsp;</a></span>setForwardClustered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::setForwardClustered </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>numSlices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>lightsPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86c1371039d40e139a37b2b174538978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c1371039d40e139a37b2b174538978">&#9670;&nbsp;</a></span>setLateMaterialResolving()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setLateMaterialResolving </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether to use late material resolving or not. </p>
<p>If set, materials will be resolved from the materials at the pass-setting stage and not at the render queue building stage. This is useful when the active material scheme during the render queue building stage is different from the one during the rendering stage. </p>

</div>
</div>
<a id="a34f3ddda75dcf75d5c5176446b3316a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f3ddda75dcf75d5c5176446b3316a8">&#9670;&nbsp;</a></span>setOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::setOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>strKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for setting a specific option of the Scene Manager. </p>
<p>These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strKey</td><td>The name of the option to set </td></tr>
    <tr><td class="paramname">pValue</td><td>A pointer to the value - the size should be calculated by the scene manager based on the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, true is returned. </dd></dl>
<dl class="section user"><dt></dt><dd>On failure, false is returned. </dd></dl>

</div>
</div>
<a id="a3ee0d5d307652b51bc7a405907a85368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee0d5d307652b51bc7a405907a85368">&#9670;&nbsp;</a></span>setRelativeOrigin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setRelativeOrigin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>relativeOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPermanent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether to use relative offset co-ordinates when rendering, ie offset to subtract to the camera, lights &amp; objects. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is a technique to alleviate some of the precision issues associated with rendering far from the origin, where single-precision floats as used in most GPUs begin to lose their precision. The origin "translates" to this new relativeOffset. <a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type. ">Any</a> previous non-permanent origin is overriden </dd></dl>
<dl class="section user"><dt></dt><dd>All that this function performs is just offseting the root scene node, and as such, will force to update the static nodes as well. Call this at a low frequency (i.e. when camera has gone too far from origin) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you need this option, you will probably also need to enable double-precision mode in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> (OGRE_DOUBLE_PRECISION), since even though this will alleviate the rendering precision, the source camera and object positions will still suffer from precision issues leading to jerky movement. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bPermanent</td><td>When false, it only affects the root nodes (static &amp; dynamic) so that everything is shifted by the relative origin, causing world &amp; view matrices to contain smaller values. This improves the quality of skeletal animations and "Z fighting"-like artifacts because vertices don't snap to the right place. However, it won't fix the jittering of objects observed while translating them by small increments, including camera movement.</td></tr>
  </table>
  </dd>
</dl>
<p>Setting this value to true will force the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> to propagate the change as much as possible to child nodes (including attached Cameras), causing the change to become permanent/irreversible. This achieves greater quality since translating objects or camera by small amounts now gets more accuracy.  propagateRelativeOrigin. </p>

</div>
</div>
<a id="ad8ab6139696f9ef50d8abea0528e85b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ab6139696f9ef50d8abea0528e85b4">&#9670;&nbsp;</a></span>setShadowColour()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowColour </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>colour</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the colour used to modulate areas in shadow. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is only applicable for shadow techniques which involve darkening the area in shadow, as opposed to masking out the light. This colour provided is used as a modulative value to darken the areas. </dd></dl>

</div>
</div>
<a id="a9d220fa31bf0d95ad65558936c71a194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d220fa31bf0d95ad65558936c71a194">&#9670;&nbsp;</a></span>setShadowDirectionalLightExtrusionDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowDirectionalLightExtrusionDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the distance a shadow volume is extruded for a directional light. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Although directional lights are essentially infinite, there are many reasons to limit the shadow extrusion distance to a finite number, not least of which is compatibility with older cards (which do not support infinite positions), and shadow caster elimination. </dd></dl>
<dl class="section user"><dt></dt><dd>The default value is 10,000 world units. This does not apply to point lights or spotlights, since they extrude up to their attenuation range. </dd></dl>

</div>
</div>
<a id="a893663f55c2b4a29467cff25b9b1b3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893663f55c2b4a29467cff25b9b1b3f4">&#9670;&nbsp;</a></span>setShadowDirLightTextureOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowDirLightTextureOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When generating a shadow texture from a directional light, an approximation is used since it is not possible to render the entire scene to one texture. The texture is projected onto an area centred on the camera, and is the shadow far distance * 2 in length (it is square). This wastes a lot of texture space outside the frustum though, so this offset allows you to move the texture in front of the camera more. However, be aware that this can cause a little shadow 'jittering' during rotation, and that if you move it too far then you'll start to get artefacts close to the camera. The value is represented as a proportion of the shadow far distance, and the default is 0.6. </dd></dl>

</div>
</div>
<a id="a0e593d05e2f892b8fc3bfca917a75fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e593d05e2f892b8fc3bfca917a75fef">&#9670;&nbsp;</a></span>setShadowFarDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowFarDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>distance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default maximum distance away from the camera that shadows will be visible. </p>
<p>You have to call this function before you create lights or the default distance of zero will be used. </p><dl class="section remark"><dt>Remarks</dt><dd>Shadow techniques can be expensive, therefore it is a good idea to limit them to being rendered close to the camera if possible, and to skip the expense of rendering shadows for distance objects. This method allows you to set the distance at which shadows will no longer be rendered. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Each shadow technique can interpret this subtely differently. For example, one technique may use this to eliminate casters, another might use it to attenuate the shadows themselves. You should tweak this value to suit your chosen shadow technique and scene setup. </dd></dl>

</div>
</div>
<a id="a9f0cde141313583e65561abdfae6a0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0cde141313583e65561abdfae6a0ec">&#9670;&nbsp;</a></span>setShadowTextureCasterMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureCasterMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default material to use for rendering shadow casters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>By default shadow casters are rendered into the shadow texture using an automatically generated fixed-function pass. This allows basic projective texture shadows, but it's possible to use more advanced shadow techniques by overriding the caster materials, for example providing vertex and fragment programs to implement shadow maps. </dd></dl>
<dl class="section user"><dt></dt><dd>You can rely on the ambient light in the scene being set to the requested texture shadow colour, if that's useful. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Individual objects may also override the vertex program in your default material if their materials include shadow_caster_vertex_program_ref, shadow_caster_material entries, so if you use both make sure they are compatible. <br />
</dd>
<dd>
Only a single pass is allowed in your material, although multiple techniques may be used for hardware fallback. </dd></dl>

</div>
</div>
<a id="a237a09e65919b808473c543fb886723f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237a09e65919b808473c543fb886723f">&#9670;&nbsp;</a></span>setShadowTextureFadeEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureFadeEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fadeEnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the proportional distance at which texture shadows finish to fading out. </p>
<dl class="section remark"><dt>Remarks</dt><dd>To hide the edges where texture shadows end (in directional lights) <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will fade out the shadow in the distance. This value is a proportional distance of the entire shadow visibility distance at which the shadow is completely invisible. The default is 0.9. </dd></dl>

</div>
</div>
<a id="a72fa019aa4efbc6943842efcf5f38078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fa019aa4efbc6943842efcf5f38078">&#9670;&nbsp;</a></span>setShadowTextureFadeStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureFadeStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fadeStart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the proportional distance at which texture shadows begin to fade out. </p>
<dl class="section remark"><dt>Remarks</dt><dd>To hide the edges where texture shadows end (in directional lights) <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will fade out the shadow in the distance. This value is a proportional distance of the entire shadow visibility distance at which the shadow begins to fade out. The default is 0.7 </dd></dl>

</div>
</div>
<a id="af419fca38294bef65224162b3ad4af36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af419fca38294bef65224162b3ad4af36">&#9670;&nbsp;</a></span>setSkyBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setSkyBox </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>distance</em> = <code>5000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drawFirst</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables / disables a 'sky box' i.e. </p>
<p>a 6-sided box at constant distance from the camera representing the sky. </p><dl class="section remark"><dt>Remarks</dt><dd>You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> as the <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Camera</a> too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). </dd></dl>
<dl class="section user"><dt></dt><dd>The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> class for more information. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable the skybox, false to disable it </td></tr>
    <tr><td class="paramname">materialName</td><td>The name of the material the box will use </td></tr>
    <tr><td class="paramname">distance</td><td>Distance in world coorinates from the camera to each plane of the box. The default is normally OK. </td></tr>
    <tr><td class="paramname">drawFirst</td><td>If true, the box is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws <em>after</em> all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky box when it is rendered. </td></tr>
    <tr><td class="paramname">orientation</td><td>Optional parameter to specify the orientation of the box. By default the 'top' of the box is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </td></tr>
    <tr><td class="paramname">groupName</td><td>The name of the resource group to which to assign the plane mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8ba1fc585a224a834ffe2624db23e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ba1fc585a224a834ffe2624db23e57">&#9670;&nbsp;</a></span>setSkyBoxEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setSkyBoxEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables / disables a 'sky box'. </p>

</div>
</div>
<a id="add758e3fa5df1291df9ff98b2594d35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add758e3fa5df1291df9ff98b2594d35b">&#9670;&nbsp;</a></span>setSkyDome()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setSkyDome </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>curvature</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>tiling</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>distance</em> = <code>4000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drawFirst</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsegments</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysegments</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysegments_keep</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables / disables a 'sky dome' i.e. </p>
<p>an illusion of a curved sky. </p><dl class="section remark"><dt>Remarks</dt><dd>A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. </dd></dl>
<dl class="section user"><dt></dt><dd>Sky domes work well with 2D repeating textures like clouds. You can change the apparent 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable the skydome, false to disable it </td></tr>
    <tr><td class="paramname">materialName</td><td>The name of the material the dome will use </td></tr>
    <tr><td class="paramname">curvature</td><td>The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </td></tr>
    <tr><td class="paramname">tiling</td><td>How many times to tile the texture(s) across the dome. </td></tr>
    <tr><td class="paramname">distance</td><td>Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </td></tr>
    <tr><td class="paramname">drawFirst</td><td>If true, the dome is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws <em>after</em> all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky when it is rendered. </td></tr>
    <tr><td class="paramname">orientation</td><td>Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </td></tr>
    <tr><td class="paramname">groupName</td><td>The name of the resource group to which to assign the plane mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50a692ae852b41cf6e7e8ac647d2660f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a692ae852b41cf6e7e8ac647d2660f">&#9670;&nbsp;</a></span>setSkyDomeEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setSkyDomeEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables / disables a 'sky dome'. </p>

</div>
</div>
<a id="a7f9395e50574b0d0c343036cf816c2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9395e50574b0d0c343036cf816c2bf">&#9670;&nbsp;</a></span>setSkyPlane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setSkyPlane </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>tiling</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drawFirst</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>bow</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsegments</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysegments</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a813da407fd91dc1afee86103d3a4f5cc">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables / disables a 'sky plane' i.e. </p>
<p>a plane at constant distance from the camera representing the sky. </p><dl class="section remark"><dt>Remarks</dt><dd>You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> as the <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Camera</a> too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>To apply scaling, scrolls etc to the sky texture(s) you should use the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> class methods. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable the plane, false to disable it </td></tr>
    <tr><td class="paramname">plane</td><td>Details of the plane, i.e. it's normal and it's distance from the camera. </td></tr>
    <tr><td class="paramname">materialName</td><td>The name of the material the plane will use </td></tr>
    <tr><td class="paramname">scale</td><td>The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </td></tr>
    <tr><td class="paramname">tiling</td><td>How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> texture coordinate transformation methods. </td></tr>
    <tr><td class="paramname">drawFirst</td><td>If true, the plane is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws <em>after</em> all other geometry which can be an optimisation - however you must ensure that the plane.d value is large enough that no objects will 'poke through' the sky plane when it is rendered. </td></tr>
    <tr><td class="paramname">bow</td><td>If zero, the plane will be completely flat (like previous versions. If above zero, the plane will be curved, allowing the sky to appear below camera level. Curved sky planes are simular to skydomes, but are more compatible with fog. </td></tr>
    <tr><td class="paramname">xsegments,ysegments</td><td>Determines the number of segments the plane will have to it. This is most important when you are bowing the plane, but may also be useful if you need tessellation on the plane to perform per-vertex effects. </td></tr>
    <tr><td class="paramname">groupName</td><td>The name of the resource group to which to assign the plane mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a213f0aaaf1341fe090e66968c8907f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213f0aaaf1341fe090e66968c8907f44">&#9670;&nbsp;</a></span>setSkyPlaneEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setSkyPlaneEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables / disables a 'sky plane'. </p>

</div>
</div>
<a id="a7c5e69ee25b1e34eadd088d7d58ef02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5e69ee25b1e34eadd088d7d58ef02d">&#9670;&nbsp;</a></span>setVisibilityMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::SceneManager::setVisibilityMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>vmask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that this is combined with any per-viewport visibility mask through an 'and' operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Viewport::setVisibilityMask </dd></dl>

<p class="reference">References <a class="el" href="namespace_ogre_1_1_visibility_flags.html#a7726a5ff6639016d642e056532a62eee">Ogre::VisibilityFlags::RESERVED_VISIBILITY_FLAGS</a>.</p>

</div>
</div>
<a id="accb0fdfbd1f61aa4d3d6e1f4625e1f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb0fdfbd1f61aa4d3d6e1f4625e1f9c">&#9670;&nbsp;</a></span>setWorldGeometry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setWorldGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the source of the 'world' geometry, i.e. </p>
<p>the large, mainly static geometry making up the world e.g. rooms, landscape etc. </p><dl class="section remark"><dt>Remarks</dt><dd>Depending on the type of <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> (subclasses will be specialised for particular world geometry types) you have requested via the <a class="el" href="class_ogre_1_1_root.html" title="The root class of the Ogre system. ">Root</a> or <a class="el" href="class_ogre_1_1_scene_manager_enumerator.html" title="Enumerates the SceneManager classes available to applications. ">SceneManagerEnumerator</a> classes, you can pass a filename to this method and it will attempt to load the world-level geometry for use. If you try to load an inappropriate type of world data an exception will be thrown. The default <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> cannot handle any sort of world geometry and so will always throw an exception. However subclasses like BspSceneManager can load particular types of world geometry e.g. "q3dm1.bsp". </dd></dl>

</div>
</div>
<a id="a9b7ebcecf64452f59211f45d4ec33576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7ebcecf64452f59211f45d4ec33576">&#9670;&nbsp;</a></span>setWorldGeometry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setWorldGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the source of the 'world' geometry, i.e. </p>
<p>the large, mainly static geometry making up the world e.g. rooms, landscape etc. </p><dl class="section remark"><dt>Remarks</dt><dd>Depending on the type of <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> (subclasses will be specialised for particular world geometry types) you have requested via the <a class="el" href="class_ogre_1_1_root.html" title="The root class of the Ogre system. ">Root</a> or <a class="el" href="class_ogre_1_1_scene_manager_enumerator.html" title="Enumerates the SceneManager classes available to applications. ">SceneManagerEnumerator</a> classes, you can pass a stream to this method and it will attempt to load the world-level geometry for use. If the manager can only handle one input format the typeName parameter is not required. The stream passed will be read (and it's state updated). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Data stream containing data to load </td></tr>
    <tr><td class="paramname">typeName</td><td>String identifying the type of world geometry contained in the stream - not required if this manager only supports one type of world geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a487859007d68fe9f261aea1645252563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487859007d68fe9f261aea1645252563">&#9670;&nbsp;</a></span>showBoundingBoxes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::showBoundingBoxes </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bShow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows all bounding boxes of scene nodes to be displayed. </p>

</div>
</div>
<a id="ac660da6d88e53b19c0062884705222ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac660da6d88e53b19c0062884705222ca">&#9670;&nbsp;</a></span>unregisterSceneNodeListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::unregisterSceneNodeListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td>
          <td class="paramname"><em>sceneNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters a registered node for listening. </p>
<p>registerSceneNodeListener </p>

</div>
</div>
<a id="a393dbe126bfaaf7f5aa4712a84d3facd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393dbe126bfaaf7f5aa4712a84d3facd">&#9670;&nbsp;</a></span>updateAllAnimations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::updateAllAnimations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates all skeletal animations in the scene. </p>
<p>This is typically called once per frame during render, but the user might want to manually call this function. </p><dl class="section remark"><dt>Remarks</dt><dd>mSkeletonAnimManagerCulledList must be set.  updateAllTransforms remarks </dd></dl>

</div>
</div>
<a id="a5de4ecb4955dcf164cfeb69c457716ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de4ecb4955dcf164cfeb69c457716ee">&#9670;&nbsp;</a></span>updateAllBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::updateAllBounds </td>
          <td>(</td>
          <td class="paramtype">const ObjectMemoryManagerVec &amp;&#160;</td>
          <td class="paramname"><em>objectMemManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the world aabbs from all entities in the scene. </p>
<p>Ought to be called right after updateAllTransforms.  updateAllTransforms </p><dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="class_ogre_1_1_movable_object.html#add737d6564593333aeac457a1a2c0269" title="SceneManager::updateAllBounds ">MovableObject::updateAllBounds</a> Don't call this function from another thread other than <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s main one (we use worker threads that may be in use for something else, and touching the sync barrier could deadlock in the best of cases). </dd></dl>

</div>
</div>
<a id="a77ce1584abf7edd2896e7f7c0d0bd629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ce1584abf7edd2896e7f7c0d0bd629">&#9670;&nbsp;</a></span>updateAllLods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::updateAllLods </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>lodBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>firstRq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>lastRq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the Lod values of all objects relative to the given camera. </p>

</div>
</div>
<a id="aa99abd1ab437720f0b1056080736b164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99abd1ab437720f0b1056080736b164">&#9670;&nbsp;</a></span>updateAllTagPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::updateAllTagPoints </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates all TagPoints, both TagPoints that are children of bones, and TagPoints that are children of other TagPoints. </p>
<dl class="section remark"><dt>Remarks</dt><dd>mTagPointNodeMemoryManagerUpdateList must be set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a1f59ebdfaadbe33f713d754737041654" title="Updates the derived transforms of all nodes in the scene. ">updateAllTransforms</a> remarks </dd></dl>

</div>
</div>
<a id="a1f59ebdfaadbe33f713d754737041654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f59ebdfaadbe33f713d754737041654">&#9670;&nbsp;</a></span>updateAllTransforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::updateAllTransforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the derived transforms of all nodes in the scene. </p>
<p>This is typically called once per frame during render, but the user may want to manually call this function. </p><dl class="section remark"><dt>Remarks</dt><dd>mEntitiesMemoryManagerUpdateList must be set. It contains multiple memory manager containing all objects to be updated (i.e. Entities &amp; Lights are both MovableObjects but are kept separate) Don't call this function from another thread other than <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s main one (we use worker threads that may be in use for something else, and touching the sync barrier could deadlock in the best of cases). </dd></dl>

</div>
</div>
<a id="a3cbd2750082529aed2375531a4d5d9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbd2750082529aed2375531a4d5d9cd">&#9670;&nbsp;</a></span>updateSceneGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::updateSceneGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the scene: Perform high level culling, <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> transforms and entity animations. </p>

</div>
</div>
<a id="a11c832526246a71e73cd517bff928a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c832526246a71e73cd517bff928a64">&#9670;&nbsp;</a></span>waitForPendingUserScalableTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::waitForPendingUserScalableTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks until the the task from processUserScalableTask finishes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Do NOT call this function if you passed bBlock = true to processUserScalableTask </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6c140ffaced93a2b854e5c519c8fb568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c140ffaced93a2b854e5c519c8fb568">&#9670;&nbsp;</a></span>QUERY_ENTITY_DEFAULT_MASK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::SceneManager::QUERY_ENTITY_DEFAULT_MASK</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default query mask for entities. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> </dd></dl>

</div>
</div>
<a id="a6617d4f358cbe1d72edd06b7a8ad62bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6617d4f358cbe1d72edd06b7a8ad62bd">&#9670;&nbsp;</a></span>QUERY_FRUSTUM_DEFAULT_MASK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::SceneManager::QUERY_FRUSTUM_DEFAULT_MASK</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default query mask for frusta and cameras. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> </dd></dl>

</div>
</div>
<a id="a412b439c03cb282ee205498d9b00220e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412b439c03cb282ee205498d9b00220e">&#9670;&nbsp;</a></span>QUERY_FX_DEFAULT_MASK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::SceneManager::QUERY_FX_DEFAULT_MASK</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default query mask for effects like billboardsets / particle systems. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> </dd></dl>

</div>
</div>
<a id="a9d2789c7eea005fd7c63b3ee3b850617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2789c7eea005fd7c63b3ee3b850617">&#9670;&nbsp;</a></span>QUERY_LIGHT_DEFAULT_MASK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::SceneManager::QUERY_LIGHT_DEFAULT_MASK</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default query mask for lights. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> </dd></dl>

</div>
</div>
<a id="a09844d40f3b7404e591224b814067e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09844d40f3b7404e591224b814067e63">&#9670;&nbsp;</a></span>QUERY_STATICGEOMETRY_DEFAULT_MASK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::SceneManager::QUERY_STATICGEOMETRY_DEFAULT_MASK</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default query mask for StaticGeometry. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_scene_manager_8h.html">OgreSceneManager.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
