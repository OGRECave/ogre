<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::HlmsComputeJob Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">2.1.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_hlms_compute_job.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_ogre_1_1_hlms_compute_job-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::HlmsComputeJob Class Reference<div class="ingroups"><a class="el" href="group___component.html">Component</a> &raquo; <a class="el" href="group___material.html">Material</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;OgreHlmsComputeJob.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::HlmsComputeJob:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_hlms_compute_job__inherit__graph.svg" width="186" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a297b925576b81843bd963d67ec561fbd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">ThreadGroupsBasedOn</a> { <a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbda697e40abfad5bdecd362193e78cdbdaf">ThreadGroupsBasedOnNothing</a>, 
<a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbdac33b17a1bd51fc701513327b1dd34aee">ThreadGroupsBasedOnTexture</a>, 
<a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbda5a8e8159a04475a17cdff51380da79ee">ThreadGroupsBasedOnUav</a>
 }</td></tr>
<tr class="separator:a297b925576b81843bd963d67ec561fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa2f584f8a3a801d850b6e16533bb14c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aa2f584f8a3a801d850b6e16533bb14c5">HlmsComputeJob</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, <a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *creator, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;sourceFilename, const <a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;includedPieceFiles)</td></tr>
<tr class="separator:aa2f584f8a3a801d850b6e16533bb14c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824bf5717b6d72f11ad9772873044bcc"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a824bf5717b6d72f11ad9772873044bcc">~HlmsComputeJob</a> ()</td></tr>
<tr class="separator:a824bf5717b6d72f11ad9772873044bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f01509a37d8699f43f520833053a3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ae1f01509a37d8699f43f520833053a3a">_calculateNumThreadGroupsBasedOnSetting</a> ()</td></tr>
<tr class="memdesc:ae1f01509a37d8699f43f520833053a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">INTERNAL USE.  <a href="#ae1f01509a37d8699f43f520833053a3a">More...</a><br /></td></tr>
<tr class="separator:ae1f01509a37d8699f43f520833053a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ea49e86dfbc11d0e64f803823bb10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_shader_params.html">ShaderParams</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a94ea49e86dfbc11d0e64f803823bb10b">_getShaderParams</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key)</td></tr>
<tr class="memdesc:a94ea49e86dfbc11d0e64f803823bb10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a shader parameter with the given key.  <a href="#a94ea49e86dfbc11d0e64f803823bb10b">More...</a><br /></td></tr>
<tr class="separator:a94ea49e86dfbc11d0e64f803823bb10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e207a03438ec6db03d518cf32a3f73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a43e207a03438ec6db03d518cf32a3f73">_setSamplerblock</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *refParams)</td></tr>
<tr class="memdesc:a43e207a03438ec6db03d518cf32a3f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a samplerblock directly.  <a href="#a43e207a03438ec6db03d518cf32a3f73">More...</a><br /></td></tr>
<tr class="separator:a43e207a03438ec6db03d518cf32a3f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523ca862e2ccf507953fa18ce79879d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a523ca862e2ccf507953fa18ce79879d8">_setUavBuffer</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *uavBuffer, <a class="el" href="namespace_ogre_1_1_resource_access.html#a732c0b8774d76d325e0749d09ce70aad">ResourceAccess::ResourceAccess</a> access, size_t offset=0, size_t sizeBytes=0)</td></tr>
<tr class="memdesc:a523ca862e2ccf507953fa18ce79879d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an UAV buffer at the given slot ID.  <a href="#a523ca862e2ccf507953fa18ce79879d8">More...</a><br /></td></tr>
<tr class="separator:a523ca862e2ccf507953fa18ce79879d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479de119004a6825886c4114fbe9beb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a479de119004a6825886c4114fbe9beb1">_setUavTexture</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, <a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> &amp;texture, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> textureArrayIndex, <a class="el" href="namespace_ogre_1_1_resource_access.html#a732c0b8774d76d325e0749d09ce70aad">ResourceAccess::ResourceAccess</a> access, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> mipmapLevel, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> pixelFormat)</td></tr>
<tr class="memdesc:a479de119004a6825886c4114fbe9beb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an UAV texture.  <a href="#a479de119004a6825886c4114fbe9beb1">More...</a><br /></td></tr>
<tr class="separator:a479de119004a6825886c4114fbe9beb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8791e7cc76517dc3199245dc708875b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ad8791e7cc76517dc3199245dc708875b">_updateAutoProperties</a> (void)</td></tr>
<tr class="separator:ad8791e7cc76517dc3199245dc708875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1889df9a4e3d48946dcbe9d2db4d1ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ab1889df9a4e3d48946dcbe9d2db4d1ba">clone</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;cloneName)</td></tr>
<tr class="separator:ab1889df9a4e3d48946dcbe9d2db4d1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63a38b43354ffa974bb834c3a156bc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ab63a38b43354ffa974bb834c3a156bc9">cloneTo</a> (<a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a> *dstJob)</td></tr>
<tr class="separator:ab63a38b43354ffa974bb834c3a156bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb470bf33ca307f270a4d10bc07a4f61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aeb470bf33ca307f270a4d10bc07a4f61">createShaderParams</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key)</td></tr>
<tr class="memdesc:aeb470bf33ca307f270a4d10bc07a4f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a set of shader paramters with a given key, e.g.  <a href="#aeb470bf33ca307f270a4d10bc07a4f61">More...</a><br /></td></tr>
<tr class="separator:aeb470bf33ca307f270a4d10bc07a4f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b75ae3cf37251daf5a06b1b973dae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a36b75ae3cf37251daf5a06b1b973dae1">getCreator</a> (void) const</td></tr>
<tr class="separator:a36b75ae3cf37251daf5a06b1b973dae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11591653841ac96f3c46dcfd72e2e5e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a11591653841ac96f3c46dcfd72e2e5e9">getName</a> (void) const</td></tr>
<tr class="separator:a11591653841ac96f3c46dcfd72e2e5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7777cbf1ece29f3f4ab6d67291e6fb94"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a7777cbf1ece29f3f4ab6d67291e6fb94">getNumTexUnits</a> (void) const</td></tr>
<tr class="separator:a7777cbf1ece29f3f4ab6d67291e6fb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85a5e4af87470de288837c2ae12f363"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#af85a5e4af87470de288837c2ae12f363">getNumThreadGroups</a> (void) const</td></tr>
<tr class="separator:af85a5e4af87470de288837c2ae12f363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41730ed273c03f4b565d8152f26c526b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a41730ed273c03f4b565d8152f26c526b">getNumThreadGroupsX</a> (void) const</td></tr>
<tr class="separator:a41730ed273c03f4b565d8152f26c526b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91999971c1d8cff7eb0aa58f526c06e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a91999971c1d8cff7eb0aa58f526c06e5">getNumThreadGroupsY</a> (void) const</td></tr>
<tr class="separator:a91999971c1d8cff7eb0aa58f526c06e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24e21932fd29c779fb0457d77f355e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aa24e21932fd29c779fb0457d77f355e7">getNumThreadGroupsZ</a> (void) const</td></tr>
<tr class="separator:aa24e21932fd29c779fb0457d77f355e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa511638c4bcef652bee3a7deef3b0ba"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aaa511638c4bcef652bee3a7deef3b0ba">getNumUavUnits</a> (void) const</td></tr>
<tr class="separator:aaa511638c4bcef652bee3a7deef3b0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1219ae9a7aa15a300185a83f7af13ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a1219ae9a7aa15a300185a83f7af13ab7">getProperty</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> defaultVal=0) const</td></tr>
<tr class="separator:a1219ae9a7aa15a300185a83f7af13ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa16d873ee37f1e1c5df313205665a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_shader_params.html">ShaderParams</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#afa16d873ee37f1e1c5df313205665a49">getShaderParams</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key)</td></tr>
<tr class="memdesc:afa16d873ee37f1e1c5df313205665a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a shader parameter with the given key.  <a href="#afa16d873ee37f1e1c5df313205665a49">More...</a><br /></td></tr>
<tr class="separator:afa16d873ee37f1e1c5df313205665a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5073e47eec1ede9ece046240224a22ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a5073e47eec1ede9ece046240224a22ff">getTexture</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx) const</td></tr>
<tr class="separator:a5073e47eec1ede9ece046240224a22ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d148757feaaae7c9bbb0e8b3c241b8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a11d148757feaaae7c9bbb0e8b3c241b8">getThreadsPerGroup</a> (void) const</td></tr>
<tr class="separator:a11d148757feaaae7c9bbb0e8b3c241b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c3fd19134052c19082ebdd92d34f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a10c3fd19134052c19082ebdd92d34f34">getThreadsPerGroupX</a> (void) const</td></tr>
<tr class="separator:a10c3fd19134052c19082ebdd92d34f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07afb5aedad54eecaf09ee9bf20fb537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a07afb5aedad54eecaf09ee9bf20fb537">getThreadsPerGroupY</a> (void) const</td></tr>
<tr class="separator:a07afb5aedad54eecaf09ee9bf20fb537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9270ed547eb4ce0de7f59737ea99e6f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a9270ed547eb4ce0de7f59737ea99e6f5">getThreadsPerGroupZ</a> (void) const</td></tr>
<tr class="separator:a9270ed547eb4ce0de7f59737ea99e6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef4f6e5c7a8b447efb15f18667ba473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a0ef4f6e5c7a8b447efb15f18667ba473">getUavBuffer</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx) const</td></tr>
<tr class="separator:a0ef4f6e5c7a8b447efb15f18667ba473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ff13623aca754d4a494022f436c853"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aa9ff13623aca754d4a494022f436c853">getUavTexture</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx) const</td></tr>
<tr class="separator:aa9ff13623aca754d4a494022f436c853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b197ca3a38da17e2eb1531a645fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a421b197ca3a38da17e2eb1531a645fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="#a421b197ca3a38da17e2eb1531a645fa2">More...</a><br /></td></tr>
<tr class="separator:a421b197ca3a38da17e2eb1531a645fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78a921e54419be677839cdf15d1f0b8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:ab78a921e54419be677839cdf15d1f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="#ab78a921e54419be677839cdf15d1f0b8">More...</a><br /></td></tr>
<tr class="separator:ab78a921e54419be677839cdf15d1f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be37baef81876985aa1071ad5acc6dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a4be37baef81876985aa1071ad5acc6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="#a4be37baef81876985aa1071ad5acc6dd">More...</a><br /></td></tr>
<tr class="separator:a4be37baef81876985aa1071ad5acc6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2943846ba6a2b5824a12857139cf5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:afa2943846ba6a2b5824a12857139cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb21babd61f9615f4ccd589278437e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#abb21babd61f9615f4ccd589278437e95">removePiece</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> pieceName)</td></tr>
<tr class="memdesc:abb21babd61f9615f4ccd589278437e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an existing piece.  <a href="#abb21babd61f9615f4ccd589278437e95">More...</a><br /></td></tr>
<tr class="separator:abb21babd61f9615f4ccd589278437e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8057044899733d9a73ce7ddfd24d2bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a8057044899733d9a73ce7ddfd24d2bbe">removeTexUnit</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx)</td></tr>
<tr class="memdesc:a8057044899733d9a73ce7ddfd24d2bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a given texture unit, displacing all the higher tex units.  <a href="#a8057044899733d9a73ce7ddfd24d2bbe">More...</a><br /></td></tr>
<tr class="separator:a8057044899733d9a73ce7ddfd24d2bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086ffb8324b45010f16fcc6f5314dedd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a086ffb8324b45010f16fcc6f5314dedd">removeUavUnit</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx)</td></tr>
<tr class="memdesc:a086ffb8324b45010f16fcc6f5314dedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a given texture unit, displacing all the higher tex units.  <a href="#a086ffb8324b45010f16fcc6f5314dedd">More...</a><br /></td></tr>
<tr class="separator:a086ffb8324b45010f16fcc6f5314dedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bc9875aa0f3a2f23d7a8c8e3a6e469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a27bc9875aa0f3a2f23d7a8c8e3a6e469">setConstBuffer</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, <a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a> *constBuffer)</td></tr>
<tr class="memdesc:a27bc9875aa0f3a2f23d7a8c8e3a6e469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a const/uniform bufferat the given slot ID.  <a href="#a27bc9875aa0f3a2f23d7a8c8e3a6e469">More...</a><br /></td></tr>
<tr class="separator:a27bc9875aa0f3a2f23d7a8c8e3a6e469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1aec87cba9ef66ee4b82267de4fb84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aea1aec87cba9ef66ee4b82267de4fb84">setInformHlmsOfTextureData</a> (bool bInformHlms)</td></tr>
<tr class="memdesc:aea1aec87cba9ef66ee4b82267de4fb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;. ">Hlms</a> has the ability to pass data to the shader source code via its syntax system to add hardcoded values.  <a href="#aea1aec87cba9ef66ee4b82267de4fb84">More...</a><br /></td></tr>
<tr class="separator:aea1aec87cba9ef66ee4b82267de4fb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0998857be120bb37963c7cb593f9bfdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a0998857be120bb37963c7cb593f9bfdc">setNumTexUnits</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> numSlots)</td></tr>
<tr class="memdesc:a0998857be120bb37963c7cb593f9bfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates 'numSlots' number of slots before they can be set.  <a href="#a0998857be120bb37963c7cb593f9bfdc">More...</a><br /></td></tr>
<tr class="separator:a0998857be120bb37963c7cb593f9bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c6b47d60cba7f70ba182d1fc8d9d62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a80c6b47d60cba7f70ba182d1fc8d9d62">setNumThreadGroups</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> numThreadGroupsX, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> numThreadGroupsY, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> numThreadGroupsZ)</td></tr>
<tr class="memdesc:a80c6b47d60cba7f70ba182d1fc8d9d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of groups of threads to dispatch.  <a href="#a80c6b47d60cba7f70ba182d1fc8d9d62">More...</a><br /></td></tr>
<tr class="separator:a80c6b47d60cba7f70ba182d1fc8d9d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad8078ce6528c5604e2a61bb516c000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a7ad8078ce6528c5604e2a61bb516c000">setNumThreadGroupsBasedOn</a> (<a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">ThreadGroupsBasedOn</a> source, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> texSlot, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> divisorX, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> divisorY, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> divisorZ)</td></tr>
<tr class="memdesc:a7ad8078ce6528c5604e2a61bb516c000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instead of calling setNumThreadGroups, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can automatically deduce them based on the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> resolution and the threads per group.  <a href="#a7ad8078ce6528c5604e2a61bb516c000">More...</a><br /></td></tr>
<tr class="separator:a7ad8078ce6528c5604e2a61bb516c000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8697f4897980adba72a42619fe6a463b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a8697f4897980adba72a42619fe6a463b">setNumUavUnits</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> numSlots)</td></tr>
<tr class="memdesc:a8697f4897980adba72a42619fe6a463b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates 'numSlots' number of slots before they can be set.  <a href="#a8697f4897980adba72a42619fe6a463b">More...</a><br /></td></tr>
<tr class="separator:a8697f4897980adba72a42619fe6a463b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbb0de211ce8fd2ff8e0d9c869ecf90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#adcbb0de211ce8fd2ff8e0d9c869ecf90">setPiece</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> pieceName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;pieceContent)</td></tr>
<tr class="memdesc:adcbb0de211ce8fd2ff8e0d9c869ecf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a piece, i.e.  <a href="#adcbb0de211ce8fd2ff8e0d9c869ecf90">More...</a><br /></td></tr>
<tr class="separator:adcbb0de211ce8fd2ff8e0d9c869ecf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b558bb23efecb99c9976312caff06c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a7b558bb23efecb99c9976312caff06c2">setProperty</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> value)</td></tr>
<tr class="memdesc:a7b558bb23efecb99c9976312caff06c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an arbitrary property to pass to the shader.  <a href="#a7b558bb23efecb99c9976312caff06c2">More...</a><br /></td></tr>
<tr class="separator:a7b558bb23efecb99c9976312caff06c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708b1694992ac7ea73e3310fbb9b478b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a708b1694992ac7ea73e3310fbb9b478b">setSamplerblock</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> &amp;refParams)</td></tr>
<tr class="memdesc:a708b1694992ac7ea73e3310fbb9b478b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a samplerblock based on reference parameters.  <a href="#a708b1694992ac7ea73e3310fbb9b478b">More...</a><br /></td></tr>
<tr class="separator:a708b1694992ac7ea73e3310fbb9b478b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86096d96501a364e040064a70143d763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a86096d96501a364e040064a70143d763">setTexBuffer</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, <a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a> *texBuffer, size_t offset=0, size_t sizeBytes=0)</td></tr>
<tr class="memdesc:a86096d96501a364e040064a70143d763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture buffer at the given slot ID.  <a href="#a86096d96501a364e040064a70143d763">More...</a><br /></td></tr>
<tr class="separator:a86096d96501a364e040064a70143d763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03270d403b5f24b482c46184a4d7c89a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a03270d403b5f24b482c46184a4d7c89a">setTexture</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, <a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> &amp;texture, const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *refParams=0)</td></tr>
<tr class="memdesc:a03270d403b5f24b482c46184a4d7c89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture buffer at the given slot ID.  <a href="#a03270d403b5f24b482c46184a4d7c89a">More...</a><br /></td></tr>
<tr class="separator:a03270d403b5f24b482c46184a4d7c89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6c36a6b27927381afeea6965b148b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a1b6c36a6b27927381afeea6965b148b4">setThreadsPerGroup</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> threadsPerGroupX, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> threadsPerGroupY, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> threadsPerGroupZ)</td></tr>
<tr class="memdesc:a1b6c36a6b27927381afeea6965b148b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of threads per group.  <a href="#a1b6c36a6b27927381afeea6965b148b4">More...</a><br /></td></tr>
<tr class="separator:a1b6c36a6b27927381afeea6965b148b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae0a13b48d89c085d90419e793aa9c8b9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ae0a13b48d89c085d90419e793aa9c8b9">HlmsCompute</a></td></tr>
<tr class="separator:ae0a13b48d89c085d90419e793aa9c8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a297b925576b81843bd963d67ec561fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297b925576b81843bd963d67ec561fbd">&#9670;&nbsp;</a></span>ThreadGroupsBasedOn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">Ogre::HlmsComputeJob::ThreadGroupsBasedOn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a297b925576b81843bd963d67ec561fbda697e40abfad5bdecd362193e78cdbdaf"></a>ThreadGroupsBasedOnNothing&#160;</td><td class="fielddoc"><p>Disabled. (obey setNumThreadGroups) </p>
</td></tr>
<tr><td class="fieldname"><a id="a297b925576b81843bd963d67ec561fbdac33b17a1bd51fc701513327b1dd34aee"></a>ThreadGroupsBasedOnTexture&#160;</td><td class="fielddoc"><p>Based the number of thread groups on a texture. See setNumThreadGroupsBasedOn. </p>
</td></tr>
<tr><td class="fieldname"><a id="a297b925576b81843bd963d67ec561fbda5a8e8159a04475a17cdff51380da79ee"></a>ThreadGroupsBasedOnUav&#160;</td><td class="fielddoc"><p>Based the number of thread groups on a UAV. See setNumThreadGroupsBasedOn. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa2f584f8a3a801d850b6e16533bb14c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f584f8a3a801d850b6e16533bb14c5">&#9670;&nbsp;</a></span>HlmsComputeJob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::HlmsComputeJob::HlmsComputeJob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>includedPieceFiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a824bf5717b6d72f11ad9772873044bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824bf5717b6d72f11ad9772873044bcc">&#9670;&nbsp;</a></span>~HlmsComputeJob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::HlmsComputeJob::~HlmsComputeJob </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae1f01509a37d8699f43f520833053a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f01509a37d8699f43f520833053a3a">&#9670;&nbsp;</a></span>_calculateNumThreadGroupsBasedOnSetting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_calculateNumThreadGroupsBasedOnSetting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>INTERNAL USE. </p>
<p>Calculates the number of thread groups as specified in setNumThreadGroupsBasedOn, overriding setNumThreadGroups. </p>

</div>
</div>
<a id="a94ea49e86dfbc11d0e64f803823bb10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ea49e86dfbc11d0e64f803823bb10b">&#9670;&nbsp;</a></span>_getShaderParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_shader_params.html">ShaderParams</a>* Ogre::HlmsComputeJob::_getShaderParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a shader parameter with the given key. </p>
<p>e.g. "default" "glsl" "hlsl". Returns null if doesn't exist. See createShaderParams </p>

</div>
</div>
<a id="a43e207a03438ec6db03d518cf32a3f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e207a03438ec6db03d518cf32a3f73">&#9670;&nbsp;</a></span>_setSamplerblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_setSamplerblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *&#160;</td>
          <td class="paramname"><em>refParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a samplerblock directly. </p>
<p>For internal use / advanced users. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>See setNumTexUnits. </td></tr>
    <tr><td class="paramname">refParams</td><td>Direct samplerblock. Reference count is assumed to already have been increased. We won't increase it ourselves. </td></tr>
    <tr><td class="paramname">params</td><td>The sampler block to use as reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a523ca862e2ccf507953fa18ce79879d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523ca862e2ccf507953fa18ce79879d8">&#9670;&nbsp;</a></span>_setUavBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_setUavBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>uavBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_resource_access.html#a732c0b8774d76d325e0749d09ce70aad">ResourceAccess::ResourceAccess</a>&#160;</td>
          <td class="paramname"><em>access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an UAV buffer at the given slot ID. </p>
<dl class="section remark"><dt>Remarks</dt><dd>UAV slots are shared with setUavTexture. Calling this function will remove the settings from previous setUavTexture calls to the same slot index. </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if setInformHlmsOfTextureData is enabled. </dd></dl>
<dl class="section user"><dt></dt><dd>Be very careful when calling this directly. The Compositor needs to evaluate memory barriers and resource transitions. Leaving inconsistent memory barriers can result in hazards/race conditions in some APIs. If in doubt, change the <a class="el" href="class_ogre_1_1_compositor_pass_compute_def.html">CompositorPassComputeDef</a> instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>See setNumUavUnits. The slot index to bind this UAV buffer. </td></tr>
    <tr><td class="paramname">access</td><td>Access. Should match what the shader expects. Needed by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to resolve memory barrier dependencies. </td></tr>
    <tr><td class="paramname">uavBuffer</td><td>UAV buffer to bind. </td></tr>
    <tr><td class="paramname">offset</td><td>0-based offset. It is possible to bind a region of the buffer. Offset needs to be aligned. You can query the RS capabilities for the alignment, however 256 bytes is the maximum allowed alignment per the OpenGL specification, making it a safe bet to hardcode. </td></tr>
    <tr><td class="paramname">sizeBytes</td><td>Size in bytes to bind the tex buffer. When zero, binds from offset until the end of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a479de119004a6825886c4114fbe9beb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479de119004a6825886c4114fbe9beb1">&#9670;&nbsp;</a></span>_setUavTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_setUavTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>textureArrayIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_resource_access.html#a732c0b8774d76d325e0749d09ce70aad">ResourceAccess::ResourceAccess</a>&#160;</td>
          <td class="paramname"><em>access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>mipmapLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an UAV texture. </p>
<dl class="section remark"><dt>Remarks</dt><dd>UAV buffer slots are shared with setUavTexture's. Calling this function will remove the settings from previous setUavBuffer calls to the same slot index. </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if setInformHlmsOfTextureData is enabled. </dd></dl>
<dl class="section user"><dt></dt><dd>Be very careful when calling this directly. The Compositor needs to evaluate memory barriers and resource transitions. Leaving inconsistent memory barriers can result in hazards/race conditions in some APIs. If in doubt, change the <a class="el" href="class_ogre_1_1_compositor_pass_compute_def.html">CompositorPassComputeDef</a> instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>See setNumUavUnits. </td></tr>
    <tr><td class="paramname">texture</td><td></td></tr>
    <tr><td class="paramname">textureArrayIndex</td><td></td></tr>
    <tr><td class="paramname">access</td><td></td></tr>
    <tr><td class="paramname">mipmapLevel</td><td></td></tr>
    <tr><td class="paramname">pixelFormat</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8791e7cc76517dc3199245dc708875b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8791e7cc76517dc3199245dc708875b">&#9670;&nbsp;</a></span>_updateAutoProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_updateAutoProperties </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1889df9a4e3d48946dcbe9d2db4d1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1889df9a4e3d48946dcbe9d2db4d1ba">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a>* Ogre::HlmsComputeJob::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab63a38b43354ffa974bb834c3a156bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63a38b43354ffa974bb834c3a156bc9">&#9670;&nbsp;</a></span>cloneTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::cloneTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a> *&#160;</td>
          <td class="paramname"><em>dstJob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb470bf33ca307f270a4d10bc07a4f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb470bf33ca307f270a4d10bc07a4f61">&#9670;&nbsp;</a></span>createShaderParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::createShaderParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a set of shader paramters with a given key, e.g. </p>
<p>"default" "glsl" "hlsl". Does nothing if parameters already exist. </p>

</div>
</div>
<a id="a36b75ae3cf37251daf5a06b1b973dae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b75ae3cf37251daf5a06b1b973dae1">&#9670;&nbsp;</a></span>getCreator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms.html">Hlms</a>* Ogre::HlmsComputeJob::getCreator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11591653841ac96f3c46dcfd72e2e5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11591653841ac96f3c46dcfd72e2e5e9">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::HlmsComputeJob::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7777cbf1ece29f3f4ab6d67291e6fb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7777cbf1ece29f3f4ab6d67291e6fb94">&#9670;&nbsp;</a></span>getNumTexUnits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::HlmsComputeJob::getNumTexUnits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af85a5e4af87470de288837c2ae12f363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85a5e4af87470de288837c2ae12f363">&#9670;&nbsp;</a></span>getNumThreadGroups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>* Ogre::HlmsComputeJob::getNumThreadGroups </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41730ed273c03f4b565d8152f26c526b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41730ed273c03f4b565d8152f26c526b">&#9670;&nbsp;</a></span>getNumThreadGroupsX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsComputeJob::getNumThreadGroupsX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91999971c1d8cff7eb0aa58f526c06e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91999971c1d8cff7eb0aa58f526c06e5">&#9670;&nbsp;</a></span>getNumThreadGroupsY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsComputeJob::getNumThreadGroupsY </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa24e21932fd29c779fb0457d77f355e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24e21932fd29c779fb0457d77f355e7">&#9670;&nbsp;</a></span>getNumThreadGroupsZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsComputeJob::getNumThreadGroupsZ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa511638c4bcef652bee3a7deef3b0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa511638c4bcef652bee3a7deef3b0ba">&#9670;&nbsp;</a></span>getNumUavUnits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::HlmsComputeJob::getNumUavUnits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1219ae9a7aa15a300185a83f7af13ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1219ae9a7aa15a300185a83f7af13ab7">&#9670;&nbsp;</a></span>getProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> Ogre::HlmsComputeJob::getProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>defaultVal</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa16d873ee37f1e1c5df313205665a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa16d873ee37f1e1c5df313205665a49">&#9670;&nbsp;</a></span>getShaderParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_shader_params.html">ShaderParams</a>&amp; Ogre::HlmsComputeJob::getShaderParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a shader parameter with the given key. </p>
<p>e.g. "default" "glsl" "hlsl". Creates if does not exist. </p>

</div>
</div>
<a id="a5073e47eec1ede9ece046240224a22ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5073e47eec1ede9ece046240224a22ff">&#9670;&nbsp;</a></span>getTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a>&amp; Ogre::HlmsComputeJob::getTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11d148757feaaae7c9bbb0e8b3c241b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d148757feaaae7c9bbb0e8b3c241b8">&#9670;&nbsp;</a></span>getThreadsPerGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>* Ogre::HlmsComputeJob::getThreadsPerGroup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10c3fd19134052c19082ebdd92d34f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c3fd19134052c19082ebdd92d34f34">&#9670;&nbsp;</a></span>getThreadsPerGroupX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsComputeJob::getThreadsPerGroupX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07afb5aedad54eecaf09ee9bf20fb537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07afb5aedad54eecaf09ee9bf20fb537">&#9670;&nbsp;</a></span>getThreadsPerGroupY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsComputeJob::getThreadsPerGroupY </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9270ed547eb4ce0de7f59737ea99e6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9270ed547eb4ce0de7f59737ea99e6f5">&#9670;&nbsp;</a></span>getThreadsPerGroupZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsComputeJob::getThreadsPerGroupZ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ef4f6e5c7a8b447efb15f18667ba473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef4f6e5c7a8b447efb15f18667ba473">&#9670;&nbsp;</a></span>getUavBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a>* Ogre::HlmsComputeJob::getUavBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9ff13623aca754d4a494022f436c853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ff13623aca754d4a494022f436c853">&#9670;&nbsp;</a></span>getUavTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a>&amp; Ogre::HlmsComputeJob::getUavTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357fe4fb4849772b94baa4bf47c7ded">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c727e879a260c37b00ce5505fe8e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c727e879a260c37b00ce5505fe8e144">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46d4b0a597156d9ba5abc39d127792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46d4b0a597156d9ba5abc39d127792">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a86dde5483c053ca0f2a85bbfd6c">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595ea4c05da8aa987d3800e65d23355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595ea4c05da8aa987d3800e65d23355d">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a421b197ca3a38da17e2eb1531a645fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421b197ca3a38da17e2eb1531a645fa2">&#9670;&nbsp;</a></span>operator new() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a id="ac4bdf968b7b9af8a5239a27da73d5711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bdf968b7b9af8a5239a27da73d5711">&#9670;&nbsp;</a></span>operator new() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab78a921e54419be677839cdf15d1f0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78a921e54419be677839cdf15d1f0b8">&#9670;&nbsp;</a></span>operator new() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a id="a4be37baef81876985aa1071ad5acc6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be37baef81876985aa1071ad5acc6dd">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a id="afa2943846ba6a2b5824a12857139cf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2943846ba6a2b5824a12857139cf5e">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb21babd61f9615f4ccd589278437e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb21babd61f9615f4ccd589278437e95">&#9670;&nbsp;</a></span>removePiece()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::removePiece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>pieceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an existing piece. </p>
<p>See setPiece. Does nothing if the piece didn't exist. </p>

</div>
</div>
<a id="a8057044899733d9a73ce7ddfd24d2bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8057044899733d9a73ce7ddfd24d2bbe">&#9670;&nbsp;</a></span>removeTexUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::removeTexUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a given texture unit, displacing all the higher tex units. </p>

</div>
</div>
<a id="a086ffb8324b45010f16fcc6f5314dedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086ffb8324b45010f16fcc6f5314dedd">&#9670;&nbsp;</a></span>removeUavUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::removeUavUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a given texture unit, displacing all the higher tex units. </p>

</div>
</div>
<a id="a27bc9875aa0f3a2f23d7a8c8e3a6e469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bc9875aa0f3a2f23d7a8c8e3a6e469">&#9670;&nbsp;</a></span>setConstBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setConstBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>constBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a const/uniform bufferat the given slot ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>Slot to bind to. It's independent from the texture &amp; UAV ones. </td></tr>
    <tr><td class="paramname">constBuffer</td><td>Const buffer to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea1aec87cba9ef66ee4b82267de4fb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1aec87cba9ef66ee4b82267de4fb84">&#9670;&nbsp;</a></span>setInformHlmsOfTextureData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setInformHlmsOfTextureData </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInformHlms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;. ">Hlms</a> has the ability to pass data to the shader source code via its syntax system to add hardcoded values. </p>
<p>For example, you may want to unroll a loop based on the width of a texture for maximum performance. </p><dl class="section user"><dt></dt><dd>Enabling this feature informs the <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;. ">Hlms</a> to reparse the shader on any change to bound textures that could trigger a recompilation. If you don't need it, keep this feature disabled to prevent unnecessary recompilations. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bInformHlms</td><td>True to enable this feature, false to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0998857be120bb37963c7cb593f9bfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0998857be120bb37963c7cb593f9bfdc">&#9670;&nbsp;</a></span>setNumTexUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumTexUnits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>numSlots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates 'numSlots' number of slots before they can be set. </p>

</div>
</div>
<a id="a80c6b47d60cba7f70ba182d1fc8d9d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c6b47d60cba7f70ba182d1fc8d9d62">&#9670;&nbsp;</a></span>setNumThreadGroups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumThreadGroups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>numThreadGroupsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>numThreadGroupsY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>numThreadGroupsZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of groups of threads to dispatch. </p>
<p>Note the actual value may be changed by the shader template using the () function. These values are passed to the template as: num_thread_groups_x num_thread_groups_y num_thread_groups_z </p><dl class="section remark"><dt>Remarks</dt><dd>As an example, it's typical to do: numThreadGroupsX = ceil( threadsPerGroupX / image.width ); numThreadGroupsY = ceil( threadsPerGroupY / image.height ); </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if the value changes, regardless of what setInformHlmsOfTextureData says. There may be API / HW limitations on the max values for each dimension. </dd></dl>

</div>
</div>
<a id="a7ad8078ce6528c5604e2a61bb516c000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad8078ce6528c5604e2a61bb516c000">&#9670;&nbsp;</a></span>setNumThreadGroupsBasedOn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumThreadGroupsBasedOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">ThreadGroupsBasedOn</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>texSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>divisorX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>divisorY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>divisorZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instead of calling setNumThreadGroups, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can automatically deduce them based on the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> resolution and the threads per group. </p>
<p>It is calculated as follows: scaledWidth = (textureWidth + divisorX - 1u) / divisorX; numThreadGroupsX = (scaledWidth + threadsPerGroupX - 1u) / threadsPerGroupX; </p><dl class="section remark"><dt>Remarks</dt><dd>Unless disabled, this will overwrite your setNumThreadGroups based on the texture bound at the time the job is dispatched. </dd></dl>
<dl class="section user"><dt></dt><dd>If no texture/uav is bound at the given slot (or no such slot exists), we will log a warning. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>What to use as source for the calculations. See ThreadGroupsBasedOn </td></tr>
    <tr><td class="paramname">texSlot</td><td>Index of the texture/uav unit. </td></tr>
    <tr><td class="paramname">divisorX</td><td>divisorY divisorZ Often compute shaders operate on multiple pixels, thus you need less thread groups. For example if you operate on blocks of 2x2, then you want divisorX = 2 and divisorY = 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8697f4897980adba72a42619fe6a463b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8697f4897980adba72a42619fe6a463b">&#9670;&nbsp;</a></span>setNumUavUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumUavUnits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>numSlots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates 'numSlots' number of slots before they can be set. </p>

</div>
</div>
<a id="adcbb0de211ce8fd2ff8e0d9c869ecf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbb0de211ce8fd2ff8e0d9c869ecf90">&#9670;&nbsp;</a></span>setPiece()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setPiece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>pieceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>pieceContent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a piece, i.e. </p>
<p>the same as doing ( pieceName )pieceContent If the piece doesn't exist, it gets created. If the piece already exists, it gets overwritten. </p><dl class="section remark"><dt>Remarks</dt><dd>Because we need to efficiently track changes (to know when to recompile, when we can reuse a cached shader, etc), we store a property of the same name as pieceName with the hash of the piece's content as value. e.g. doing setPiece( pieceName, pieceContent ) implies calling setProperty( pieceName, hash( pieceContent ). Hence you should NOT manipulate mPieces directly, otherwise we won't see changes performed to it, or use shaders from a cache we shouldn't use. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pieceName</td><td>Name of the piece. </td></tr>
    <tr><td class="paramname">pieceContent</td><td>The contents of the piece. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b558bb23efecb99c9976312caff06c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b558bb23efecb99c9976312caff06c2">&#9670;&nbsp;</a></span>setProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an arbitrary property to pass to the shader. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Will trigger a recompilation if the value changes, regardless of what setInformHlmsOfTextureData says. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Name of the property </td></tr>
    <tr><td class="paramname">value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a708b1694992ac7ea73e3310fbb9b478b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708b1694992ac7ea73e3310fbb9b478b">&#9670;&nbsp;</a></span>setSamplerblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setSamplerblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> &amp;&#160;</td>
          <td class="paramname"><em>refParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a samplerblock based on reference parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>See setNumTexUnits. </td></tr>
    <tr><td class="paramname">refParams</td><td>We'll create (or retrieve an existing) samplerblock based on the input parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86096d96501a364e040064a70143d763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86096d96501a364e040064a70143d763">&#9670;&nbsp;</a></span>setTexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setTexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>texBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a texture buffer at the given slot ID. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> buffer slots are shared with setTexture's. Calling this function will remove the settings from previous setTexture calls to the same slot index. </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if setInformHlmsOfTextureData is enabled. </dd></dl>
<dl class="section user"><dt></dt><dd>Setting a <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation. ">RenderTarget</a> that could be used for writing is dangerous in explicit APIs (DX12, Vulkan). Use the <a class="el" href="class_ogre_1_1_compositor_pass_compute_def.html">CompositorPassComputeDef</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>See setNumTexUnits. The slot index to bind this texture buffer In OpenGL, a few cards support between to 16-18 texture units, while most cards support up to 32 </td></tr>
    <tr><td class="paramname">texBuffer</td><td><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> buffer to bind. </td></tr>
    <tr><td class="paramname">offset</td><td>0-based offset. It is possible to bind a region of the buffer. Offset needs to be aligned. You can query the RS capabilities for the alignment, however 256 bytes is the maximum allowed alignment per the OpenGL specification, making it a safe bet to hardcode. </td></tr>
    <tr><td class="paramname">sizeBytes</td><td>Size in bytes to bind the tex buffer. When zero, binds from offset until the end of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03270d403b5f24b482c46184a4d7c89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03270d403b5f24b482c46184a4d7c89a">&#9670;&nbsp;</a></span>setTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *&#160;</td>
          <td class="paramname"><em>refParams</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a texture buffer at the given slot ID. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> slots are shared with setTexBuffer's. Calling this function will remove the settings from previous setTexBuffer calls to the same slot index. </dd></dl>
<dl class="section user"><dt></dt><dd>UAVs and Textures share the same slots in OpenGL, but don't in D3D11. For best compatibility, assume they're shared and put the UAVs in the first slots. </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if setInformHlmsOfTextureData is enabled. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>See setNumTexUnits. The slot index to bind this texture In OpenGL, some cards support up to 16-18 texture units, while most cards support up to 32 </td></tr>
    <tr><td class="paramname">texBuffer</td><td><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> buffer to bind. </td></tr>
    <tr><td class="paramname">texture</td><td><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> to bind. </td></tr>
    <tr><td class="paramname">samplerblock</td><td>Optional. We'll create (or retrieve an existing) samplerblock based on the input parameters. When null, we leave the previously set samplerblock (if a texture is being set, and if no samplerblock was set, we'll create a default one) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b6c36a6b27927381afeea6965b148b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6c36a6b27927381afeea6965b148b4">&#9670;&nbsp;</a></span>setThreadsPerGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setThreadsPerGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>threadsPerGroupX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>threadsPerGroupY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>threadsPerGroupZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of threads per group. </p>
<p>Note the actual value may be changed by the shader template using the () function. These values are passed to the template as: threads_per_group_x threads_per_group_y threads_per_group_z </p><dl class="section remark"><dt>Remarks</dt><dd>May trigger a recompilation if the value changes, regardless of what setInformHlmsOfTextureData says. There may be API / HW limitations on the max values for each dimension. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae0a13b48d89c085d90419e793aa9c8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a13b48d89c085d90419e793aa9c8b9">&#9670;&nbsp;</a></span>HlmsCompute</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_ogre_1_1_hlms_compute.html">HlmsCompute</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_hlms_compute_job_8h.html">OgreHlmsComputeJob.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
