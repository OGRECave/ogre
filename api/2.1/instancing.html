<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Instancing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">2.1.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('instancing.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Instancing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#WhatIsInstancing">What is instancing?</a></li>
<li class="level1"><a href="#Instancing101">Instancing 101</a><ul><li class="level2"><a href="#InstancesPerBatch">Instances per batch</a></li>
</ul>
</li>
<li class="level1"><a href="#InstancingTechniques">Techniques</a><ul><li class="level2"><a href="#InstancingTechniquesShaderBased">ShaderBased</a></li>
<li class="level2"><a href="#InstancingTechniquesVTFSoftware">VTF (Software)</a></li>
<li class="level2"><a href="#InstancingTechniquesHWVTF">HW VTF</a><ul><li class="level3"><a href="#InstancingTechniquesHW">HW VTF LUT</a></li>
</ul>
</li>
<li class="level2"><a href="#InstancingTechniquesHWBasic">HW Basic</a></li>
</ul>
</li>
<li class="level1"><a href="#InstancingCustomParameters">Custom parameters</a></li>
<li class="level1"><a href="#InstancingMultipleSubmeshes">Supporting multiple submeshes</a></li>
<li class="level1"><a href="#InstancingDefragmentingBatches">Defragmenting batches</a><ul><li class="level2"><a href="#InstancingDefragmentingBatchesIntro">What is batch fragmentation?</a></li>
<li class="level2"><a href="#InstancingDefragmentingBatchesPrevention">Prevention: Avoiding fragmentation</a></li>
<li class="level2"><a href="#InstancingDefragmentingBatchesOnTheFly">Cure: Defragmenting on the fly</a></li>
</ul>
</li>
<li class="level1"><a href="#InstancingTroubleshooting">Troubleshooting</a></li>
</ul>
</div>
<div class="textblock"><blockquote class="doxtable">
<p>Attention!</p>
<p>This section was writen for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 rather 2.1; it relies on legacy code. On <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.1; this section has become almost irrelevant as 2.1 can auto instance meshes automatically; and apply instancing even if the meshes are using different materials. The InstanceManager can only beat the Hlms if you have a very, very large number of instances (&gt;50k objects) with the same mesh and same material, which isn't very common. If you're working on <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.1; you can skip this section. </p>
</blockquote>
<h1><a class="anchor" id="WhatIsInstancing"></a>
What is instancing?</h1>
<p>Instancing is a rendering technique to draw multiple instances of the same mesh using just one render call. There are two kinds of instancing:</p>
<ul>
<li><b>Software:</b> Two larges vertex &amp; index buffers are created and the mesh vertices/indices are duplicated N number of times. When rendering, invisible instances receive a transform matrix filled with 0s. This technique can take a lot of VRAM and has limited culling capabilities.</li>
<li><b>Hardware:</b> The hardware supports an extra param which allows <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to tell the GPU to repeat the drawing of vertices N number of times; thus taking considerably less VRAM. Because N can be controlled at runtime, individual instances can be culled before sending the data to the GPU.</li>
</ul>
<p>Hardware techniques are almost always superior to Software techniques, but Software are more compatible, where as Hardware techniques require D3D9 or GL3, and is not supported in GLES2</p>
<p>All instancing techniques require shaders. It is not possible to use instancing with FFP (Fixed Function Pipeline)</p>
<h1><a class="anchor" id="Instancing101"></a>
Instancing 101</h1>
<p>A common question is why should I use instancing. The big reason is performance. There can be 10x improvements or more when used correctly. Here's a guide on when you should use instancing:</p>
<ol type="1">
<li>You have <em>a lot</em> of Entities that are repeated and based on the same Mesh (i.e. a rock, a building, a tree, loose leaves, enemies, irrelevant crowds or NPCs)</li>
<li>These Entities that repeat a lot also share the same material (or just a few materials, i.e. 3 or 4)</li>
<li>Your game is CPU bottleneck.</li>
</ol>
<p>If these three requirements are all met in your game, chances are instancing is for you. There will be minimal gains when using instancing on an Entity that repeats very little, or if each instance actually has a different material, or it could run even slower if the Entity never repeats.</p>
<p>If your game is not CPU bottleneck'ed (i.e. it's GPU bottleneck'ed) then instancing won't make a noticeable difference.</p>
<h2><a class="anchor" id="InstancesPerBatch"></a>
Instances per batch</h2>
<p>As explained in the previous section, instancing groups all instances into one draw call. However this is half the truth. Instancing actually groups a certain number of instances into a batch. One batch = One draw call.</p>
<p>If the technique is using 80 instances per batch; then rendering 160 instances is going to need 2 draw calls (two batches); if there are 180 instances, 3 draw calls will be needed (3 batches).</p>
<p>What is a good value for instances-per-batch setting? That depends on a lot of factors, which you will have to profile. Normally, increasing the number should improve performance because the system is most likely CPU bottleneck. However, past certain number, certain trade offs begin to show up:</p>
<ul>
<li>Culling is first performed at batch level, then for HW techniques culling is also done at per instance level. If the batch contains too many instances, its Aabb will grow too large; thus the hierarchy culling will always pass and <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> won't be able skip entire batches.</li>
<li>If the instance per batch is at 10.000 and the application created 10.001 instances; a lot of RAM &amp; VRAM will be wasted because it's set for 20.000 instances; HW techniques will spent an excessive amount of CPU time parsing the 9.999 inactive instances; and SW techniques will saturate the Bus bandwidth sending null matrices for the inactive instances to the GPU.</li>
</ul>
<p>The actual value will depend a lot on the application and whether all instances are often on screen or frustum culled and whether the total number of instances can be known at production time (i.e. environment props). Normally numbers between 80 and 500 work best, but there have been cases where big values like 5.000 actually improved performance.</p>
<h1><a class="anchor" id="InstancingTechniques"></a>
Techniques</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports 4 different instancing techniques. Unfortunately, each of them requires a different vertex shader, since their approaches are different. Also their compatibility and performance varies.</p>
<h2><a class="anchor" id="InstancingTechniquesShaderBased"></a>
ShaderBased</h2>
<p>This is the most compatible technique. It is a Software Instancing technique. World matrices are passed through constant registers, and thus the maximum number of instances per batch is 80; which quickly goes down if the object is skeletally animated. This technique does not play very well with skeletal animation because of that, unless the number of bones is very low (3 or less).</p>
<p>See <code>material Examples/Instancing/ShaderBased</code> for an example on how to write the vertex shader. Files:</p>
<ul>
<li>ShaderInstancing.material</li>
<li>ShaderInstancing.vert (GLSL)</li>
<li>ShaderInstancing.cg (Cg, works with HLSL)</li>
</ul>
<h2><a class="anchor" id="InstancingTechniquesVTFSoftware"></a>
VTF (Software)</h2>
<p>VTF stands for "Vertex Texture Fetch". It is a Software Instancing technique. Unlike ShaderBased, world matrices are passed to the vertex shader through a texture. Such feature has only been supported since Vertex Shader 3.0 and is not supported on Radeon X1xxx cards and is quite slow on GeForce 6 &amp; 7. However it's very fast on any modern GPU (GeForce 8, 9, 200, 300, 400, 500, 600, 700; all Radeon HD series, Intel HD 3000 and above)</p>
<p>The advantage of VTF over ShaderBased is that it supports a very high max number of instances per batch; even if it's skeletally animated.</p>
<p>Take note that you will need to set a <code>texture_unit</code> (preferrably the first one, for compatibility) including the shadow caster besides the texture (eg. diffuse, specular, normal maps) so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> gets where to put the vertex texture.</p>
<p>See <code>material Examples/Instancing/VTF</code> for an example on how to write the vertex shader and setup the material. Files:</p>
<ul>
<li>VTFInstancing.material</li>
<li>VTFInstancing.vert (GLSL)</li>
<li>VTFInstancing.cg (Cg, also works with HLSL)</li>
</ul>
<h2><a class="anchor" id="InstancingTechniquesHWVTF"></a>
HW VTF</h2>
<p>This is the same technique as VTF; but implemented through hardware instancing. It is probably one of the best and most flexible techniques.</p>
<p>The vertex shader has to be slightly different from SW VTF version. See <code>material Examples/Instancing/HW_VTF</code> for an example on how to write the vertex shader and setup the material. Files:</p>
<ul>
<li>HW_VTFInstancing.material</li>
<li>HW_VTFInstancing.vert (GLSL)</li>
<li>HW_VTFInstancing.cg (Cg, works with HLSL)</li>
</ul>
<h3><a class="anchor" id="InstancingTechniquesHW"></a>
HW VTF LUT</h3>
<p>LUT is a special feature of HW VTF; which stands for <b>L</b>ook <b>U</b>p <b>T</b>able. It has been particularly designed for drawing large animated crowds.</p>
<p>The technique is a trick that works by animating a limited number of instances (i.e. 16 animations) storing them in a look up table in the VTF, and then repeating these animations to all instances uniformly, giving the appearance that all instances are independently animated when seen in large crowds.</p>
<p>See <code>material Examples/Instancing/HW_VTF_LUT</code>. Files:</p>
<ul>
<li>Same as HW VTF (different macros defined)</li>
</ul>
<p>To enable the use of LUT, <code>SceneManager::createInstanceManager</code>'s flags must include the flag <code>IM_VTFBONEMATRIXLOOKUP</code> and specify HW VTF as technique.</p>
<div class="fragment"><div class="line">mSceneMgr-&gt;createInstanceManager(<span class="stringliteral">&quot;InstanceMgr&quot;</span>,<span class="stringliteral">&quot;MyMesh.mesh&quot;</span>,</div><div class="line">            ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME,</div><div class="line">            InstanceManager::HWInstancingVTF,</div><div class="line">            numInstancesPerBatch,<a class="code" href="group___general.html#gga4921efc65b347efe08a6d4992af069e2a0ef5ea7756d41449148c181eef505d92">IM_USEALL</a>|<a class="code" href="group___general.html#gga4921efc65b347efe08a6d4992af069e2a2e31b097f5510963d742dce628d868ef">IM_VTFBONEMATRIXLOOKUP</a> );</div></div><!-- fragment --><h2><a class="anchor" id="InstancingTechniquesHWBasic"></a>
HW Basic</h2>
<p>HW Basic is probably the fastest instancing technique[^7], but is surely more compatible than HW VTF.</p>
<p>The world matrix data is passed to the vertex shader using three <code>TEXCOORD</code>s (<em>attribute</em> in GLSL jargon) instead of a vertex texture. The other big difference with HW VTF, besides how data is being passed, is that HW Basic doesn't support skeletal animations at all, making it the preferred choice for rendering inanimate objects like trees, falling leaves, buildings, etc.</p>
<p>See <code>material Examples/Instancing/HWBasic</code> for an example. Files:</p>
<ul>
<li>HWInstancing.material</li>
<li>HWBasicInstancing.vert (GLSL)</li>
<li>HWBasicInstancing.cg (Cg, works with HLSL)</li>
</ul>
<h1><a class="anchor" id="InstancingCustomParameters"></a>
Custom parameters</h1>
<p>Some instancing techniques allow passing custom parameters to vertex shaders. For example a custom colour in an RTS game to identify player units; a single value for randomly colourizing vegetation, light parameters for rendering deferred shading's light volumes (diffuse colour, specular colour, etc)</p>
<p>At the time of writing only HW Basic supports passing the custom parameters. All other techniques will ignore it.[^8]</p>
<p>To use custom parameters, call <code>InstanceManager::setNumCustomParams</code> to tell the number of custom parameters the user will need. <b>This number cannot be changed after creating the first batch</b> (call createInstancedEntity)</p>
<p>Afterwards, it's just a matter of calling <code>InstancedEntity::setCustomParam</code> with the param you wish to send.</p>
<p>For HW Basic techniques, the vertex shader will receive the custom param in an extra <code>TEXCOORD.</code></p>
<div class="fragment"><div class="line"> InstanceManager *instanceMgr;<span class="comment">//Assumed to be valid ptr</span></div><div class="line">instanceMgr-&gt;setNumCustomParams(2);</div><div class="line"></div><div class="line">InstancedEntity *instancedEntity =instanceMgr-&gt;createInstancedEntity(<span class="stringliteral">&quot;myMaterial&quot;</span>);</div><div class="line">instancedEntity-&gt;setCustomParam(0,Vector4(1.0f,1.0f,1.2f,0.0f));</div><div class="line">instancedEntity-&gt;setCustomParam(1,Vector4(0.2f,0.0f,0.7f,1.0f));     </div></div><!-- fragment --><h1><a class="anchor" id="InstancingMultipleSubmeshes"></a>
Supporting multiple submeshes</h1>
<p>Multiple submeshes means different instance managers, because instancing can only be applied to the same submesh.</p>
<p>Nevertheless, it is actually quite easy to support multiple submeshes. The first step is to create the InstanceManager setting the <code>subMeshIdx</code> parameter to the number of submesh you want to use:</p>
<div class="fragment"><div class="line">std::vector&lt;InstanceManager*&gt;instanceManagers;</div><div class="line"><a class="code" href="namespace_ogre.html#a5c4c0c56ea9f824c49e331f6fad33ddb">MeshPtr</a> mesh =MeshManager::getSingleton().load(<span class="stringliteral">&quot;myMesh.mesh&quot;</span>);</div><div class="line"><span class="keywordflow">for</span>(<a class="code" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> i=0;i&lt;mesh-&gt;getNumSubMeshes();++i )</div><div class="line">{</div><div class="line">    InstanceManager *mgr =</div><div class="line">        mSceneMgr-&gt;createInstanceManager(<span class="stringliteral">&quot;MyManager&quot;</span>+<a class="code" href="namespace_ogre_1_1_resource_access.html#a1feaa6e1253297279f75eedaae089d09">StringConverter::toString</a>(i ),</div><div class="line">                    <span class="stringliteral">&quot;myMesh.mesh&quot;</span>,</div><div class="line">                ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME,</div><div class="line">                    InstanceManager::HWInstancingVTF,numInstancePerBatch,</div><div class="line">                    flags,i );</div><div class="line">    instanceManagers.push_back(mgr );</div><div class="line">}    </div></div><!-- fragment --><p>The second step lies in sharing the transform with one of the submeshes (which will be named 'master'; i.e. the first submesh) to improve performance and reduce RAM consumption when creating the Instanced Entities:</p>
<div class="fragment"><div class="line">SceneNode *sceneNode;<span class="comment">//Asumed to be valid ptr</span></div><div class="line">std::vector&lt;InstancedEntity*&gt;instancedEntities;</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;instanceManagers.size();++i )</div><div class="line">{</div><div class="line">    InstancedEntity *ent =instanceManagers[i]-&gt;createInstancedEntity(<span class="stringliteral">&quot;MyMaterial&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(i !=0)</div><div class="line">        instancedEntities[0]-&gt;shareTransformWith(ent );</div><div class="line"></div><div class="line">    sceneNode-&gt;attachObject(ent );</div><div class="line">    instancedEntities.push_back(ent );</div><div class="line">}</div></div><!-- fragment --><p>Note that it is perfectly possible that each <code>InstancedEntity</code> based on a different "submesh" uses a different material. Selecting the same material won't cause the InstanceManagers to get batched together (though the RenderQueue will try to reduce state change reduction, like with any normal Entity).</p>
<p>Because the transform is shared, animating the master InstancedEntity (in this example, <code>instancedEntity[0]</code>) will cause all other slave instances to follow the same animation.</p>
<p>To destroy the instanced entities, use the normal procedure:</p>
<div class="fragment"><div class="line">SceneNode *sceneNode;<span class="comment">//Asumed to be valid ptr</span></div><div class="line">std::vector&lt;InstancedEntity*&gt;instancedEntities;</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;instanceManagers.size();++i )</div><div class="line">{</div><div class="line">    instanceManagers[i]-&gt;destroyInstancedEntity(instancedEntities[i]);</div><div class="line">}</div><div class="line">mSceneMgr-&gt;getRootSceneNode()-&gt;removeAndDestroyChild(sceneNode );</div></div><!-- fragment --><h1><a class="anchor" id="InstancingDefragmentingBatches"></a>
Defragmenting batches</h1>
<h2><a class="anchor" id="InstancingDefragmentingBatchesIntro"></a>
What is batch fragmentation?</h2>
<p>There are two kinds of fragmentation:</p>
<ol type="1">
<li>"Deletion" Fragmentation is when many instances have been created, spanning multiple batches; <em>and many of them got later removed</em> but they were all from different batches. If there were 10 instances per batch, 100 instances created, then later 90 removed; it is possible that now there are 10 batches with one instance each (which equals 10 drawcalls); instead of being just 1 batch with 10 instances (which equals 1 drawcall).</li>
<li>"Culling" Fragmentation is also when many instances of different batches are all sparsed across the whole scene. If they were defragmented, they would've been put together in the same batch (all instances sorted by proximity to each other should be in the same batch) to take advantage of hierachy culling optimizations.</li>
</ol>
<p>Defragmented batches can dramatically improve performance:</p>
<p>Suppose there 50 instances per batch, and 100 batches total (which means 5000 instanced entities of the same mesh with same material), and they're all moving all the time.</p>
<p>Normally, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> first updates all instances' position, then their AABBs; and while at it, computes the AABB for each batch that encloses all of its instances.</p>
<p>When frustum culling, we first cull the batches, then we cull their instances[^9] (that are inside those culled batches). <b>This is the typical hierachial culling optimization</b>. We then upload the instances transforms to the GPU.</p>
<p>After moving many instances around the whole world, they will make the batch' enclosing aabb bigger and bigger. Eventually, every batch' aabb will be so large, that wherever the camera looks, all 100 batches will end up passing the frustum culling test; thus having to resort to cull all 5000 instances individually.</p>
<h2><a class="anchor" id="InstancingDefragmentingBatchesPrevention"></a>
Prevention: Avoiding fragmentation</h2>
<p>If you're creating static objects that won't move (i.e. trees), create them sorted by proximity. This helps both types of fragmentation:</p>
<ol type="1">
<li>When unloading areas (i.e. open world games), these objects will be removed all together, thus whole batches will no longer have active instances.</li>
<li>Batches and instances are often assigned by order of creation. Those instances will belong to the same batch and thus maximizing culling efficiency.</li>
</ol>
<h2><a class="anchor" id="InstancingDefragmentingBatchesOnTheFly"></a>
Cure: Defragmenting on the fly</h2>
<p>There are cases where preventing fragmentation, for example units in an RTS game. By design, all units may end up scattering and moving from one extreme of the scene to the other after hours of gameplay; additionally, lots of units may be in an endless loop of creation and destroying, but if the loop for a certain type of unit is broken; it is possible to end up with the kind of "Deletion" Fragmentation too.</p>
<p>For this reason, the function <code>InstanceManager::defragmentBatches( bool optimizeCulling )</code> exists.</p>
<p>Using it as simple as calling the function. <b>The sample NewInstancing shows how to do this interactively</b>. When <code>optimizeCulling</code> is true, both types of fragmentation will be attempted to be fixed. When false, only the "deletion" kind of fragmentation will be fixed.</p>
<p>Take in mind that when <code>optimizeCulling = true</code> it takes significantly more time depending on the level of fragmentation and could cause framerate spikes, even stalls. Do it sparingly and profile the optimal frequency of calling.</p>
<h1><a class="anchor" id="InstancingTroubleshooting"></a>
Troubleshooting</h1>
<p>Q: My mesh doesn't show up.</p>
<p>A: Verify you're using the right material, the vertex shader is set correctly, and it matches the instancing technique being used.</p>
<p>Q: My animation plays quite differently than when it is an Entity, or previewed in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Meshy</p>
<p>A: Your rig animation must be using more than one weight per bone. You need to add support for it in the vertex shader, and make sure you didn't create the instance manager with the flags <code>IM_USEONEWEIGHT</code> or <code>IM_FORCEONEWEIGHT</code>.</p>
<p>For example, to modify the HW VTF vertex shader, you need to sample the additional matrices from the VTF:</p>
<div class="fragment"><div class="line">float2uv0       :   TEXCOORD0;</div><div class="line"><span class="comment">// Up to four weights per vertex. Don&#39;t use this shader on a model with 3 weights per vertex, or 2 or 1</span></div><div class="line">float4m03_0 :   TEXCOORD1;<span class="comment">//m03.w is always 0</span></div><div class="line">float4m03_1 :   TEXCOORD2;</div><div class="line">float4m03_2 :   TEXCOORD3;</div><div class="line">float4m03_3 :   TEXCOORD4;</div><div class="line">float4mWeights  :   TEXCOORD5;</div><div class="line"></div><div class="line">float2mOffset   :   TEXCOORD6;</div><div class="line"></div><div class="line"></div><div class="line">float3x4worldMatrix[4];</div><div class="line">worldMatrix[0][0] =tex2D(matrixTexture, m03_0.xw +mOffset );</div><div class="line">worldMatrix[0][1] =tex2D(matrixTexture, m03_0.yw +mOffset );</div><div class="line">worldMatrix[0][2] =tex2D(matrixTexture, m03_0.zw +mOffset );</div><div class="line"></div><div class="line">worldMatrix[1][0] =tex2D(matrixTexture, m03_1.xw +mOffset );</div><div class="line">worldMatrix[1][1] =tex2D(matrixTexture, m03_1.yw +mOffset );</div><div class="line">worldMatrix[1][2] =tex2D(matrixTexture, m03_1.zw +mOffset );</div><div class="line"></div><div class="line">worldMatrix[2][0] =tex2D(matrixTexture, m03_2.xw +mOffset );</div><div class="line">worldMatrix[2][1] =tex2D(matrixTexture, m03_2.yw +mOffset );</div><div class="line">worldMatrix[2][2] =tex2D(matrixTexture, m03_2.zw +mOffset );</div><div class="line"></div><div class="line">worldMatrix[3][0] =tex2D(matrixTexture, m03_3.xw +mOffset );</div><div class="line">worldMatrix[3][1] =tex2D(matrixTexture, m03_3.yw +mOffset );</div><div class="line">worldMatrix[3][2] =tex2D(matrixTexture, m03_3.zw +mOffset );</div><div class="line"></div><div class="line">float4 worldPos = float4(mul(worldMatrix[0], inPos ).xyz, 1.0f )* mWeights.x;</div><div class="line">worldPos +=float4(mul(worldMatrix[1], inPos ).xyz, 1.0f )* mWeights.y;</div><div class="line">worldPos +=float4(mul(worldMatrix[2], inPos ).xyz, 1.0f )* mWeights.z;</div><div class="line">worldPos +=float4(mul(worldMatrix[3], inPos ).xyz, 1.0f )* mWeights.w;</div><div class="line"></div><div class="line">float4 worldNor = float4(mul(worldMatrix[0], inNor ).xyz, 1.0f )* mWeights.x;</div><div class="line">worldNor +=float4(mul(worldMatrix[1], inNor ).xyz, 1.0f )* mWeights.y;</div><div class="line">worldNor +=float4(mul(worldMatrix[2], inNor ).xyz, 1.0f )* mWeights.z;</div><div class="line">worldNor +=float4(mul(worldMatrix[3], inNor ).xyz, 1.0f )* mWeights.w;</div></div><!-- fragment --><p>As you can witness, a HW VTF vertex shader with 4 weights per vertex needs a lot of texture fetches. Fortunately they fit the texture cache very well; nonetheless it's something to keep watching out.</p>
<p>Instancing is meant for rendering large number of objects in a scene. If you plan on rendering thousands or tens of thousands of animated objects with 4 weights per vertex, don't expect it to be fast; no matter what technique you use to draw them.</p>
<p>Try convincing the art department to lower the animation quality or just use <code>IM_FORCEONEWEIGHT</code> for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to do the downgrade for you. There are many plugins for popular modeling packages (3DS Max, Maya, Blender) out there that help automatizing this task.</p>
<p>Q: The instance doesn't show up, or when playing animations the mesh deforms very weirdly or other very visible artifacts occur</p>
<p>A: Your rig uses more than one weight per vertex. Either create the instance manager with the flag <code>IM_FORCEONEWEIGHT</code>, or modify the vertex shader to support the <em>exact</em> amount of weights per vertex needed (see previous questions).</p>
<p>Q: How do I find how many weights per vertices is using my model?</p>
<p>A: The quickest way is by looking at the size of <code>VES_BLEND_WEIGHTS</code> and divide it by 4[^10].</p>
<div class="image">
<img src="ogre_meshy.png" alt="ogre_meshy.png"/>
</div>
<p>In the picture above, the <a href="http://yosoygames.com.ar/wp/ogre-meshy/">Ogre Meshy</a> viewer is being used to quickly display the mesh' information. It can be seen that the Hair uses 1 weight per vertex, while the Head needs 2 weights per vertex.</p>
<p>[^7]: Whether it is actually faster than HW VTF depends on the GPU architecture</p>
<p>[^8]: In theory all other techniques could implement custom parameters but for performance reasons only HW VTF is well suited to implement it. Thought yet remains to be seen whether it should be passed to the shader through the VTF, or through additional TEXCOORDs.</p>
<p>[^9]: Only HW instancing techniques cull per instance. SW instancing techniques send all of their instances, zeroing matrices of those instances that are not in the scene.</p>
<p>[^10]: One weight is one float. One float is 4 bytes; hence number of weights * 4 is the size of the vertex element. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
