<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hlms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLMS: High Level Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#components">The three components</a></li>
<li class="level1"><a href="#materials">Compared to classical materials</a></li>
<li class="level1"><a href="#data">Material parameters are stored in “Blocks”</a><ul><li class="level2"><a href="#toc52">Datablocks</a></li>
</ul>
</li>
<li class="level1"><a href="#toc69">Hlms templates</a><ul><li class="level2"><a href="#preproc">The Hlms preprocessor</a></li>
<li class="level2"><a href="#syntax">Preprocessor syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#shaders">Creation of shaders</a></li>
<li class="level1"><a href="#cpp">C++ interaction with shader templates</a></li>
<li class="level1"><a href="#customization">Customization</a></li>
</ul>
</div>
<div class="textblock"><p>This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.</p>
<p>Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.</p>
<p>Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.</p>
<p>But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.</p>
<p>Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.</p>
<h1><a class="anchor" id="components"></a>
The three components</h1>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg">hlms_components.svg</object>
</div>
<ol type="1">
<li>Scripts. To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). <b>You currently have to do this from C++.</b> Everybody will be using this part.</li>
<li>Shader template. The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn’t contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you’re not forced to use it. Here’s a simple example of the preprocessor. I won’t be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li>C++ classes implementation. The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constans data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it’s harder to use than good ol’ Materials because those used to be data-driven: there are no AutoParamsSource here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniforms buffers sorted by update frequency. Very advanced user will be using messing with this part.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Material scripts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x do not yet support the HLMS - you must use the C++ API. e.g. <a class="el" href="class_ogre_1_1_pbs_material.html">Ogre::PbsMaterial</a>.</dd></dl>
<p>Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<h1><a class="anchor" id="materials"></a>
Compared to classical materials</h1>
<p>Materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template’s syntax or a C++ module when you can just write a script and start coding?. The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it’s fast, and will check for syntax errors!), but it’s most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don’t need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they’re at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can’t optimize. But it doesn’t matter much either, because it’s not like there are 100 fullscreen passes. Usually there’s less than 10.</li>
</ul>
<h1><a class="anchor" id="data"></a>
Material parameters are stored in “Blocks”</h1>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that’s a half truth and an awesome side effect. I’ve been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and they’re right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it’s much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can’t afford. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won’t be used in practice.</li>
</ol>
<p>Of course it’s not perfect, it can’t fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you’ll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We’re aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I’m not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="toc52"></a>
Datablocks</h2>
<p>We’re introducing the concept of Datablocks. A Datablock is a “material” from the user’s perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg">hlms_blocks.svg</object>
</div>
<p>The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<dl class="section note"><dt>Note</dt><dd>Macroblocks and Blendblocks are not available in 1.x - use <a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not. ">Ogre::Pass::setDepthCheckEnabled</a> etc. as usual, to change the respective properties</dd></dl>
<h1><a class="anchor" id="toc69"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names "VertexShader_vs", "PixelShader_ps", "GeometryShader_gs", "HullShader_hs", "DomainShader_ds" will be fully parsed and compiled into the shader. If an implementation only provides "VertexShader_vs.glslt", "PixelShader_ps.glslt"; only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string "_piece_vs" in their filenames will be parsed only for collecting pieces (more on pieces later). Likewise, the words "_piece_ps", "_piece_gs", "_piece_hs", "_piece_ds” correspond to the pieces for their respective shader stages. Note that you can concatenate, thus "MyUtilities_piece_vs_piece_ps.glslt” will be collected both in the vertex and pixel shader stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h2><a class="anchor" id="preproc"></a>
The Hlms preprocessor</h2>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can't evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can't check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable “IncludeLightingEquals2” and check whether it's non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can't see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you'll depend on the driver implementation having a good macro preprocessor.</p>
<h2><a class="anchor" id="syntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<h3>@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands &amp;&amp; || ! are valid.</p>
<p>Examples: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: </p><div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div><div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div></div><!-- fragment --><h3>@foreach( scopedVar, count, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.</p>
<ul>
<li>scopedVar is a variable that can be used to print the current iteration of the loop while inside the block. i.e. “@scopedVar” will be converted into a number in the range [start; count)</li>
<li>count The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li>start Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="doxtable">
<tr>
<th>Expression </th><th>Output  </th></tr>
<tr>
<td>@foreach( 4, n ) <br />
&emsp; @n@end </td><td><br />
0<br />
1<br />
2<br />
3 </td></tr>
<tr>
<td>@foreach( 4, n ) @n@end </td><td>0 1 2 3 </td></tr>
<tr>
<td>@foreach( 4, n )<br />
&emsp;@n<br />
@end </td><td><br />
0<br />
<br />
1<br />
<br />
2<br />
<br />
3<br />
 </td></tr>
<tr>
<td>@foreach( 4, n, 2 ) @n@end </td><td>2 3 </td></tr>
<tr>
<td>@pset( myStartVar, 1 )<br />
@pset( myCountVar, 3 )<br />
@foreach( myStartVar, n, myCountVar )<br />
&emsp;@n@end </td><td>1<br />
2 </td></tr>
<tr>
<td>@foreach( 2, n )<br />
&emsp;@insertpiece( pieceName@n )@end </td><td>@insertpiece( pieceName0 )<br />
 @insertpiece( pieceName1 ) </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Attention #1!</b></p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. “@foreach( 1, i )@insertpiece( pieceName )@end” will print “0nsertpiece( pieceName )” which is probably not what you intended.</p>
<p><b>Attention #2!</b></p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div><div class="line"></div><div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div><div class="line"></div><div class="line"><span class="comment">//Code</span></div><div class="line"></div><div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( myVar )</div><div class="line"></div><div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3>@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples: </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@counter( myVar )   1</div><div class="line"></div><div class="line">@counter( myVar )   2</div></div><!-- fragment --><h3>@value( variable )</h3>
<p>Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@value( myVar )     1</div><div class="line"></div><div class="line">@value( myVar )     1</div></div><!-- fragment --><h3>@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c</p>
<p>Useful in combination with @counter and @value</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Output </th><th>Math  </th></tr>
<tr>
<td>@set( myVar, 1 ) <br />
 @value( myVar ) </td><td>1 </td><td>myVar = 1 </td></tr>
<tr>
<td>@add( myVar, 5 )<br />
 @value( myVar ) </td><td>6 </td><td>myVar = 1 + 5 </td></tr>
<tr>
<td>@div( myVar, 2 ) <br />
 @value( myVar ) </td><td>3 </td><td>myVar = 6 / 2 </td></tr>
<tr>
<td>@mul( myVar, myVar )<br />
 @value( myVar ) </td><td>9 </td><td>myVar = 3 * 3 </td></tr>
<tr>
<td>@mod( myVar, 5 ) <br />
 @value( myVar ) </td><td>4 </td><td>myVar = 9 % 5 </td></tr>
<tr>
<td>@add( myVar, 1, 1 ) <br />
 @value( myVar ) </td><td>2 </td><td>myVar = 1 + 1 </td></tr>
</table>
<h3>@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                        Output</div><div class="line"></div><div class="line">@piece( VertexTransform )         </div><div class="line"></div><div class="line">outPos = worldViewProj * inPos   </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><h3>@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                                                     Output</div><div class="line"></div><div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div><div class="line"></div><div class="line">void main()                                                    {</div><div class="line"></div><div class="line">{                                                              outPos = worldViewProj * inPos</div><div class="line"></div><div class="line">@insertpiece( VertexTransform )                                }</div><div class="line"></div><div class="line">@insertpiece( InexistentPiece )                                </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a href="#toc304"><em>the family of math functions without the 'p' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )</p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="shaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropiately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg">hlms_hash.svg</object>
</div>
<p>Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a “<a href="#toc567"><em>pass hash</em></a>” instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg">hlms_caching.svg</object>
</div>
<h1><a class="anchor" id="cpp"></a>
C++ interaction with shader templates</h1>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set “key” to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod</p>
<p>To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.</p>
<p>The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.</p>
<h2>Common conventions</h2>
<p>Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in underscore_case are set from C++; propierties in camelCase are set from the template.</p>
<p>Propierties and pieces starting with 'custom_' are for user customizations of the template</p>
<p>TBD</p>
<h2>Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.</p>
<h1><a class="anchor" id="customization"></a>
Customization</h1>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.</p>
<p>Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a href="#toc574"><em>Hlms Initialization</em></a>. pass a set of piece files in a folder by pushing the folder to ArchiveVec. The files in that folder will be parsed first, in order (archiveVec[0] then archiveVec[1], … archiveVec[N-1]); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no 'custom_' pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF: <div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div><div class="line"></div><div class="line">@pset( BRDF_CookTorrance, 0 )</div><div class="line"></div><div class="line">@pset( BRDF_Default, 0 )</div><div class="line"></div><div class="line">@piece( DeclareBRDF )</div><div class="line"></div><div class="line"><span class="comment">// Your BRDF code declaration here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --></li>
</ol>
<ol type="1">
<li>Via listener, through HlmsListener. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload HlmsPbs. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload HlmsPbs::createDatablockImpl to create these custom datablocks)</li>
<li>Directly modify HlmsPbs, HlmsPbsDatablock and the template. <table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td>custom_passBuffer </td><td>Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs. </td></tr>
<tr>
<td>custom_VStoPS </td><td>Piece where users can add more interpolants for passing data from the vertex to the pixel shader. </td></tr>
<tr>
<td>custom_vs_attributes </td><td>Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc). </td></tr>
<tr>
<td>custom_vs_uniformDeclaration </td><td>Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_posExecution </td><td>Executed after all code from the Vertex Shader has been performed. </td></tr>
<tr>
<td>custom_ps_uniformDeclaration </td><td>Same as custom_vs_uniformDeclaration, but for the Pixel Shader </td></tr>
<tr>
<td>custom_ps_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Pixel Shader. </td></tr>
<tr>
<td>custom_ps_posMaterialLoad </td><td>Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation) </td></tr>
<tr>
<td>custom_ps_preLights </td><td>Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now. </td></tr>
<tr>
<td>custom_ps_posExecution </td><td>Executed after all code from the Pixel Shader has been performed. </td></tr>
</table>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
