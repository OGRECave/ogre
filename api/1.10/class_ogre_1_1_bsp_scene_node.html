<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::BspSceneNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_ogre_1_1_bsp_scene_node.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_bsp_scene_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::BspSceneNode Class Reference<div class="ingroups"><a class="el" href="group___plugins.html">Plugins</a> &raquo; <a class="el" href="group___b_s_p_scene_manager.html">BSPSceneManager</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Specialisation of <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> for the <a class="el" href="class_ogre_1_1_bsp_scene_manager.html" title="Specialisation of the SceneManager class to deal with indoor scenes based on a BSP tree...">BspSceneManager</a>.  
 <a href="class_ogre_1_1_bsp_scene_node.html#details">More...</a></p>

<p><code>#include &lt;OgreBspSceneNode.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::BspSceneNode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_bsp_scene_node__inherit__graph.svg" width="160" height="262"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0b69022b50c829ec21e9589bbc591597"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_node.html#a8f5f85d7e0f2685a057c66d51398ae5b">ChildNodeMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a0b69022b50c829ec21e9589bbc591597">ChildNodeIterator</a></td></tr>
<tr class="separator:a0b69022b50c829ec21e9589bbc591597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5f85d7e0f2685a057c66d51398ae5b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="class_ogre_1_1_node.html">Node</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a8f5f85d7e0f2685a057c66d51398ae5b">ChildNodeMap</a></td></tr>
<tr class="separator:a8f5f85d7e0f2685a057c66d51398ae5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984f44c9104d5c195f67a2b9d88ebae1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_node.html#a8f5f85d7e0f2685a057c66d51398ae5b">ChildNodeMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a984f44c9104d5c195f67a2b9d88ebae1">ConstChildNodeIterator</a></td></tr>
<tr class="separator:a984f44c9104d5c195f67a2b9d88ebae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57219459f45733699562ae3fd2abda24"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_scene_node.html#a9155734bb4e41cbf734504b85daa02b7">ObjectMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a57219459f45733699562ae3fd2abda24">ConstObjectIterator</a></td></tr>
<tr class="separator:a57219459f45733699562ae3fd2abda24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1279b4ce58509856588b0c57641d0a64"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_scene_node.html#a9155734bb4e41cbf734504b85daa02b7">ObjectMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a1279b4ce58509856588b0c57641d0a64">ObjectIterator</a></td></tr>
<tr class="separator:a1279b4ce58509856588b0c57641d0a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9155734bb4e41cbf734504b85daa02b7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a9155734bb4e41cbf734504b85daa02b7">ObjectMap</a></td></tr>
<tr class="separator:a9155734bb4e41cbf734504b85daa02b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42e2063379286eb673eaffff6ca5e99"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> { <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>, 
<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>, 
<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99ae28ff4f09161c3f5d19c08c5ef210e04">TS_WORLD</a>
 }<tr class="memdesc:ac42e2063379286eb673eaffff6ca5e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration denoting the spaces which a transform can be relative to.  <a href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac42e2063379286eb673eaffff6ca5e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3c9fc7c13d2a9a92130e1b595f74fe8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_scene_node.html#a3c9fc7c13d2a9a92130e1b595f74fe8d">BspSceneNode</a> (<a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *creator)</td></tr>
<tr class="separator:a3c9fc7c13d2a9a92130e1b595f74fe8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387df029179fce1955902d2b6cd3ae8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_scene_node.html#a387df029179fce1955902d2b6cd3ae8b">BspSceneNode</a> (<a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *creator, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="separator:a387df029179fce1955902d2b6cd3ae8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093e08130e57e03496b8009c7033d21b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a093e08130e57e03496b8009c7033d21b">_addBoundingBoxToQueue</a> (<a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *queue)</td></tr>
<tr class="memdesc:a093e08130e57e03496b8009c7033d21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the bounding box to the rendering queue.  <a href="#a093e08130e57e03496b8009c7033d21b">More...</a><br /></td></tr>
<tr class="separator:a093e08130e57e03496b8009c7033d21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12f7409930e2c7ae1fb33c39f71d0ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#ae12f7409930e2c7ae1fb33c39f71d0ea">_autoTrack</a> (void)</td></tr>
<tr class="memdesc:ae12f7409930e2c7ae1fb33c39f71d0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method used by OGRE to update auto-tracking cameras.  <a href="#ae12f7409930e2c7ae1fb33c39f71d0ea">More...</a><br /></td></tr>
<tr class="separator:ae12f7409930e2c7ae1fb33c39f71d0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e11a4a0a39106a02c45bd5521c5996c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a6e11a4a0a39106a02c45bd5521c5996c">_findVisibleObjects</a> (<a class="el" href="class_ogre_1_1_camera.html">Camera</a> *cam, <a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *queue, <a class="el" href="struct_ogre_1_1_visible_objects_bounds_info.html">VisibleObjectsBoundsInfo</a> *visibleBounds, bool includeChildren=true, bool displayNodes=false, bool onlyShadowCasters=false)</td></tr>
<tr class="memdesc:a6e11a4a0a39106a02c45bd5521c5996c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method which locates any visible objects attached to this node and adds them to the passed in queue.  <a href="#a6e11a4a0a39106a02c45bd5521c5996c">More...</a><br /></td></tr>
<tr class="separator:a6e11a4a0a39106a02c45bd5521c5996c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6afb3ab2d6bece0391c6592b946c11"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aae6afb3ab2d6bece0391c6592b946c11">_getDerivedOrientation</a> (void) const</td></tr>
<tr class="memdesc:aae6afb3ab2d6bece0391c6592b946c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the orientation of the node as derived from all parents.  <a href="#aae6afb3ab2d6bece0391c6592b946c11">More...</a><br /></td></tr>
<tr class="separator:aae6afb3ab2d6bece0391c6592b946c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d8ef3c62635ce44260efd749a4bbfc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa6d8ef3c62635ce44260efd749a4bbfc">_getDerivedPosition</a> (void) const</td></tr>
<tr class="memdesc:aa6d8ef3c62635ce44260efd749a4bbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of the node as derived from all parents.  <a href="#aa6d8ef3c62635ce44260efd749a4bbfc">More...</a><br /></td></tr>
<tr class="separator:aa6d8ef3c62635ce44260efd749a4bbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac948570c146461805c4ff0d79a7de2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aac948570c146461805c4ff0d79a7de2f">_getDerivedScale</a> (void) const</td></tr>
<tr class="memdesc:aac948570c146461805c4ff0d79a7de2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scaling factor of the node as derived from all parents.  <a href="#aac948570c146461805c4ff0d79a7de2f">More...</a><br /></td></tr>
<tr class="separator:aac948570c146461805c4ff0d79a7de2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50b010530f4ed9f7aa4c590cf2cb5d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac50b010530f4ed9f7aa4c590cf2cb5d1">_getFullTransform</a> (void) const</td></tr>
<tr class="memdesc:ac50b010530f4ed9f7aa4c590cf2cb5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the full transformation matrix for this node.  <a href="#ac50b010530f4ed9f7aa4c590cf2cb5d1">More...</a><br /></td></tr>
<tr class="separator:ac50b010530f4ed9f7aa4c590cf2cb5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5541f6607ef566e07991a0642b0f70f9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a5541f6607ef566e07991a0642b0f70f9">_getWorldAABB</a> (void) const</td></tr>
<tr class="memdesc:a5541f6607ef566e07991a0642b0f70f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the axis-aligned bounding box of this node (and hence all subnodes).  <a href="#a5541f6607ef566e07991a0642b0f70f9">More...</a><br /></td></tr>
<tr class="separator:a5541f6607ef566e07991a0642b0f70f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256519b10007f0cf64c3f23cd0642581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a256519b10007f0cf64c3f23cd0642581">_notifyRootNode</a> (void)</td></tr>
<tr class="memdesc:a256519b10007f0cf64c3f23cd0642581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies this <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> that it is the root scene node.  <a href="#a256519b10007f0cf64c3f23cd0642581">More...</a><br /></td></tr>
<tr class="separator:a256519b10007f0cf64c3f23cd0642581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd410326335dd2b974e832ad102458b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#acfd410326335dd2b974e832ad102458b">_setDerivedOrientation</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr class="memdesc:acfd410326335dd2b974e832ad102458b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the final world orientation of the node directly.  <a href="#acfd410326335dd2b974e832ad102458b">More...</a><br /></td></tr>
<tr class="separator:acfd410326335dd2b974e832ad102458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31de962a55b0455d7bb3851706073e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a31de962a55b0455d7bb3851706073e95">_setDerivedPosition</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;pos)</td></tr>
<tr class="memdesc:a31de962a55b0455d7bb3851706073e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the final world position of the node directly.  <a href="#a31de962a55b0455d7bb3851706073e95">More...</a><br /></td></tr>
<tr class="separator:a31de962a55b0455d7bb3851706073e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee88a2f5a1f7fe70c4ea39a245aa6a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_scene_node.html#a1ee88a2f5a1f7fe70c4ea39a245aa6a1">_update</a> (bool updateChildren, bool parentHasChanged)</td></tr>
<tr class="memdesc:a1ee88a2f5a1f7fe70c4ea39a245aa6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overridden from <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a>.  <a href="#a1ee88a2f5a1f7fe70c4ea39a245aa6a1">More...</a><br /></td></tr>
<tr class="separator:a1ee88a2f5a1f7fe70c4ea39a245aa6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a14f326bf38f516d8db82a687c987c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a82a14f326bf38f516d8db82a687c987c">_updateBounds</a> (void)</td></tr>
<tr class="memdesc:a82a14f326bf38f516d8db82a687c987c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> to update the world bound info it stores.  <a href="#a82a14f326bf38f516d8db82a687c987c">More...</a><br /></td></tr>
<tr class="separator:a82a14f326bf38f516d8db82a687c987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01698919040092766a3a4bfab8e7ceb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af01698919040092766a3a4bfab8e7ceb">addChild</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *child)</td></tr>
<tr class="memdesc:af01698919040092766a3a4bfab8e7ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a (precreated) child scene node to this node.  <a href="#af01698919040092766a3a4bfab8e7ceb">More...</a><br /></td></tr>
<tr class="separator:af01698919040092766a3a4bfab8e7ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51052c58747a77a6cf7451b700e7eb87"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a> (<a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *obj)</td></tr>
<tr class="memdesc:a51052c58747a77a6cf7451b700e7eb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an instance of a scene object to this node.  <a href="#a51052c58747a77a6cf7451b700e7eb87">More...</a><br /></td></tr>
<tr class="separator:a51052c58747a77a6cf7451b700e7eb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bca65a1d911499aba99843fa41b3e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad4bca65a1d911499aba99843fa41b3e9">cancelUpdate</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *child)</td></tr>
<tr class="memdesc:ad4bca65a1d911499aba99843fa41b3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by children to notify their parent that they no longer need an update.  <a href="#ad4bca65a1d911499aba99843fa41b3e9">More...</a><br /></td></tr>
<tr class="separator:ad4bca65a1d911499aba99843fa41b3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3969475af6a52109883d7c7d44f35fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a3969475af6a52109883d7c7d44f35fec">convertLocalToWorldDirection</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;localDir, bool useScale)</td></tr>
<tr class="memdesc:a3969475af6a52109883d7c7d44f35fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the world direction of a point in the node local space useful for simple transforms that don't require a child node.  <a href="#a3969475af6a52109883d7c7d44f35fec">More...</a><br /></td></tr>
<tr class="separator:a3969475af6a52109883d7c7d44f35fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87d582898b40ea668fe67ab428cfdcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa87d582898b40ea668fe67ab428cfdcf">convertLocalToWorldOrientation</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;localOrientation)</td></tr>
<tr class="memdesc:aa87d582898b40ea668fe67ab428cfdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the world orientation of an orientation in the node local space useful for simple transforms that don't require a child node.  <a href="#aa87d582898b40ea668fe67ab428cfdcf">More...</a><br /></td></tr>
<tr class="separator:aa87d582898b40ea668fe67ab428cfdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bba0ab306650f26ab9f59df8666f3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad0bba0ab306650f26ab9f59df8666f3c">convertLocalToWorldPosition</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;localPos)</td></tr>
<tr class="memdesc:ad0bba0ab306650f26ab9f59df8666f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the world position of a point in the node local space useful for simple transforms that don't require a child node.  <a href="#ad0bba0ab306650f26ab9f59df8666f3c">More...</a><br /></td></tr>
<tr class="separator:ad0bba0ab306650f26ab9f59df8666f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e1a5a9da67b7bc7292b74ee2cfaba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a25e1a5a9da67b7bc7292b74ee2cfaba6">convertWorldToLocalDirection</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;worldDir, bool useScale)</td></tr>
<tr class="memdesc:a25e1a5a9da67b7bc7292b74ee2cfaba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local direction, relative to this node, of the given world-space direction.  <a href="#a25e1a5a9da67b7bc7292b74ee2cfaba6">More...</a><br /></td></tr>
<tr class="separator:a25e1a5a9da67b7bc7292b74ee2cfaba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553f4e76d2416bd2c514f82c2f6117b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a553f4e76d2416bd2c514f82c2f6117b7">convertWorldToLocalOrientation</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;worldOrientation)</td></tr>
<tr class="memdesc:a553f4e76d2416bd2c514f82c2f6117b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local orientation, relative to this node, of the given world-space orientation.  <a href="#a553f4e76d2416bd2c514f82c2f6117b7">More...</a><br /></td></tr>
<tr class="separator:a553f4e76d2416bd2c514f82c2f6117b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8302c220e1e1f9ae9d83142bcb2e30ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a8302c220e1e1f9ae9d83142bcb2e30ca">convertWorldToLocalPosition</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;worldPos)</td></tr>
<tr class="memdesc:a8302c220e1e1f9ae9d83142bcb2e30ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local position, relative to this node, of the given world-space position.  <a href="#a8302c220e1e1f9ae9d83142bcb2e30ca">More...</a><br /></td></tr>
<tr class="separator:a8302c220e1e1f9ae9d83142bcb2e30ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baeb7e192fc802f6bf846d3a69dfc19"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a8baeb7e192fc802f6bf846d3a69dfc19">createChild</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;<a class="el" href="class_ogre_1_1_node.html#a45bb282556bc68d072b62097f3006221">translate</a>=<a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a>, const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;<a class="el" href="class_ogre_1_1_node.html#ae1991a38daed956ca9edc635e418d6d8">rotate</a>=<a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>)</td></tr>
<tr class="memdesc:a8baeb7e192fc802f6bf846d3a69dfc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an unnamed new <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> as a child of this node.  <a href="#a8baeb7e192fc802f6bf846d3a69dfc19">More...</a><br /></td></tr>
<tr class="separator:a8baeb7e192fc802f6bf846d3a69dfc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5595d0f506945c66795322b1878e16aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a5595d0f506945c66795322b1878e16aa">createChild</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;<a class="el" href="class_ogre_1_1_node.html#a45bb282556bc68d072b62097f3006221">translate</a>=<a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a>, const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;<a class="el" href="class_ogre_1_1_node.html#ae1991a38daed956ca9edc635e418d6d8">rotate</a>=<a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>)</td></tr>
<tr class="memdesc:a5595d0f506945c66795322b1878e16aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new named <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> as a child of this node.  <a href="#a5595d0f506945c66795322b1878e16aa">More...</a><br /></td></tr>
<tr class="separator:a5595d0f506945c66795322b1878e16aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaee9cb1cb0c23fab2cc9bab08f51181"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;<a class="el" href="class_ogre_1_1_node.html#a45bb282556bc68d072b62097f3006221">translate</a>=<a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a>, const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;<a class="el" href="class_ogre_1_1_node.html#ae1991a38daed956ca9edc635e418d6d8">rotate</a>=<a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>)</td></tr>
<tr class="memdesc:aeaee9cb1cb0c23fab2cc9bab08f51181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an unnamed new <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> as a child of this node.  <a href="#aeaee9cb1cb0c23fab2cc9bab08f51181">More...</a><br /></td></tr>
<tr class="separator:aeaee9cb1cb0c23fab2cc9bab08f51181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559442664e8b83cb40ca1d2c68c5d01c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a559442664e8b83cb40ca1d2c68c5d01c">createChildSceneNode</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;<a class="el" href="class_ogre_1_1_node.html#a45bb282556bc68d072b62097f3006221">translate</a>=<a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a>, const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;<a class="el" href="class_ogre_1_1_node.html#ae1991a38daed956ca9edc635e418d6d8">rotate</a>=<a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>)</td></tr>
<tr class="memdesc:a559442664e8b83cb40ca1d2c68c5d01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new named <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> as a child of this node.  <a href="#a559442664e8b83cb40ca1d2c68c5d01c">More...</a><br /></td></tr>
<tr class="separator:a559442664e8b83cb40ca1d2c68c5d01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb8690d7cd00a804a659eac1ee45060"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_scene_node.html#aedb8690d7cd00a804a659eac1ee45060">detachAllObjects</a> (void)</td></tr>
<tr class="memdesc:aedb8690d7cd00a804a659eac1ee45060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches all objects attached to this node.  <a href="#aedb8690d7cd00a804a659eac1ee45060">More...</a><br /></td></tr>
<tr class="separator:aedb8690d7cd00a804a659eac1ee45060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932a5feecc7144344cbb3bda8534cb5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_scene_node.html#a932a5feecc7144344cbb3bda8534cb5a">detachObject</a> (unsigned short index)</td></tr>
<tr class="memdesc:a932a5feecc7144344cbb3bda8534cb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the indexed object from this scene node.  <a href="#a932a5feecc7144344cbb3bda8534cb5a">More...</a><br /></td></tr>
<tr class="separator:a932a5feecc7144344cbb3bda8534cb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320bc152963657c2ff26fc0e5caf29f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_scene_node.html#a320bc152963657c2ff26fc0e5caf29f4">detachObject</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:a320bc152963657c2ff26fc0e5caf29f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the named object from this node and returns a pointer to it.  <a href="#a320bc152963657c2ff26fc0e5caf29f4">More...</a><br /></td></tr>
<tr class="separator:a320bc152963657c2ff26fc0e5caf29f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4846642c14ab6e3ca1a4f6296b859a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#abc4846642c14ab6e3ca1a4f6296b859a">detachObject</a> (<a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *obj)</td></tr>
<tr class="memdesc:abc4846642c14ab6e3ca1a4f6296b859a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches an object by pointer.  <a href="#abc4846642c14ab6e3ca1a4f6296b859a">More...</a><br /></td></tr>
<tr class="separator:abc4846642c14ab6e3ca1a4f6296b859a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d97c1153036cdc6db138c6b03c9828"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a63d97c1153036cdc6db138c6b03c9828">findLights</a> (<a class="el" href="group___general.html#gaab30ef14aae93306a6044cb38d835f0c">LightList</a> &amp;destList, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> radius, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> lightMask=0xFFFFFFFF) const</td></tr>
<tr class="memdesc:a63d97c1153036cdc6db138c6b03c9828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows retrieval of the nearest lights to the centre of this <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>.  <a href="#a63d97c1153036cdc6db138c6b03c9828">More...</a><br /></td></tr>
<tr class="separator:a63d97c1153036cdc6db138c6b03c9828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0600f3479f44ec86d29e049dad48e9dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a0600f3479f44ec86d29e049dad48e9dc">flipVisibility</a> (bool cascade=true)</td></tr>
<tr class="memdesc:a0600f3479f44ec86d29e049dad48e9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the visibility of all objects attached to this node.  <a href="#a0600f3479f44ec86d29e049dad48e9dc">More...</a><br /></td></tr>
<tr class="separator:a0600f3479f44ec86d29e049dad48e9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff8d20961b48225690e1561bc39f993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993">getAttachedObject</a> (unsigned short index)</td></tr>
<tr class="memdesc:a2ff8d20961b48225690e1561bc39f993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to an attached object.  <a href="#a2ff8d20961b48225690e1561bc39f993">More...</a><br /></td></tr>
<tr class="separator:a2ff8d20961b48225690e1561bc39f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f64cc674aed856340df7a0507b90423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a3f64cc674aed856340df7a0507b90423">getAttachedObject</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:a3f64cc674aed856340df7a0507b90423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to an attached object.  <a href="#a3f64cc674aed856340df7a0507b90423">More...</a><br /></td></tr>
<tr class="separator:a3f64cc674aed856340df7a0507b90423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e3b93b490eb75ed1bf1db5d6035ff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_node.html#a1279b4ce58509856588b0c57641d0a64">ObjectIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a14e3b93b490eb75ed1bf1db5d6035ff1">getAttachedObjectIterator</a> (void)</td></tr>
<tr class="memdesc:a14e3b93b490eb75ed1bf1db5d6035ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator which can be used to efficiently step through the objects attached to this node.  <a href="#a14e3b93b490eb75ed1bf1db5d6035ff1">More...</a><br /></td></tr>
<tr class="separator:a14e3b93b490eb75ed1bf1db5d6035ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176f01ff035f682fa00a1500c8d795a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_node.html#a57219459f45733699562ae3fd2abda24">ConstObjectIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a176f01ff035f682fa00a1500c8d795a9">getAttachedObjectIterator</a> (void) const</td></tr>
<tr class="memdesc:a176f01ff035f682fa00a1500c8d795a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator which can be used to efficiently step through the objects attached to this node.  <a href="#a176f01ff035f682fa00a1500c8d795a9">More...</a><br /></td></tr>
<tr class="separator:a176f01ff035f682fa00a1500c8d795a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76fe7cdecec48166697bb06174f1333"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_scene_node.html#a9155734bb4e41cbf734504b85daa02b7">ObjectMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#ad76fe7cdecec48166697bb06174f1333">getAttachedObjects</a> () const</td></tr>
<tr class="memdesc:ad76fe7cdecec48166697bb06174f1333"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MovableObjects associated with this node.  <a href="#ad76fe7cdecec48166697bb06174f1333">More...</a><br /></td></tr>
<tr class="separator:ad76fe7cdecec48166697bb06174f1333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98e1967863c0dd15aeb3aa55134e0bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#ac98e1967863c0dd15aeb3aa55134e0bd">getAutoTrackLocalDirection</a> (void)</td></tr>
<tr class="memdesc:ac98e1967863c0dd15aeb3aa55134e0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the auto tracking local direction for this node, if it is auto tracking.  <a href="#ac98e1967863c0dd15aeb3aa55134e0bd">More...</a><br /></td></tr>
<tr class="separator:ac98e1967863c0dd15aeb3aa55134e0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693d0aef8a49e063d4591e62ec44d3db"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a693d0aef8a49e063d4591e62ec44d3db">getAutoTrackOffset</a> (void)</td></tr>
<tr class="memdesc:a693d0aef8a49e063d4591e62ec44d3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the auto tracking offset for this node, if the node is auto tracking.  <a href="#a693d0aef8a49e063d4591e62ec44d3db">More...</a><br /></td></tr>
<tr class="separator:a693d0aef8a49e063d4591e62ec44d3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4cc71121595aadbbfbc8916ad19809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#aee4cc71121595aadbbfbc8916ad19809">getAutoTrackTarget</a> (void)</td></tr>
<tr class="memdesc:aee4cc71121595aadbbfbc8916ad19809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the auto tracking target for this node, if any.  <a href="#aee4cc71121595aadbbfbc8916ad19809">More...</a><br /></td></tr>
<tr class="separator:aee4cc71121595aadbbfbc8916ad19809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c9109a64d2f1b3f5bbec7ca324aa6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ae6c9109a64d2f1b3f5bbec7ca324aa6c">getChild</a> (unsigned short index) const</td></tr>
<tr class="memdesc:ae6c9109a64d2f1b3f5bbec7ca324aa6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to a child node.  <a href="#ae6c9109a64d2f1b3f5bbec7ca324aa6c">More...</a><br /></td></tr>
<tr class="separator:ae6c9109a64d2f1b3f5bbec7ca324aa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23885bdc27be588857d6d67b2dedf3f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a23885bdc27be588857d6d67b2dedf3f5">getChild</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const</td></tr>
<tr class="memdesc:a23885bdc27be588857d6d67b2dedf3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to a named child node.  <a href="#a23885bdc27be588857d6d67b2dedf3f5">More...</a><br /></td></tr>
<tr class="separator:a23885bdc27be588857d6d67b2dedf3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac345064ed97045297dd394c0ac38686e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html#a0b69022b50c829ec21e9589bbc591597">ChildNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac345064ed97045297dd394c0ac38686e">getChildIterator</a> (void)</td></tr>
<tr class="memdesc:ac345064ed97045297dd394c0ac38686e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator for efficiently looping through all children of this node.  <a href="#ac345064ed97045297dd394c0ac38686e">More...</a><br /></td></tr>
<tr class="separator:ac345064ed97045297dd394c0ac38686e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e673500fba746b62c188771a78ff8d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html#a984f44c9104d5c195f67a2b9d88ebae1">ConstChildNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a2e673500fba746b62c188771a78ff8d6">getChildIterator</a> (void) const</td></tr>
<tr class="separator:a2e673500fba746b62c188771a78ff8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eed1961961324d7eaaa6af5cc88dbc5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_node.html#a8f5f85d7e0f2685a057c66d51398ae5b">ChildNodeMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a7eed1961961324d7eaaa6af5cc88dbc5">getChildren</a> () const</td></tr>
<tr class="memdesc:a7eed1961961324d7eaaa6af5cc88dbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of sub-nodes of this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a>.  <a href="#a7eed1961961324d7eaaa6af5cc88dbc5">More...</a><br /></td></tr>
<tr class="separator:a7eed1961961324d7eaaa6af5cc88dbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d203d81bd4ec6c8c626d7c1bf96a80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#aa8d203d81bd4ec6c8c626d7c1bf96a80">getCreator</a> (void) const</td></tr>
<tr class="memdesc:aa8d203d81bd4ec6c8c626d7c1bf96a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the creator of this scene node.  <a href="#aa8d203d81bd4ec6c8c626d7c1bf96a80">More...</a><br /></td></tr>
<tr class="separator:aa8d203d81bd4ec6c8c626d7c1bf96a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7491e67f16b068edad24c7458ded3105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node_1_1_debug_renderable.html">DebugRenderable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a7491e67f16b068edad24c7458ded3105">getDebugRenderable</a> ()</td></tr>
<tr class="memdesc:a7491e67f16b068edad24c7458ded3105"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <a class="el" href="class_ogre_1_1_node.html#ae4f67c715bdbf4d0d543939939f110df" title="Get a debug renderable for rendering the Node. ">Node::getDebugRenderable</a>, except scaling is automatically determined.  <a href="#a7491e67f16b068edad24c7458ded3105">More...</a><br /></td></tr>
<tr class="separator:a7491e67f16b068edad24c7458ded3105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f67c715bdbf4d0d543939939f110df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node_1_1_debug_renderable.html">DebugRenderable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ae4f67c715bdbf4d0d543939939f110df">getDebugRenderable</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> scaling)</td></tr>
<tr class="memdesc:ae4f67c715bdbf4d0d543939939f110df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a debug renderable for rendering the <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a>.  <a href="#ae4f67c715bdbf4d0d543939939f110df">More...</a><br /></td></tr>
<tr class="separator:ae4f67c715bdbf4d0d543939939f110df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9319dda7b15d46d2e1cb64fd22894811"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a9319dda7b15d46d2e1cb64fd22894811">getInheritOrientation</a> (void) const</td></tr>
<tr class="memdesc:a9319dda7b15d46d2e1cb64fd22894811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is affected by orientation applied to the parent node.  <a href="#a9319dda7b15d46d2e1cb64fd22894811">More...</a><br /></td></tr>
<tr class="separator:a9319dda7b15d46d2e1cb64fd22894811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cdc6392ec73953b327323cac09307b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad4cdc6392ec73953b327323cac09307b">getInheritScale</a> (void) const</td></tr>
<tr class="memdesc:ad4cdc6392ec73953b327323cac09307b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is affected by scaling factors applied to the parent node.  <a href="#ad4cdc6392ec73953b327323cac09307b">More...</a><br /></td></tr>
<tr class="separator:ad4cdc6392ec73953b327323cac09307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10da4e58434d3e61c6d76f97a0fd1a80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a10da4e58434d3e61c6d76f97a0fd1a80">getInitialOrientation</a> (void) const</td></tr>
<tr class="memdesc:a10da4e58434d3e61c6d76f97a0fd1a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initial orientation of this node, see setInitialState for more info.  <a href="#a10da4e58434d3e61c6d76f97a0fd1a80">More...</a><br /></td></tr>
<tr class="separator:a10da4e58434d3e61c6d76f97a0fd1a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515361d8231fc86d9b602ba55f714fa9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a515361d8231fc86d9b602ba55f714fa9">getInitialPosition</a> (void) const</td></tr>
<tr class="memdesc:a515361d8231fc86d9b602ba55f714fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initial position of this node, see setInitialState for more info.  <a href="#a515361d8231fc86d9b602ba55f714fa9">More...</a><br /></td></tr>
<tr class="separator:a515361d8231fc86d9b602ba55f714fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9b0b08edc2984d41ad38520354a407"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a5b9b0b08edc2984d41ad38520354a407">getInitialScale</a> (void) const</td></tr>
<tr class="memdesc:a5b9b0b08edc2984d41ad38520354a407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initial position of this node, see setInitialState for more info.  <a href="#a5b9b0b08edc2984d41ad38520354a407">More...</a><br /></td></tr>
<tr class="separator:a5b9b0b08edc2984d41ad38520354a407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad75165137ce70fd865b3c5aa302a3bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aad75165137ce70fd865b3c5aa302a3bc">getListener</a> (void) const</td></tr>
<tr class="memdesc:aad75165137ce70fd865b3c5aa302a3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current listener for this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a>.  <a href="#aad75165137ce70fd865b3c5aa302a3bc">More...</a><br /></td></tr>
<tr class="separator:aad75165137ce70fd865b3c5aa302a3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89628765eff6cbe3ed708337764edf7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a89628765eff6cbe3ed708337764edf7f">getLocalAxes</a> (void) const</td></tr>
<tr class="memdesc:a89628765eff6cbe3ed708337764edf7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a matrix whose columns are the local axes based on the nodes orientation relative to it's parent.  <a href="#a89628765eff6cbe3ed708337764edf7f">More...</a><br /></td></tr>
<tr class="separator:a89628765eff6cbe3ed708337764edf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264df23a0763ef9f8879c97bcbba0f47"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a264df23a0763ef9f8879c97bcbba0f47">getName</a> (void) const</td></tr>
<tr class="memdesc:a264df23a0763ef9f8879c97bcbba0f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the node.  <a href="#a264df23a0763ef9f8879c97bcbba0f47">More...</a><br /></td></tr>
<tr class="separator:a264df23a0763ef9f8879c97bcbba0f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf89f99cfb8241341c931c887d6bc40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a5cf89f99cfb8241341c931c887d6bc40">getOrientation</a> () const</td></tr>
<tr class="memdesc:a5cf89f99cfb8241341c931c887d6bc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a quaternion representing the nodes orientation.  <a href="#a5cf89f99cfb8241341c931c887d6bc40">More...</a><br /></td></tr>
<tr class="separator:a5cf89f99cfb8241341c931c887d6bc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aae34f3fa479e9c532360f93518160a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a8aae34f3fa479e9c532360f93518160a">getParent</a> (void) const</td></tr>
<tr class="memdesc:a8aae34f3fa479e9c532360f93518160a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets this node's parent (NULL if this is the root).  <a href="#a8aae34f3fa479e9c532360f93518160a">More...</a><br /></td></tr>
<tr class="separator:a8aae34f3fa479e9c532360f93518160a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807c8125f277a83154d677ce88c97fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a807c8125f277a83154d677ce88c97fa7">getParentSceneNode</a> (void) const</td></tr>
<tr class="memdesc:a807c8125f277a83154d677ce88c97fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent of this <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>.  <a href="#a807c8125f277a83154d677ce88c97fa7">More...</a><br /></td></tr>
<tr class="separator:a807c8125f277a83154d677ce88c97fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220642657bd0e307c4ecccb46991267e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a220642657bd0e307c4ecccb46991267e">getPosition</a> (void) const</td></tr>
<tr class="memdesc:a220642657bd0e307c4ecccb46991267e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of the node relative to it's parent.  <a href="#a220642657bd0e307c4ecccb46991267e">More...</a><br /></td></tr>
<tr class="separator:a220642657bd0e307c4ecccb46991267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1133d2ef5623b7ede0fa15aacbe47311"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a1133d2ef5623b7ede0fa15aacbe47311">getScale</a> (void) const</td></tr>
<tr class="memdesc:a1133d2ef5623b7ede0fa15aacbe47311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scaling factor of this node.  <a href="#a1133d2ef5623b7ede0fa15aacbe47311">More...</a><br /></td></tr>
<tr class="separator:a1133d2ef5623b7ede0fa15aacbe47311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023a989fcd364ff3f41543b6ccb0ee9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a023a989fcd364ff3f41543b6ccb0ee9b">getShowBoundingBox</a> () const</td></tr>
<tr class="memdesc:a023a989fcd364ff3f41543b6ccb0ee9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This allows scene managers to determine if the node's bounding box should be added to the rendering queue.  <a href="#a023a989fcd364ff3f41543b6ccb0ee9b">More...</a><br /></td></tr>
<tr class="separator:a023a989fcd364ff3f41543b6ccb0ee9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6249bf582ea32554236af812a2e8a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a1d6249bf582ea32554236af812a2e8a2">getSquaredViewDepth</a> (const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *cam) const</td></tr>
<tr class="memdesc:a1d6249bf582ea32554236af812a2e8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, get the squared view depth.  <a href="#a1d6249bf582ea32554236af812a2e8a2">More...</a><br /></td></tr>
<tr class="separator:a1d6249bf582ea32554236af812a2e8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa158a89aa8c4d8113ea52435eda1da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_any.html">Any</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a9fa158a89aa8c4d8113ea52435eda1da">getUserAny</a> (void) const</td></tr>
<tr class="separator:a9fa158a89aa8c4d8113ea52435eda1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fcf16e43b07e046816125cbb8dc8f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af3fcf16e43b07e046816125cbb8dc8f3">getUserObjectBindings</a> ()</td></tr>
<tr class="memdesc:af3fcf16e43b07e046816125cbb8dc8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="#af3fcf16e43b07e046816125cbb8dc8f3">More...</a><br /></td></tr>
<tr class="separator:af3fcf16e43b07e046816125cbb8dc8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa154e07b616313f4c345ec6c0da635cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa154e07b616313f4c345ec6c0da635cd">getUserObjectBindings</a> () const</td></tr>
<tr class="memdesc:aa154e07b616313f4c345ec6c0da635cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="#aa154e07b616313f4c345ec6c0da635cd">More...</a><br /></td></tr>
<tr class="separator:aa154e07b616313f4c345ec6c0da635cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab001c4e10d13d5f5cd31bae778080c90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#ab001c4e10d13d5f5cd31bae778080c90">hideBoundingBox</a> (bool bHide)</td></tr>
<tr class="memdesc:ab001c4e10d13d5f5cd31bae778080c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the overriding of the node's bounding box over the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>'s bounding box setting.  <a href="#ab001c4e10d13d5f5cd31bae778080c90">More...</a><br /></td></tr>
<tr class="separator:ab001c4e10d13d5f5cd31bae778080c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b32cab596d715adaa6879b5a6beb8e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a8b32cab596d715adaa6879b5a6beb8e2">isInSceneGraph</a> (void) const</td></tr>
<tr class="memdesc:a8b32cab596d715adaa6879b5a6beb8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this node is in the scene graph, i.e.  <a href="#a8b32cab596d715adaa6879b5a6beb8e2">More...</a><br /></td></tr>
<tr class="separator:a8b32cab596d715adaa6879b5a6beb8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665c4750906917dd061b141c03d432de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de">lookAt</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;targetPoint, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;localDirectionVector=<a class="el" href="class_ogre_1_1_vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a>)</td></tr>
<tr class="memdesc:a665c4750906917dd061b141c03d432de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points the local -Z direction of this node at a point in space.  <a href="#a665c4750906917dd061b141c03d432de">More...</a><br /></td></tr>
<tr class="separator:a665c4750906917dd061b141c03d432de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8671415cc4cf15e45bf716a823678736"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a8671415cc4cf15e45bf716a823678736">needUpdate</a> (bool forceParentUpdate=false)</td></tr>
<tr class="memdesc:a8671415cc4cf15e45bf716a823678736"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be called in the event of transform changes to this node that require it's recalculation.  <a href="#a8671415cc4cf15e45bf716a823678736">More...</a><br /></td></tr>
<tr class="separator:a8671415cc4cf15e45bf716a823678736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d8019108beba3fe34250fb2e2fc7c4"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#af0d8019108beba3fe34250fb2e2fc7c4">numAttachedObjects</a> (void) const</td></tr>
<tr class="memdesc:af0d8019108beba3fe34250fb2e2fc7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of objects attached to this node.  <a href="#af0d8019108beba3fe34250fb2e2fc7c4">More...</a><br /></td></tr>
<tr class="separator:af0d8019108beba3fe34250fb2e2fc7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622555b1fd2f2d1982e7ab9f2313ef1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a622555b1fd2f2d1982e7ab9f2313ef1f">numChildren</a> (void) const</td></tr>
<tr class="memdesc:a622555b1fd2f2d1982e7ab9f2313ef1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of child nodes under this one.  <a href="#a622555b1fd2f2d1982e7ab9f2313ef1f">More...</a><br /></td></tr>
<tr class="separator:a622555b1fd2f2d1982e7ab9f2313ef1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d3de1c197a805dd692f775fbbeb022"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac7d3de1c197a805dd692f775fbbeb022">pitch</a> (const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:ac7d3de1c197a805dd692f775fbbeb022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around the X-axis.  <a href="#ac7d3de1c197a805dd692f775fbbeb022">More...</a><br /></td></tr>
<tr class="separator:ac7d3de1c197a805dd692f775fbbeb022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b3e979879906d5500b961a98d04bc0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a79b3e979879906d5500b961a98d04bc0">removeAllChildren</a> (void)</td></tr>
<tr class="memdesc:a79b3e979879906d5500b961a98d04bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all child Nodes attached to this node.  <a href="#a79b3e979879906d5500b961a98d04bc0">More...</a><br /></td></tr>
<tr class="separator:a79b3e979879906d5500b961a98d04bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19866a1f0035b7bd69fabade69ec2927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a19866a1f0035b7bd69fabade69ec2927">removeAndDestroyAllChildren</a> (void)</td></tr>
<tr class="memdesc:a19866a1f0035b7bd69fabade69ec2927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and destroys all children of this node.  <a href="#a19866a1f0035b7bd69fabade69ec2927">More...</a><br /></td></tr>
<tr class="separator:a19866a1f0035b7bd69fabade69ec2927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ad2296a7da9a8ba0e3ac929b08f8c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a94ad2296a7da9a8ba0e3ac929b08f8c8">removeAndDestroyChild</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:a94ad2296a7da9a8ba0e3ac929b08f8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method removes and destroys the named child and all of its children.  <a href="#a94ad2296a7da9a8ba0e3ac929b08f8c8">More...</a><br /></td></tr>
<tr class="separator:a94ad2296a7da9a8ba0e3ac929b08f8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e82a92af445a65985851d84e046faa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a86e82a92af445a65985851d84e046faa">removeAndDestroyChild</a> (unsigned short index)</td></tr>
<tr class="separator:a86e82a92af445a65985851d84e046faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6728059acfdcebf75e0fec4fc16c4b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#ac6728059acfdcebf75e0fec4fc16c4b6">removeAndDestroyChild</a> (<a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *child)</td></tr>
<tr class="separator:ac6728059acfdcebf75e0fec4fc16c4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912d9d3a804edf9faf8a9e32482502b1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a912d9d3a804edf9faf8a9e32482502b1">removeChild</a> (unsigned short index)</td></tr>
<tr class="memdesc:a912d9d3a804edf9faf8a9e32482502b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the specified child from this node.  <a href="#a912d9d3a804edf9faf8a9e32482502b1">More...</a><br /></td></tr>
<tr class="separator:a912d9d3a804edf9faf8a9e32482502b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dae5b62b42bcb4590aea678c3056f26"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a1dae5b62b42bcb4590aea678c3056f26">removeChild</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *child)</td></tr>
<tr class="separator:a1dae5b62b42bcb4590aea678c3056f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1a96d0ca30f5ca56a5dacf27d68f6c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a7b1a96d0ca30f5ca56a5dacf27d68f6c">removeChild</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:a7b1a96d0ca30f5ca56a5dacf27d68f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the named child from this node.  <a href="#a7b1a96d0ca30f5ca56a5dacf27d68f6c">More...</a><br /></td></tr>
<tr class="separator:a7b1a96d0ca30f5ca56a5dacf27d68f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97676492945c888304b71ad4edc85e5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a97676492945c888304b71ad4edc85e5a">requestUpdate</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *child, bool forceParentUpdate=false)</td></tr>
<tr class="memdesc:a97676492945c888304b71ad4edc85e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by children to notify their parent that they need an update.  <a href="#a97676492945c888304b71ad4edc85e5a">More...</a><br /></td></tr>
<tr class="separator:a97676492945c888304b71ad4edc85e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40baf1928d11cd3cd678445f5d3d7e45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a40baf1928d11cd3cd678445f5d3d7e45">resetOrientation</a> (void)</td></tr>
<tr class="memdesc:a40baf1928d11cd3cd678445f5d3d7e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the nodes orientation (local axes as world axes, no rotation).  <a href="#a40baf1928d11cd3cd678445f5d3d7e45">More...</a><br /></td></tr>
<tr class="separator:a40baf1928d11cd3cd678445f5d3d7e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398e7142b2fbadea2a63097d37d4112b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a398e7142b2fbadea2a63097d37d4112b">resetToInitialState</a> (void)</td></tr>
<tr class="memdesc:a398e7142b2fbadea2a63097d37d4112b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the position / orientation / scale of this node to it's initial state, see setInitialState for more info.  <a href="#a398e7142b2fbadea2a63097d37d4112b">More...</a><br /></td></tr>
<tr class="separator:a398e7142b2fbadea2a63097d37d4112b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb62b05fce457b8509cb95517154425f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aeb62b05fce457b8509cb95517154425f">roll</a> (const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:aeb62b05fce457b8509cb95517154425f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around the Z-axis.  <a href="#aeb62b05fce457b8509cb95517154425f">More...</a><br /></td></tr>
<tr class="separator:aeb62b05fce457b8509cb95517154425f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1991a38daed956ca9edc635e418d6d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ae1991a38daed956ca9edc635e418d6d8">rotate</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;axis, const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:ae1991a38daed956ca9edc635e418d6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around an arbitrary axis.  <a href="#ae1991a38daed956ca9edc635e418d6d8">More...</a><br /></td></tr>
<tr class="separator:ae1991a38daed956ca9edc635e418d6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711e0d29d57360d7a17d99823a409c50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a711e0d29d57360d7a17d99823a409c50">rotate</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;q, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:a711e0d29d57360d7a17d99823a409c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around an aritrary axis using a Quarternion.  <a href="#a711e0d29d57360d7a17d99823a409c50">More...</a><br /></td></tr>
<tr class="separator:a711e0d29d57360d7a17d99823a409c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01627f9f9f1a19afe5965c4ba873a573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a01627f9f9f1a19afe5965c4ba873a573">scale</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;scale)</td></tr>
<tr class="memdesc:a01627f9f9f1a19afe5965c4ba873a573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the node, combining it's current scale with the passed in scaling factor.  <a href="#a01627f9f9f1a19afe5965c4ba873a573">More...</a><br /></td></tr>
<tr class="separator:a01627f9f9f1a19afe5965c4ba873a573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa670d25ccc7206afb3d7cd6dd709cd34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa670d25ccc7206afb3d7cd6dd709cd34">scale</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="separator:aa670d25ccc7206afb3d7cd6dd709cd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c8588895d3623bbe0007ea157af1a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#ae4c8588895d3623bbe0007ea157af1a4">setAutoTracking</a> (bool enabled, <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *const target=0, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;localDirectionVector=<a class="el" href="class_ogre_1_1_vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a>, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;offset=<a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a>)</td></tr>
<tr class="memdesc:ae4c8588895d3623bbe0007ea157af1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables / disables automatic tracking of another <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>.  <a href="#ae4c8588895d3623bbe0007ea157af1a4">More...</a><br /></td></tr>
<tr class="separator:ae4c8588895d3623bbe0007ea157af1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afaaf0dfd3c7140342059a94788e341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a3afaaf0dfd3c7140342059a94788e341">setDebugDisplayEnabled</a> (bool enabled, bool cascade=true)</td></tr>
<tr class="memdesc:a3afaaf0dfd3c7140342059a94788e341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells all objects attached to this node whether to display their debug information or not.  <a href="#a3afaaf0dfd3c7140342059a94788e341">More...</a><br /></td></tr>
<tr class="separator:a3afaaf0dfd3c7140342059a94788e341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc1a1db6ae1023ec6e709bd6f82220f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#aebc1a1db6ae1023ec6e709bd6f82220f">setDirection</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;localDirectionVector=<a class="el" href="class_ogre_1_1_vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a>)</td></tr>
<tr class="memdesc:aebc1a1db6ae1023ec6e709bd6f82220f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the node's direction vector ie it's local -z.  <a href="#aebc1a1db6ae1023ec6e709bd6f82220f">More...</a><br /></td></tr>
<tr class="separator:aebc1a1db6ae1023ec6e709bd6f82220f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52652642857138f859291a88598877c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a52652642857138f859291a88598877c9">setDirection</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;vec, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;localDirectionVector=<a class="el" href="class_ogre_1_1_vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a>)</td></tr>
<tr class="separator:a52652642857138f859291a88598877c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b72c066884d0021bd2b2a6693a66c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#ae7b72c066884d0021bd2b2a6693a66c3">setFixedYawAxis</a> (bool useFixed, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;fixedAxis=<a class="el" href="class_ogre_1_1_vector3.html#a8d1a1f7af535bcc8d9c78b1732bc1b90">Vector3::UNIT_Y</a>)</td></tr>
<tr class="memdesc:ae7b72c066884d0021bd2b2a6693a66c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the node whether to yaw around it's own local Y axis or a fixed axis of choice.  <a href="#ae7b72c066884d0021bd2b2a6693a66c3">More...</a><br /></td></tr>
<tr class="separator:ae7b72c066884d0021bd2b2a6693a66c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bf413c5680b8ff4ea913bcb83d25f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a66bf413c5680b8ff4ea913bcb83d25f1">setInheritOrientation</a> (bool inherit)</td></tr>
<tr class="memdesc:a66bf413c5680b8ff4ea913bcb83d25f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the node whether it should inherit orientation from it's parent node.  <a href="#a66bf413c5680b8ff4ea913bcb83d25f1">More...</a><br /></td></tr>
<tr class="separator:a66bf413c5680b8ff4ea913bcb83d25f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6319b597c3c75a30c521d532466c4d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ae6319b597c3c75a30c521d532466c4d9">setInheritScale</a> (bool inherit)</td></tr>
<tr class="memdesc:ae6319b597c3c75a30c521d532466c4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the node whether it should inherit scaling factors from it's parent node.  <a href="#ae6319b597c3c75a30c521d532466c4d9">More...</a><br /></td></tr>
<tr class="separator:ae6319b597c3c75a30c521d532466c4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7832ae769b627172de3cf594b9769084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a7832ae769b627172de3cf594b9769084">setInitialState</a> (void)</td></tr>
<tr class="memdesc:a7832ae769b627172de3cf594b9769084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current transform of this node to be the 'initial state' ie that position / orientation / scale to be used as a basis for delta values used in keyframe animation.  <a href="#a7832ae769b627172de3cf594b9769084">More...</a><br /></td></tr>
<tr class="separator:a7832ae769b627172de3cf594b9769084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aadf525c7f437c32cd17b0ccd606f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a9aadf525c7f437c32cd17b0ccd606f71">setListener</a> (<a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a> *listener)</td></tr>
<tr class="memdesc:a9aadf525c7f437c32cd17b0ccd606f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a listener for this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a>.  <a href="#a9aadf525c7f437c32cd17b0ccd606f71">More...</a><br /></td></tr>
<tr class="separator:a9aadf525c7f437c32cd17b0ccd606f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307fe0438fb098be6748e044f66155b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a307fe0438fb098be6748e044f66155b6">setOrientation</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr class="memdesc:a307fe0438fb098be6748e044f66155b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the orientation of this node via a quaternion.  <a href="#a307fe0438fb098be6748e044f66155b6">More...</a><br /></td></tr>
<tr class="separator:a307fe0438fb098be6748e044f66155b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76bc19286a78c598eec88f80f3b16fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad76bc19286a78c598eec88f80f3b16fb">setOrientation</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> w, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="separator:ad76bc19286a78c598eec88f80f3b16fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e58d4789cfe29e4538399b4250ce5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;pos)</td></tr>
<tr class="memdesc:a72e58d4789cfe29e4538399b4250ce5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position of the node relative to it's parent.  <a href="#a72e58d4789cfe29e4538399b4250ce5a">More...</a><br /></td></tr>
<tr class="separator:a72e58d4789cfe29e4538399b4250ce5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af054933a193ed930790fcd2fb80ba684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af054933a193ed930790fcd2fb80ba684">setPosition</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="separator:af054933a193ed930790fcd2fb80ba684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad031614d90a8fb18750b350c4221cca2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad031614d90a8fb18750b350c4221cca2">setScale</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;<a class="el" href="class_ogre_1_1_node.html#a01627f9f9f1a19afe5965c4ba873a573">scale</a>)</td></tr>
<tr class="memdesc:ad031614d90a8fb18750b350c4221cca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scaling factor applied to this node.  <a href="#ad031614d90a8fb18750b350c4221cca2">More...</a><br /></td></tr>
<tr class="separator:ad031614d90a8fb18750b350c4221cca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a075aeadb2ad76cc74ed68e02c9ef26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a9a075aeadb2ad76cc74ed68e02c9ef26">setScale</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="separator:a9a075aeadb2ad76cc74ed68e02c9ef26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdf947d54d8b67b5fef19d68da899ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a2fdf947d54d8b67b5fef19d68da899ae">setUserAny</a> (const <a class="el" href="class_ogre_1_1_any.html">Any</a> &amp;anything)</td></tr>
<tr class="separator:a2fdf947d54d8b67b5fef19d68da899ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe422d8fd0d6986b99a0d7848369388f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#afe422d8fd0d6986b99a0d7848369388f">setVisible</a> (bool visible, bool cascade=true)</td></tr>
<tr class="memdesc:afe422d8fd0d6986b99a0d7848369388f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes all objects attached to this node become visible / invisible.  <a href="#afe422d8fd0d6986b99a0d7848369388f">More...</a><br /></td></tr>
<tr class="separator:afe422d8fd0d6986b99a0d7848369388f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9860a1b68e45854017ad5167890bd6a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a9860a1b68e45854017ad5167890bd6a1">showBoundingBox</a> (bool bShow)</td></tr>
<tr class="memdesc:a9860a1b68e45854017ad5167890bd6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the showing of the node's bounding box.  <a href="#a9860a1b68e45854017ad5167890bd6a1">More...</a><br /></td></tr>
<tr class="separator:a9860a1b68e45854017ad5167890bd6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bb282556bc68d072b62097f3006221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a45bb282556bc68d072b62097f3006221">translate</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;d, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>)</td></tr>
<tr class="memdesc:a45bb282556bc68d072b62097f3006221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the node along the Cartesian axes.  <a href="#a45bb282556bc68d072b62097f3006221">More...</a><br /></td></tr>
<tr class="separator:a45bb282556bc68d072b62097f3006221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef45be557e0d74354214418a61d1412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aaef45be557e0d74354214418a61d1412">translate</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>)</td></tr>
<tr class="separator:aaef45be557e0d74354214418a61d1412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198cc48d48e52176bbab96e71cc40696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a198cc48d48e52176bbab96e71cc40696">translate</a> (const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;axes, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;move, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>)</td></tr>
<tr class="memdesc:a198cc48d48e52176bbab96e71cc40696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the node along arbitrary axes.  <a href="#a198cc48d48e52176bbab96e71cc40696">More...</a><br /></td></tr>
<tr class="separator:a198cc48d48e52176bbab96e71cc40696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c8ec60f7539ac029c9c47b788b2629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a37c8ec60f7539ac029c9c47b788b2629">translate</a> (const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;axes, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>)</td></tr>
<tr class="separator:a37c8ec60f7539ac029c9c47b788b2629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cfc691608c8dedd4b9b3b88b3923c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html#a95cfc691608c8dedd4b9b3b88b3923c3">yaw</a> (const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:a95cfc691608c8dedd4b9b3b88b3923c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around the Y-axis.  <a href="#a95cfc691608c8dedd4b9b3b88b3923c3">More...</a><br /></td></tr>
<tr class="separator:a95cfc691608c8dedd4b9b3b88b3923c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af990db414b5c4b26b055375401d3b5d1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af990db414b5c4b26b055375401d3b5d1">processQueuedUpdates</a> (void)</td></tr>
<tr class="memdesc:af990db414b5c4b26b055375401d3b5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process queued 'needUpdate' calls.  <a href="#af990db414b5c4b26b055375401d3b5d1">More...</a><br /></td></tr>
<tr class="separator:af990db414b5c4b26b055375401d3b5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4609e37d3a70cf4318c99e9e1fb8dfd9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a4609e37d3a70cf4318c99e9e1fb8dfd9">queueNeedUpdate</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *n)</td></tr>
<tr class="memdesc:a4609e37d3a70cf4318c99e9e1fb8dfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue a 'needUpdate' call to a node safely.  <a href="#a4609e37d3a70cf4318c99e9e1fb8dfd9">More...</a><br /></td></tr>
<tr class="separator:a4609e37d3a70cf4318c99e9e1fb8dfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Specialisation of <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> for the <a class="el" href="class_ogre_1_1_bsp_scene_manager.html" title="Specialisation of the SceneManager class to deal with indoor scenes based on a BSP tree...">BspSceneManager</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This specialisation of <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> is to enable information about the leaf node in which any attached objects are held is stored for use in the visibility determination. </dd></dl>
<dl class="section user"><dt></dt><dd>Do not confuse this class with <a class="el" href="class_ogre_1_1_bsp_node.html" title="Encapsulates a node in a BSP tree. ">BspNode</a>, which reflects nodes in the BSP tree itself. This class is just like a regular <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>, except that it should be locating <a class="el" href="class_ogre_1_1_bsp_node.html" title="Encapsulates a node in a BSP tree. ">BspNode</a> leaf elements which objects should be included in. Note that because objects are movable, and thus may very well be overlapping the boundaries of more than one leaf, that it is possible that an object attached to one <a class="el" href="class_ogre_1_1_bsp_scene_node.html" title="Specialisation of SceneNode for the BspSceneManager. ">BspSceneNode</a> may actually be associated with more than one <a class="el" href="class_ogre_1_1_bsp_node.html" title="Encapsulates a node in a BSP tree. ">BspNode</a>. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9155734bb4e41cbf734504b85daa02b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9155734bb4e41cbf734504b85daa02b7">&#9670;&nbsp;</a></span>ObjectMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a>*&gt;::type <a class="el" href="class_ogre_1_1_scene_node.html#a9155734bb4e41cbf734504b85daa02b7">Ogre::SceneNode::ObjectMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1279b4ce58509856588b0c57641d0a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1279b4ce58509856588b0c57641d0a64">&#9670;&nbsp;</a></span>ObjectIterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_scene_node.html#a9155734bb4e41cbf734504b85daa02b7">ObjectMap</a>&gt; <a class="el" href="class_ogre_1_1_scene_node.html#a1279b4ce58509856588b0c57641d0a64">Ogre::SceneNode::ObjectIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57219459f45733699562ae3fd2abda24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57219459f45733699562ae3fd2abda24">&#9670;&nbsp;</a></span>ConstObjectIterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_scene_node.html#a9155734bb4e41cbf734504b85daa02b7">ObjectMap</a>&gt; <a class="el" href="class_ogre_1_1_scene_node.html#a57219459f45733699562ae3fd2abda24">Ogre::SceneNode::ConstObjectIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f5f85d7e0f2685a057c66d51398ae5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5f85d7e0f2685a057c66d51398ae5b">&#9670;&nbsp;</a></span>ChildNodeMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="class_ogre_1_1_node.html">Node</a>*&gt;::type <a class="el" href="class_ogre_1_1_node.html#a8f5f85d7e0f2685a057c66d51398ae5b">Ogre::Node::ChildNodeMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b69022b50c829ec21e9589bbc591597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b69022b50c829ec21e9589bbc591597">&#9670;&nbsp;</a></span>ChildNodeIterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_node.html#a8f5f85d7e0f2685a057c66d51398ae5b">ChildNodeMap</a>&gt; <a class="el" href="class_ogre_1_1_node.html#a0b69022b50c829ec21e9589bbc591597">Ogre::Node::ChildNodeIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a984f44c9104d5c195f67a2b9d88ebae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984f44c9104d5c195f67a2b9d88ebae1">&#9670;&nbsp;</a></span>ConstChildNodeIterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_node.html#a8f5f85d7e0f2685a057c66d51398ae5b">ChildNodeMap</a>&gt; <a class="el" href="class_ogre_1_1_node.html#a984f44c9104d5c195f67a2b9d88ebae1">Ogre::Node::ConstChildNodeIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac42e2063379286eb673eaffff6ca5e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42e2063379286eb673eaffff6ca5e99">&#9670;&nbsp;</a></span>TransformSpace</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">Ogre::Node::TransformSpace</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration denoting the spaces which a transform can be relative to. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2"></a>TS_LOCAL&#160;</td><td class="fielddoc"><p>Transform is relative to the local space. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce"></a>TS_PARENT&#160;</td><td class="fielddoc"><p>Transform is relative to the space of the parent node. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac42e2063379286eb673eaffff6ca5e99ae28ff4f09161c3f5d19c08c5ef210e04"></a>TS_WORLD&#160;</td><td class="fielddoc"><p>Transform is relative to world space. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3c9fc7c13d2a9a92130e1b595f74fe8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9fc7c13d2a9a92130e1b595f74fe8d">&#9670;&nbsp;</a></span>BspSceneNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::BspSceneNode::BspSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>creator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a387df029179fce1955902d2b6cd3ae8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387df029179fce1955902d2b6cd3ae8b">&#9670;&nbsp;</a></span>BspSceneNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::BspSceneNode::BspSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_bsp_scene_node.html#a1ee88a2f5a1f7fe70c4ea39a245aa6a1">_update()</a>, <a class="el" href="class_ogre_1_1_bsp_scene_node.html#aedb8690d7cd00a804a659eac1ee45060">detachAllObjects()</a>, and <a class="el" href="class_ogre_1_1_bsp_scene_node.html#a932a5feecc7144344cbb3bda8534cb5a">detachObject()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1ee88a2f5a1f7fe70c4ea39a245aa6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee88a2f5a1f7fe70c4ea39a245aa6a1">&#9670;&nbsp;</a></span>_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::BspSceneNode::_update </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateChildren</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parentHasChanged</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overridden from <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a>. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_scene_node.html#a0388a0a024cbbf669c6843d4bc69ac9a">Ogre::SceneNode</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_bsp_scene_node.html#a387df029179fce1955902d2b6cd3ae8b">BspSceneNode()</a>.</p>

</div>
</div>
<a id="a932a5feecc7144344cbb3bda8534cb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932a5feecc7144344cbb3bda8534cb5a">&#9670;&nbsp;</a></span>detachObject() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a>* Ogre::BspSceneNode::detachObject </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches the indexed object from this scene node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Detaches by index, see the alternate version to detach by name. Object indexes may change as other objects are added / removed. </dd></dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_scene_node.html#a4d0832b90b91afe9fd4154e12c8481a1">Ogre::SceneNode</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_bsp_scene_node.html#a387df029179fce1955902d2b6cd3ae8b">BspSceneNode()</a>.</p>

</div>
</div>
<a id="a320bc152963657c2ff26fc0e5caf29f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320bc152963657c2ff26fc0e5caf29f4">&#9670;&nbsp;</a></span>detachObject() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a>* Ogre::BspSceneNode::detachObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches the named object from this node and returns a pointer to it. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_scene_node.html#af52d04c1d2aa341f7e02daeb7355372b">Ogre::SceneNode</a>.</p>

</div>
</div>
<a id="aedb8690d7cd00a804a659eac1ee45060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb8690d7cd00a804a659eac1ee45060">&#9670;&nbsp;</a></span>detachAllObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::BspSceneNode::detachAllObjects </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches all objects attached to this node. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_scene_node.html#a064b81e279b10a488ba018d1ac87abb5">Ogre::SceneNode</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_bsp_scene_node.html#a387df029179fce1955902d2b6cd3ae8b">BspSceneNode()</a>.</p>

</div>
</div>
<a id="a51052c58747a77a6cf7451b700e7eb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51052c58747a77a6cf7451b700e7eb87">&#9670;&nbsp;</a></span>attachObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::attachObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an instance of a scene object to this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Scene objects can include <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> objects, <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Camera</a> objects, <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Light</a> objects, <a class="el" href="class_ogre_1_1_particle_system.html" title="Class defining particle system based special effects. ">ParticleSystem</a> objects etc. Anything that subclasses from <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a>. </dd></dl>

</div>
</div>
<a id="af0d8019108beba3fe34250fb2e2fc7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d8019108beba3fe34250fb2e2fc7c4">&#9670;&nbsp;</a></span>numAttachedObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::SceneNode::numAttachedObjects </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the number of objects attached to this node. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000183">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_scene_node.html#ad76fe7cdecec48166697bb06174f1333" title="The MovableObjects associated with this node. ">getAttachedObjects()</a> </dd></dl>

</div>
</div>
<a id="a2ff8d20961b48225690e1561bc39f993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff8d20961b48225690e1561bc39f993">&#9670;&nbsp;</a></span>getAttachedObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a>* Ogre::SceneNode::getAttachedObject </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a pointer to an attached object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Retrieves by index, see alternate version to retrieve by name. The index of an object may change as other objects are added / removed. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000184">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_scene_node.html#ad76fe7cdecec48166697bb06174f1333" title="The MovableObjects associated with this node. ">getAttachedObjects()</a> </dd></dl>

</div>
</div>
<a id="a3f64cc674aed856340df7a0507b90423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f64cc674aed856340df7a0507b90423">&#9670;&nbsp;</a></span>getAttachedObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a>* Ogre::SceneNode::getAttachedObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a pointer to an attached object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Retrieves by object name, see alternate version to retrieve by index. </dd></dl>

</div>
</div>
<a id="abc4846642c14ab6e3ca1a4f6296b859a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4846642c14ab6e3ca1a4f6296b859a">&#9670;&nbsp;</a></span>detachObject() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::detachObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches an object by pointer. </p>

</div>
</div>
<a id="a8b32cab596d715adaa6879b5a6beb8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b32cab596d715adaa6879b5a6beb8e2">&#9670;&nbsp;</a></span>isInSceneGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::SceneNode::isInSceneGraph </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this node is in the scene graph, i.e. </p>
<p>whether it's ultimate ancestor is the root scene node. </p>

</div>
</div>
<a id="a256519b10007f0cf64c3f23cd0642581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256519b10007f0cf64c3f23cd0642581">&#9670;&nbsp;</a></span>_notifyRootNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::_notifyRootNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies this <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> that it is the root scene node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> should call this! </dd></dl>

</div>
</div>
<a id="a82a14f326bf38f516d8db82a687c987c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a14f326bf38f516d8db82a687c987c">&#9670;&nbsp;</a></span>_updateBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::_updateBounds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> to update the world bound info it stores. </p>

</div>
</div>
<a id="a6e11a4a0a39106a02c45bd5521c5996c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e11a4a0a39106a02c45bd5521c5996c">&#9670;&nbsp;</a></span>_findVisibleObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::_findVisibleObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_visible_objects_bounds_info.html">VisibleObjectsBoundsInfo</a> *&#160;</td>
          <td class="paramname"><em>visibleBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeChildren</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>displayNodes</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyShadowCasters</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method which locates any visible objects attached to this node and adds them to the passed in queue. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Should only be called by a <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> implementation, and only after the _updat method has been called to ensure transforms and world bounds are up to date. <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> implementations can choose to let the search cascade automatically, or choose to prevent this and select nodes themselves based on some other criteria. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cam</td><td>The active camera </td></tr>
    <tr><td class="paramname">queue</td><td>The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>'s rendering queue </td></tr>
    <tr><td class="paramname">visibleBounds</td><td>bounding information created on the fly containing all visible objects by the camera </td></tr>
    <tr><td class="paramname">includeChildren</td><td>If true, the call is cascaded down to all child nodes automatically. </td></tr>
    <tr><td class="paramname">displayNodes</td><td>If true, the nodes themselves are rendered as a set of 3 axes as well as the objects being rendered. For debugging purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5541f6607ef566e07991a0642b0f70f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5541f6607ef566e07991a0642b0f70f9">&#9670;&nbsp;</a></span>_getWorldAABB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>&amp; Ogre::SceneNode::_getWorldAABB </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the axis-aligned bounding box of this node (and hence all subnodes). </p>
<dl class="section remark"><dt>Remarks</dt><dd>Recommended only if you are extending a <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>, because the bounding box returned from this method is only up to date after the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> has called _update. </dd></dl>

</div>
</div>
<a id="a14e3b93b490eb75ed1bf1db5d6035ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e3b93b490eb75ed1bf1db5d6035ff1">&#9670;&nbsp;</a></span>getAttachedObjectIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_node.html#a1279b4ce58509856588b0c57641d0a64">ObjectIterator</a> Ogre::SceneNode::getAttachedObjectIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an iterator which can be used to efficiently step through the objects attached to this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is a much faster way to go through <b>all</b> the objects attached to the node than using getAttachedObject. But the iterator returned is only valid until a change is made to the collection (ie an addition or removal) so treat the returned iterator as transient, and don't add / remove items as you go through the iterator, save changes until the end, or retrieve a new iterator after making the change. Making changes to the object returned through the iterator is OK though. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000185">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_scene_node.html#ad76fe7cdecec48166697bb06174f1333" title="The MovableObjects associated with this node. ">getAttachedObjects()</a> </dd></dl>

</div>
</div>
<a id="a176f01ff035f682fa00a1500c8d795a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176f01ff035f682fa00a1500c8d795a9">&#9670;&nbsp;</a></span>getAttachedObjectIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_node.html#a57219459f45733699562ae3fd2abda24">ConstObjectIterator</a> Ogre::SceneNode::getAttachedObjectIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an iterator which can be used to efficiently step through the objects attached to this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is a much faster way to go through <b>all</b> the objects attached to the node than using getAttachedObject. But the iterator returned is only valid until a change is made to the collection (ie an addition or removal) so treat the returned iterator as transient, and don't add / remove items as you go through the iterator, save changes until the end, or retrieve a new iterator after making the change. Making changes to the object returned through the iterator is OK though. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000186">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_scene_node.html#ad76fe7cdecec48166697bb06174f1333" title="The MovableObjects associated with this node. ">getAttachedObjects()</a> </dd></dl>

</div>
</div>
<a id="ad76fe7cdecec48166697bb06174f1333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76fe7cdecec48166697bb06174f1333">&#9670;&nbsp;</a></span>getAttachedObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_scene_node.html#a9155734bb4e41cbf734504b85daa02b7">ObjectMap</a>&amp; Ogre::SceneNode::getAttachedObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The MovableObjects associated with this node. </p>

</div>
</div>
<a id="aa8d203d81bd4ec6c8c626d7c1bf96a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d203d81bd4ec6c8c626d7c1bf96a80">&#9670;&nbsp;</a></span>getCreator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a>* Ogre::SceneNode::getCreator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the creator of this scene node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method returns the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> which created this node. This can be useful for destroying this node. </dd></dl>

</div>
</div>
<a id="a94ad2296a7da9a8ba0e3ac929b08f8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ad2296a7da9a8ba0e3ac929b08f8c8">&#9670;&nbsp;</a></span>removeAndDestroyChild() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::removeAndDestroyChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method removes and destroys the named child and all of its children. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike removeChild, which removes a single named child from this node but does not destroy it, this method destroys the child and all of it's children. </dd></dl>
<dl class="section user"><dt></dt><dd>Use this if you wish to recursively destroy a node as well as detaching it from it's parent. Note that any objects attached to the nodes will be detached but will not themselves be destroyed. </dd></dl>

</div>
</div>
<a id="a86e82a92af445a65985851d84e046faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e82a92af445a65985851d84e046faa">&#9670;&nbsp;</a></span>removeAndDestroyChild() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::removeAndDestroyChild </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ac6728059acfdcebf75e0fec4fc16c4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6728059acfdcebf75e0fec4fc16c4b6">&#9670;&nbsp;</a></span>removeAndDestroyChild() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::removeAndDestroyChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a19866a1f0035b7bd69fabade69ec2927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19866a1f0035b7bd69fabade69ec2927">&#9670;&nbsp;</a></span>removeAndDestroyAllChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::removeAndDestroyAllChildren </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes and destroys all children of this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Use this to destroy all child nodes of this node and remove them from the scene graph. Note that all objects attached to this node will be detached but will not be destroyed. </dd></dl>

</div>
</div>
<a id="a9860a1b68e45854017ad5167890bd6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9860a1b68e45854017ad5167890bd6a1">&#9670;&nbsp;</a></span>showBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::showBoundingBox </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bShow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the showing of the node's bounding box. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Use this to show or hide the bounding box of the node. </dd></dl>

</div>
</div>
<a id="ab001c4e10d13d5f5cd31bae778080c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab001c4e10d13d5f5cd31bae778080c90">&#9670;&nbsp;</a></span>hideBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::hideBoundingBox </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bHide</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the overriding of the node's bounding box over the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>'s bounding box setting. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Use this to override the bounding box setting of the node. </dd></dl>

</div>
</div>
<a id="a093e08130e57e03496b8009c7033d21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093e08130e57e03496b8009c7033d21b">&#9670;&nbsp;</a></span>_addBoundingBoxToQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::_addBoundingBoxToQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the bounding box to the rendering queue. </p>

</div>
</div>
<a id="a023a989fcd364ff3f41543b6ccb0ee9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023a989fcd364ff3f41543b6ccb0ee9b">&#9670;&nbsp;</a></span>getShowBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::SceneNode::getShowBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This allows scene managers to determine if the node's bounding box should be added to the rendering queue. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Scene Managers that implement their own _findVisibleObjects will have to check this flag and then use _addBoundingBoxToQueue to add the bounding box wireframe. </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Ogre::Quaternion::IDENTITY</a>, <a class="el" href="class_ogre_1_1_vector3.html#abdeebea4e94e114215a51831f9792f19">Ogre::Vector3::NEGATIVE_UNIT_Z</a>, <a class="el" href="class_ogre_1_1_vector3.html#a8d1a1f7af535bcc8d9c78b1732bc1b90">Ogre::Vector3::UNIT_Y</a>, and <a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Ogre::Vector3::ZERO</a>.</p>

</div>
</div>
<a id="aeaee9cb1cb0c23fab2cc9bab08f51181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaee9cb1cb0c23fab2cc9bab08f51181">&#9670;&nbsp;</a></span>createChildSceneNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneNode::createChildSceneNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>translate</em> = <code><a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotate</em> = <code><a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an unnamed new <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> as a child of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translate</td><td>Initial translation offset of child relative to parent </td></tr>
    <tr><td class="paramname">rotate</td><td>Initial rotation relative to parent </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_p_c_z_scene_node.html#a9724ee135a6bd6fa898359af92cff1be">Ogre::PCZSceneNode</a>.</p>

</div>
</div>
<a id="a559442664e8b83cb40ca1d2c68c5d01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559442664e8b83cb40ca1d2c68c5d01c">&#9670;&nbsp;</a></span>createChildSceneNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneNode::createChildSceneNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>translate</em> = <code><a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotate</em> = <code><a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new named <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> as a child of this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This creates a child node with a given name, which allows you to look the node up from the parent which holds this collection of nodes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translate</td><td>Initial translation offset of child relative to parent </td></tr>
    <tr><td class="paramname">rotate</td><td>Initial rotation relative to parent </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_p_c_z_scene_node.html#aa9d3137d63a4997105cfee5d015e771b">Ogre::PCZSceneNode</a>.</p>

</div>
</div>
<a id="a63d97c1153036cdc6db138c6b03c9828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d97c1153036cdc6db138c6b03c9828">&#9670;&nbsp;</a></span>findLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::findLights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#gaab30ef14aae93306a6044cb38d835f0c">LightList</a> &amp;&#160;</td>
          <td class="paramname"><em>destList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>lightMask</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows retrieval of the nearest lights to the centre of this <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method allows a list of lights, ordered by proximity to the centre of this <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>, to be retrieved. Can be useful when implementing <a class="el" href="class_ogre_1_1_movable_object.html#a4fbc0296b902a113376688aff724d02d" title="Gets a list of lights, ordered relative to how close they are to this movable object. ">MovableObject::queryLights</a> and <a class="el" href="class_ogre_1_1_renderable.html#a91a5cc5e517b7c79fa510b9fdcc98691" title="Gets a list of lights, ordered relative to how close they are to this renderable. ...">Renderable::getLights</a>. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that only lights could be affecting the frustum will take into account, which cached in scene manager. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a71f1b4d0045fa52c584ab016b0ccc0c1" title="Get the list of lights which could be affecting the frustum. ">SceneManager::_getLightsAffectingFrustum</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_scene_manager.html#ad7330d1bfd3ed9700a1716151acbead3" title="Populate a light list with an ordered set of the lights which are closest to the position specified...">SceneManager::_populateLightList</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destList</td><td>List to be populated with ordered set of lights; will be cleared by this method before population. </td></tr>
    <tr><td class="paramname">radius</td><td>Parameter to specify lights intersecting a given radius of this <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>'s centre. </td></tr>
    <tr><td class="paramname">lightMask</td><td>The mask with which to include / exclude lights </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7b72c066884d0021bd2b2a6693a66c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b72c066884d0021bd2b2a6693a66c3">&#9670;&nbsp;</a></span>setFixedYawAxis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::setFixedYawAxis </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>fixedAxis</em> = <code><a class="el" href="class_ogre_1_1_vector3.html#a8d1a1f7af535bcc8d9c78b1732bc1b90">Vector3::UNIT_Y</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the node whether to yaw around it's own local Y axis or a fixed axis of choice. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method allows you to change the yaw behaviour of the node - by default, it yaws around it's own local Y axis when told to yaw with TS_LOCAL, this makes it yaw around a fixed axis. You only really need this when you're using auto tracking (see setAutoTracking, because when you're manually rotating a node you can specify the TransformSpace in which you wish to work anyway. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useFixed</td><td>If true, the axis passed in the second parameter will always be the yaw axis no matter what the node orientation. If false, the node returns to it's default behaviour. </td></tr>
    <tr><td class="paramname">fixedAxis</td><td>The axis to use if the first parameter is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95cfc691608c8dedd4b9b3b88b3923c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cfc691608c8dedd4b9b3b88b3923c3">&#9670;&nbsp;</a></span>yaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::yaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate the node around the Y-axis. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_node.html#af0d40ab6711058fa41ec905888587b32">Ogre::Node</a>.</p>

</div>
</div>
<a id="aebc1a1db6ae1023ec6e709bd6f82220f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc1a1db6ae1023ec6e709bd6f82220f">&#9670;&nbsp;</a></span>setDirection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::setDirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localDirectionVector</em> = <code><a class="el" href="class_ogre_1_1_vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the node's direction vector ie it's local -z. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that the 'up' vector for the orientation will automatically be recalculated based on the current 'up' vector (i.e. the roll will remain the same). If you need more control, use setOrientation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y,z</td><td>The components of the direction vector </td></tr>
    <tr><td class="paramname">relativeTo</td><td>The space in which this direction vector is expressed </td></tr>
    <tr><td class="paramname">localDirectionVector</td><td>The vector which normally describes the natural direction of the node, usually -Z </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52652642857138f859291a88598877c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52652642857138f859291a88598877c9">&#9670;&nbsp;</a></span>setDirection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::setDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localDirectionVector</em> = <code><a class="el" href="class_ogre_1_1_vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a665c4750906917dd061b141c03d432de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665c4750906917dd061b141c03d432de">&#9670;&nbsp;</a></span>lookAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::lookAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>targetPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localDirectionVector</em> = <code><a class="el" href="class_ogre_1_1_vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Points the local -Z direction of this node at a point in space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetPoint</td><td>A vector specifying the look at point. </td></tr>
    <tr><td class="paramname">relativeTo</td><td>The space in which the point resides </td></tr>
    <tr><td class="paramname">localDirectionVector</td><td>The vector which normally describes the natural direction of the node, usually -Z </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4c8588895d3623bbe0007ea157af1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c8588895d3623bbe0007ea157af1a4">&#9670;&nbsp;</a></span>setAutoTracking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::setAutoTracking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *const&#160;</td>
          <td class="paramname"><em>target</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localDirectionVector</em> = <code><a class="el" href="class_ogre_1_1_vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables / disables automatic tracking of another <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If you enable auto-tracking, this <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> will automatically rotate to point it's -Z at the target <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> every frame, no matter how it or the other <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> move. Note that by default the -Z points at the origin of the target <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>, if you want to tweak this, provide a vector in the 'offset' parameter and the target point will be adjusted. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>If true, tracking will be enabled and the next parameter cannot be null. If false tracking will be disabled and the current orientation will be maintained. </td></tr>
    <tr><td class="paramname">target</td><td>Pointer to the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> to track. Make sure you don't delete this <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> before turning off tracking (e.g. <a class="el" href="class_ogre_1_1_scene_manager.html#aa5b2047b5740b691b0e636d57f2dba7e" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc...">SceneManager::clearScene</a> will delete it so be careful of this). Can be null if and only if the enabled param is false. </td></tr>
    <tr><td class="paramname">localDirectionVector</td><td>The local vector considered to be the usual 'direction' of the node; normally the local -Z but can be another direction. </td></tr>
    <tr><td class="paramname">offset</td><td>If supplied, this is the target point in local space of the target node instead of the origin of the target node. Good for fine tuning the look at point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee4cc71121595aadbbfbc8916ad19809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4cc71121595aadbbfbc8916ad19809">&#9670;&nbsp;</a></span>getAutoTrackTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneNode::getAutoTrackTarget </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the auto tracking target for this node, if any. </p>

</div>
</div>
<a id="a693d0aef8a49e063d4591e62ec44d3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693d0aef8a49e063d4591e62ec44d3db">&#9670;&nbsp;</a></span>getAutoTrackOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&amp; Ogre::SceneNode::getAutoTrackOffset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the auto tracking offset for this node, if the node is auto tracking. </p>

</div>
</div>
<a id="ac98e1967863c0dd15aeb3aa55134e0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98e1967863c0dd15aeb3aa55134e0bd">&#9670;&nbsp;</a></span>getAutoTrackLocalDirection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&amp; Ogre::SceneNode::getAutoTrackLocalDirection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the auto tracking local direction for this node, if it is auto tracking. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_node.html#ae4f67c715bdbf4d0d543939939f110df">Ogre::Node::getDebugRenderable()</a>.</p>

</div>
</div>
<a id="ae12f7409930e2c7ae1fb33c39f71d0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12f7409930e2c7ae1fb33c39f71d0ea">&#9670;&nbsp;</a></span>_autoTrack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::_autoTrack </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method used by OGRE to update auto-tracking cameras. </p>

</div>
</div>
<a id="a807c8125f277a83154d677ce88c97fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807c8125f277a83154d677ce88c97fa7">&#9670;&nbsp;</a></span>getParentSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::SceneNode::getParentSceneNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the parent of this <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>. </p>

</div>
</div>
<a id="afe422d8fd0d6986b99a0d7848369388f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe422d8fd0d6986b99a0d7848369388f">&#9670;&nbsp;</a></span>setVisible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cascade</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes all objects attached to this node become visible / invisible. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is a shortcut to calling <a class="el" href="class_ogre_1_1_scene_node.html#afe422d8fd0d6986b99a0d7848369388f" title="Makes all objects attached to this node become visible / invisible. ">setVisible()</a> on the objects attached to this node, and optionally to all objects attached to child nodes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visible</td><td>Whether the objects are to be made visible or invisible </td></tr>
    <tr><td class="paramname">cascade</td><td>If true, this setting cascades into child nodes too. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0600f3479f44ec86d29e049dad48e9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0600f3479f44ec86d29e049dad48e9dc">&#9670;&nbsp;</a></span>flipVisibility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::flipVisibility </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cascade</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the visibility of all objects attached to this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is a shortcut to calling setVisible(!isVisible()) on the objects attached to this node, and optionally to all objects attached to child nodes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cascade</td><td>If true, this setting cascades into child nodes too. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3afaaf0dfd3c7140342059a94788e341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afaaf0dfd3c7140342059a94788e341">&#9670;&nbsp;</a></span>setDebugDisplayEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::setDebugDisplayEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cascade</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells all objects attached to this node whether to display their debug information or not. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is a shortcut to calling <a class="el" href="class_ogre_1_1_scene_node.html#a3afaaf0dfd3c7140342059a94788e341" title="Tells all objects attached to this node whether to display their debug information or not...">setDebugDisplayEnabled()</a> on the objects attached to this node, and optionally to all objects attached to child nodes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Whether the objects are to display debug info or not </td></tr>
    <tr><td class="paramname">cascade</td><td>If true, this setting cascades into child nodes too. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7491e67f16b068edad24c7458ded3105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7491e67f16b068edad24c7458ded3105">&#9670;&nbsp;</a></span>getDebugRenderable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node_1_1_debug_renderable.html">DebugRenderable</a>* Ogre::SceneNode::getDebugRenderable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As <a class="el" href="class_ogre_1_1_node.html#ae4f67c715bdbf4d0d543939939f110df" title="Get a debug renderable for rendering the Node. ">Node::getDebugRenderable</a>, except scaling is automatically determined. </p>

</div>
</div>
<a id="ae4f67c715bdbf4d0d543939939f110df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f67c715bdbf4d0d543939939f110df">&#9670;&nbsp;</a></span>getDebugRenderable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node_1_1_debug_renderable.html">DebugRenderable</a>* Ogre::Node::getDebugRenderable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>scaling</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a debug renderable for rendering the <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a>. </p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_scene_node.html#ac98e1967863c0dd15aeb3aa55134e0bd">Ogre::SceneNode::getAutoTrackLocalDirection()</a>.</p>

</div>
</div>
<a id="a264df23a0763ef9f8879c97bcbba0f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264df23a0763ef9f8879c97bcbba0f47">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Node::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the node. </p>

</div>
</div>
<a id="a8aae34f3fa479e9c532360f93518160a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aae34f3fa479e9c532360f93518160a">&#9670;&nbsp;</a></span>getParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::getParent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets this node's parent (NULL if this is the root). </p>

</div>
</div>
<a id="a5cf89f99cfb8241341c931c887d6bc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf89f99cfb8241341c931c887d6bc40">&#9670;&nbsp;</a></span>getOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&amp; Ogre::Node::getOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a quaternion representing the nodes orientation. </p>

</div>
</div>
<a id="a307fe0438fb098be6748e044f66155b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307fe0438fb098be6748e044f66155b6">&#9670;&nbsp;</a></span>setOrientation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the orientation of this node via a quaternion. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="ad76bc19286a78c598eec88f80f3b16fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76bc19286a78c598eec88f80f3b16fb">&#9670;&nbsp;</a></span>setOrientation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a40baf1928d11cd3cd678445f5d3d7e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40baf1928d11cd3cd678445f5d3d7e45">&#9670;&nbsp;</a></span>resetOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::resetOrientation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the nodes orientation (local axes as world axes, no rotation). </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="a72e58d4789cfe29e4538399b4250ce5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e58d4789cfe29e4538399b4250ce5a">&#9670;&nbsp;</a></span>setPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the position of the node relative to it's parent. </p>

</div>
</div>
<a id="af054933a193ed930790fcd2fb80ba684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af054933a193ed930790fcd2fb80ba684">&#9670;&nbsp;</a></span>setPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a220642657bd0e307c4ecccb46991267e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220642657bd0e307c4ecccb46991267e">&#9670;&nbsp;</a></span>getPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&amp; Ogre::Node::getPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the position of the node relative to it's parent. </p>

</div>
</div>
<a id="ad031614d90a8fb18750b350c4221cca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad031614d90a8fb18750b350c4221cca2">&#9670;&nbsp;</a></span>setScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the scaling factor applied to this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="a9a075aeadb2ad76cc74ed68e02c9ef26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a075aeadb2ad76cc74ed68e02c9ef26">&#9670;&nbsp;</a></span>setScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a1133d2ef5623b7ede0fa15aacbe47311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1133d2ef5623b7ede0fa15aacbe47311">&#9670;&nbsp;</a></span>getScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&amp; Ogre::Node::getScale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the scaling factor of this node. </p>

</div>
</div>
<a id="a66bf413c5680b8ff4ea913bcb83d25f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bf413c5680b8ff4ea913bcb83d25f1">&#9670;&nbsp;</a></span>setInheritOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setInheritOrientation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inherit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the node whether it should inherit orientation from it's parent node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inherit</td><td>If true, this node's orientation will be affected by its parent's orientation. If false, it will not be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9319dda7b15d46d2e1cb64fd22894811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9319dda7b15d46d2e1cb64fd22894811">&#9670;&nbsp;</a></span>getInheritOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Node::getInheritOrientation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this node is affected by orientation applied to the parent node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd>
<dd>
See setInheritOrientation for more info. </dd></dl>

</div>
</div>
<a id="ae6319b597c3c75a30c521d532466c4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6319b597c3c75a30c521d532466c4d9">&#9670;&nbsp;</a></span>setInheritScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setInheritScale </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inherit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the node whether it should inherit scaling factors from it's parent node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inherit</td><td>If true, this node's scale will be affected by its parent's scale. If false, it will not be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4cdc6392ec73953b327323cac09307b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cdc6392ec73953b327323cac09307b">&#9670;&nbsp;</a></span>getInheritScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Node::getInheritScale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this node is affected by scaling factors applied to the parent node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>See setInheritScale for more info. </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Ogre::Quaternion::IDENTITY</a>, and <a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Ogre::Vector3::ZERO</a>.</p>

</div>
</div>
<a id="a01627f9f9f1a19afe5965c4ba873a573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01627f9f9f1a19afe5965c4ba873a573">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales the node, combining it's current scale with the passed in scaling factor. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method applies an extra scaling factor to the node's existing scale, (unlike setScale which overwrites it) combining it's current scale with the new one. E.g. calling this method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if the existing scale was 1. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="aa670d25ccc7206afb3d7cd6dd709cd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa670d25ccc7206afb3d7cd6dd709cd34">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a45bb282556bc68d072b62097f3006221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bb282556bc68d072b62097f3006221">&#9670;&nbsp;</a></span>translate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the node along the Cartesian axes. </p>
<dl class="section user"><dt></dt><dd>This method moves the node by the supplied vector along the world Cartesian axes, i.e. along world x,y,z </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Vector with x,y,z values representing the translation. </td></tr>
    <tr><td class="paramname">relativeTo</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaef45be557e0d74354214418a61d1412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef45be557e0d74354214418a61d1412">&#9670;&nbsp;</a></span>translate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a198cc48d48e52176bbab96e71cc40696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198cc48d48e52176bbab96e71cc40696">&#9670;&nbsp;</a></span>translate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the node along arbitrary axes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method translates the node by a vector which is relative to a custom set of axes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>A 3x3 Matrix containing 3 column vectors each representing the axes X, Y and Z respectively. In this format the standard cartesian axes would be expressed as: <pre>
    1 0 0
    0 1 0
    0 0 1
    </pre> i.e. the identity matrix. </td></tr>
    <tr><td class="paramname">move</td><td>Vector relative to the axes above. </td></tr>
    <tr><td class="paramname">relativeTo</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37c8ec60f7539ac029c9c47b788b2629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c8ec60f7539ac029c9c47b788b2629">&#9670;&nbsp;</a></span>translate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aeb62b05fce457b8509cb95517154425f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb62b05fce457b8509cb95517154425f">&#9670;&nbsp;</a></span>roll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::roll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate the node around the Z-axis. </p>

</div>
</div>
<a id="ac7d3de1c197a805dd692f775fbbeb022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d3de1c197a805dd692f775fbbeb022">&#9670;&nbsp;</a></span>pitch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::pitch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate the node around the X-axis. </p>

</div>
</div>
<a id="ae1991a38daed956ca9edc635e418d6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1991a38daed956ca9edc635e418d6d8">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate the node around an arbitrary axis. </p>

</div>
</div>
<a id="a711e0d29d57360d7a17d99823a409c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711e0d29d57360d7a17d99823a409c50">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate the node around an aritrary axis using a Quarternion. </p>

</div>
</div>
<a id="a89628765eff6cbe3ed708337764edf7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89628765eff6cbe3ed708337764edf7f">&#9670;&nbsp;</a></span>getLocalAxes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> Ogre::Node::getLocalAxes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a matrix whose columns are the local axes based on the nodes orientation relative to it's parent. </p>

</div>
</div>
<a id="a8baeb7e192fc802f6bf846d3a69dfc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8baeb7e192fc802f6bf846d3a69dfc19">&#9670;&nbsp;</a></span>createChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::createChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>translate</em> = <code><a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotate</em> = <code><a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an unnamed new <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> as a child of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translate</td><td>Initial translation offset of child relative to parent </td></tr>
    <tr><td class="paramname">rotate</td><td>Initial rotation relative to parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5595d0f506945c66795322b1878e16aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5595d0f506945c66795322b1878e16aa">&#9670;&nbsp;</a></span>createChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::createChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>translate</em> = <code><a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotate</em> = <code><a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new named <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> as a child of this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This creates a child node with a given name, which allows you to look the node up from the parent which holds this collection of nodes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translate</td><td>Initial translation offset of child relative to parent </td></tr>
    <tr><td class="paramname">rotate</td><td>Initial rotation relative to parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af01698919040092766a3a4bfab8e7ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01698919040092766a3a4bfab8e7ceb">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a (precreated) child scene node to this node. </p>
<p>If it is attached to another node, it must be detached first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> which is to become a child node of this one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a622555b1fd2f2d1982e7ab9f2313ef1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622555b1fd2f2d1982e7ab9f2313ef1f">&#9670;&nbsp;</a></span>numChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> Ogre::Node::numChildren </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the number of child nodes under this one. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000093">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_node.html#a7eed1961961324d7eaaa6af5cc88dbc5" title="List of sub-nodes of this Node. ">getChildren()</a> </dd></dl>

</div>
</div>
<a id="ae6c9109a64d2f1b3f5bbec7ca324aa6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c9109a64d2f1b3f5bbec7ca324aa6c">&#9670;&nbsp;</a></span>getChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to a child node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>There is an alternate getChild method which returns a named child. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000094">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_node.html#a7eed1961961324d7eaaa6af5cc88dbc5" title="List of sub-nodes of this Node. ">getChildren()</a> </dd></dl>

</div>
</div>
<a id="a23885bdc27be588857d6d67b2dedf3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23885bdc27be588857d6d67b2dedf3f5">&#9670;&nbsp;</a></span>getChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::getChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to a named child node. </p>

</div>
</div>
<a id="ac345064ed97045297dd394c0ac38686e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac345064ed97045297dd394c0ac38686e">&#9670;&nbsp;</a></span>getChildIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html#a0b69022b50c829ec21e9589bbc591597">ChildNodeIterator</a> Ogre::Node::getChildIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an iterator for efficiently looping through all children of this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Using this is faster than repeatedly calling getChild if you want to go through all (or most of) the children of this node. Note that the returned iterator is only valid whilst no children are added or removed from this node. Thus you should not store this returned iterator for later use, nor should you add / remove children whilst iterating through it; store up changes for later. Note that calling methods on returned items in the iterator IS allowed and does not invalidate the iterator. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000095">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_node.html#a7eed1961961324d7eaaa6af5cc88dbc5" title="List of sub-nodes of this Node. ">getChildren()</a> </dd></dl>

</div>
</div>
<a id="a2e673500fba746b62c188771a78ff8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e673500fba746b62c188771a78ff8d6">&#9670;&nbsp;</a></span>getChildIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html#a984f44c9104d5c195f67a2b9d88ebae1">ConstChildNodeIterator</a> Ogre::Node::getChildIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a7eed1961961324d7eaaa6af5cc88dbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eed1961961324d7eaaa6af5cc88dbc5">&#9670;&nbsp;</a></span>getChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_node.html#a8f5f85d7e0f2685a057c66d51398ae5b">ChildNodeMap</a>&amp; Ogre::Node::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of sub-nodes of this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a>. </p>

</div>
</div>
<a id="a912d9d3a804edf9faf8a9e32482502b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912d9d3a804edf9faf8a9e32482502b1">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::removeChild </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the specified child from this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. There is also an alternate version which drops a named child from this node. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_octree_node.html#a27d91455c0aff16b58c6115be6ad76d7">Ogre::OctreeNode</a>.</p>

</div>
</div>
<a id="a1dae5b62b42bcb4590aea678c3056f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dae5b62b42bcb4590aea678c3056f26">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_octree_node.html#ad04d694bde578f6d418a37636e99147e">Ogre::OctreeNode</a>.</p>

</div>
</div>
<a id="a7b1a96d0ca30f5ca56a5dacf27d68f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1a96d0ca30f5ca56a5dacf27d68f6c">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::removeChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the named child from this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_octree_node.html#a537607a4aafbfad12a2bfc2d6fb37e4a">Ogre::OctreeNode</a>.</p>

</div>
</div>
<a id="a79b3e979879906d5500b961a98d04bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b3e979879906d5500b961a98d04bc0">&#9670;&nbsp;</a></span>removeAllChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::removeAllChildren </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all child Nodes attached to this node. </p>
<p>Does not delete the nodes, just detaches them from this parent, potentially to be reattached elsewhere. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_octree_node.html#a8ba5a2e4da664125e8a7da8723157e85">Ogre::OctreeNode</a>.</p>

</div>
</div>
<a id="a31de962a55b0455d7bb3851706073e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31de962a55b0455d7bb3851706073e95">&#9670;&nbsp;</a></span>_setDerivedPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::_setDerivedPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the final world position of the node directly. </p>
<dl class="section remark"><dt>Remarks</dt><dd>It's advisable to use the local setPosition if possible </dd></dl>

</div>
</div>
<a id="acfd410326335dd2b974e832ad102458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd410326335dd2b974e832ad102458b">&#9670;&nbsp;</a></span>_setDerivedOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::_setDerivedOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the final world orientation of the node directly. </p>
<dl class="section remark"><dt>Remarks</dt><dd>It's advisable to use the local setOrientation if possible, this simply does the conversion for you. </dd></dl>

</div>
</div>
<a id="aae6afb3ab2d6bece0391c6592b946c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6afb3ab2d6bece0391c6592b946c11">&#9670;&nbsp;</a></span>_getDerivedOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&amp; Ogre::Node::_getDerivedOrientation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the orientation of the node as derived from all parents. </p>

</div>
</div>
<a id="aa6d8ef3c62635ce44260efd749a4bbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d8ef3c62635ce44260efd749a4bbfc">&#9670;&nbsp;</a></span>_getDerivedPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&amp; Ogre::Node::_getDerivedPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the position of the node as derived from all parents. </p>

</div>
</div>
<a id="aac948570c146461805c4ff0d79a7de2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac948570c146461805c4ff0d79a7de2f">&#9670;&nbsp;</a></span>_getDerivedScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&amp; Ogre::Node::_getDerivedScale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the scaling factor of the node as derived from all parents. </p>

</div>
</div>
<a id="ac50b010530f4ed9f7aa4c590cf2cb5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50b010530f4ed9f7aa4c590cf2cb5d1">&#9670;&nbsp;</a></span>_getFullTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&amp; Ogre::Node::_getFullTransform </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the full transformation matrix for this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method returns the full transformation matrix for this node, including the effect of any parent node transformations, provided they have been updated using the <a class="el" href="class_ogre_1_1_node.html#a5e829eb9715fa8fa1fdc99739d734eac" title="Internal method to update the Node. ">Node::_update</a> method. This should only be called by a <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> which knows the derived transforms have been updated before calling this method. Applications using <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should just use the relative transforms. </dd></dl>

</div>
</div>
<a id="a9aadf525c7f437c32cd17b0ccd606f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aadf525c7f437c32cd17b0ccd606f71">&#9670;&nbsp;</a></span>setListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a listener for this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note for size and performance reasons only one listener per node is allowed. </dd></dl>

</div>
</div>
<a id="aad75165137ce70fd865b3c5aa302a3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad75165137ce70fd865b3c5aa302a3bc">&#9670;&nbsp;</a></span>getListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a>* Ogre::Node::getListener </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current listener for this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a>. </p>

</div>
</div>
<a id="a7832ae769b627172de3cf594b9769084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7832ae769b627172de3cf594b9769084">&#9670;&nbsp;</a></span>setInitialState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setInitialState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current transform of this node to be the 'initial state' ie that position / orientation / scale to be used as a basis for delta values used in keyframe animation. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You never need to call this method unless you plan to animate this node. If you do plan to animate it, call this method once you've loaded the node with it's base state, ie the state on which all keyframes are based. </dd></dl>
<dl class="section user"><dt></dt><dd>If you never call this method, the initial state is the identity transform, ie do nothing. </dd></dl>

</div>
</div>
<a id="a398e7142b2fbadea2a63097d37d4112b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398e7142b2fbadea2a63097d37d4112b">&#9670;&nbsp;</a></span>resetToInitialState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::resetToInitialState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the position / orientation / scale of this node to it's initial state, see setInitialState for more info. </p>

</div>
</div>
<a id="a515361d8231fc86d9b602ba55f714fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515361d8231fc86d9b602ba55f714fa9">&#9670;&nbsp;</a></span>getInitialPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&amp; Ogre::Node::getInitialPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the initial position of this node, see setInitialState for more info. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Also resets the cumulative animation weight used for blending. </dd></dl>

</div>
</div>
<a id="a8302c220e1e1f9ae9d83142bcb2e30ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8302c220e1e1f9ae9d83142bcb2e30ca">&#9670;&nbsp;</a></span>convertWorldToLocalPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::convertWorldToLocalPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>worldPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the local position, relative to this node, of the given world-space position. </p>

</div>
</div>
<a id="ad0bba0ab306650f26ab9f59df8666f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bba0ab306650f26ab9f59df8666f3c">&#9670;&nbsp;</a></span>convertLocalToWorldPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::convertLocalToWorldPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the world position of a point in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a id="a25e1a5a9da67b7bc7292b74ee2cfaba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e1a5a9da67b7bc7292b74ee2cfaba6">&#9670;&nbsp;</a></span>convertWorldToLocalDirection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::convertWorldToLocalDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>worldDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the local direction, relative to this node, of the given world-space direction. </p>

</div>
</div>
<a id="a3969475af6a52109883d7c7d44f35fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3969475af6a52109883d7c7d44f35fec">&#9670;&nbsp;</a></span>convertLocalToWorldDirection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::convertLocalToWorldDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the world direction of a point in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a id="a553f4e76d2416bd2c514f82c2f6117b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553f4e76d2416bd2c514f82c2f6117b7">&#9670;&nbsp;</a></span>convertWorldToLocalOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> Ogre::Node::convertWorldToLocalOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>worldOrientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the local orientation, relative to this node, of the given world-space orientation. </p>

</div>
</div>
<a id="aa87d582898b40ea668fe67ab428cfdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87d582898b40ea668fe67ab428cfdcf">&#9670;&nbsp;</a></span>convertLocalToWorldOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> Ogre::Node::convertLocalToWorldOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>localOrientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the world orientation of an orientation in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a id="a10da4e58434d3e61c6d76f97a0fd1a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10da4e58434d3e61c6d76f97a0fd1a80">&#9670;&nbsp;</a></span>getInitialOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&amp; Ogre::Node::getInitialOrientation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the initial orientation of this node, see setInitialState for more info. </p>

</div>
</div>
<a id="a5b9b0b08edc2984d41ad38520354a407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9b0b08edc2984d41ad38520354a407">&#9670;&nbsp;</a></span>getInitialScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&amp; Ogre::Node::getInitialScale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the initial position of this node, see setInitialState for more info. </p>

</div>
</div>
<a id="a1d6249bf582ea32554236af812a2e8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6249bf582ea32554236af812a2e8a2">&#9670;&nbsp;</a></span>getSquaredViewDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Node::getSquaredViewDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>cam</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function, get the squared view depth. </p>

</div>
</div>
<a id="a8671415cc4cf15e45bf716a823678736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8671415cc4cf15e45bf716a823678736">&#9670;&nbsp;</a></span>needUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::needUpdate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceParentUpdate</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To be called in the event of transform changes to this node that require it's recalculation. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This not only tags the node state as being 'dirty', it also requests it's parent to know about it's dirtiness so it will get an update next time. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forceParentUpdate</td><td>Even if the node thinks it has already told it's parent, tell it anyway </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_bone.html#a5b32f720032133ebc0706669b20ee528">Ogre::Bone</a>, and <a class="el" href="class_ogre_1_1_tag_point.html#aacb9004b79fb9fceac07ec7963da944e">Ogre::TagPoint</a>.</p>

</div>
</div>
<a id="a97676492945c888304b71ad4edc85e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97676492945c888304b71ad4edc85e5a">&#9670;&nbsp;</a></span>requestUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::requestUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceParentUpdate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by children to notify their parent that they need an update. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forceParentUpdate</td><td>Even if the node thinks it has already told it's parent, tell it anyway </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4bca65a1d911499aba99843fa41b3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bca65a1d911499aba99843fa41b3e9">&#9670;&nbsp;</a></span>cancelUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::cancelUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by children to notify their parent that they no longer need an update. </p>

</div>
</div>
<a id="a4609e37d3a70cf4318c99e9e1fb8dfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4609e37d3a70cf4318c99e9e1fb8dfd9">&#9670;&nbsp;</a></span>queueNeedUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Node::queueNeedUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue a 'needUpdate' call to a node safely. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You can't call <a class="el" href="class_ogre_1_1_node.html#a8671415cc4cf15e45bf716a823678736" title="To be called in the event of transform changes to this node that require it&#39;s recalculation. ">needUpdate()</a> during the scene graph update, e.g. in response to a <a class="el" href="class_ogre_1_1_node_1_1_listener.html" title="Listener which gets called back on Node events. ">Node::Listener</a> hook, because the graph is already being updated, and update flag changes cannot be made reliably in that context. Call this method if you need to queue a needUpdate call in this case. </dd></dl>

</div>
</div>
<a id="af990db414b5c4b26b055375401d3b5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af990db414b5c4b26b055375401d3b5d1">&#9670;&nbsp;</a></span>processQueuedUpdates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Node::processQueuedUpdates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process queued 'needUpdate' calls. </p>

</div>
</div>
<a id="a2fdf947d54d8b67b5fef19d68da899ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdf947d54d8b67b5fef19d68da899ae">&#9670;&nbsp;</a></span>setUserAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setUserAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_any.html">Any</a> &amp;&#160;</td>
          <td class="paramname"><em>anything</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000096">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance. ">UserObjectBindings::setUserAny</a> via <a class="el" href="class_ogre_1_1_node.html#af3fcf16e43b07e046816125cbb8dc8f3" title="Return an instance of user objects binding associated with this class. ">getUserObjectBindings()</a> instead.</dd></dl>
<p>Sets any kind of user value on this object. </p><dl class="section remark"><dt>Remarks</dt><dd>This method allows you to associate any user value you like with this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a>. This can be a pointer back to one of your own classes for instance. </dd></dl>

</div>
</div>
<a id="a9fa158a89aa8c4d8113ea52435eda1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa158a89aa8c4d8113ea52435eda1da">&#9670;&nbsp;</a></span>getUserAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_any.html">Any</a>&amp; Ogre::Node::getUserAny </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000097">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_user_object_bindings.html#a7b0c9bd7cf25e2d95aea3ee5138ef5b5" title="Retrieves the custom key less user object associated with this class. ">UserObjectBindings::getUserAny</a> via <a class="el" href="class_ogre_1_1_node.html#af3fcf16e43b07e046816125cbb8dc8f3" title="Return an instance of user objects binding associated with this class. ">getUserObjectBindings()</a> instead.</dd></dl>
<p>Retrieves the custom user value associated with this object. </p>

</div>
</div>
<a id="af3fcf16e43b07e046816125cbb8dc8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fcf16e43b07e046816125cbb8dc8f3">&#9670;&nbsp;</a></span>getUserObjectBindings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::Node::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance. ">UserObjectBindings::setUserAny</a>. </dd></dl>

</div>
</div>
<a id="aa154e07b616313f4c345ec6c0da635cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa154e07b616313f4c345ec6c0da635cd">&#9670;&nbsp;</a></span>getUserObjectBindings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::Node::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance. ">UserObjectBindings::setUserAny</a>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_bsp_scene_node_8h.html">OgreBspSceneNode.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_bsp_scene_node.html">BspSceneNode</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
