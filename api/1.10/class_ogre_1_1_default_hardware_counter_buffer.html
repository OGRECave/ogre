<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::DefaultHardwareCounterBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_ogre_1_1_default_hardware_counter_buffer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_default_hardware_counter_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::DefaultHardwareCounterBuffer Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___render_system.html">RenderSystem</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Specialisation of <a class="el" href="class_ogre_1_1_hardware_counter_buffer.html" title="Specialisation of HardwareBuffer for a counter buffer. ">HardwareCounterBuffer</a> for emulation.  
 <a href="class_ogre_1_1_default_hardware_counter_buffer.html#details">More...</a></p>

<p><code>#include &lt;OgreDefaultHardwareBufferManager.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::DefaultHardwareCounterBuffer:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_default_hardware_counter_buffer__inherit__graph.svg" width="214" height="276"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aac34930556f611928ec9157c04bd1b0f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#aac34930556f611928ec9157c04bd1b0f">LockOptions</a> { <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_hardware_buffer.html#aac34930556f611928ec9157c04bd1b0fae11601d29cd56aad7ea7a1b23a688b0e">HBL_NORMAL</a>, 
<a class="el" href="class_ogre_1_1_hardware_buffer.html#aac34930556f611928ec9157c04bd1b0fa176ad39ac15fc0a6028d820a6fe228ae">HBL_DISCARD</a>, 
<a class="el" href="class_ogre_1_1_hardware_buffer.html#aac34930556f611928ec9157c04bd1b0faa364c1511514cd4d7ee1e7092eb41288">HBL_READ_ONLY</a>, 
<a class="el" href="class_ogre_1_1_hardware_buffer.html#aac34930556f611928ec9157c04bd1b0fa32a2f7b1c3430cc9c3f0f665934d0c4a">HBL_NO_OVERWRITE</a>, 
<br />
&#160;&#160;<a class="el" href="class_ogre_1_1_hardware_buffer.html#aac34930556f611928ec9157c04bd1b0faf4acad29e302c7c02ce72c3fce8990df">HBL_WRITE_ONLY</a>
<br />
 }<tr class="memdesc:aac34930556f611928ec9157c04bd1b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locking options.  <a href="class_ogre_1_1_hardware_buffer.html#aac34930556f611928ec9157c04bd1b0f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aac34930556f611928ec9157c04bd1b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11b63d113942454f431e7edeec86716"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716">UploadOptions</a> { <a class="el" href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716a2dd88219456f6e18989efe92cfab530d">HBU_DEFAULT</a> = 0x0000, 
<a class="el" href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716ad38b82757bd310710a6bebebd60b0d54">HBU_ON_DEMAND</a> = 0x0001
 }<tr class="memdesc:ad11b63d113942454f431e7edeec86716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device load options The following enum is used to controls how data is loaded to devices in a multi device environment This enum only works with the Direct3D 9 render system (5/2013).  <a href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad11b63d113942454f431e7edeec86716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51f5970d879af736e4cf53e1ec46630"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630">Usage</a> { <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630a6f26f67ab31d60248314c9c6c77c9edb">HBU_STATIC</a> = 1, 
<a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630abec61c14b13652a06566a79afd6f7518">HBU_DYNAMIC</a> = 2, 
<a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630a2fe20ff00e9acb928a2d9680f0c505e2">HBU_WRITE_ONLY</a> = 4, 
<a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630a246699879ba7647973a2d8ed86acf76f">HBU_DISCARDABLE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630a5ffbb339becd31435c5f616be4c28996">HBU_STATIC_WRITE_ONLY</a> = HBU_STATIC | HBU_WRITE_ONLY, 
<a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630aa0c82d1b27d6cc04e4b5f6d47a22a74c">HBU_DYNAMIC_WRITE_ONLY</a> = HBU_DYNAMIC | HBU_WRITE_ONLY, 
<a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630a29ff2e0fd2b408359e84291b27282516">HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE</a> = HBU_DYNAMIC_WRITE_ONLY | HBU_DISCARDABLE
<br />
 }<tr class="memdesc:ae51f5970d879af736e4cf53e1ec46630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enums describing buffer usage; not mutually exclusive.  <a href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae51f5970d879af736e4cf53e1ec46630"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae43f3b7c77ab4168d925de59d6865425"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_hardware_counter_buffer.html#ae43f3b7c77ab4168d925de59d6865425">DefaultHardwareCounterBuffer</a> (<a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> *mgr, size_t sizeBytes, <a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630">HardwareBuffer::Usage</a> usage, bool useShadowBuffer=false, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name=&quot;&quot;)</td></tr>
<tr class="separator:ae43f3b7c77ab4168d925de59d6865425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bf06975ac3feef907f925645bd5ae3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_hardware_counter_buffer.html#ad7bf06975ac3feef907f925645bd5ae3">~DefaultHardwareCounterBuffer</a> ()</td></tr>
<tr class="separator:ad7bf06975ac3feef907f925645bd5ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344c52f2214eaff097d5fbc390e7684b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a344c52f2214eaff097d5fbc390e7684b">_updateFromShadow</a> (void)</td></tr>
<tr class="memdesc:a344c52f2214eaff097d5fbc390e7684b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the real buffer from the shadow buffer, if required.  <a href="#a344c52f2214eaff097d5fbc390e7684b">More...</a><br /></td></tr>
<tr class="separator:a344c52f2214eaff097d5fbc390e7684b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721891f0c0bd391dd5848c8a585ba054"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a721891f0c0bd391dd5848c8a585ba054">copyData</a> (<a class="el" href="class_ogre_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;srcBuffer, size_t srcOffset, size_t dstOffset, size_t length, bool discardWholeBuffer=false)</td></tr>
<tr class="memdesc:a721891f0c0bd391dd5848c8a585ba054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from another buffer into this one.  <a href="#a721891f0c0bd391dd5848c8a585ba054">More...</a><br /></td></tr>
<tr class="separator:a721891f0c0bd391dd5848c8a585ba054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf3147b1f99a81dd84fb7b978c4686d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a0bf3147b1f99a81dd84fb7b978c4686d">copyData</a> (<a class="el" href="class_ogre_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;srcBuffer)</td></tr>
<tr class="memdesc:a0bf3147b1f99a81dd84fb7b978c4686d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all data from another buffer into this one.  <a href="#a0bf3147b1f99a81dd84fb7b978c4686d">More...</a><br /></td></tr>
<tr class="separator:a0bf3147b1f99a81dd84fb7b978c4686d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55b7b464be821ef2536e2470b15865c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___render_system.html#ga55b7b464be821ef2536e2470b15865c9">getManager</a> () const</td></tr>
<tr class="memdesc:ga55b7b464be821ef2536e2470b15865c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the manager of this buffer, if any.  <a href="group___render_system.html#ga55b7b464be821ef2536e2470b15865c9">More...</a><br /></td></tr>
<tr class="separator:ga55b7b464be821ef2536e2470b15865c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbd3b457eeca52094cf44fb8b3f853d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___render_system.html#gacbd3b457eeca52094cf44fb8b3f853d6">getName</a> () const</td></tr>
<tr class="separator:gacbd3b457eeca52094cf44fb8b3f853d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9194c7e8b536f4825b15b9e6a6912ce8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a9194c7e8b536f4825b15b9e6a6912ce8">getSizeInBytes</a> (void) const</td></tr>
<tr class="memdesc:a9194c7e8b536f4825b15b9e6a6912ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of this buffer in bytes.  <a href="#a9194c7e8b536f4825b15b9e6a6912ce8">More...</a><br /></td></tr>
<tr class="separator:a9194c7e8b536f4825b15b9e6a6912ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5ee6468dcb269e422e213b82726e4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630">Usage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a9c5ee6468dcb269e422e213b82726e4f">getUsage</a> (void) const</td></tr>
<tr class="memdesc:a9c5ee6468dcb269e422e213b82726e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Usage flags with which this buffer was created.  <a href="#a9c5ee6468dcb269e422e213b82726e4f">More...</a><br /></td></tr>
<tr class="separator:a9c5ee6468dcb269e422e213b82726e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a623d95552d9b1858e5c300a3ad68c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a40a623d95552d9b1858e5c300a3ad68c">hasShadowBuffer</a> (void) const</td></tr>
<tr class="memdesc:a40a623d95552d9b1858e5c300a3ad68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this buffer has a system memory shadow for quicker reading.  <a href="#a40a623d95552d9b1858e5c300a3ad68c">More...</a><br /></td></tr>
<tr class="separator:a40a623d95552d9b1858e5c300a3ad68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c874c6b30c39aa38ae0d6abe2ba42bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a7c874c6b30c39aa38ae0d6abe2ba42bc">isLocked</a> (void) const</td></tr>
<tr class="memdesc:a7c874c6b30c39aa38ae0d6abe2ba42bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this buffer is currently locked.  <a href="#a7c874c6b30c39aa38ae0d6abe2ba42bc">More...</a><br /></td></tr>
<tr class="separator:a7c874c6b30c39aa38ae0d6abe2ba42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1881a6106c59d5aae27589ca1bca5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a0e1881a6106c59d5aae27589ca1bca5d">isSystemMemory</a> (void) const</td></tr>
<tr class="memdesc:a0e1881a6106c59d5aae27589ca1bca5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this buffer is held in system memory.  <a href="#a0e1881a6106c59d5aae27589ca1bca5d">More...</a><br /></td></tr>
<tr class="separator:a0e1881a6106c59d5aae27589ca1bca5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b85f6f33832f4f69d6bb869c88ccfd3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_hardware_counter_buffer.html#a8b85f6f33832f4f69d6bb869c88ccfd3">lock</a> (size_t offset, size_t length, <a class="el" href="class_ogre_1_1_hardware_buffer.html#aac34930556f611928ec9157c04bd1b0f">LockOptions</a> options, <a class="el" href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716">UploadOptions</a> uploadOpt=<a class="el" href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716a2dd88219456f6e18989efe92cfab530d">HBU_DEFAULT</a>)</td></tr>
<tr class="memdesc:a8b85f6f33832f4f69d6bb869c88ccfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override <a class="el" href="class_ogre_1_1_hardware_buffer.html" title="Abstract class defining common features of hardware buffers. ">HardwareBuffer</a> to turn off all shadowing.  <a href="#a8b85f6f33832f4f69d6bb869c88ccfd3">More...</a><br /></td></tr>
<tr class="separator:a8b85f6f33832f4f69d6bb869c88ccfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee477b6f3d54b83060b212e0b68b129"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#aaee477b6f3d54b83060b212e0b68b129">lock</a> (<a class="el" href="class_ogre_1_1_hardware_buffer.html#aac34930556f611928ec9157c04bd1b0f">LockOptions</a> options, <a class="el" href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716">UploadOptions</a> uploadOpt=<a class="el" href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716a2dd88219456f6e18989efe92cfab530d">HBU_DEFAULT</a>)</td></tr>
<tr class="separator:aaee477b6f3d54b83060b212e0b68b129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0a8558644446eb744a1b5d6d4dbea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_hardware_counter_buffer.html#ace0a8558644446eb744a1b5d6d4dbea9">readData</a> (size_t offset, size_t length, void *pDest)</td></tr>
<tr class="memdesc:ace0a8558644446eb744a1b5d6d4dbea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_ogre_1_1_hardware_buffer.html" title="Abstract class defining common features of hardware buffers. ">HardwareBuffer</a>.  <a href="#ace0a8558644446eb744a1b5d6d4dbea9">More...</a><br /></td></tr>
<tr class="separator:ace0a8558644446eb744a1b5d6d4dbea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688e1be4a913099ce5e06172771e2d45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a688e1be4a913099ce5e06172771e2d45">suppressHardwareUpdate</a> (bool suppress)</td></tr>
<tr class="memdesc:a688e1be4a913099ce5e06172771e2d45"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a> true to suppress hardware upload of shadow buffer changes.  <a href="#a688e1be4a913099ce5e06172771e2d45">More...</a><br /></td></tr>
<tr class="separator:a688e1be4a913099ce5e06172771e2d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0106887fa02d52596d77b601ebc0859"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_hardware_counter_buffer.html#aa0106887fa02d52596d77b601ebc0859">unlock</a> (void)</td></tr>
<tr class="memdesc:aa0106887fa02d52596d77b601ebc0859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override <a class="el" href="class_ogre_1_1_hardware_buffer.html" title="Abstract class defining common features of hardware buffers. ">HardwareBuffer</a> to turn off all shadowing.  <a href="#aa0106887fa02d52596d77b601ebc0859">More...</a><br /></td></tr>
<tr class="separator:aa0106887fa02d52596d77b601ebc0859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700f6f79c73fa3e1b8225ebf4177c884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_hardware_counter_buffer.html#a700f6f79c73fa3e1b8225ebf4177c884">writeData</a> (size_t offset, size_t length, const void *pSource, bool discardWholeBuffer=false)</td></tr>
<tr class="memdesc:a700f6f79c73fa3e1b8225ebf4177c884"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_ogre_1_1_hardware_buffer.html" title="Abstract class defining common features of hardware buffers. ">HardwareBuffer</a>.  <a href="#a700f6f79c73fa3e1b8225ebf4177c884">More...</a><br /></td></tr>
<tr class="separator:a700f6f79c73fa3e1b8225ebf4177c884"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Specialisation of <a class="el" href="class_ogre_1_1_hardware_counter_buffer.html" title="Specialisation of HardwareBuffer for a counter buffer. ">HardwareCounterBuffer</a> for emulation. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ae51f5970d879af736e4cf53e1ec46630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51f5970d879af736e4cf53e1ec46630">&#9670;&nbsp;</a></span>Usage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630">Ogre::HardwareBuffer::Usage</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enums describing buffer usage; not mutually exclusive. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae51f5970d879af736e4cf53e1ec46630a6f26f67ab31d60248314c9c6c77c9edb"></a>HBU_STATIC&#160;</td><td class="fielddoc"><p>Static buffer which the application rarely modifies once created. </p>
<p>Modifying the contents of this buffer will involve a performance hit. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae51f5970d879af736e4cf53e1ec46630abec61c14b13652a06566a79afd6f7518"></a>HBU_DYNAMIC&#160;</td><td class="fielddoc"><p>Indicates the application would like to modify this buffer with the CPU fairly often. </p>
<p>Buffers created with this flag will typically end up in AGP memory rather than video memory.</p>
<p>This is the least optimal buffer setting. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae51f5970d879af736e4cf53e1ec46630a2fe20ff00e9acb928a2d9680f0c505e2"></a>HBU_WRITE_ONLY&#160;</td><td class="fielddoc"><p>Indicates the application will never read the contents of the buffer back, it will only ever write data. </p>
<p>Locking a buffer with this flag will ALWAYS return a pointer to new, blank memory rather than the memory associated with the contents of the buffer; this avoids DMA stalls because you can write to a new memory area while the previous one is being used.</p>
<p>However, you may read from it’s shadow buffer if you set one up </p>
</td></tr>
<tr><td class="fieldname"><a id="ae51f5970d879af736e4cf53e1ec46630a246699879ba7647973a2d8ed86acf76f"></a>HBU_DISCARDABLE&#160;</td><td class="fielddoc"><p>Indicates that the application will be refilling the contents of the buffer regularly (not just updating, but generating the contents from scratch), and therefore does not mind if the contents of the buffer are lost somehow and need to be recreated. </p>
<p>This allows and additional level of optimisation on the buffer. This option only really makes sense when combined with HBU_DYNAMIC_WRITE_ONLY. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae51f5970d879af736e4cf53e1ec46630a5ffbb339becd31435c5f616be4c28996"></a>HBU_STATIC_WRITE_ONLY&#160;</td><td class="fielddoc"><p>Combination of HBU_STATIC and HBU_WRITE_ONLY This is the optimal buffer usage setting. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae51f5970d879af736e4cf53e1ec46630aa0c82d1b27d6cc04e4b5f6d47a22a74c"></a>HBU_DYNAMIC_WRITE_ONLY&#160;</td><td class="fielddoc"><p>Combination of HBU_DYNAMIC and HBU_WRITE_ONLY. </p>
<p>If you use this, strongly consider using HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE instead if you update the entire contents of the buffer very regularly. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae51f5970d879af736e4cf53e1ec46630a29ff2e0fd2b408359e84291b27282516"></a>HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE&#160;</td><td class="fielddoc"><p>Combination of HBU_DYNAMIC, HBU_WRITE_ONLY and HBU_DISCARDABLE This means that you expect to replace the entire contents of the buffer on an extremely regular basis, most likely every frame. </p>
<p>By selecting this option, you free the system up from having to be concerned about losing the existing contents of the buffer at any time, because if it does lose them, you will be replacing them next frame anyway. On some platforms this can make a significant performance difference, so you should try to use this whenever you have a buffer you need to update regularly. Note that if you create a buffer this way, you should use the HBL_DISCARD flag when locking the contents of it for writing. </p>
</td></tr>
</table>

</div>
</div>
<a id="aac34930556f611928ec9157c04bd1b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac34930556f611928ec9157c04bd1b0f">&#9670;&nbsp;</a></span>LockOptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_hardware_buffer.html#aac34930556f611928ec9157c04bd1b0f">Ogre::HardwareBuffer::LockOptions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locking options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aac34930556f611928ec9157c04bd1b0fae11601d29cd56aad7ea7a1b23a688b0e"></a>HBL_NORMAL&#160;</td><td class="fielddoc"><p>Normal mode, ie allows read/write and contents are preserved. </p>
<p>This kind of lock allows reading and writing from the buffer - it’s also the least optimal because basically you’re telling the card you could be doing anything at all. If you’re not using a shadow buffer, it requires the buffer to be transferred from the card and back again. If you’re using a shadow buffer the effect is minimal. </p>
</td></tr>
<tr><td class="fieldname"><a id="aac34930556f611928ec9157c04bd1b0fa176ad39ac15fc0a6028d820a6fe228ae"></a>HBL_DISCARD&#160;</td><td class="fielddoc"><p>Discards the <em>entire</em> buffer while locking. </p>
<p>This means you are happy for the card to discard the entire current contents of the buffer. Implicitly this means you are not going to read the data - it also means that the card can avoid any stalls if the buffer is currently being rendered from, because it will actually give you an entirely different one. Use this wherever possible when you are locking a buffer which was not created with a shadow buffer. If you are using a shadow buffer it matters less, although with a shadow buffer it’s preferable to lock the entire buffer at once, because that allows the shadow buffer to use HBL_DISCARD when it uploads the updated contents to the real buffer. Only allowed on buffers created with the HBU_DYNAMIC flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="aac34930556f611928ec9157c04bd1b0faa364c1511514cd4d7ee1e7092eb41288"></a>HBL_READ_ONLY&#160;</td><td class="fielddoc"><p>Lock the buffer for reading only. </p>
<p>Not allowed in buffers which are created with HBU_WRITE_ONLY. Mandatory on static buffers, i.e. those created without the HBU_DYNAMIC flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="aac34930556f611928ec9157c04bd1b0fa32a2f7b1c3430cc9c3f0f665934d0c4a"></a>HBL_NO_OVERWRITE&#160;</td><td class="fielddoc"><p>As HBL_DISCARD, except the application guarantees not to overwrite any region of the buffer which has already been used in this frame, can allow some optimisation on some APIs. </p>
<p>This is only useful on buffers with no shadow buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="aac34930556f611928ec9157c04bd1b0faf4acad29e302c7c02ce72c3fce8990df"></a>HBL_WRITE_ONLY&#160;</td><td class="fielddoc"><p>Lock the buffer for writing only. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad11b63d113942454f431e7edeec86716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11b63d113942454f431e7edeec86716">&#9670;&nbsp;</a></span>UploadOptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716">Ogre::HardwareBuffer::UploadOptions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Device load options The following enum is used to controls how data is loaded to devices in a multi device environment This enum only works with the Direct3D 9 render system (5/2013). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000055">Deprecated:</a></b></dt><dd>do not use </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad11b63d113942454f431e7edeec86716a2dd88219456f6e18989efe92cfab530d"></a>HBU_DEFAULT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad11b63d113942454f431e7edeec86716ad38b82757bd310710a6bebebd60b0d54"></a>HBU_ON_DEMAND&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae43f3b7c77ab4168d925de59d6865425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43f3b7c77ab4168d925de59d6865425">&#9670;&nbsp;</a></span>DefaultHardwareCounterBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::DefaultHardwareCounterBuffer::DefaultHardwareCounterBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630">HardwareBuffer::Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7bf06975ac3feef907f925645bd5ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bf06975ac3feef907f925645bd5ae3">&#9670;&nbsp;</a></span>~DefaultHardwareCounterBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::DefaultHardwareCounterBuffer::~DefaultHardwareCounterBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace0a8558644446eb744a1b5d6d4dbea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0a8558644446eb744a1b5d6d4dbea9">&#9670;&nbsp;</a></span>readData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::DefaultHardwareCounterBuffer::readData </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_ogre_1_1_hardware_buffer.html" title="Abstract class defining common features of hardware buffers. ">HardwareBuffer</a>. </p>

<p>Implements <a class="el" href="class_ogre_1_1_hardware_buffer.html#a552f466b57ba77f29e083266d4688765">Ogre::HardwareBuffer</a>.</p>

</div>
</div>
<a id="a700f6f79c73fa3e1b8225ebf4177c884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700f6f79c73fa3e1b8225ebf4177c884">&#9670;&nbsp;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::DefaultHardwareCounterBuffer::writeData </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discardWholeBuffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_ogre_1_1_hardware_buffer.html" title="Abstract class defining common features of hardware buffers. ">HardwareBuffer</a>. </p>

<p>Implements <a class="el" href="class_ogre_1_1_hardware_buffer.html#a8c313688a0df3c28a36738c31fcbc3ee">Ogre::HardwareBuffer</a>.</p>

</div>
</div>
<a id="a8b85f6f33832f4f69d6bb869c88ccfd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b85f6f33832f4f69d6bb869c88ccfd3">&#9670;&nbsp;</a></span>lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* Ogre::DefaultHardwareCounterBuffer::lock </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html#aac34930556f611928ec9157c04bd1b0f">LockOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716">UploadOptions</a>&#160;</td>
          <td class="paramname"><em>uploadOpt</em> = <code><a class="el" href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716a2dd88219456f6e18989efe92cfab530d">HBU_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override <a class="el" href="class_ogre_1_1_hardware_buffer.html" title="Abstract class defining common features of hardware buffers. ">HardwareBuffer</a> to turn off all shadowing. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_hardware_buffer.html#a22e4620e677f33050ac3c0df43130e20">Ogre::HardwareBuffer</a>.</p>

</div>
</div>
<a id="aa0106887fa02d52596d77b601ebc0859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0106887fa02d52596d77b601ebc0859">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::DefaultHardwareCounterBuffer::unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override <a class="el" href="class_ogre_1_1_hardware_buffer.html" title="Abstract class defining common features of hardware buffers. ">HardwareBuffer</a> to turn off all shadowing. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_hardware_buffer.html#a64ddd429ff2c8ac4f0cca5decb5c6757">Ogre::HardwareBuffer</a>.</p>

</div>
</div>
<a id="aaee477b6f3d54b83060b212e0b68b129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee477b6f3d54b83060b212e0b68b129">&#9670;&nbsp;</a></span>lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* Ogre::HardwareBuffer::lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html#aac34930556f611928ec9157c04bd1b0f">LockOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716">UploadOptions</a>&#160;</td>
          <td class="paramname"><em>uploadOpt</em> = <code><a class="el" href="class_ogre_1_1_hardware_buffer.html#ad11b63d113942454f431e7edeec86716a2dd88219456f6e18989efe92cfab530d">HBU_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a721891f0c0bd391dd5848c8a585ba054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721891f0c0bd391dd5848c8a585ba054">&#9670;&nbsp;</a></span>copyData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::HardwareBuffer::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discardWholeBuffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from another buffer into this one. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that the source buffer must not be created with the usage HBU_WRITE_ONLY otherwise this will fail. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuffer</td><td>The buffer from which to read the copied data </td></tr>
    <tr><td class="paramname">srcOffset</td><td>Offset in the source buffer at which to start reading </td></tr>
    <tr><td class="paramname">dstOffset</td><td>Offset in the destination buffer to start writing </td></tr>
    <tr><td class="paramname">length</td><td>Length of the data to copy, in bytes. </td></tr>
    <tr><td class="paramname">discardWholeBuffer</td><td>If true, will discard the entire contents of this buffer before copying </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_hardware_buffer.html#a09a5a1ce569c36ad6b180b9cb3ebb67d">Ogre::D3D11HardwareBuffer</a>, <a class="el" href="class_ogre_1_1_g_l_e_s2_hardware_vertex_buffer.html#afefa05dcff66fa31f42fdaa3cfea3306">Ogre::GLES2HardwareVertexBuffer</a>, <a class="el" href="class_ogre_1_1_g_l_e_s2_hardware_index_buffer.html#a3bd36b4afae92a7290ef2e10914fb036">Ogre::GLES2HardwareIndexBuffer</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_hardware_shader_storage_buffer.html#af07ad7987c6163b9c35806258731174e">Ogre::GL3PlusHardwareShaderStorageBuffer</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_hardware_uniform_buffer.html#ae6ffa229d8a5cc47b89daeca337569ff">Ogre::GL3PlusHardwareUniformBuffer</a>, <a class="el" href="class_ogre_1_1_g_l_e_s2_hardware_uniform_buffer.html#abe6f9462acaf1030f71688b891e6e3b4">Ogre::GLES2HardwareUniformBuffer</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_hardware_counter_buffer.html#a28234be9fd3744901c51edef35db8d70">Ogre::GL3PlusHardwareCounterBuffer</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_hardware_vertex_buffer.html#ad4c0b74df9eb2b9558f79e52b568cdc8">Ogre::GL3PlusHardwareVertexBuffer</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_hardware_index_buffer.html#ad79b3e5a58bb93202ac0e6975b745f0c">Ogre::GL3PlusHardwareIndexBuffer</a>, <a class="el" href="class_ogre_1_1_d3_d11_hardware_uniform_buffer.html#aaea2187a82b97ccab8188cfd1377a763">Ogre::D3D11HardwareUniformBuffer</a>, <a class="el" href="class_ogre_1_1_d3_d11_hardware_vertex_buffer.html#aeeb8e6df6043a3d77ae487f7a1f6ed86">Ogre::D3D11HardwareVertexBuffer</a>, and <a class="el" href="class_ogre_1_1_d3_d11_hardware_index_buffer.html#aa7657864dada56b4849b556ffb5da86e">Ogre::D3D11HardwareIndexBuffer</a>.</p>

<p class="reference">References <a class="el" href="class_ogre_1_1_hardware_buffer.html#a22e4620e677f33050ac3c0df43130e20">Ogre::HardwareBuffer::lock()</a>, and <a class="el" href="class_ogre_1_1_hardware_buffer.html#a64ddd429ff2c8ac4f0cca5decb5c6757">Ogre::HardwareBuffer::unlock()</a>.</p>

</div>
</div>
<a id="a0bf3147b1f99a81dd84fb7b978c4686d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf3147b1f99a81dd84fb7b978c4686d">&#9670;&nbsp;</a></span>copyData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::HardwareBuffer::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all data from another buffer into this one. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Normally these buffers should be of identical size, but if they're not, the routine will use the smallest of the two sizes. </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_hardware_buffer.html#a9194c7e8b536f4825b15b9e6a6912ce8">Ogre::HardwareBuffer::getSizeInBytes()</a>.</p>

</div>
</div>
<a id="a344c52f2214eaff097d5fbc390e7684b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344c52f2214eaff097d5fbc390e7684b">&#9670;&nbsp;</a></span>_updateFromShadow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::HardwareBuffer::_updateFromShadow </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the real buffer from the shadow buffer, if required. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_hardware_buffer.html#ad40dc0a7f9b7de45253809aa204b1b71">Ogre::D3D11HardwareBuffer</a>, <a class="el" href="class_ogre_1_1_g_l_e_s2_hardware_vertex_buffer.html#a0c195f00d7faf0c4f2a69a9f266dd1e7">Ogre::GLES2HardwareVertexBuffer</a>, <a class="el" href="class_ogre_1_1_g_l_e_s2_hardware_index_buffer.html#ad3219addcfdce2d004259d77030197fb">Ogre::GLES2HardwareIndexBuffer</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_hardware_vertex_buffer.html#a917af878074a23bf62feec742ec31b4a">Ogre::GL3PlusHardwareVertexBuffer</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_hardware_index_buffer.html#a50d34e04964ae41fd391a5c78c32382a">Ogre::GL3PlusHardwareIndexBuffer</a>, <a class="el" href="class_ogre_1_1_g_l_hardware_vertex_buffer.html#a770bdaf9b841a146c1f9254129d26a03">Ogre::GLHardwareVertexBuffer</a>, and <a class="el" href="class_ogre_1_1_g_l_hardware_index_buffer.html#a2e41fb0146913c740432a990b75216a5">Ogre::GLHardwareIndexBuffer</a>.</p>

</div>
</div>
<a id="a9194c7e8b536f4825b15b9e6a6912ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9194c7e8b536f4825b15b9e6a6912ce8">&#9670;&nbsp;</a></span>getSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::HardwareBuffer::getSizeInBytes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of this buffer in bytes. </p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_hardware_buffer.html#a0bf3147b1f99a81dd84fb7b978c4686d">Ogre::HardwareBuffer::copyData()</a>.</p>

</div>
</div>
<a id="a9c5ee6468dcb269e422e213b82726e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5ee6468dcb269e422e213b82726e4f">&#9670;&nbsp;</a></span>getUsage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hardware_buffer.html#ae51f5970d879af736e4cf53e1ec46630">Usage</a> Ogre::HardwareBuffer::getUsage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Usage flags with which this buffer was created. </p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_lod0_stripifier.html#aaf8b57b5395eed707f960a10a1856d1d">Ogre::Lod0Stripifier::~Lod0Stripifier()</a>.</p>

</div>
</div>
<a id="a0e1881a6106c59d5aae27589ca1bca5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1881a6106c59d5aae27589ca1bca5d">&#9670;&nbsp;</a></span>isSystemMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::HardwareBuffer::isSystemMemory </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this buffer is held in system memory. </p>

</div>
</div>
<a id="a40a623d95552d9b1858e5c300a3ad68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a623d95552d9b1858e5c300a3ad68c">&#9670;&nbsp;</a></span>hasShadowBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::HardwareBuffer::hasShadowBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this buffer has a system memory shadow for quicker reading. </p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_lod0_stripifier.html#aaf8b57b5395eed707f960a10a1856d1d">Ogre::Lod0Stripifier::~Lod0Stripifier()</a>.</p>

</div>
</div>
<a id="a7c874c6b30c39aa38ae0d6abe2ba42bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c874c6b30c39aa38ae0d6abe2ba42bc">&#9670;&nbsp;</a></span>isLocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::HardwareBuffer::isLocked </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this buffer is currently locked. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_hardware_buffer.html#a7c874c6b30c39aa38ae0d6abe2ba42bc">Ogre::HardwareBuffer::isLocked()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_hardware_buffer.html#a7c874c6b30c39aa38ae0d6abe2ba42bc">Ogre::HardwareBuffer::isLocked()</a>, and <a class="el" href="class_ogre_1_1_hardware_buffer.html#a64ddd429ff2c8ac4f0cca5decb5c6757">Ogre::HardwareBuffer::unlock()</a>.</p>

</div>
</div>
<a id="a688e1be4a913099ce5e06172771e2d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688e1be4a913099ce5e06172771e2d45">&#9670;&nbsp;</a></span>suppressHardwareUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HardwareBuffer::suppressHardwareUpdate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suppress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a> true to suppress hardware upload of shadow buffer changes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_default_hardware_buffer_manager_8h.html">OgreDefaultHardwareBufferManager.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_default_hardware_counter_buffer.html">DefaultHardwareCounterBuffer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
