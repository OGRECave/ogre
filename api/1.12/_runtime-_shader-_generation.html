<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Runtime Shader Generation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.12.13</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_runtime-_shader-_generation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Runtime Shader Generation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Writing shading programs is a common task when developing 3D based application. Most of the visual effects used by 3D based applications involve shader programs. Additionally with D3D11/ GL3, support for fixed pipeline functionality was removed. Meaning you can only render objects using shaders.</p>
<p>While <a class="el" href="_high-level-_programs.html">GPU Program Scripts</a> offer you maximal control and flexibility over how your objects are rendered, writing and maintaining them is also a very time consuming task.</p>
<p>Instead Ogre can also automatically generate shaders on the fly, based on object material properties, scene setup and other user definitions. While the resulting shaders are less optimized, they offer the following advantages:</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes.</li>
</ul>
<p>The system is implemented as a component, so you can enable/ disable it at compile time.</p>
<ul>
<li><a class="el" href="rtss.html">RTSS: Run Time Shader System</a> <br  />
 The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" notably include full Fixed Function emulation. At the core these components are plain shader files providing a set of functions. The shaders are based on properties defined in <a class="el" href="_material-_scripts.html">Material Scripts</a>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md192"></a>
Uber shader tips</h1>
<p>In case, you are not conviced and want to go with your hand-rolled uber shader, here are some tips:</p>
<ol type="1">
<li>Ogre supports <code>#include</code> directives universally - even with GLSL, so use them to split up your shader.</li>
<li>The <code>OgreUnifiedShader.h</code> header provides macros to map GLSL to HLSL and (to some extent) Metal. This allows you to write shader code once and use it for multiple rendersystems.</li>
<li>The <code>HLSL_SM4Support.hlsl</code> helper allows mapping HLSL9/ Cg to HLSL SM4 (D3D11), if you only target D3D.</li>
</ol>
<p>Then you can have a shader skeleton like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef USE_UV</span></div>
<div class="line"><span class="preprocessor">#include &quot;parameters_uv.glsl&quot;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#ifdef USE_SKINNING</span></div>
<div class="line"><span class="preprocessor">#include &lt;parameters_skinning.glsl&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">void main()</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#ifdef USE_UV</span></div>
<div class="line"><span class="preprocessor">    #include &lt;transform_uv.glsl&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#ifdef USE_SKINNING</span></div>
<div class="line"><span class="preprocessor">    #include &lt;transform_skinning.glsl&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#ifdef USE_TANGENT</span></div>
<div class="line"><span class="preprocessor">    #include &lt;construct_tbn.glsl&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    ...</div>
<div class="line">    gl_Position = ...;</div>
<div class="line">}</div>
</div><!-- fragment --><p>then in the material file, you can instanciate it as:</p>
<div class="fragment"><div class="line">vertex_program TextureAndSkinning glsl</div>
<div class="line">{</div>
<div class="line">    source UberShader_vp.glsl</div>
<div class="line">    preprocessor_defines USE_UV,USE_SKINNING</div>
<div class="line">    default_params</div>
<div class="line">    {</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>and reference it with your materials.</p>
<p>Incidentally, this is very similar to what the RTSS is doing internally. Except, you do not need the <code>preprocessor_defines</code> part, as it can derive automatically from the material what needs to be done.</p>
<h1><a class="anchor" id="autotoc_md193"></a>
Historical background</h1>
<p>When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).</p>
<p>As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.</p>
<p>Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.</p>
<p>The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.</p>
<p>With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS is an excellent tool for this purpose. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
