<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Instancing User-Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_what_is_instancing.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Instancing User-Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#InstancesPerBatch">Instances per batch</a></li>
<li class="level1"><a href="#InstancingTechniques">Techniques</a><ul><li class="level2"><a href="#InstancingTechniquesShaderBased">ShaderBased</a></li>
<li class="level2"><a href="#InstancingTechniquesVTFSoftware">VTF (Software)</a></li>
<li class="level2"><a href="#InstancingTechniquesHWVTF">HW VTF</a><ul><li class="level3"><a href="#InstancingTechniquesHW">HW VTF LUT</a></li>
</ul>
</li>
<li class="level2"><a href="#InstancingTechniquesHWBasic">HW Basic</a></li>
</ul>
</li>
<li class="level1"><a href="#InstancingCustomParameters">Custom parameters</a></li>
<li class="level1"><a href="#InstancingMultipleSubmeshes">Supporting multiple submeshes</a></li>
<li class="level1"><a href="#InstancingDefragmentingBatches">Defragmenting batches</a><ul><li class="level2"><a href="#InstancingDefragmentingBatchesIntro">What is batch fragmentation?</a></li>
<li class="level2"><a href="#InstancingDefragmentingBatchesPrevention">Prevention: Avoiding fragmentation</a></li>
<li class="level2"><a href="#InstancingDefragmentingBatchesOnTheFly">Cure: Defragmenting on the fly</a></li>
</ul>
</li>
<li class="level1"><a href="#InstancingTroubleshooting">Troubleshooting</a></li>
</ul>
</div>
<div class="textblock"><p>A common question is why should I use instancing. The big reason is performance. There can be 10x improvements or more when used correctly. Here's a guide on when you should use instancing:</p>
<ol type="1">
<li>You have <em>a lot</em> of Entities that are repeated and based on the same Mesh (i.e. a rock, a building, a tree, loose leaves, enemies, irrelevant crowds or NPCs)</li>
<li>These Entities that repeat a lot also share the same material (or just a few materials, i.e. 3 or 4)</li>
<li>The bottleneck in your game is the CPU.</li>
</ol>
<p>If these three requirements are all met in your game, chances are instancing is for you. There will be minimal gains when using instancing on an Entity that repeats very little, or if each instance actually has a different material, or it could run even slower if the Entity never repeats.</p>
<p>If the bottleneck in your game is not CPU (i.e. it's in the GPU) then instancing won't make a noticeable difference.</p>
<h1><a class="anchor" id="InstancesPerBatch"></a>
Instances per batch</h1>
<p>As explained in the previous section, instancing groups all instances into one draw call. However this is half the truth. Instancing actually groups a certain number of instances into a batch. One batch = One draw call.</p>
<p>If the technique is using 80 instances per batch; then rendering 160 instances is going to need 2 draw calls (two batches); if there are 180 instances, 3 draw calls will be needed (3 batches).</p>
<p>What is a good value for instances-per-batch setting? That depends on a lot of factors, which you will have to profile. Normally, increasing the number should improve performance because the system is most likely CPU bottleneck. However, past certain number, certain trade offs begin to show up:</p>
<ul>
<li>Culling is first performed at batch level, then for HW techniques culling is also done at per instance level. If the batch contains too many instances, its AABB will grow too large; thus the hierarchy culling will always pass and <a class="el" href="namespace_ogre.html">Ogre</a> won't be able skip entire batches.</li>
<li>If the instance per batch is at 10.000 and the application created 10.001 instances; a lot of RAM &amp; VRAM will be wasted because it's set for 20.000 instances; HW techniques will spent an excessive amount of CPU time parsing the 9.999 inactive instances; and SW techniques will saturate the Bus bandwidth sending null matrices for the inactive instances to the GPU.</li>
</ul>
<p>The actual value will depend a lot on the application and whether all instances are often on screen or frustum culled and whether the total number of instances can be known at production time (i.e. environment props). Normally numbers between 80 and 500 work best, but there have been cases where big values like 5.000 actually improved performance.</p>
<h1><a class="anchor" id="InstancingTechniques"></a>
Techniques</h1>
<p><a class="el" href="namespace_ogre.html">Ogre</a> supports 4 different instancing techniques. Unfortunately, each of them requires a different vertex shader, since their approaches are different. Also their compatibility and performance varies.</p>
<h2><a class="anchor" id="InstancingTechniquesShaderBased"></a>
ShaderBased</h2>
<p>This is the same technique the old InstancedGeometry implementation used (with improvements).  </p>
<p>Basically it creates a large vertex buffer with many repeating entities, and sends per instance data through shader constants. Because SM 2.0 &amp; 3.0 have up to 256 shader constant registers, this means there can be approx up to 84 instances per batch, assuming they're not skinned But using shader constants for other stuff (i.e. lighting) also affects negatively this number A mesh with skeletally animated 2 bones reduces the number 84 to 42 instances per batch.</p>
<p>The main advantage of this technique is that it's supported on a high variety of hardware (SM 2.0 cards are required) and the same shader can be used for both skeletally animated normal entities and instanced entities without a single change required.</p>
<p>Unlike the old <code>InstancedGeometry</code> implementation, the developer doesn't need to worry about reaching the 84 instances limit, the InstanceManager automatically takes care of splitting and creating new batches. But beware internally, this means less performance improvement. Another improvement is that vertex buffers are shared between batches, which significantly reduces GPU VRAM usage.  </p>
<p>Vertex Shader input example: </p><div class="fragment"><div class="line">...</div>
<div class="line">float4 blendIdx : BLENDINDICES,</div>
<div class="line">uniform float3x4 worldMatrix3x4Array[80],</div>
<div class="line">...</div>
</div><!-- fragment --><p>Vertex position calculation example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> idx = int(blendIdx[0]);</div>
<div class="line">float4 worldPos  = float4( mul( worldMatrix3x4Array[idx], position ).xyz, 1.0f );</div>
<div class="line">oClipPos = mul( viewProjMatrix, worldPos );</div>
<div class="line">...</div>
</div><!-- fragment --><p>See <code>Examples/Instancing/RTSS/Robot</code> for an example on how to use instancing with the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a></p>
<p>See <code>material Examples/Instancing/ShaderBased</code> for an example on how to write the vertex shader. (You can find these files in OGRE sources from before v1.12) Files:</p><ul>
<li>ShaderInstancing.material</li>
<li>ShaderInstancing.vert (GLSL)</li>
<li>ShaderInstancing.cg (Cg, works with HLSL)</li>
</ul>
<h2><a class="anchor" id="InstancingTechniquesVTFSoftware"></a>
VTF (Software)</h2>
<p>Instancing implementation using vertex texture through Vertex Texture Fetch (VTF) This implementation has the following advantages:  </p>
<p>- Supports huge amount of instances per batch</p><ul>
<li>Supports skinning even with huge ammounts of instances per batch</li>
<li>Doesn't need shader constants registers.</li>
<li>Best suited for skinned entities</li>
</ul>
<p>But beware the disadvantages:</p><ul>
<li>VTF is only fast on modern GPUs (ATI Radeon HD 2000+, GeForce 8+ series onwards)</li>
<li>On GeForce 6/7 series VTF is too slow</li>
<li>VTF isn't (controversely) supported on old ATI X1800 hardware</li>
<li>Only one bone weight per vertex is supported</li>
<li>GPUs with low memory bandwidth (i.e. laptops and integrated GPUs) may perform even worse than no instancing</li>
</ul>
<p>Whether this performs great or bad depends on the hardware. It improved up to 4x performance on a Intel Core 2 Quad Core X9650 GeForce 8600 GTS, and in an Intel Core 2 Duo P7350 ATI Mobility Radeon HD 4650, but went 0.75x slower on an AthlonX2 5000+ integrated nForce 6150 SE Each BaseInstanceBatchVTF has it's own texture, which occupies memory in VRAM. Approx VRAM usage can be computed by doing 12 bytes * 3 * numInstances * numBones Use flag IM_VTFBESTFIT to avoid wasting VRAM (but may reduce amount of instances per batch).</p>
<p>The material requires at least a texture unit stage named <code>InstancingVTF</code>  </p>
<p>Texture unit example: </p><div class="fragment"><div class="line">texture_unit InstancingVTF</div>
<div class="line">{</div>
<div class="line">    filtering none</div>
<div class="line">}</div>
</div><!-- fragment --><p>Vertex Shader input example: </p><div class="fragment"><div class="line">...</div>
<div class="line">float4 m01 : TEXCOORD1,</div>
<div class="line">float4 m23 : TEXCOORD2,</div>
<div class="line">uniform sampler2D matrixTexture : register(s0), // s0 if texture_unit InstancingVTF appears first</div>
<div class="line">...</div>
</div><!-- fragment --><p>Vertex position calculation example:</p>
<div class="fragment"><div class="line">    float3x4 worldMatrix;</div>
<div class="line">    worldMatrix[0] = tex2Dlod( matrixTexture, float4(input.m01.xy, 0, 0) );</div>
<div class="line">    worldMatrix[1] = tex2Dlod( matrixTexture, float4(input.m01.zw, 0, 0) );</div>
<div class="line">    worldMatrix[2] = tex2Dlod( matrixTexture, float4(input.m23.xy, 0, 0) );</div>
<div class="line"> </div>
<div class="line">    worldPos = float4( mul( worldMatrix, input.Position ).xyz, 1.0f );</div>
</div><!-- fragment --><p>See <code>material Examples/Instancing/VTF</code> for an example on how to write the vertex shader and setup the material. Files:</p><ul>
<li>VTFInstancing.material</li>
<li>VTFInstancing.vert (GLSL)</li>
<li>VTFInstancing.cg (Cg, also works with HLSL)</li>
</ul>
<h2><a class="anchor" id="InstancingTechniquesHWVTF"></a>
HW VTF</h2>
<p>This is the same technique as VTF; but implemented through hardware instancing. It is probably one of the best and most flexible techniques.</p>
<p>The vertex shader has to be slightly different from SW VTF version.</p>
<p>Texture unit example: </p><div class="fragment"><div class="line">texture_unit InstancingVTF</div>
<div class="line">{</div>
<div class="line">    filtering none</div>
<div class="line">}</div>
</div><!-- fragment --><p>Vertex Shader input example: </p><div class="fragment"><div class="line">float4 m03 : TEXCOORD1,</div>
<div class="line">float2 mOffset : TEXCOORD2,</div>
<div class="line">uniform sampler2D matrixTexture : register(s1),</div>
</div><!-- fragment --><p>Vertex position calculation example:</p>
<div class="fragment"><div class="line">    float3x4 worldMatrix;</div>
<div class="line">    worldMatrix[0] = tex2Dlod( matrixTexture, float4(input.m03.xw + input.mOffset, 0, 0) );</div>
<div class="line">    worldMatrix[1] = tex2Dlod( matrixTexture, float4(input.m03.yw + input.mOffset, 0, 0) );</div>
<div class="line">    worldMatrix[2] = tex2Dlod( matrixTexture, float4(input.m03.zw + input.mOffset, 0, 0) );</div>
<div class="line"> </div>
<div class="line">    worldPos = float4( mul( worldMatrix, input.Position ).xyz, 1.0f );</div>
</div><!-- fragment --><p>See <code>material Examples/Instancing/HW_VTF</code> for an example on how to write the vertex shader and setup the material. Files:</p><ul>
<li>HW_VTFInstancing.material</li>
<li>HW_VTFInstancing.vert (GLSL)</li>
<li>HW_VTFInstancing.cg (Cg, works with HLSL)</li>
</ul>
<h3><a class="anchor" id="InstancingTechniquesHW"></a>
HW VTF LUT</h3>
<p>LUT is a special feature of HW VTF; which stands for <b>L</b>ook <b>U</b>p <b>T</b>able. It has been particularly designed for drawing large animated crowds.</p>
<p>The technique is a trick that works by animating a limited number of instances (i.e. 16 animations) storing them in a look up table in the VTF, and then repeating these animations to all instances uniformly, giving the appearance that all instances are independently animated when seen in large crowds.</p>
<p>To enable the use of LUT, <code>SceneManager::createInstanceManager</code>'s flags must include the flag <code>IM_VTFBONEMATRIXLOOKUP</code> and specify HW VTF as technique.</p>
<div class="fragment"><div class="line">mSceneMgr-&gt;createInstanceManager(<span class="stringliteral">&quot;InstanceMgr&quot;</span>,<span class="stringliteral">&quot;MyMesh.mesh&quot;</span>,</div>
<div class="line">            ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME,</div>
<div class="line">            InstanceManager::HWInstancingVTF,</div>
<div class="line">            numInstancesPerBatch,IM_USEALL|IM_VTFBONEMATRIXLOOKUP );</div>
</div><!-- fragment --><p>See <code>material Examples/Instancing/HW_VTF_LUT</code>. Files:</p><ul>
<li>Same as HW VTF (different macros defined)</li>
</ul>
<h2><a class="anchor" id="InstancingTechniquesHWBasic"></a>
HW Basic</h2>
<p>This is technique requires true instancing hardware support.  </p>
<p>Basically it creates a cloned vertex buffer from the original, with an extra buffer containing 3 additional <code>TEXCOORDS</code> (12 bytes) repeated as much as the instance count. That will be used for each instance data.</p>
<p>The main advantage of this technique is that it's <em>VERY</em> fast; but it doesn't support skeletal animation at all. Very reduced memory consumption and bandwidth. Great for particles, debris, bricks, trees, sprites. This batch is one of the few (if not the only) techniques that allows culling on an individual basis. This means we can save vertex shader performance for instances that aren't in scene or just not focused by the camera.  </p>
<p>Vertex Shader input example: </p><div class="fragment"><div class="line">...</div>
<div class="line">float3x4 worldMatrix : TEXCOORD1,</div>
<div class="line">...</div>
</div><!-- fragment --><p>Vertex position calculation example: </p><div class="fragment"><div class="line">...</div>
<div class="line">float4 worldPos = float4( mul( worldMatrix, position ).xyz, 1.0f );</div>
<div class="line">oClipPos = mul( viewProjMatrix, worldPos );</div>
<div class="line">...</div>
</div><!-- fragment --><p> See <code>Examples/Instancing/RTSS/Robot</code> for an example on how to use instancing with the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a></p>
<p>See <code>material Examples/Instancing/HWBasic</code> for an example. (You can find these files in OGRE sources from before v1.12) Files:</p><ul>
<li>HWInstancing.material</li>
<li>HWBasicInstancing.vert (GLSL)</li>
<li>HWBasicInstancing.cg (Cg, works with HLSL)</li>
</ul>
<h1><a class="anchor" id="InstancingCustomParameters"></a>
Custom parameters</h1>
<p>Some instancing techniques allow passing custom parameters to vertex shaders. For example a custom colour in an RTS game to identify player units; a single value for randomly colouring vegetation, light parameters for rendering deferred shading's light volumes (diffuse colour, specular colour, etc)</p>
<p>At the time of writing only HW Basic supports passing the custom parameters. All other techniques will ignore it.[^8]</p>
<p>To use custom parameters, call <code>InstanceManager::setNumCustomParams</code> to tell the number of custom parameters the user will need. <b>This number cannot be changed after creating the first batch</b> (call createInstancedEntity)</p>
<p>Afterwards, it's just a matter of calling <code>InstancedEntity::setCustomParam</code> with the param you wish to send.</p>
<p>For HW Basic techniques, the vertex shader will receive the custom param in an extra <code>TEXCOORD.</code></p>
<div class="fragment"><div class="line"> InstanceManager *instanceMgr;<span class="comment">//Assumed to be valid ptr</span></div>
<div class="line">instanceMgr-&gt;setNumCustomParams(2);</div>
<div class="line"> </div>
<div class="line">InstancedEntity *instancedEntity =instanceMgr-&gt;createInstancedEntity(<span class="stringliteral">&quot;myMaterial&quot;</span>);</div>
<div class="line">instancedEntity-&gt;setCustomParam(0,Vector4(1.0f,1.0f,1.2f,0.0f));</div>
<div class="line">instancedEntity-&gt;setCustomParam(1,Vector4(0.2f,0.0f,0.7f,1.0f));</div>
</div><!-- fragment --><h1><a class="anchor" id="InstancingMultipleSubmeshes"></a>
Supporting multiple submeshes</h1>
<p>Multiple submeshes means different instance managers, because instancing can only be applied to the same submesh.</p>
<p>Nevertheless, it is actually quite easy to support multiple submeshes. The first step is to create the InstanceManager setting the <code>subMeshIdx</code> parameter to the number of submesh you want to use:</p>
<div class="fragment"><div class="line">std::vector&lt;InstanceManager*&gt;instanceManagers;</div>
<div class="line">MeshPtr mesh =MeshManager::getSingleton().load(<span class="stringliteral">&quot;myMesh.mesh&quot;</span>);</div>
<div class="line"><span class="keywordflow">for</span>(uint16 i=0;i&lt;mesh-&gt;getNumSubMeshes();++i )</div>
<div class="line">{</div>
<div class="line">    InstanceManager *mgr =</div>
<div class="line">        mSceneMgr-&gt;createInstanceManager(<span class="stringliteral">&quot;MyManager&quot;</span>+StringConverter::toString(i ),</div>
<div class="line">                    <span class="stringliteral">&quot;myMesh.mesh&quot;</span>,</div>
<div class="line">                ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME,</div>
<div class="line">                    InstanceManager::HWInstancingVTF,numInstancePerBatch,</div>
<div class="line">                    flags,i );</div>
<div class="line">    instanceManagers.push_back(mgr );</div>
<div class="line">}</div>
</div><!-- fragment --><p>The second step lies in sharing the transform with one of the submeshes (which will be named 'master'; i.e. the first submesh) to improve performance and reduce RAM consumption when creating the Instanced Entities:</p>
<div class="fragment"><div class="line">SceneNode *sceneNode; <span class="comment">//Assumed to be valid ptr</span></div>
<div class="line">std::vector&lt;InstancedEntity*&gt;instancedEntities;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;instanceManagers.size();++i )</div>
<div class="line">{</div>
<div class="line">    InstancedEntity *ent =instanceManagers[i]-&gt;createInstancedEntity(<span class="stringliteral">&quot;MyMaterial&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(i !=0)</div>
<div class="line">        instancedEntities[0]-&gt;shareTransformWith(ent );</div>
<div class="line"> </div>
<div class="line">    sceneNode-&gt;attachObject(ent );</div>
<div class="line">    instancedEntities.push_back(ent );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that it is perfectly possible that each <code>InstancedEntity</code> based on a different "submesh" uses a different material. Selecting the same material won't cause the InstanceManagers to get batched together (though the RenderQueue will try to reduce state change reduction, like with any normal Entity).</p>
<p>Because the transform is shared, animating the master InstancedEntity (in this example, <code>instancedEntity[0]</code>) will cause all other slave instances to follow the same animation.</p>
<p>To destroy the instanced entities, use the normal procedure:</p>
<div class="fragment"><div class="line">SceneNode *sceneNode; <span class="comment">//Assumed to be valid ptr</span></div>
<div class="line">std::vector&lt;InstancedEntity*&gt;instancedEntities;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;instanceManagers.size();++i )</div>
<div class="line">{</div>
<div class="line">    instanceManagers[i]-&gt;destroyInstancedEntity(instancedEntities[i]);</div>
<div class="line">}</div>
<div class="line">mSceneMgr-&gt;getRootSceneNode()-&gt;removeAndDestroyChild(sceneNode );</div>
</div><!-- fragment --><h1><a class="anchor" id="InstancingDefragmentingBatches"></a>
Defragmenting batches</h1>
<h2><a class="anchor" id="InstancingDefragmentingBatchesIntro"></a>
What is batch fragmentation?</h2>
<p>There are two kinds of fragmentation:</p>
<ol type="1">
<li>"Deletion" Fragmentation is when many instances have been created, spanning multiple batches; <em>and many of them got later removed</em> but they were all from different batches. If there were 10 instances per batch, 100 instances created, then later 90 removed; it is possible that now there are 10 batches with one instance each (which equals 10 drawcalls); instead of being just 1 batch with 10 instances (which equals 1 drawcall).</li>
<li>"Culling" Fragmentation is also when many instances of different batches are all sparsed across the whole scene. If they were defragmented, they would've been put together in the same batch (all instances sorted by proximity to each other should be in the same batch) to take advantage of hierarchy culling optimizations.</li>
</ol>
<p>Defragmented batches can dramatically improve performance:</p>
<p>Suppose there 50 instances per batch, and 100 batches total (which means 5000 instanced entities of the same mesh with same material), and they're all moving all the time.</p>
<p>Normally, <a class="el" href="namespace_ogre.html">Ogre</a> first updates all instances' position, then their AABBs; and while at it, computes the AABB for each batch that encloses all of its instances.</p>
<p>When frustum culling, we first cull the batches, then we cull their instances[^9] (that are inside those culled batches). <b>This is the typical hierarchical culling optimization</b>. We then upload the instances transforms to the GPU.</p>
<p>After moving many instances around the whole world, they will make the batch' enclosing AABB bigger and bigger. Eventually, every batch' AABB will be so large, that wherever the camera looks, all 100 batches will end up passing the frustum culling test; thus having to resort to cull all 5000 instances individually.</p>
<h2><a class="anchor" id="InstancingDefragmentingBatchesPrevention"></a>
Prevention: Avoiding fragmentation</h2>
<p>If you're creating static objects that won't move (i.e. trees), create them sorted by proximity. This helps both types of fragmentation:</p>
<ol type="1">
<li>When unloading areas (i.e. open world games), these objects will be removed all together, thus whole batches will no longer have active instances.</li>
<li>Batches and instances are often assigned by order of creation. Those instances will belong to the same batch and thus maximizing culling efficiency.</li>
</ol>
<h2><a class="anchor" id="InstancingDefragmentingBatchesOnTheFly"></a>
Cure: Defragmenting on the fly</h2>
<p>There are cases where preventing fragmentation, for example units in an RTS game. By design, all units may end up scattering and moving from one extreme of the scene to the other after hours of gameplay; additionally, lots of units may be in an endless loop of creation and destroying, but if the loop for a certain type of unit is broken; it is possible to end up with the kind of "Deletion" Fragmentation too.</p>
<p>For this reason, the function <code>InstanceManager::defragmentBatches( bool optimizeCulling )</code> exists.</p>
<p>Using it as simple as calling the function. <b>The sample NewInstancing shows how to do this interactively</b>. When <code>optimizeCulling</code> is true, both types of fragmentation will be attempted to be fixed. When false, only the "deletion" kind of fragmentation will be fixed.</p>
<p>Take in mind that when <code>optimizeCulling = true</code> it takes significantly more time depending on the level of fragmentation and could cause framerate spikes, even stalls. Do it sparingly and profile the optimal frequency of calling.</p>
<h1><a class="anchor" id="InstancingTroubleshooting"></a>
Troubleshooting</h1>
<dl class="section user"><dt>Q: My mesh doesn't show up.</dt><dd>A: Verify you're using the right material, the vertex shader is set correctly, and it matches the instancing technique being used.</dd></dl>
<dl class="section user"><dt>Q: My animation plays quite differently than when it is an Entity, or previewed in Ogre Mesh Viewer.</dt><dd>A: Your rig animation must be using more than one weight per bone. You need to add support for it in the vertex shader, and make sure you didn't create the instance manager with the flags <a class="el" href="group___general.html#gga4921efc65b347efe08a6d4992af069e2ac4105c2b84b7dfd08e4bfa35a5ea9848" title="Use one weight per vertex when recommended (i.e.">Ogre::IM_USEONEWEIGHT</a> or <a class="el" href="group___general.html#gga4921efc65b347efe08a6d4992af069e2a7f599ab5ea537d8bab3af8aef358fe0a" title="All techniques are forced to one weight per vertex.">Ogre::IM_FORCEONEWEIGHT</a>.</dd></dl>
<p>For example, to modify the HW VTF vertex shader, you need to sample the additional matrices from the VTF:</p>
<div class="fragment"><div class="line">float2uv0       :   TEXCOORD0;</div>
<div class="line"><span class="comment">// Up to four weights per vertex. Don&#39;t use this shader on a model with 3 weights per vertex, or 2 or 1</span></div>
<div class="line">float4m03_0 :   TEXCOORD1;<span class="comment">//m03.w is always 0</span></div>
<div class="line">float4m03_1 :   TEXCOORD2;</div>
<div class="line">float4m03_2 :   TEXCOORD3;</div>
<div class="line">float4m03_3 :   TEXCOORD4;</div>
<div class="line">float4mWeights  :   TEXCOORD5;</div>
<div class="line"> </div>
<div class="line">float2mOffset   :   TEXCOORD6;</div>
<div class="line"> </div>
<div class="line">float3x4worldMatrix[4];</div>
<div class="line">worldMatrix[0][0] =tex2D(matrixTexture, m03_0.xw +mOffset );</div>
<div class="line">worldMatrix[0][1] =tex2D(matrixTexture, m03_0.yw +mOffset );</div>
<div class="line">worldMatrix[0][2] =tex2D(matrixTexture, m03_0.zw +mOffset );</div>
<div class="line"> </div>
<div class="line">worldMatrix[1][0] =tex2D(matrixTexture, m03_1.xw +mOffset );</div>
<div class="line">worldMatrix[1][1] =tex2D(matrixTexture, m03_1.yw +mOffset );</div>
<div class="line">worldMatrix[1][2] =tex2D(matrixTexture, m03_1.zw +mOffset );</div>
<div class="line"> </div>
<div class="line">worldMatrix[2][0] =tex2D(matrixTexture, m03_2.xw +mOffset );</div>
<div class="line">worldMatrix[2][1] =tex2D(matrixTexture, m03_2.yw +mOffset );</div>
<div class="line">worldMatrix[2][2] =tex2D(matrixTexture, m03_2.zw +mOffset );</div>
<div class="line"> </div>
<div class="line">worldMatrix[3][0] =tex2D(matrixTexture, m03_3.xw +mOffset );</div>
<div class="line">worldMatrix[3][1] =tex2D(matrixTexture, m03_3.yw +mOffset );</div>
<div class="line">worldMatrix[3][2] =tex2D(matrixTexture, m03_3.zw +mOffset );</div>
<div class="line"> </div>
<div class="line">float4 worldPos = float4(mul(worldMatrix[0], inPos ).xyz, 1.0f )* mWeights.x;</div>
<div class="line">worldPos +=float4(mul(worldMatrix[1], inPos ).xyz, 1.0f )* mWeights.y;</div>
<div class="line">worldPos +=float4(mul(worldMatrix[2], inPos ).xyz, 1.0f )* mWeights.z;</div>
<div class="line">worldPos +=float4(mul(worldMatrix[3], inPos ).xyz, 1.0f )* mWeights.w;</div>
<div class="line"> </div>
<div class="line">float4 worldNor = float4(mul(worldMatrix[0], inNor ).xyz, 1.0f )* mWeights.x;</div>
<div class="line">worldNor +=float4(mul(worldMatrix[1], inNor ).xyz, 1.0f )* mWeights.y;</div>
<div class="line">worldNor +=float4(mul(worldMatrix[2], inNor ).xyz, 1.0f )* mWeights.z;</div>
<div class="line">worldNor +=float4(mul(worldMatrix[3], inNor ).xyz, 1.0f )* mWeights.w;</div>
</div><!-- fragment --><p>As you can witness, a HW VTF vertex shader with 4 weights per vertex needs a lot of texture fetches. Fortunately they fit the texture cache very well; nonetheless it's something to keep watching out.</p>
<p>Instancing is meant for rendering large number of objects in a scene. If you plan on rendering thousands or tens of thousands of animated objects with 4 weights per vertex, don't expect it to be fast; no matter what technique you use to draw them.</p>
<p>Try convincing the art department to lower the animation quality or just use <a class="el" href="group___general.html#gga4921efc65b347efe08a6d4992af069e2a7f599ab5ea537d8bab3af8aef358fe0a" title="All techniques are forced to one weight per vertex.">Ogre::IM_FORCEONEWEIGHT</a> for <a class="el" href="namespace_ogre.html">Ogre</a> to do the downgrade for you. There are many plugins for popular modeling packages (3DS Max, Maya, Blender) out there that help automatizing this task.</p>
<dl class="section user"><dt>Q: The instance doesn't show up, or when playing animations the mesh deforms very weirdly or other very visible artifacts occur</dt><dd></dd></dl>
<p>A: Your rig uses more than one weight per vertex. Either create the instance manager with the flag <a class="el" href="group___general.html#gga4921efc65b347efe08a6d4992af069e2a7f599ab5ea537d8bab3af8aef358fe0a" title="All techniques are forced to one weight per vertex.">Ogre::IM_FORCEONEWEIGHT</a>, or modify the vertex shader to support the <em>exact</em> amount of weights per vertex needed (see previous questions).</p>
<dl class="section user"><dt>Q: How do I find how many weights per vertices is using my model?</dt><dd></dd></dl>
<p>A: The quickest way is by looking at the type of <a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655a63d3494547f373f5c4397a41b39cf6a0" title="Blending weights.">Ogre::VES_BLEND_WEIGHTS</a>, where <code>VET_FLOAT&lt;N&gt;</code> means N weights.</p>
<p>[^8]: In theory all other techniques could implement custom parameters but for performance reasons only HW VTF is well suited to implement it. Though it yet remains to be seen whether it should be passed to the shader through the VTF, or through additional TEXCOORDs.</p>
<p>[^9]: Only HW instancing techniques cull per instance. SW instancing techniques send all of their instances, zeroing matrices of those instances that are not in the scene. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li><li class="navelem"><a class="el" href="_instancing.html">Instancing</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
