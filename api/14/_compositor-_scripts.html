<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Compositor Scripts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_compositor-_scripts.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Compositor Scripts</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Compositor-Fundamentals">Compositor Fundamentals</a></li>
<li class="level1"><a href="#Compositor-Techniques">Techniques</a><ul><li class="level2"><a href="#compositor-texture">texture</a></li>
<li class="level2"><a href="#autotoc_md64">texture_ref</a></li>
<li class="level2"><a href="#autotoc_md65">scheme</a></li>
<li class="level2"><a href="#autotoc_md66">compositor_logic</a></li>
</ul>
</li>
<li class="level1"><a href="#Compositor-Target-Passes">Target Sections</a><ul><li class="level2"><a href="#autotoc_md67">input</a></li>
<li class="level2"><a href="#autotoc_md68">only_initial</a></li>
<li class="level2"><a href="#autotoc_md69">visibility_mask</a></li>
<li class="level2"><a href="#autotoc_md70">lod_bias</a></li>
<li class="level2"><a href="#autotoc_md71">shadows</a></li>
<li class="level2"><a href="#autotoc_md72">material_scheme</a></li>
</ul>
</li>
<li class="level1"><a href="#Compositor-Passes">Passes</a><ul><li class="level2"><a href="#autotoc_md73">render_quad &amp; compute</a><ul><li class="level3"><a href="#autotoc_md74">material</a></li>
<li class="level3"><a href="#autotoc_md75">input</a></li>
<li class="level3"><a href="#autotoc_md76">identifier</a></li>
<li class="level3"><a href="#autotoc_md77">quad_normals</a></li>
<li class="level3"><a href="#autotoc_md78">thread_groups</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md79">render_scene</a><ul><li class="level3"><a href="#autotoc_md80">first_render_queue</a></li>
<li class="level3"><a href="#autotoc_md81">last_render_queue</a></li>
<li class="level3"><a href="#autotoc_md82">material_scheme</a></li>
<li class="level3"><a href="#autotoc_md83">camera</a></li>
</ul>
</li>
<li class="level2"><a href="#Clear-Section">clear</a><ul><li class="level3"><a href="#autotoc_md84">buffers</a></li>
<li class="level3"><a href="#autotoc_md85">colour_value</a></li>
<li class="level3"><a href="#autotoc_md86">depth_value</a></li>
<li class="level3"><a href="#autotoc_md87">stencil_value</a></li>
</ul>
</li>
<li class="level2"><a href="#Stencil-Section">stencil</a><ul><li class="level3"><a href="#autotoc_md88">check</a></li>
<li class="level3"><a href="#autotoc_md89">comp_func</a></li>
<li class="level3"><a href="#autotoc_md90">ref_value</a></li>
<li class="level3"><a href="#autotoc_md91">mask</a></li>
<li class="level3"><a href="#autotoc_md92">fail_op</a></li>
<li class="level3"><a href="#autotoc_md93">depth_fail_op</a></li>
<li class="level3"><a href="#autotoc_md94">pass_op</a></li>
<li class="level3"><a href="#autotoc_md95">two_sided</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Applying-a-Compositor">Applying a Compositor</a></li>
<li class="level1"><a href="#Compositor-API">Programmatic creation</a></li>
</ul>
</div>
<div class="textblock"><p>The compositor framework is a subsection of the OGRE API that allows you to easily define how to assemble the final image. A typical use-case are full screen post-processing effects - however Compositors are not limited to that. Compositor scripts offer you the ability to define rendering pipelines in a script which can be reused and modified easily, rather than having to use the API to define them. You still need to use code to instantiate a compositor against one of your visible viewports, but this is a much simpler process than actually defining the compositor itself.</p>
<h1><a class="anchor" id="Compositor-Fundamentals"></a>
Compositor Fundamentals</h1>
<p>Compositing generally involves rendering the scene to a texture, either in addition to or instead of the main window. Once the scene is in a texture, you can then pull the scene image into a fragment program and perform operations on it by rendering it through full screen quad. The target of this post processing render can be the main result (e.g. a window), or it can be another render texture so that you can perform multi-stage convolutions on the image. You can even ’ping-pong’ the render back and forth between a couple of render textures to perform convolutions which require many iterations, without using a separate texture for each stage. Eventually you’ll want to render the result to the final output, which you do with a full screen quad. This might replace the whole window (thus the main window doesn’t need to render the scene itself), or it might be a combinational effect.</p>
<p>So that we can discuss how to implement these techniques efficiently, a number of definitions are required:</p>
<dl compact="compact">
<dt>Compositor </dt>
<dd><p class="startdd"></p>
<p class="interdd">Definition of a rendering pipeline that can be applied to a user viewport. This is what you’re defining when writing compositor scripts as detailed in this section.</p>
<p class="enddd"></p>
</dd>
<dt>Compositor Instance </dt>
<dd><p class="startdd"></p>
<p class="interdd">An instance of a compositor as applied to a single viewport. You create these based on compositor definitions, See <a class="el" href="_compositor-_scripts.html#Applying-a-Compositor">Applying a Compositor</a>.</p>
<p class="enddd"></p>
</dd>
<dt>Compositor Chain </dt>
<dd><p class="startdd"></p>
<p class="interdd">It is possible to enable more than one compositor instance on a viewport at the same time, with one compositor taking the results of the previous one as input. This is known as a compositor chain. Every viewport which has at least one compositor attached to it has a compositor chain. See <a class="el" href="_compositor-_scripts.html#Applying-a-Compositor">Applying a Compositor</a></p>
<p class="enddd"></p>
</dd>
<dt>Target </dt>
<dd><p class="startdd"></p>
<p class="interdd">This is a <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">Ogre::RenderTarget</a>, i.e. the canvas where the result of a series of render operations is sent. A target may be the final output (e.g. your <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window.">Ogre::RenderWindow</a>), or it may be an intermediate render texture, which you declare in your script with the <a class="el" href="_compositor-_scripts.html#compositor-texture">texture</a> line. A target which is not the output target has a size and pixel format which you can define inside the compositor script.</p>
<p class="enddd"></p>
</dd>
<dt>Output Target </dt>
<dd><p class="startdd"></p>
<p class="interdd">As Target, but this is the single final result of all operations. The size and pixel format of this target cannot be controlled by the compositor since it is defined by the application using it, thus you don’t declare it in your script. However, you do declare a Target Section for it, see below.</p>
<p class="enddd"></p>
</dd>
<dt>Target Section </dt>
<dd><p class="startdd"></p>
<p class="enddd">A Target may be rendered to many times in the course of a composition effect. In particular if you ’ping pong’ a convolution between a couple of textures, you will have more than one Target Sections per Target. Target Sections are declared in the script using a <a class="el" href="_compositor-_scripts.html#Compositor-Target-Passes">target or target_output line</a>, the latter being the final output of which there can be only one. </p><dl class="section note"><dt>Note</dt><dd>Internally this is referred to as <a class="el" href="class_ogre_1_1_composition_target_pass.html" title="Object representing one render to a RenderTarget or Viewport in the Ogre Composition framework.">Ogre::CompositionTargetPass</a></dd></dl>
</dd>
<dt>Pass </dt>
<dd><p class="startdd"></p>
<p class="interdd">Within a Target Section, there are one or more individual <a class="el" href="_compositor-_scripts.html#Compositor-Passes">Passes</a>, which perform a very specific action, such as rendering the original scene (or pulling the result from the previous compositor in the chain), rendering a fullscreen quad, or clearing one or more buffers. Typically within a single target section you will use the either a <code>render_scene</code> pass or a <code>render_quad</code> pass, not both. Clear can be used with either type.</p>
<p class="enddd"></p>
</dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// Black and white effect</span></div>
<div class="line">compositor B&amp;W</div>
<div class="line">{</div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Temporary textures</span></div>
<div class="line">        texture rt0 target_width target_height PF_BYTE_RGBA</div>
<div class="line"> </div>
<div class="line">        target rt0</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Render output from previous compositor (or original scene)</span></div>
<div class="line">            input previous</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        target_output</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Start with clear output</span></div>
<div class="line">            input none</div>
<div class="line">            <span class="comment">// Draw a fullscreen quad with the black and white image</span></div>
<div class="line">            pass render_quad</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Renders a fullscreen quad with a material</span></div>
<div class="line">                material <a class="code hl_namespace" href="namespace_ogre.html">Ogre</a>/Compositor/BlackAndWhite</div>
<div class="line">                input 0 rt0</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_ogre_html"><div class="ttname"><a href="namespace_ogre.html">Ogre</a></div><div class="ttdef"><b>Definition</b> OgreAlignedAllocator.h:34</div></div>
</div><!-- fragment --><p>The major components of a compositor are the <a class="el" href="_compositor-_scripts.html#Compositor-Techniques">Techniques</a>, the <a class="el" href="_compositor-_scripts.html#Compositor-Target-Passes">Target Sections</a> and the <a class="el" href="_compositor-_scripts.html#Compositor-Passes">Passes</a>, which are covered in detail in the following sections.</p>
<h1><a class="anchor" id="Compositor-Techniques"></a>
Techniques</h1>
<p>A compositor technique is much like a <a class="el" href="_material-_scripts.html#Techniques">material technique</a> in that it describes one approach to achieving the effect you’re looking for. A compositor definition can have more than one technique if you wish to provide some fallback should the hardware not support the technique you’d prefer to use. Techniques are evaluated for hardware support based on 2 things:</p>
<dl compact="compact">
<dt>Material support </dt>
<dd><p class="startdd"></p>
<p class="interdd">All <a class="el" href="_compositor-_scripts.html#Compositor-Passes">Passes</a> that render a fullscreen quad use a material; for the technique to be supported, all of the materials referenced must have at least one supported material technique. If they don’t, the compositor technique is marked as unsupported and won’t be used.</p>
<p class="enddd"></p>
</dd>
<dt>Texture format support </dt>
<dd><p class="startdd"></p>
<p class="interdd">This one is slightly more complicated. When you request a <a class="el" href="_compositor-_scripts.html#compositor-texture">texture</a> in your technique, you request a pixel format. Not all formats are natively supported by hardware, especially the floating point formats. However, in this case the hardware will typically downgrade the texture format requested to one that the hardware does support - with compositor effects though, you might want to use a different approach if this is the case. So, when evaluating techniques, the compositor will first look for native support for the exact pixel format you’ve asked for, and will skip onto the next technique if it is not supported, thus allowing you to define other techniques with simpler pixel formats which use a different approach. If it doesn’t find any techniques which are natively supported, it tries again, this time allowing the hardware to downgrade the texture format and thus should find at least some support for what you’ve asked for.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>As with material techniques, compositor techniques are evaluated in the order you define them in the script, so techniques declared first are preferred over those declared later.</p>
<dl class="section user"><dt></dt><dd>Format: technique { }</dd></dl>
<p>Techniques can have the following nested elements:</p>
<ul>
<li><a class="el" href="_compositor-_scripts.html#compositor-texture">texture</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005ftexture_005fref">texture_ref</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fscheme">scheme</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005flogic">compositor_logic</a></li>
<li><a class="el" href="_compositor-_scripts.html#Compositor-Target-Passes">target</a></li>
<li><a class="el" href="_compositor-_scripts.html#Compositor-Target-Passes">target_output</a></li>
</ul>
<p><a class="anchor" id="compositor_005ftexture"></a><a class="anchor" id="texture-2"></a></p>
<h2><a class="anchor" id="compositor-texture"></a>
texture</h2>
<p>This declares a render texture for use in subsequent <a class="el" href="_compositor-_scripts.html#Compositor-Target-Passes">Target Sections</a>. </p><dl class="section user"><dt></dt><dd>Format: texture &lt;name&gt; &lt;width&gt; &lt;height&gt; [depth] &lt;PixelFormat&gt; [&lt;MRT Pixel_Format2&gt;] [&lt;MRT Pixel_FormatN&gt;] [pooled] [gamma] [no_fsaa] [fsaa &lt;level&gt;] [depth_pool &lt;poolId&gt;] [&lt;scope&gt;] [cubic|2d_array]</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A name to give the render texture, which must be unique within this compositor. This name is used to reference the texture in <a class="el" href="_compositor-_scripts.html#Compositor-Target-Passes">Target Sections</a>, when the texture is rendered to, and in <a class="el" href="_compositor-_scripts.html#Compositor-Passes">Passes</a>, when the texture is used as input to a material rendering a fullscreen quad.</td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">height</td><td>The dimensions of the render texture. You can either specify a fixed width and height, or you can request that the texture is based on the physical dimensions of the viewport to which the compositor is attached. The options for the latter are either of <ul>
<li>
<code>target_width</code> and <code>target_height</code> </li>
<li>
<code>target_width_scaled &lt;factor&gt;</code> and <code>target_height_scaled &lt;factor&gt;</code> </li>
</ul>
where &lt;factor&gt; is the amount by which you wish to multiply the size of the main target to derive the dimensions. </td></tr>
    <tr><td class="paramname">depth</td><td>The number of slices in the texture. This is only relevant for <code>2d_array</code> textures. The default is 1 slice. </td></tr>
    <tr><td class="paramname">PixelFormat</td><td>The <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c" title="The pixel format used for images, textures, and render surfaces.">Ogre::PixelFormat</a> of the render texture. This affects how much memory it will take, what colour channels will be available, and what precision you will have within those channels. You can in fact repeat this element if you wish. If you do so, that means that this render texture becomes a Multiple Render Target (MRT), when the GPU writes to multiple textures at once. If you use a depth format here, the texture will be used as the depth attachment instead of the depth-buffer. Use the MRT format to specify both the depth and the colour attachments.</td></tr>
    <tr><td class="paramname">pooled</td><td>If present, this directive makes this texture ’pooled’ among compositor instances, which can save some memory.</td></tr>
    <tr><td class="paramname">gamma</td><td>If present, this directive means that sRGB gamma correction will be enabled on writes to this texture. You should remember to include the opposite sRGB conversion when you read this texture back in another material, such as a quad. This option will automatically enabled if you use a <code>render_scene</code> pass on this texture and the viewport on which the compositor is based has sRGB write support enabled.</td></tr>
    <tr><td class="paramname">no_fsaa</td><td></td></tr>
    <tr><td class="paramname">fsaa</td><td>If present, this directive controls the use of anti-aliasing on this texture. FSAA is only used if this texture is subject to a <code>render_scene</code> pass.<ul>
<li><code>fsaa 1</code> (the default) will match the FSAA level of the viewport</li>
<li><code>fsaa 0</code> will turn off FSAA for this texture. <code>fsaa 0</code> and <code>no_fsaa</code> have the same effect.</li>
<li><code>fsaa N</code> will set FSAA to level N.</li>
</ul>
</td></tr>
    <tr><td class="paramname">depth_pool</td><td>When present, this directive has to be followed by an integer. This directive is unrelated to the "pooled" directive. This directive determines from which Depth buffer pool the depth buffer will be selected. All RTs from all compositors (including render windows if the render system API allows it) with the same pool ID share the same depth buffers.<ul>
<li><code>depth_pool 0</code> means no depth buffer is used, which can save memory for passes that do not need a Depth buffer.</li>
<li>Default is <code>depth_pool 1</code>.</li>
<li>Ignored with depth pixel formats.</li>
</ul>
</td></tr>
    <tr><td class="paramname">scope</td><td>If present, this directive sets the scope for the texture for being accessed by other compositors using the <a class="el" href="_compositor-_scripts.html#compositor_005ftexture_005fref">texture_ref</a> directive. There are three options:<ol type="1">
<li><code>local_scope</code> (which is also the default) means that only the compositor defining the texture can access it.</li>
<li><code>chain_scope</code> means that the compositors after this compositor in the chain can reference its textures, and</li>
<li><code>global_scope</code> means that the entire application can access the texture. This directive also affects the creation of the textures (global textures are created once and thus can’t be used with the pooled directive, and can’t rely on viewport size).</li>
</ol>
</td></tr>
    <tr><td class="paramname">cubic</td><td>This texture is of type <a class="el" href="group___resources.html#ggaac3431531c3258e3c1c86ef8a4c06228ae295fe0fa26623b66cc023f462962344" title="cube map (six two dimensional textures, one for each cube face), used in combination with 3D texture ...">Ogre::TEX_TYPE_CUBE_MAP</a> - i.e. made up of 6 2D textures which are pasted around the inside of a cube.</td></tr>
    <tr><td class="paramname">2d_array</td><td>This texture is of type <a class="el" href="group___resources.html#ggaac3431531c3258e3c1c86ef8a4c06228a11589b2d4fbe6213dcdaf4e78894a3a7" title="2D texture array">Ogre::TEX_TYPE_2D_ARRAY</a> - i.e. made up of N 2D textures which are stacked on top of each other in a single texture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd>Example: texture rt0 512 512 PF_R8G8B8A8 </dd></dl>
<dl class="section user"><dt></dt><dd>Example: texture rt1 target_width target_height PF_FLOAT32_RGB </dd></dl>
<dl class="section user"><dt></dt><dd>Example : texture mrt_output target_width target_height PF_FLOAT16_RGBA PF_FLOAT16_RGBA chain_scope</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is imperative that if you use MRT that the shaders that render to it render to ALL the targets. Not doing so can cause undefined results. It is also important to note that although you can use different pixel formats for each target in a MRT, each one should have the same total bit depth since most cards do not support independent bit depths. If you try to use this feature on cards that do not support the number of MRTs you’ve asked for, the technique will be skipped (so you ought to write a fallback technique).</dd></dl>
<p><a class="anchor" id="compositor_005ftexture_005fref"></a><a class="anchor" id="texture_005fref"></a></p>
<h2><a class="anchor" id="autotoc_md64"></a>
texture_ref</h2>
<p>This declares a reference of a texture from another compositor to be used in this compositor.</p>
<dl class="section user"><dt></dt><dd>Format: texture_ref &lt;Local_Name&gt; &lt;Reference_Compositor&gt; &lt;Reference_Texture_Name&gt;</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Local_Name</td><td>A name to give the referenced texture, which must be unique within this compositor. This name is used to reference the texture in <a class="el" href="_compositor-_scripts.html#Compositor-Target-Passes">Target Sections</a>, when the texture is rendered to, and in <a class="el" href="_compositor-_scripts.html#Compositor-Passes">Passes</a>, when the texture is used as input to a material rendering a fullscreen quad.</td></tr>
    <tr><td class="paramname">Reference_Compositor</td><td>The name of the compositor that we are referencing a texture from</td></tr>
    <tr><td class="paramname">Reference_Texture_Name</td><td>The name of the texture in the compositor that we are referencing</td></tr>
  </table>
  </dd>
</dl>
<p>Make sure that the texture being referenced is scoped accordingly (either chain or global scope) and placed accordingly during chain creation (if referencing a chain-scoped texture, the compositor must be present in the chain and placed before the compositor referencing it).</p>
<dl class="section user"><dt></dt><dd>Example : texture_ref GBuffer GBufferCompositor mrt_output</dd></dl>
<p><a class="anchor" id="compositor_005fscheme"></a><a class="anchor" id="scheme-2"></a></p>
<h2><a class="anchor" id="autotoc_md65"></a>
scheme</h2>
<p>This gives a compositor technique a scheme name, allowing you to manually switch between different techniques for this compositor when instantiated on a viewport by calling <a class="el" href="class_ogre_1_1_compositor_instance.html#a0f111f02ceebc1a2589fc07663dbe2ee" title="Pick a technique to use to render this compositor based on a scheme.">Ogre::CompositorInstance::setScheme</a>.</p>
<dl class="section user"><dt></dt><dd>Format: scheme &lt;Name&gt;</dd></dl>
<p><a class="anchor" id="compositor_005flogic"></a><a class="anchor" id="compositor_005flogic-1"></a></p>
<h2><a class="anchor" id="autotoc_md66"></a>
compositor_logic</h2>
<p>This connects between a compositor and code that it requires in order to function correctly. When an instance of this compositor will be created, the compositor logic will be notified and will have the chance to prepare the compositor’s operation (for example, adding a listener).</p>
<dl class="section user"><dt></dt><dd>Format: compositor_logic &lt;Name&gt;</dd></dl>
<p>Registration of compositor logics is done by name through <a class="el" href="class_ogre_1_1_compositor_manager.html#a9c7d4168d56868599badb2789d54157c" title="Register a compositor logic for listening in to expecting composition techniques.">Ogre::CompositorManager::registerCompositorLogic</a>.</p>
<h1><a class="anchor" id="Compositor-Target-Passes"></a>
Target Sections</h1>
<p>A target section defines the rendering of either a render texture or the final output. You can update the same target multiple times by adding more than one target section to your compositor script - this is very useful for ’ping pong’ renders between a couple of render textures to perform complex convolutions that cannot be done in a single render, such as blurring.</p>
<p>There are two types of target sections, the sort that updates a render texture</p>
<dl class="section user"><dt></dt><dd>Format: target &lt;Name&gt; [&lt;slice&gt;] { }</dd></dl>
<p>and the sort that defines the final output render</p>
<dl class="section user"><dt></dt><dd>Format: target_output { }</dd></dl>
<p>The contents of both are identical, the only real difference is that you can only have a single target_output entry, whilst you can have many target entries.</p>
<p>Note, the target entry can refer to <a class="el" href="_hardware-_buffers.html#Cube-map-textures">Cube map textures</a> and 2D Array textures. Therefore, it takes an optional <em>decimal</em> slice parameter that specifies which face you want to render on. The default is 0, hence +X.</p>
<p>Here are the attributes you can use in a ’target’ or ’target_output’ section of a .compositor script:</p>
<ul>
<li><a class="el" href="_compositor-_scripts.html#compositor_005ftarget_005finput">input</a></li>
<li><a class="el" href="_compositor-_scripts.html#only_005finitial">only_initial</a></li>
<li><a class="el" href="_compositor-_scripts.html#visibility_005fmask">visibility_mask</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005flod_005fbias">lod_bias</a></li>
<li><a class="el" href="_compositor-_scripts.html#material_005fscheme">material_scheme</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fshadows">shadows</a></li>
</ul>
<p><a class="anchor" id="compositor_005ftarget_005finput"></a><a class="anchor" id="input"></a></p>
<h2><a class="anchor" id="autotoc_md67"></a>
input</h2>
<p>Sets input mode of the target, which tells the target pass what is pulled in before any of its own passes are rendered.</p>
<dl class="section user"><dt></dt><dd>Format: input (none | previous) </dd></dl>
<dl class="section user"><dt></dt><dd>Default: input none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>The target will have nothing as input, all the contents of the target must be generated using its own passes. Note this does not mean the target will be empty, just no data will be pulled in. For it to truly be blank you’d need a ’clear’ pass within this target.</td></tr>
    <tr><td class="paramname">previous</td><td>The target will pull in the previous contents of the viewport. This will be either the original scene if this is the first compositor in the chain, or it will be the output from the previous compositor in the chain if the viewport has multiple compositors enabled.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="only_005finitial"></a><a class="anchor" id="only_005finitial-1"></a></p>
<h2><a class="anchor" id="autotoc_md68"></a>
only_initial</h2>
<p>If set to on, this target pass will only execute once initially after the effect has been enabled. This could be useful to perform once-off renders, after which the static contents are used by the rest of the compositor.</p>
<dl class="section user"><dt></dt><dd>Format: only_initial (on | off) </dd></dl>
<dl class="section user"><dt></dt><dd>Default: only_initial off</dd></dl>
<p><a class="anchor" id="visibility_005fmask"></a><a class="anchor" id="visibility_005fmask-1"></a></p>
<h2><a class="anchor" id="autotoc_md69"></a>
visibility_mask</h2>
<p>Sets the visibility mask for any render_scene passes performed in this target pass. This is a bitmask (specified as decimal or hex) and maps to <a class="el" href="class_ogre_1_1_viewport.html#ad5a4fe00ee05861c157bf63e78e1c2b0" title="Sets a per-viewport visibility mask.">Ogre::Viewport::setVisibilityMask</a>. </p><dl class="section user"><dt></dt><dd>Format: visibility_mask &lt;mask&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: visibility_mask 0xFFFFFFFF</dd></dl>
<p><a class="anchor" id="compositor_005flod_005fbias"></a><a class="anchor" id="lod_005fbias"></a></p>
<h2><a class="anchor" id="autotoc_md70"></a>
lod_bias</h2>
<p>Set the scene LOD bias for any render_scene passes performed in this target pass. The default is 1.0, everything below that means lower quality, higher means higher quality. </p><dl class="section user"><dt></dt><dd>Format: lod_bias &lt;lodbias&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: lod_bias 1.0</dd></dl>
<p><a class="anchor" id="compositor_005fshadows"></a><a class="anchor" id="shadows"></a></p>
<h2><a class="anchor" id="autotoc_md71"></a>
shadows</h2>
<p>Sets whether shadows should be rendered during any render_scene pass performed in this target pass.</p>
<dl class="section user"><dt></dt><dd>Format: shadows (on | off) </dd></dl>
<dl class="section user"><dt></dt><dd>Default: shadows on</dd></dl>
<p><a class="anchor" id="material_005fscheme"></a><a class="anchor" id="material_005fscheme-1"></a></p>
<h2><a class="anchor" id="autotoc_md72"></a>
material_scheme</h2>
<p>If set, indicates the material scheme to use for any render_scene pass. Useful for performing special-case rendering effects.</p>
<dl class="section user"><dt></dt><dd>Format: material_scheme &lt;scheme name&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: None</dd></dl>
<h1><a class="anchor" id="Compositor-Passes"></a>
Passes</h1>
<p>A pass is a single rendering action to be performed in a target section. </p><dl class="section user"><dt></dt><dd>Format: pass &lt;type&gt; [custom name] { }</dd></dl>
<p>There are the following types of a pass:</p>
<dl compact="compact">
<dt>clear </dt>
<dd><p class="startdd"></p>
<p class="interdd">This kind of pass sets the contents of one or more buffers in the target to a fixed value. So this could clear the colour buffer to a fixed colour, set the depth buffer to a certain set of contents, fill the stencil buffer with a value, or any combination of the above.</p>
<p class="enddd"></p>
</dd>
<dt>stencil </dt>
<dd><p class="startdd"></p>
<p class="interdd">This kind of pass configures stencil operations for the subsequent passes. It can set the stencil compare function, operations and reference values for you to perform your own stencil effects.</p>
<p class="enddd"></p>
</dd>
<dt>render_scene </dt>
<dd><p class="startdd"></p>
<p class="interdd">This kind of pass performs a regular rendering of the scene. It will use the <a class="el" href="_compositor-_scripts.html#visibility_005fmask">visibility_mask</a>, <a class="el" href="_compositor-_scripts.html#compositor_005flod_005fbias">lod_bias</a>, and <a class="el" href="_compositor-_scripts.html#material_005fscheme">material_scheme</a> from the parent target pass.</p>
<p class="enddd"></p>
</dd>
<dt>render_quad </dt>
<dd><p class="startdd"></p>
<p class="interdd">This kind of pass renders a quad over the entire render target, using a given material. You will undoubtedly want to pull in the results of other target passes into this operation to perform fullscreen effects.</p>
<p class="enddd"></p>
</dd>
<dt>compute </dt>
<dd><p class="startdd"></p>
<p class="interdd">This kind of a pass dispatches a compute shader as attached to the given material. Compute shaders are independent from normal rendering pipeline as triggered by <code>render_scene</code> or <code>render_quad</code>. They do not have any predefined input/ outputs but rather read/ write to any buffers you attach to them.</p>
<p class="enddd"></p>
</dd>
<dt>render_custom </dt>
<dd><p class="startdd"></p>
<p class="interdd">This kind of pass is just a callback to user code for the composition pass specified in the custom name (and registered via <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass.">Ogre::CompositorManager::registerCustomCompositionPass</a>) and allows the user to create custom render operations for more advanced effects. This is the only pass type that requires the custom name parameter.</p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="autotoc_md73"></a>
render_quad &amp; compute</h2>
<p>Here are the attributes you can use in the <code>render_quad</code> and <code>compute</code> sections of a .compositor script:</p>
<ul>
<li><a class="el" href="_compositor-_scripts.html#material">material</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fpass_005finput">input</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fpass_005fidentifier">identifier</a></li>
<li><a class="el" href="_compositor-_scripts.html#thread_groups">thread_groups</a></li>
<li><a class="el" href="_compositor-_scripts.html#quad_normals">quad_normals</a></li>
</ul>
<p><a class="anchor" id="material"></a><a class="anchor" id="material-1"></a></p>
<h3><a class="anchor" id="autotoc_md74"></a>
material</h3>
<p>Sets the material to be used. With <code>compute</code> passes only the compute shader is used and only global auto parameter can be accessed. For <code>render_quad</code> you will want to use shaders in this material to perform fullscreen effects, and use the <a class="el" href="_compositor-_scripts.html#compositor_005fpass_005finput">input</a> attribute to map other texture targets into the texture bindings needed by this material.</p>
<dl class="section user"><dt></dt><dd>Format: material &lt;Name&gt;</dd></dl>
<p><a class="anchor" id="compositor_005fpass_005finput"></a><a class="anchor" id="input-1"></a></p>
<h3><a class="anchor" id="autotoc_md75"></a>
input</h3>
<p>This is how you map one or more local <a class="el" href="_compositor-_scripts.html#compositor-texture">texture</a> into the material you’re using to render. To bind more than one texture, repeat this attribute with different texUnit indices.</p>
<dl class="section user"><dt></dt><dd>Format: input &lt;texUnit&gt; &lt;name&gt; [&lt;mrtIndex&gt;]</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texUnit</td><td>The index of the target texture unit, must be a number in the range [0, OGRE_MAX_TEXTURE_LAYERS-1]. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the local render texture to bind, as declared by <a class="el" href="_compositor-_scripts.html#compositor-texture">texture</a> and rendered to in one or more <a class="el" href="_compositor-_scripts.html#Compositor-Target-Passes">Target Sections</a>. </td></tr>
    <tr><td class="paramname">mrtIndex</td><td>If the local texture that you’re referencing is a Multiple Render Target (MRT), this identifies the surface from the MRT that you wish to reference (0 is the first surface, 1 the second etc).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd>Example: input 0 rt0</dd></dl>
<p><a class="anchor" id="compositor_005fpass_005fidentifier"></a><a class="anchor" id="identifier"></a></p>
<h3><a class="anchor" id="autotoc_md76"></a>
identifier</h3>
<p>Associates a numeric identifier with a pass involving a material. This is useful for registering a listener with <a class="el" href="class_ogre_1_1_compositor_instance.html#ad2dcb9ae6aa4e0dfc0843a4cab32f800" title="Add a listener.">Ogre::CompositorInstance::addListener</a>, and being able to identify which pass it is that’s being processed, so that material parameters can be varied. Numbers between 0 and 2^32 - 1 are allowed.</p>
<dl class="section user"><dt></dt><dd>Format: identifier &lt;number&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: identifier 99945 </dd></dl>
<dl class="section user"><dt></dt><dd>Default: identifier 0</dd></dl>
<p><a class="anchor" id="quad_normals"></a></p>
<h3><a class="anchor" id="autotoc_md77"></a>
quad_normals</h3>
<p>Pass the camera Frustum far corner vectors in the quad normals for passes of type <code>quad</code>. This is particularly useful for efficiently reconstructing position using only the depth and the corners.</p>
<dl class="section user"><dt></dt><dd>Format: quad_normals &lt;camera_far_corners_world_space|camera_far_corners_view_space&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: None</dd></dl>
<p><a class="anchor" id="thread_groups"></a></p>
<h3><a class="anchor" id="autotoc_md78"></a>
thread_groups</h3>
<p>Passes of type <code>compute</code> operate on an abstract "compute space". This space is typically divided into threads and thread groups (work groups). The size of a thread group is defined inside the compute shader itself. This defines how many groups should be launched.</p>
<dl class="section user"><dt></dt><dd>Example: if you want to process a 256x256px image and have a thread group size of 16x16x1, you want to specify <code>16 16 1</code> here as well.</dd></dl>
<dl class="section user"><dt></dt><dd>Format: thread_groups &lt;groups_x&gt; &lt;groups_y&gt; &lt;groups_z&gt;</dd></dl>
<h2><a class="anchor" id="autotoc_md79"></a>
render_scene</h2>
<p>Here are the attributes you can use in a <code>render_scene</code> section of a .compositor script:</p>
<ul>
<li><a class="el" href="_compositor-_scripts.html#first_005frender_005fqueue">first_render_queue</a></li>
<li><a class="el" href="_compositor-_scripts.html#last_005frender_005fqueue">last_render_queue</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fpass_005fmaterial_005fscheme">material_scheme</a></li>
<li><a class="el" href="_compositor-_scripts.html#camera">camera</a></li>
</ul>
<p><a class="anchor" id="first_005frender_005fqueue"></a><a class="anchor" id="first_005frender_005fqueue-1"></a></p>
<h3><a class="anchor" id="autotoc_md80"></a>
first_render_queue</h3>
<p>For passes of type ’render_scene’, this sets the first render queue id that is included in the render. Defaults to the value of <a class="el" href="group___render_system.html#ggad08013a341ff0ef07c39fa3502bf6c00a6f63169671858ecbaf90d237f5726cd4" title="Use this queue for objects which must be rendered first e.g. backgrounds.">Ogre::RENDER_QUEUE_BACKGROUND</a>. </p><dl class="section user"><dt></dt><dd>Format: first_render_queue &lt;id&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: first_render_queue 0</dd></dl>
<p><a class="anchor" id="last_005frender_005fqueue"></a><a class="anchor" id="last_005frender_005fqueue-1"></a></p>
<h3><a class="anchor" id="autotoc_md81"></a>
last_render_queue</h3>
<p>For passes of type ’render_scene’, this sets the last render queue id that is included in the render. Defaults to the value of <a class="el" href="group___render_system.html#ggad08013a341ff0ef07c39fa3502bf6c00a53468f34583f3a469cc8ca2f444fb6ff" title="Used for skyboxes if rendered last.">Ogre::RENDER_QUEUE_SKIES_LATE</a>. </p><dl class="section user"><dt></dt><dd>Format: last_render_queue &lt;id&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: last_render_queue 95</dd></dl>
<p><a class="anchor" id="compositor_005fpass_005fmaterial_005fscheme"></a></p>
<h3><a class="anchor" id="autotoc_md82"></a>
material_scheme</h3>
<p>If set, indicates the material scheme to use for this pass only. Useful for performing special-case rendering effects. This will overwrite any scheme set in the parent <a class="el" href="_compositor-_scripts.html#Compositor-Target-Passes">Target Sections</a>. </p><dl class="section user"><dt></dt><dd>Format: material_scheme &lt;scheme name&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: None</dd></dl>
<p><a class="anchor" id="camera"></a></p>
<h3><a class="anchor" id="autotoc_md83"></a>
camera</h3>
<p>Use a camera different from the output Viewport for rendering the scene into this target. Very useful for reflection effects like mirrors or water. The camera will be searched by name in the currently active scene and must be created prior to activating the compositor.</p>
<p>The optional parameter <code>align_to_face</code> automatically rotates the camera towards the target cubemap face, when rendering to a cubic texture.</p>
<dl class="section user"><dt></dt><dd>Format: camera &lt;name&gt; [&lt;align_to_face&gt;] </dd></dl>
<dl class="section user"><dt></dt><dd>Default: None</dd></dl>
<h2><a class="anchor" id="Clear-Section"></a>
clear</h2>
<p>For passes of type ’clear’, this section defines the buffer clearing parameters. <br  />
</p>
<dl class="section user"><dt></dt><dd>Format: pass clear { }</dd></dl>
<p>Here are the attributes you can use in a ’clear’ section of a .compositor script:</p>
<ul>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fclear_005fbuffers">buffers</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fclear_005fcolour_005fvalue">colour_value</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fclear_005fdepth_005fvalue">depth_value</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fclear_005fstencil_005fvalue">stencil_value</a> <a class="anchor" id="compositor_005fclear_005fbuffers"></a><a class="anchor" id="buffers"></a></li>
</ul>
<h3><a class="anchor" id="autotoc_md84"></a>
buffers</h3>
<p>Sets the buffers cleared by this pass.</p>
<dl class="section user"><dt></dt><dd>Format: buffers [colour] [depth] [stencil] </dd></dl>
<dl class="section user"><dt></dt><dd>Default: buffers colour depth</dd></dl>
<p><a class="anchor" id="compositor_005fclear_005fcolour_005fvalue"></a><a class="anchor" id="colour_005fvalue"></a></p>
<h3><a class="anchor" id="autotoc_md85"></a>
colour_value</h3>
<p>Set the colour used to fill the colour buffer by this pass, if the colour buffer is being cleared </p><dl class="section user"><dt></dt><dd>Format: colour_value (&lt;red&gt; &lt;green&gt; &lt;blue&gt; &lt;alpha&gt; | auto) </dd></dl>
<dl class="section user"><dt></dt><dd>Default: colour_value 0 0 0 0</dd></dl>
<p>If set to <code>auto</code> the background colour of the viewport is used, to which the parent compositor is attached to.</p>
<p><a class="anchor" id="compositor_005fclear_005fdepth_005fvalue"></a><a class="anchor" id="depth_005fvalue"></a></p>
<h3><a class="anchor" id="autotoc_md86"></a>
depth_value</h3>
<p>Set the depth value used to fill the depth buffer by this pass, if the depth buffer is being cleared </p><dl class="section user"><dt></dt><dd>Format: depth_value &lt;depth&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: depth_value 1.0</dd></dl>
<p><a class="anchor" id="compositor_005fclear_005fstencil_005fvalue"></a><a class="anchor" id="stencil_005fvalue"></a></p>
<h3><a class="anchor" id="autotoc_md87"></a>
stencil_value</h3>
<p>Set the stencil value used to fill the stencil buffer by this pass, if the stencil buffer is being cleared </p><dl class="section user"><dt></dt><dd>Format: stencil_value &lt;value&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: stencil_value 0.0</dd></dl>
<h2><a class="anchor" id="Stencil-Section"></a>
stencil</h2>
<p>For passes of type ’stencil’, this section defines the stencil operation parameters.</p>
<dl class="section user"><dt></dt><dd>Format: pass stencil { }</dd></dl>
<p>The stencil buffer is used to mask out pixels in the render target, allowing you to do effects like mirrors, cut-outs, stencil shadows and more. Each of your batches of rendering is likely to ignore the stencil buffer, update it with new values, or apply it to mask the output of the render.</p>
<p>The stencil test is: $$(referenceValue\,\&amp;\,compareMask)\;compareOp\;(stencilBuffer\,\&amp;\,compareMask)$$</p>
<p>The result of this will cause one of 3 actions depending on whether</p><ol type="1">
<li>the stencil test fails</li>
<li>the stencil test succeeds but the depth buffer check fails</li>
<li>both depth buffer check and stencil test pass  </li>
</ol>
<p>Here are the attributes you can use in a ’stencil’ section of a .compositor script:</p>
<ul>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fstencil_005fcheck">check</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fstencil_005fcomp_005ffunc">comp_func</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fstencil_005fref_005fvalue">ref_value</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fstencil_005fmask">mask</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fstencil_005ffail_005fop">fail_op</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fstencil_005fdepth_005ffail_005fop">depth_fail_op</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fstencil_005fpass_005fop">pass_op</a></li>
<li><a class="el" href="_compositor-_scripts.html#compositor_005fstencil_005ftwo_005fsided">two_sided</a> <a class="anchor" id="compositor_005fstencil_005fcheck"></a><a class="anchor" id="check"></a></li>
</ul>
<h3><a class="anchor" id="autotoc_md88"></a>
check</h3>
<p>Enables or disables the stencil check. The rest of the options in this section do nothing if the stencil check is off. </p><dl class="section user"><dt></dt><dd>Format: check (on | off)</dd></dl>
<p><a class="anchor" id="compositor_005fstencil_005fcomp_005ffunc"></a><a class="anchor" id="comp_005ffunc"></a></p>
<h3><a class="anchor" id="autotoc_md89"></a>
comp_func</h3>
<p>Comparison operator for the stencil test.  </p>
<dl class="section user"><dt></dt><dd>Format: comp_func &lt;func&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: comp_func always_pass</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>one of <a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6" title="Comparison functions used for the depth/stencil buffer operations and others.">Ogre::CompareFunction</a> without the <code>CMPF_</code> prefix. E.g. <code>CMPF_LESS_EQUAL</code> becomes <code>less_equal</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="compositor_005fstencil_005fref_005fvalue"></a><a class="anchor" id="ref_005fvalue"></a></p>
<h3><a class="anchor" id="autotoc_md90"></a>
ref_value</h3>
<p>The reference value used in the stencil comparison.  </p>
<dl class="section user"><dt></dt><dd>Format: ref_value &lt;value&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: ref_value 0.0</dd></dl>
<p><a class="anchor" id="compositor_005fstencil_005fmask"></a><a class="anchor" id="mask"></a></p>
<h3><a class="anchor" id="autotoc_md91"></a>
mask</h3>
<p>The bitmask applied to both the stencil value and the reference value before comparison.  </p>
<dl class="section user"><dt></dt><dd>Format: mask &lt;value&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: mask 4294967295</dd></dl>
<p><a class="anchor" id="compositor_005fstencil_005ffail_005fop"></a><a class="anchor" id="fail_005fop"></a></p>
<h3><a class="anchor" id="autotoc_md92"></a>
fail_op</h3>
<p>The action to perform when the stencil check fails.  </p>
<dl class="section user"><dt></dt><dd>Format: fail_op &lt;op&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: fail_op keep</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>one of <a class="el" href="group___render_system.html#gae8bb1cb809660de802d1d592ba4adb61" title="Enum describing the various actions which can be taken on the stencil buffer.">Ogre::StencilOperation</a> without the <code>SOP_</code> prefix. E.g. <code>SOP_INCREMENT_WRAP</code> becomes <code>increment_wrap</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="compositor_005fstencil_005fdepth_005ffail_005fop"></a><a class="anchor" id="depth_005ffail_005fop"></a></p>
<h3><a class="anchor" id="autotoc_md93"></a>
depth_fail_op</h3>
<p>The action to perform when the stencil check passes, but the depth buffer check fails.  </p>
<dl class="section user"><dt></dt><dd>Format: depth_fail_op &lt;op&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: depth_fail_op keep</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>one of <a class="el" href="group___render_system.html#gae8bb1cb809660de802d1d592ba4adb61" title="Enum describing the various actions which can be taken on the stencil buffer.">Ogre::StencilOperation</a> without the <code>SOP_</code> prefix. E.g. <code>SOP_INCREMENT_WRAP</code> becomes <code>increment_wrap</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="compositor_005fstencil_005fpass_005fop"></a><a class="anchor" id="pass_005fop"></a></p>
<h3><a class="anchor" id="autotoc_md94"></a>
pass_op</h3>
<p>The action to take when both the stencil and depth check pass.  </p>
<dl class="section user"><dt></dt><dd>Format: pass_op &lt;op&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: pass_op keep</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>one of <a class="el" href="group___render_system.html#gae8bb1cb809660de802d1d592ba4adb61" title="Enum describing the various actions which can be taken on the stencil buffer.">Ogre::StencilOperation</a> without the <code>SOP_</code> prefix. E.g. <code>SOP_INCREMENT_WRAP</code> becomes <code>increment_wrap</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="compositor_005fstencil_005ftwo_005fsided"></a><a class="anchor" id="two_005fsided"></a></p>
<h3><a class="anchor" id="autotoc_md95"></a>
two_sided</h3>
<p>Toggles two-sided stencil operation, which swaps increment and decrement for back-facing polygons.  </p>
<dl class="section user"><dt></dt><dd>Format: two_sided (on | off) </dd></dl>
<dl class="section user"><dt></dt><dd>Default: two_sided off</dd></dl>
<h1><a class="anchor" id="Applying-a-Compositor"></a>
Applying a Compositor</h1>
<p>Adding a compositor instance to a viewport is very simple. All you need to do is:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="class_ogre_1_1_compositor_manager.html#a14161d8b081fa94f9caae3a0473d08db">Ogre::CompositorManager::getSingleton</a>().addCompositor(viewport, compositorName);</div>
<div class="ttc" id="aclass_ogre_1_1_compositor_manager_html_a14161d8b081fa94f9caae3a0473d08db"><div class="ttname"><a href="class_ogre_1_1_compositor_manager.html#a14161d8b081fa94f9caae3a0473d08db">Ogre::CompositorManager::getSingleton</a></div><div class="ttdeci">static CompositorManager &amp; getSingleton(void)</div><div class="ttdoc">Get the singleton instance.</div></div>
</div><!-- fragment --><p>Where viewport is a pointer to your viewport, and compositorName is the name of the compositor to create an instance of. By doing this, a new instance of a compositor will be added to a new compositor chain on that viewport. You can call the method multiple times to add further compositors to the chain on this viewport. By default, each compositor which is added is disabled, but you can change this state by calling:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="class_ogre_1_1_compositor_manager.html#a14161d8b081fa94f9caae3a0473d08db">Ogre::CompositorManager::getSingleton</a>().setCompositorEnabled(viewport, compositorName, enabledOrDisabled);</div>
</div><!-- fragment --><p>For more information on defining and using compositors, see <code>Sample_Compositor</code> in the Samples area, together with the Examples.compositor script in the media area.</p>
<h1><a class="anchor" id="Compositor-API"></a>
Programmatic creation</h1>
<p>In case you need to create Compositors programmatically, see the following example for how the script is mapped to the API.</p>
<div class="fragment"><div class="line">compositor Glass</div>
<div class="line">{</div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        texture rt0 target_width target_height PF_BYTE_RGB</div>
<div class="line"> </div>
<div class="line">        target rt0 { input previous }</div>
<div class="line"> </div>
<div class="line">        target_output</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Start with clear output</span></div>
<div class="line">            input none</div>
<div class="line"> </div>
<div class="line">            pass render_quad</div>
<div class="line">            {</div>
<div class="line">                material <a class="code hl_namespace" href="namespace_ogre.html">Ogre</a>/Compositor/GlassPass</div>
<div class="line">                input 0 rt0</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>becomes </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ogre.html">Ogre</a>;</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">CompositorPtr</a> <a class="code hl_struct" href="struct_ogre_1_1vector.html">glass</a> = CompositorManager::getSingleton().create(<span class="stringliteral">&quot;Glass&quot;</span>, RGN_DEFAULT);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_composition_technique.html">CompositionTechnique</a> *<a class="code hl_struct" href="struct_ogre_1_1vector.html">t</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">glass</a>-&gt;createTechnique();</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_struct" href="struct_ogre_1_1vector.html">td</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">t</a>-&gt;createTextureDefinition(<span class="stringliteral">&quot;rt0&quot;</span>);</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">td</a>-&gt;width = 0;</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">td</a>-&gt;height = 0;</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">td</a>-&gt;format = PF_BYTE_RGB;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_composition_target_pass.html">CompositionTargetPass</a> *<a class="code hl_struct" href="struct_ogre_1_1vector.html">tp</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">t</a>-&gt;createTargetPass();</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">tp</a>-&gt;setInputMode(CompositionTargetPass::IM_PREVIOUS);</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">tp</a>-&gt;setOutputName(<span class="stringliteral">&quot;rt0&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_composition_target_pass.html">CompositionTargetPass</a> *<a class="code hl_struct" href="struct_ogre_1_1vector.html">tp</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">t</a>-&gt;getOutputTargetPass();</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">tp</a>-&gt;setInputMode(CompositionTargetPass::IM_NONE);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_composition_pass.html">CompositionPass</a> *pass = <a class="code hl_struct" href="struct_ogre_1_1vector.html">tp</a>-&gt;createPass(CompositionPass::PT_RENDERQUAD)</div>
<div class="line">pass-&gt;<a class="code hl_function" href="class_ogre_1_1_composition_pass.html#a453231b980fc04dd9af9f330feec5236">setMaterialName</a>(<span class="stringliteral">&quot;Ogre/Compositor/GlassPass&quot;</span>);</div>
<div class="line">pass-&gt;<a class="code hl_function" href="class_ogre_1_1_composition_pass.html#afa546e1e7d46879c3dc6ce5dff470d4d">setInput</a>(0, <span class="stringliteral">&quot;rt0&quot;</span>);</div>
<div class="ttc" id="aclass_ogre_1_1_composition_pass_html"><div class="ttname"><a href="class_ogre_1_1_composition_pass.html">Ogre::CompositionPass</a></div><div class="ttdoc">Object representing one pass or operation in a composition sequence.</div><div class="ttdef"><b>Definition</b> OgreCompositionPass.h:47</div></div>
<div class="ttc" id="aclass_ogre_1_1_composition_pass_html_a453231b980fc04dd9af9f330feec5236"><div class="ttname"><a href="class_ogre_1_1_composition_pass.html#a453231b980fc04dd9af9f330feec5236">Ogre::CompositionPass::setMaterialName</a></div><div class="ttdeci">void setMaterialName(const String &amp;name)</div><div class="ttdoc">Set the material used by this pass.</div></div>
<div class="ttc" id="aclass_ogre_1_1_composition_pass_html_afa546e1e7d46879c3dc6ce5dff470d4d"><div class="ttname"><a href="class_ogre_1_1_composition_pass.html#afa546e1e7d46879c3dc6ce5dff470d4d">Ogre::CompositionPass::setInput</a></div><div class="ttdeci">void setInput(size_t id, const String &amp;input=BLANKSTRING, size_t mrtIndex=0)</div><div class="ttdoc">Set an input local texture.</div></div>
<div class="ttc" id="aclass_ogre_1_1_composition_target_pass_html"><div class="ttname"><a href="class_ogre_1_1_composition_target_pass.html">Ogre::CompositionTargetPass</a></div><div class="ttdoc">Object representing one render to a RenderTarget or Viewport in the Ogre Composition framework.</div><div class="ttdef"><b>Definition</b> OgreCompositionTargetPass.h:48</div></div>
<div class="ttc" id="aclass_ogre_1_1_composition_technique_html"><div class="ttname"><a href="class_ogre_1_1_composition_technique.html">Ogre::CompositionTechnique</a></div><div class="ttdoc">Base composition technique, can be subclassed in plugins.</div><div class="ttdef"><b>Definition</b> OgreCompositionTechnique.h:47</div></div>
<div class="ttc" id="astruct_ogre_1_1vector_html"><div class="ttname"><a href="struct_ogre_1_1vector.html">Ogre::vector</a></div><div class="ttdef"><b>Definition</b> OgreDeprecated.h:54</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li><li class="navelem"><a class="el" href="_scripts.html">Scripts</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
