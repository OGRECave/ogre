<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_shadows.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Shadows</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Enabling-shadows">Enabling shadows</a></li>
<li class="level1"><a href="#Opting-out-of-shadows">Opting out of shadows</a></li>
<li class="level1"><a href="#Stencil-Shadows">Stencil Shadows</a><ul><li class="level2"><a href="#autotoc_md35">CPU Overhead</a></li>
<li class="level2"><a href="#autotoc_md36">Extrusion distance</a></li>
<li class="level2"><a href="#autotoc_md37">Camera far plane positioning</a></li>
<li class="level2"><a href="#autotoc_md38">Mesh edge lists</a></li>
<li class="level2"><a href="#autotoc_md39">The Silhouette Edge</a></li>
<li class="level2"><a href="#autotoc_md40">Be realistic</a></li>
<li class="level2"><a href="#autotoc_md41">Stencil optimisations performed by Ogre</a></li>
</ul>
</li>
<li class="level1"><a href="#Texture_002dbased-Shadows">Texture-based Shadows</a><ul><li class="level2"><a href="#autotoc_md42">Directional Lights</a></li>
<li class="level2"><a href="#autotoc_md43">Spotlights</a></li>
<li class="level2"><a href="#autotoc_md44">Point Lights</a></li>
<li class="level2"><a href="#autotoc_md45">Shadow Casters and Shadow Receivers</a></li>
</ul>
</li>
<li class="level1"><a href="#Configuring-Texture-Shadows">Configuring Texture Shadows</a><ul><li class="level2"><a href="#autotoc_md46">Maximum number of shadow textures</a></li>
<li class="level2"><a href="#autotoc_md47">Shadow texture size</a></li>
<li class="level2"><a href="#autotoc_md48">Shadow far distance</a></li>
<li class="level2"><a href="#autotoc_md49">Shadow texture offset (Directional Lights)</a></li>
<li class="level2"><a href="#autotoc_md50">Shadow fade settings</a></li>
</ul>
</li>
<li class="level1"><a href="#texture_shadows_and_shaders">Texture shadows and vertex / fragment programs</a><ul><li class="level2"><a href="#autotoc_md51">Custom shadow camera setups</a></li>
<li class="level2"><a href="#autotoc_md52">Shadow texture Depth Buffer sharing</a></li>
<li class="level2"><a href="#Integrated-Texture-Shadows">Integrated Texture Shadows</a></li>
</ul>
</li>
<li class="level1"><a href="#Modulative-Shadows">Modulative Shadows</a><ul><li class="level2"><a href="#autotoc_md53">Shadow Colour</a></li>
</ul>
</li>
<li class="level1"><a href="#Additive-Light-Masking">Additive Light Masking</a><ul><li class="level2"><a href="#Manually-Categorising-Illumination-Passes">Manually Categorising Illumination Passes</a></li>
<li class="level2"><a href="#Pass-Classification-and-Vertex-Programs">Pass Classification and Vertex Programs</a></li>
<li class="level2"><a href="#Static-Lighting">Static Lighting</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Shadows are clearly an important part of rendering a believable scene - they provide a more tangible feel to the objects in the scene, and aid the viewer in understanding the spatial relationship between objects. Unfortunately, shadows are also one of the most challenging aspects of 3D rendering, and they are still very much an active area of research. Whilst there are many techniques to render shadows, none is perfect and they all come with advantages and disadvantages. For this reason, Ogre provides multiple shadow implementations, with plenty of configuration settings, so you can choose which technique is most appropriate for your scene.</p>
<p>Shadow implementations fall into 2 basic categories:</p><ul>
<li><a class="el" href="_shadows.html#Stencil-Shadows">Stencil Shadows</a></li>
<li><a class="el" href="_shadows.html#Texture_002dbased-Shadows">Texture-based Shadows</a>.</li>
</ul>
<p>This describes the method by which the shape of the shadow is generated.</p>
<p>In addition, there is more than one way to render the shadow into the scene:</p><ul>
<li><a class="el" href="_shadows.html#Modulative-Shadows">Modulative Shadows</a>, which darkens the scene in areas of shadow, and</li>
<li><a class="el" href="_shadows.html#Additive-Light-Masking">Additive Light Masking</a>, which by contrast builds up light contribution in areas which are not in shadow.</li>
</ul>
<p>You also have the option of <a class="el" href="_shadows.html#Integrated-Texture-Shadows">Integrated Texture Shadows</a> which gives you complete control over texture shadow application, allowing for complex single-pass shadowing shaders. Ogre supports all these combinations.</p>
<h1><a class="anchor" id="Enabling-shadows"></a>
Enabling shadows</h1>
<p>Shadows are disabled by default, here’s how you turn them on and configure them in the general sense:</p>
<ol type="1">
<li>Enable a shadow technique on the SceneManager as the <b>first</b> thing you doing your scene setup. It is important that this is done first because the shadow technique can alter the way meshes are loaded. Here’s an example: <div class="fragment"><div class="line">mSceneMgr-&gt;setShadowTechnique(SHADOWTYPE_STENCIL_ADDITIVE);</div>
</div><!-- fragment --></li>
<li>Create one or more lights. Note that not all light types are necessarily supported by all shadow techniques, you should check the sections about each technique to check. Note that if certain lights should not cast shadows, you can turn that off by calling setCastShadows(false) on the light, the default is true.</li>
<li>Disable shadow casting on objects which should not cast shadows. Call setCastShadows(false) on objects you don’t want to cast shadows, the default for all objects is to cast shadows.</li>
<li>Configure shadow far distance. You can limit the distance at which shadows are considered for performance reasons, by calling <a class="el" href="class_ogre_1_1_scene_manager.html#a103f475cd458b8bbdbf5ff679eeb20a8" title="Sets the default maximum distance away from the camera that shadows will be visible.">Ogre::SceneManager::setShadowFarDistance</a>.</li>
<li>Turn off the receipt of shadows on materials that should not receive them. You can turn off the receipt of shadows (note, not the casting of shadows - that is done per-object) by calling Material::setReceiveShadows or using the receive_shadows material attribute. This is useful for materials which should be considered self-illuminated for example. Note that transparent materials are typically excluded from receiving and casting shadows, although see the <a class="el" href="_material-_scripts.html#transparency_005fcasts_005fshadows">transparency_casts_shadows</a> option for exceptions.</li>
</ol>
<h1><a class="anchor" id="Opting-out-of-shadows"></a>
Opting out of shadows</h1>
<p>By default <a class="el" href="namespace_ogre.html">Ogre</a> treats all non-transparent objects as shadow casters and receivers (depending on the shadow technique they may not be able to be both at once, check the docs for your chosen technique first). You can disable shadows in various ways:</p>
<dl compact="compact">
<dt>Turning off shadow casting on the light </dt>
<dd><p class="startdd"></p>
<p class="interdd">Calling <code>Light::setCastShadows(false)</code> will mean this light casts no shadows at all.</p>
<p class="enddd"></p>
</dd>
<dt>Turn off shadow receipt on a material </dt>
<dd><p class="startdd"></p>
<p class="interdd">Calling <code>Material::setReceiveShadows(false)</code> will prevent any objects using this material from receiving shadows.</p>
<p class="enddd"></p>
</dd>
<dt>Turn off shadow casting on individual objects </dt>
<dd><p class="startdd"></p>
<p class="interdd">Calling <code>MovableObject::setCastShadows(false)</code> will disable shadow casting for this object.</p>
<p class="enddd"></p>
</dd>
<dt>Turn off shadows on an entire rendering queue group </dt>
<dd><p class="startdd"></p>
<p class="interdd">Calling <code>RenderQueueGroup::setShadowsEnabled(false)</code> will turn off both shadow casting and receiving on an entire rendering queue group. This is useful because <a class="el" href="namespace_ogre.html">Ogre</a> has to do light setup tasks per group in order to preserve the inter-group ordering. <a class="el" href="namespace_ogre.html">Ogre</a> automatically disables shadows on a number of groups automatically, such as <code>RENDER_QUEUE_BACKGROUND, RENDER_QUEUE_OVERLAY, RENDER_QUEUE_SKIES_EARLY</code> and <code>RENDER_QUEUE_SKIES_LATE</code>. If you choose to use more rendering queues (and by default, you won’t be using any more than this plus the ’standard’ queue, so ignore this if you don’t know what it means!), be aware that each one can incur a light setup cost, and you should disable shadows on the additional ones you use if you can.</p>
<p class="enddd"></p>
</dd>
</dl>
<h1><a class="anchor" id="Stencil-Shadows"></a>
Stencil Shadows</h1>
<p>Stencil shadows are a method by which a ’mask’ is created for the screen using a feature called the stencil buffer. This mask can be used to exclude areas of the screen from subsequent renders, and thus it can be used to either include or exclude areas in shadow. They are enabled by calling <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene.">Ogre::SceneManager::setShadowTechnique</a> with a parameter of either <code>SHADOWTYPE_STENCIL_ADDITIVE</code> or <code>SHADOWTYPE_STENCIL_MODULATIVE</code>. Because the stencil can only mask areas to be either ’enabled’ or ’disabled’, stencil shadows have ’hard’ edges, that is to say clear dividing lines between light and shadow - it is not possible to soften these edges.</p>
<p>In order to generate the stencil, ’shadow volumes’ are rendered by extruding the silhouette of the shadow caster away from the light. Where these shadow volumes intersect other objects (or the caster, since self-shadowing is supported using this technique), the stencil is updated, allowing subsequent operations to differentiate between light and shadow. How exactly this is used to render the shadows depends on whether <a class="el" href="_shadows.html#Modulative-Shadows">Modulative Shadows</a> or <a class="el" href="_shadows.html#Additive-Light-Masking">Additive Light Masking</a> is being used. Objects can both cast and receive stencil shadows, so self-shadowing is inbuilt.</p>
<p>The advantage of stencil shadows is that they can do self-shadowing simply on low-end hardware, provided you keep your poly count under control. In contrast doing self-shadowing with <a class="el" href="_shadows.html#Texture_002dbased-Shadows">Texture-based Shadows</a> requires a fairly modern machine. For this reason, you’re likely to pick stencil shadows if you need an accurate shadowing solution for an application aimed at older or lower-spec machines.</p>
<p>The disadvantages of stencil shadows are numerous though, especially on more modern hardware. Because stencil shadows are a geometric technique, they are inherently more costly the higher the number of polygons you use, meaning you are penalized the more detailed you make your meshes. The fillrate cost, which comes from having to render shadow volumes, also escalates the same way. Since more modern applications are likely to use higher polygon counts, stencil shadows can start to become a bottleneck. In addition, the visual aspects of stencil shadows are pretty primitive - your shadows will always be hard-edged, and you have no possibility of doing clever things with shaders since the stencil is not available for manipulation there. Therefore, if your application is aimed at higher-end machines you should definitely consider switching to <a class="el" href="_shadows.html#Texture_002dbased-Shadows">Texture-based Shadows</a>.</p>
<p>There are a number of issues to consider which are specific to stencil shadows:</p>
<ul>
<li><a class="el" href="_shadows.html#CPU-Overhead">CPU Overhead</a></li>
<li><a class="el" href="_shadows.html#Extrusion-distance">Extrusion distance</a></li>
<li><a class="el" href="_shadows.html#Camera-far-plane-positioning">Camera far plane positioning</a></li>
<li><a class="el" href="_shadows.html#Mesh-edge-lists">Mesh edge lists</a></li>
<li><a class="el" href="_shadows.html#The-Silhouette-Edge">The Silhouette Edge</a></li>
<li><a class="el" href="_shadows.html#Be-realistic">Be realistic</a></li>
<li><a class="el" href="_shadows.html#Stencil-Optimisations-Performed-By-Ogre">Stencil Optimisations Performed By Ogre</a></li>
</ul>
<p><a class="anchor" id="CPU-Overhead"></a><a class="anchor" id="CPU-Overhead-1"></a></p>
<h2><a class="anchor" id="autotoc_md35"></a>
CPU Overhead</h2>
<p>Calculating the shadow volume for a mesh can be expensive, and it has to be done on the CPU, it is not a hardware accelerated feature. Therefore, you can find that if you overuse this feature, you can create a CPU bottleneck for your application. <a class="el" href="namespace_ogre.html">Ogre</a> quite aggressively eliminates objects which cannot be casting shadows on the frustum, but there are limits to how much it can do, and large, elongated shadows (e.g. representing a very low sun position) are very difficult to cull efficiently. Try to avoid having too many shadow casters around at once, and avoid long shadows if you can. Also, make use of the ’shadow far distance’ parameter on the SceneManager, this can eliminate distant shadow casters from the shadow volume construction and save you some time, at the expense of only having shadows for closer objects. Lastly, make use of Ogre’s Level-Of-Detail (LOD) features; you can generate automatically calculated LODs for your meshes in code (see the Mesh API docs) or when using the mesh tools such as <a class="el" href="_mesh-_tools.html#XMLConverter">XMLConverter</a> and <a class="el" href="_mesh-_tools.html#MeshUpgrader">MeshUpgrader</a>. Alternatively, you can assign your own manual LODs by providing alternative mesh files at lower detail levels. Both methods will cause the shadow volume complexity to decrease as the object gets further away, which saves you valuable volume calculation time.</p>
<p><a class="anchor" id="Extrusion-distance"></a><a class="anchor" id="Extrusion-distance-1"></a></p>
<h2><a class="anchor" id="autotoc_md36"></a>
Extrusion distance</h2>
<p>When vertex programs are not available, <a class="el" href="namespace_ogre.html">Ogre</a> can only extrude shadow volumes a finite distance from the object. If an object gets too close to a light, any finite extrusion distance will be inadequate to guarantee all objects will be shadowed properly by this object. Therefore, you are advised not to let shadow casters pass too close to light sources if you can avoid it, unless you can guarantee that your target audience will have vertex program capable hardware (in this case, <a class="el" href="namespace_ogre.html">Ogre</a> extrudes the volume to infinity using a vertex program so the problem does not occur). When infinite extrusion is not possible, <a class="el" href="namespace_ogre.html">Ogre</a> uses finite extrusion, either derived from the attenuation range of a light (in the case of a point light or spotlight), or a fixed extrusion distance set in the application in the case of directional lights. To change the directional light extrusion distance, use SceneManager::setShadowDirectionalLightExtrusionDistance.</p>
<p><a class="anchor" id="Camera-far-plane-positioning"></a><a class="anchor" id="Camera-far-plane-positioning-1"></a></p>
<h2><a class="anchor" id="autotoc_md37"></a>
Camera far plane positioning</h2>
<p>Stencil shadow volumes rely very much on not being clipped by the far plane. When you enable stencil shadows, <a class="el" href="namespace_ogre.html">Ogre</a> internally changes the far plane settings of your cameras such that there is no far plane - i.e. it is placed at infinity (Camera::setFarClipDistance(0)). This avoids artifacts caused by clipping the dark caps on shadow volumes, at the expense of a (very) small amount of depth precision.</p>
<p><a class="anchor" id="Mesh-edge-lists"></a><a class="anchor" id="Mesh-edge-lists-1"></a></p>
<h2><a class="anchor" id="autotoc_md38"></a>
Mesh edge lists</h2>
<p>Stencil shadows can only be calculated when an ’edge list’ has been built for all the geometry in a mesh. The official exporters and tools automatically build this for you (or have an option to do so), but if you create your own meshes, you must remember to build edge lists for them before using them with stencil shadows - you can do that by using <a class="el" href="_mesh-_tools.html#MeshUpgrader">MeshUpgrader</a>, or by calling <a class="el" href="class_ogre_1_1_mesh.html#a3b18cd2008a447fe5fac98d06a541994" title="Builds an edge list for this mesh, which can be used for generating a shadow volume among other thing...">Ogre::Mesh::buildEdgeList</a> before you export or use the mesh. If a mesh doesn’t have edge lists, OGRE assumes that it is not supposed to cast stencil shadows.</p>
<p><a class="anchor" id="The-Silhouette-Edge"></a><a class="anchor" id="The-Silhouette-Edge-1"></a></p>
<h2><a class="anchor" id="autotoc_md39"></a>
The Silhouette Edge</h2>
<p>Stencil shadowing is about finding a silhouette of the mesh, and projecting it away to form a volume. What this means is that there is a definite boundary on the shadow caster between light and shadow; a set of edges where where the triangle on one side is facing toward the light, and one is facing away. This produces a sharp edge around the mesh as the transition occurs. Provided there is little or no other light in the scene, and the mesh has smooth normals to produce a gradual light change in its underlying shading, the silhouette edge can be hidden - this works better the higher the tessellation of the mesh. However, if the scene includes ambient light, then the difference is far more marked. This is especially true when using <a class="el" href="_shadows.html#Modulative-Shadows">Modulative Shadows</a>, because the light contribution of each shadowed area is not taken into account by this simplified approach, and so using 2 or more lights in a scene using modulative stencil shadows is not advisable; the silhouette edges will be very marked. Additive lights do not suffer from this as badly because each light is masked individually, meaning that it is only ambient light which can show up the silhouette edges.</p>
<p><a class="anchor" id="Be-realistic"></a><a class="anchor" id="Be-realistic-1"></a></p>
<h2><a class="anchor" id="autotoc_md40"></a>
Be realistic</h2>
<p>Don’t expect to be able to throw any scene using any hardware at the stencil shadow algorithm and expect to get perfect, optimum speed results. Shadows are a complex and expensive technique, so you should impose some reasonable limitations on your placing of lights and objects; they’re not really that restricting, but you should be aware that this is not a complete free-for-all.</p>
<ul>
<li>Try to avoid letting objects pass very close (or even through) lights - it might look nice but it’s one of the cases where artifacts can occur on machines not capable of running vertex programs.</li>
<li>Be aware that shadow volumes do not respect the ’solidity’ of the objects they pass through, and if those objects do not themselves cast shadows (which would hide the effect) then the result will be that you can see shadows on the other side of what should be an occluding object.</li>
<li>Make use of SceneManager::setShadowFarDistance to limit the number of shadow volumes constructed</li>
<li>Make use of LOD to reduce shadow volume complexity at distance</li>
<li><p class="startli">Avoid very long (dusk and dawn) shadows - they exacerbate other issues such as volume clipping, fillrate, and cause many more objects at a greater distance to require volume construction.</p>
<p class="startli"><a class="anchor" id="Stencil-Optimisations-Performed-By-Ogre"></a><a class="anchor" id="Stencil-Optimisations-Performed-By-Ogre-1"></a></p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md41"></a>
Stencil optimisations performed by Ogre</h2>
<p>Despite all that, stencil shadows can look very nice (especially with <a class="el" href="_shadows.html#Additive-Light-Masking">Additive Light Masking</a>) and can be fast if you respect the rules above. In addition, Ogre comes pre-packed with a lot of optimisations which help to make this as quick as possible. This section is more for developers or people interested in knowing something about the ’under the hood’ behaviour of Ogre.</p>
<dl compact="compact">
<dt>Vertex program extrusion </dt>
<dd><p class="startdd"></p>
<p class="interdd">As previously mentioned, <a class="el" href="namespace_ogre.html">Ogre</a> performs the extrusion of shadow volumes in hardware on vertex program-capable hardware. This has 2 major benefits; the obvious one being speed, but secondly that vertex programs can extrude points to infinity, which the fixed-function pipeline cannot, at least not without performing all calculations in software. This leads to more robust volumes, and also eliminates more than half the volume triangles on directional lights since all points are projected to a single point at infinity.</p>
<p class="enddd"></p>
</dd>
<dt>Scissor test optimisation </dt>
<dd><p class="startdd"></p>
<p class="interdd"><a class="el" href="namespace_ogre.html">Ogre</a> uses a scissor rectangle to limit the effect of point / spot lights when their range does not cover the entire viewport; that means we save fillrate when rendering stencil volumes, especially with distant lights</p>
<p class="enddd"></p>
</dd>
<dt>Z-Pass and Z-Fail algorithms </dt>
<dd><p class="startdd"></p>
<p class="interdd">The Z-Fail algorithm, often attributed to John Carmack, is used in <a class="el" href="namespace_ogre.html">Ogre</a> to make sure shadows are robust when the camera passes through the shadow volume. However, the Z-Fail algorithm is more expensive than the traditional Z-Pass; so <a class="el" href="namespace_ogre.html">Ogre</a> detects when Z-Fail is required and only uses it then, Z-Pass is used at all other times.</p>
<p class="enddd"></p>
</dd>
<dt>2-Sided stenciling and stencil wrapping </dt>
<dd><p class="startdd"></p>
<p class="interdd"><a class="el" href="namespace_ogre.html">Ogre</a> supports the 2-Sided stenciling / stencil wrapping extensions, which when supported allow volumes to be rendered in a single pass instead of having to do one pass for back facing tris and another for front-facing tris. This doesn’t save fillrate, since the same number of stencil updates are done, but it does save primitive setup and the overhead incurred in the driver every time a render call is made.</p>
<p class="enddd"></p>
</dd>
<dt>Aggressive shadow volume culling </dt>
<dd><p class="startdd"></p>
<p class="interdd"><a class="el" href="namespace_ogre.html">Ogre</a> is pretty good at detecting which lights could be affecting the frustum, and from that, which objects could be casting a shadow on the frustum. This means we don’t waste time constructing shadow geometry we don’t need. Setting the shadow far distance is another important way you can reduce stencil shadow overhead since it culls far away shadow volumes even if they are visible, which is beneficial in practice since you’re most interested in shadows for close-up objects.</p>
<p class="enddd"></p>
</dd>
</dl>
<h1><a class="anchor" id="Texture_002dbased-Shadows"></a>
Texture-based Shadows</h1>
<p>Texture shadows involve rendering shadow casters from the point of view of the light into a texture, which is then projected onto shadow receivers. The main advantage of texture shadows as opposed to <a class="el" href="_shadows.html#Stencil-Shadows">Stencil Shadows</a> is that the overhead of increasing the geometric detail is far lower, since there is no need to perform per-triangle calculations. Most of the work in rendering texture shadows is done by the graphics card, meaning the technique scales well when taking advantage of the latest cards, which are at present outpacing CPUs in terms of their speed of development. In addition, texture shadows are <b>much</b> more customisable - you can pull them into shaders to apply as you like (particularly with <a class="el" href="_shadows.html#Integrated-Texture-Shadows">Integrated Texture Shadows</a>, you can perform filtering to create softer shadows or perform other special effects on them. Basically, most modern engines use texture shadows as their primary shadow technique simply because they are more powerful, and the increasing speed of GPUs is rapidly amortizing the fillrate / texture access costs of using them.</p>
<p>The main disadvantage to texture shadows is that, because they are simply a texture, they have a fixed resolution which means if stretched, the pixellation of the texture can become obvious. There are ways to combat this though:</p>
<dl compact="compact">
<dt>Choosing a projection basis </dt>
<dd><p class="startdd"></p>
<p class="interdd">The simplest projection is just to render the shadow casters from the lights perspective using a regular camera setup. This can look bad though, so there are many other projections which can help to improve the quality from the main camera’s perspective. OGRE supports pluggable projection bases via its ShadowCameraSetup class, and comes with several existing options</p><ul>
<li><b>Uniform</b>, which is the simplest,</li>
<li><b>Uniform Focused</b>, which is still a normal camera projection, except that the camera is focused into the area that the main viewing camera is looking at</li>
<li><b>Light Space Perspective Shadow Mapping</b> (LiSPSM), which both focuses and distorts the shadow frustum based on the main view camera and</li>
<li><b>Plane Optimal</b>, which seeks to optimise the shadow fidelity for a single receiver plane.</li>
</ul>
<p class="enddd"></p>
</dd>
<dt>Filtering </dt>
<dd><p class="startdd"></p>
<p class="interdd">You can also sample the shadow texture multiple times rather than once to soften the shadow edges and improve the appearance. Percentage Closest Filtering (PCF) is the most popular approach, although there are multiple variants depending on the number and pattern of the samples you take. Our shadows demo includes a 5-tap PCF example combined with depth shadow mapping.</p>
<p class="enddd"></p>
</dd>
<dt>Using a larger texture </dt>
<dd><p class="startdd"></p>
<p class="interdd">Again as GPUs get faster and gain more memory, you can scale up to take advantage of this.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>If you combine all 3 of these techniques you can get a very high quality shadow solution.</p>
<p>The other issue is with point lights. Because texture shadows require a render to texture in the direction of the light, omnidirectional lights (point lights) would require 6 renders to totally cover all the directions shadows might be cast. For this reason, <a class="el" href="namespace_ogre.html">Ogre</a> primarily supports directional lights and spotlights for generating texture shadows; you can use point lights but they will only work if off-camera since they are essentially turned into a spotlight shining into your camera frustum for the purposes of texture shadows.</p>
<p><a class="anchor" id="Directional-Lights"></a></p>
<h2><a class="anchor" id="autotoc_md42"></a>
Directional Lights</h2>
<p>Directional lights in theory shadow the entire scene from an infinitely distant light. Now, since we only have a finite texture which will look very poor quality if stretched over the entire scene, clearly a simplification is required. <a class="el" href="namespace_ogre.html">Ogre</a> places a shadow texture over the area immediately in front of the camera, and moves it as the camera moves (although it rounds this movement to multiples of texels so that the slight ’swimming shadow’ effect caused by moving the texture is minimised). The range to which this shadow extends, and the offset used to move it in front of the camera, are configurable (See <a class="el" href="_shadows.html#Configuring-Texture-Shadows">Configuring Texture Shadows</a>). At the far edge of the shadow, <a class="el" href="namespace_ogre.html">Ogre</a> fades out the shadow based on other configurable parameters so that the termination of the shadow is softened.</p>
<p><a class="anchor" id="Spotlights"></a></p>
<h2><a class="anchor" id="autotoc_md43"></a>
Spotlights</h2>
<p>Spotlights are much easier to represent as renderable shadow textures than directional lights, since they are naturally a frustum. <a class="el" href="namespace_ogre.html">Ogre</a> represents spotlight directly by rendering the shadow from the light position, in the direction of the light cone; the field-of-view of the texture camera is adjusted based on the spotlight falloff angles. In addition, to hide the fact that the shadow texture is square and has definite edges which could show up outside the spotlight, <a class="el" href="namespace_ogre.html">Ogre</a> uses a second texture unit when projecting the shadow onto the scene which fades out the shadow gradually in a projected circle around the spotlight.</p>
<p><a class="anchor" id="Point-Lights"></a></p>
<h2><a class="anchor" id="autotoc_md44"></a>
Point Lights</h2>
<p>As mentioned above, to support point lights properly would require multiple renders (either 6 for a cubic render or perhaps 2 for a less precise parabolic mapping), so rather than do that we approximate point lights as spotlights, where the configuration is changed on the fly to make the light shine from its position over the whole of the viewing frustum. This is not an ideal setup since it means it can only really work if the point light’s position is out of view, and in addition the changing parameterisation can cause some ’swimming’ of the texture. Generally we recommend avoiding making point lights cast texture shadows.</p>
<p><a class="anchor" id="Shadow-Casters-and-Shadow-Receivers"></a></p>
<h2><a class="anchor" id="autotoc_md45"></a>
Shadow Casters and Shadow Receivers</h2>
<p>To enable texture shadows, use the shadow technique SHADOWTYPE_TEXTURE_MODULATIVE or SHADOWTYPE_TEXTURE_ADDITIVE; as the name suggests this produces <a class="el" href="_shadows.html#Modulative-Shadows">Modulative Shadows</a> or <a class="el" href="_shadows.html#Additive-Light-Masking">Additive Light Masking</a> respectively. The cheapest and simplest texture shadow techniques do not use depth information, they merely render casters to a texture and render this onto receivers as plain colour - this means self-shadowing is not possible using these methods. This is the default behaviour if you use the automatic, fixed-function compatible (and thus usable on lower end hardware) texture shadow techniques. You can however use shaders-based techniques through custom shadow materials for casters and receivers to perform more complex shadow algorithms, such as depth shadow mapping which does allow self-shadowing. OGRE comes with an example of this in its shadows demo, although it’s only usable on Shader Model 2 cards or better. Whilst fixed-function depth shadow mapping is available in OpenGL, it was never standardised in Direct3D so using shaders in custom caster &amp; receiver materials is the only portable way to do it. If you use this approach, call SceneManager::setShadowTextureSelfShadow with a parameter of ’true’ to allow texture shadow casters to also be receivers. If you’re not using depth shadow mapping, OGRE divides shadow casters and receivers into 2 disjoint groups. Simply by turning off shadow casting on an object, you automatically make it a shadow receiver (although this can be disabled by setting the ’receive_shadows’ option to ’false’ in a material script. Similarly, if an object is set as a shadow caster, it cannot receive shadows.</p>
<h1><a class="anchor" id="Configuring-Texture-Shadows"></a>
Configuring Texture Shadows</h1>
<p>There are a number of settings which will help you configure your texture-based shadows so that they match your requirements.</p>
<ul>
<li><a class="el" href="_shadows.html#Maximum-number-of-shadow-textures">Maximum number of shadow textures</a></li>
<li><a class="el" href="_shadows.html#Shadow-texture-size">Shadow texture size</a></li>
<li><a class="el" href="_shadows.html#Shadow-far-distance">Shadow far distance</a></li>
<li><a class="el" href="_shadows.html#Shadow-texture-offset-Directional-Lights_0029">Shadow texture offset (Directional Lights)</a></li>
<li><a class="el" href="_shadows.html#Shadow-fade-settings">Shadow fade settings</a></li>
<li><a class="el" href="_shadows.html#Custom-shadow-camera-setups">Custom shadow camera setups</a></li>
<li><a class="el" href="_shadows.html#Shadow-texture-Depth-Buffer-sharing">Shadow texture Depth Buffer sharing</a></li>
<li><a class="el" href="_shadows.html#Integrated-Texture-Shadows">Integrated Texture Shadows</a></li>
</ul>
<p><a class="anchor" id="Maximum-number-of-shadow-textures"></a><a class="anchor" id="Maximum-number-of-shadow-textures-1"></a></p>
<h2><a class="anchor" id="autotoc_md46"></a>
Maximum number of shadow textures</h2>
<p>Shadow textures take up texture memory, and to avoid stalling the rendering pipeline <a class="el" href="namespace_ogre.html">Ogre</a> does not reuse the same shadow texture for multiple lights within the same frame. This means that each light which is to cast shadows must have its own shadow texture. In practice, if you have a lot of lights in your scene you would not wish to incur that sort of texture overhead. You can adjust this manually by simply turning off shadow casting for lights you do not wish to cast shadows. In addition, you can set a maximum limit on the number of shadow textures <a class="el" href="namespace_ogre.html">Ogre</a> is allowed to use by calling <a class="el" href="class_ogre_1_1_scene_manager.html#a85c3a0d9755dfdfa841ec1383b20687c" title="Set the number of textures allocated for texture-based shadows.">Ogre::SceneManager::setShadowTextureCount</a>. Each frame, <a class="el" href="namespace_ogre.html">Ogre</a> determines the lights which could be affecting the frustum, and then allocates the number of shadow textures it is allowed to use to the lights on a first-come-first-served basis. Any additional lights will not cast shadows that frame. Note that you can set the number of shadow textures and their size at the same time by using the <a class="el" href="class_ogre_1_1_scene_manager.html#a6efbc50e4ab15a4436cac712e049e79e" title="Sets the size and count of textures used in texture-based shadows.">Ogre::SceneManager::setShadowTextureSettings</a> method; this is useful because both the individual calls require the potential creation / destruction of texture resources.</p>
<p><a class="anchor" id="Shadow-texture-size"></a><a class="anchor" id="Shadow-texture-size-1"></a></p>
<h2><a class="anchor" id="autotoc_md47"></a>
Shadow texture size</h2>
<p>The size of the textures used for rendering the shadow casters into can be altered; clearly using larger textures will give you better quality shadows, but at the expense of greater memory usage. Changing the texture size is done by calling <a class="el" href="class_ogre_1_1_scene_manager.html#aa55e7f4482a2860c6378d97d8b5dfb57" title="Set the size of the texture used for all texture-based shadows.">Ogre::SceneManager::setShadowTextureSize</a> - textures are assumed to be square and you must specify a texture size that is a power of 2. Be aware that each modulative shadow texture will take \(size*size*3\) bytes of texture memory.</p>
<dl class="section note"><dt>Note</dt><dd>if you use the GL render system your shadow texture size can only be larger (in either dimension) than the size of your primary window surface if the hardware supports the Frame Buffer Object (FBO) or Pixel Buffer Object (PBO) extensions. Most modern cards support this now, but be careful of older cards - you can check the ability of the hardware to manage this through <a class="el" href="group___render_system.html#gga3d2965b7f378ebdcfe8a4a6cf74c3de7a640e063db30008a88378659bc5d0ed70" title="Supports hardware render-to-texture (bigger than framebuffer)">Ogre::RSC_HWRENDER_TO_TEXTURE</a>. If this is absent, if you create a shadow texture larger in any dimension than the primary surface, the rest of the shadow texture will be blank.</dd></dl>
<p><a class="anchor" id="Shadow-far-distance"></a><a class="anchor" id="Shadow-far-distance-1"></a></p>
<h2><a class="anchor" id="autotoc_md48"></a>
Shadow far distance</h2>
<p>This determines the distance at which shadows are terminated; it also determines how far into the distance the texture shadows for directional lights are stretched - by reducing this value, or increasing the texture size, you can improve the quality of shadows from directional lights at the expense of closer shadow termination or increased memory usage, respectively.</p>
<p><a class="anchor" id="Shadow-texture-offset-Directional-Lights_0029"></a></p>
<h2><a class="anchor" id="autotoc_md49"></a>
Shadow texture offset (Directional Lights)</h2>
<p>When generating a shadow texture from a directional light, an approximation is used since it is not possible to render the entire scene to one texture. The texture is projected onto an area centred on the camera, and is the shadow far distance * 2 in length (it is square). This wastes a lot of texture space outside the frustum though, so this offset allows you to move the texture in front of the camera more. However, be aware that this can cause a little shadow 'jittering' during rotation, and that if you move it too far then you'll start to get artefacts close to the camera. The value is represented as a proportion of the shadow far distance, and the default is 0.6.  </p>
<p>You change this value by calling <a class="el" href="class_ogre_1_1_scene_manager.html#a3596ae101fe86d686cc67e9b3aad58cb" title="Sets the proportional distance which a texture shadow which is generated from a directional light wil...">Ogre::SceneManager::setShadowDirLightTextureOffset</a>.</p>
<p><a class="anchor" id="Shadow-fade-settings"></a><a class="anchor" id="Shadow-fade-settings-1"></a></p>
<h2><a class="anchor" id="autotoc_md50"></a>
Shadow fade settings</h2>
<p>Shadows fade out before the shadow far distance so that the termination of shadow is not abrupt. You can configure the start and end points of this fade by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#a25f052046f0d421ac78a89730fd766e1" title="Sets the proportional distance at which texture shadows begin to fade out.">Ogre::SceneManager::setShadowTextureFadeStart</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a4e166fc972e614490ab6164eda2be0e5" title="Sets the proportional distance at which texture shadows finish to fading out.">Ogre::SceneManager::setShadowTextureFadeEnd</a> methods, both take distances as a proportion of the shadow far distance. Because of the inaccuracies caused by using a square texture and a radial fade distance, you cannot use 1.0 as the fade end, if you do you’ll see artifacts at the extreme edges. The default values are 0.7 and 0.9, which serve most purposes but you can change them if you like.</p>
<h1><a class="anchor" id="texture_shadows_and_shaders"></a>
Texture shadows and vertex / fragment programs</h1>
<p>When rendering shadow casters into a modulative shadow texture, <a class="el" href="namespace_ogre.html">Ogre</a> turns off all textures, and all lighting contributions except for ambient light, which it sets to the colour of the shadow (<a class="el" href="_shadows.html#Shadow-Colour">Shadow Colour</a>). For additive shadows, it render the casters into a black &amp; white texture instead. This is enough to render shadow casters for fixed-function material techniques, however where a vertex program is used <a class="el" href="namespace_ogre.html">Ogre</a> doesn’t have so much control. If you use a vertex program in the <b>first pass</b> of your technique, then you must also tell ogre which vertex program you want it to use when rendering the shadow caster; see <a class="el" href="_high-level-_programs.html#Shadows-and-Vertex-Programs">Shadows and Vertex Programs</a> for full details.</p>
<p><a class="anchor" id="Custom-shadow-camera-setups"></a><a class="anchor" id="Custom-shadow-camera-setups-1"></a></p>
<h2><a class="anchor" id="autotoc_md51"></a>
Custom shadow camera setups</h2>
<p>As previously mentioned, one of the downsides of texture shadows is that the texture resolution is finite, and it’s possible to get aliasing when the size of the shadow texel is larger than a screen pixel, due to the projection of the texture. In order to address this, you can specify alternative projection bases by using or creating subclasses of the <a class="el" href="class_ogre_1_1_shadow_camera_setup.html" title="This class allows you to plug in new ways to define the camera setup when rendering and projecting sh...">Ogre::ShadowCameraSetup</a> class. The default version is called DefaultShadowCameraSetup and this sets up a simple regular frustum for point and spotlights, and an orthographic frustum for directional lights. There is also a <a class="el" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html" title="Implements the plane optimal shadow camera algorithm.">Ogre::PlaneOptimalShadowCameraSetup</a> class which specialises the projection to a plane, thus giving you much better definition provided your shadow receivers exist mostly in a single plane. Other setup classes (e.g. you might create a perspective or trapezoid shadow mapping version) can be created and plugged in at runtime, either on individual lights or on the SceneManager as a whole.</p>
<p><a class="anchor" id="Shadow-texture-Depth-Buffer-sharing"></a><a class="anchor" id="Shadow-texture-Depth-Buffer-sharing-1"></a></p>
<h2><a class="anchor" id="autotoc_md52"></a>
Shadow texture Depth Buffer sharing</h2>
<p>Shadow textures need a depth buffer like many other RTs (Render Textures). Prior to <a class="el" href="namespace_ogre.html">Ogre</a> 1.8, the depth buffer behavior was left undefined leaving a very small possibility of causing inconsistencies across different window resolutions and render systems. Depending on the render window’s resolutions and/or rendersystem being used, the depth buffer might been shared with the render window or a new one could get created to suite the shadow textures. If the application was depending on the depth buffer contents from the previous scene render (that is, no clear was performed) where a shadow texture render pass was in the middle; then the depth buffer would’ve contained garbage (but not consistent on all machines) causing graphical glitches hard to spot.</p>
<p>From <a class="el" href="namespace_ogre.html">Ogre</a> 1.8 onwards the depth buffer usage &amp; sharing can be flexible controlled through the use of depth pool IDs. These pool IDs are not specifically part of shadow textures, but rather anything involving RTs. All RTs with the same pool ID share the same depth buffers when possible (following RenderSystem API rules, check RenderSystemCapabilities flags to find out what the behavior will be). The default ID for shadow textures is 1; which is the same default value for render windows, and RTTs; thus maintaining the same behavior with older applications while achieving maximum memory saving and performance efficiency because the number of created depth buffers is as lowest as possible.</p>
<p>However there are some reasons to put shadow textures in a separate pool. This holds specially true if the application depends on the previous contents from the depth buffer before the shadow pass, instead of doing a clear:</p>
<ul>
<li>In Direct3D9, the shadow texture is more likely to share the depth buffer with the render window at high resolutions (when the window is bigger than the shadow texture resolution), but at low resolutions it won’t be shared, thus causing two different behaviors. Also probably the shadow texture will share the depth buffers with most other RTTs (i.e. compositors)</li>
<li>In OpenGL 2.1, the shadow texture can’t be shared with the main render window; and most likely will <b>not</b> be shared with many other RTTs (i.e. compositors) since OGL 2.1 has a requirement that texture resolutions should exactly match, while D3D9 specifies depth buffers can be shared as long as the resolutions are equal or less.</li>
</ul>
<p>For example, the DeferredShading sample suffers from this problem. If this is a problem for a particular effect you’re trying to achieve, you can specify a custom pool ID so that shadow textures get their own depth buffer(s), ensuring they aren’t shared with other RTs. You can set the poolId parameter from either <a class="el" href="class_ogre_1_1_scene_manager.html#a6efbc50e4ab15a4436cac712e049e79e" title="Sets the size and count of textures used in texture-based shadows.">Ogre::SceneManager::setShadowTextureSettings</a> or setShadowTextureConfig</p>
<div class="fragment"><div class="line">mSceneMgr-&gt;setShadowTextureSettings( size, count, format, PoolId );</div>
<div class="line">mSceneMgr-&gt;setShadowTextureConfig( 0, 512, 512, PF_FLOAT16_R, 50 );</div>
</div><!-- fragment --><p>Note a poolId of 0 will make the shadow textures not to use a depth buffer, which isn’t usually a desired behavior.</p>
<h2><a class="anchor" id="Integrated-Texture-Shadows"></a>
Integrated Texture Shadows</h2>
<p>Texture shadows have one major advantage over stencil shadows - the data used to represent them can be referenced in regular shaders. Whilst the default texture shadow modes (SHADOWTYPE_TEXTURE_MODULATIVE and SHADOWTYPE_TEXTURE_ADDITIVE) automatically render shadows for you, their disadvantage is that because they are generalised add-ons to your own materials, they tend to take more passes of the scene to use. In addition, you don’t have a lot of control over the composition of the shadows.</p>
<p>Here is where ’integrated’ texture shadows step in. Both of the texture shadow types above have alternative versions called SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED and SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED, where instead of rendering the shadows for you, it just creates the texture shadow and then expects you to use that shadow texture as you see fit when rendering receiver objects in the scene. The downside is that you have to take into account shadow receipt in every one of your materials if you use this option - the upside is that you have total control over how the shadow textures are used. The big advantage here is that you can can perform more complex shading, taking into account shadowing, than is possible using the generalised bolt-on approaches, AND you can probably write them in a smaller number of passes, since you know precisely what you need and can combine passes where possible. When you use one of these shadowing approaches, the only difference between additive and modulative is the colour of the casters in the shadow texture (the shadow colour for modulative, black for additive) - the actual calculation of how the texture affects the receivers is of course up to you. No separate modulative pass will be performed, and no splitting of your materials into ambient / per-light / decal etc will occur - absolutely everything is determined by your original material (which may have modulative passes or per-light iteration if you want of course, but it’s not required).</p>
<p>You reference a shadow texture in a material which implements this approach by using the <code>content_type shadow</code> directive in your <a class="el" href="_material-_scripts.html#Texture-Units">Texture Units</a>. It implicitly references a shadow texture based on the number of times you’ve used this directive in the same pass, and the light_start option or light-based pass iteration, which might start the light index higher than 0.</p>
<h1><a class="anchor" id="Modulative-Shadows"></a>
Modulative Shadows</h1>
<p>Modulative shadows work by darkening an already rendered scene with a fixed colour. First, the scene is rendered normally containing all the objects which will be shadowed, then a modulative pass is done per light, which darkens areas in shadow. Finally, objects which do not receive shadows are rendered.</p>
<p>There are 2 modulative shadow techniques:</p><ol type="1">
<li><a class="el" href="_shadows.html#Stencil-Shadows">Stencil Shadows</a>, SHADOWTYPE_STENCIL_MODULATIVE and</li>
<li><a class="el" href="_shadows.html#Texture_002dbased-Shadows">Texture-based Shadows</a>, SHADOWTYPE_TEXTURE_MODULATIVE.</li>
</ol>
<p>Modulative shadows are an inaccurate lighting model, since they darken the areas of shadow uniformly, irrespective of the amount of light which would have fallen on the shadow area anyway. However, they can give fairly attractive results for a much lower overhead than more ’correct’ methods like <a class="el" href="_shadows.html#Additive-Light-Masking">Additive Light Masking</a>, and they also combine well with pre-baked static lighting (such as pre-calculated lightmaps), which additive lighting does not. The main thing to consider is that using multiple light sources can result in overly dark shadows (where shadows overlap, which intuitively looks right in fact, but it’s not physically correct) and artifacts when using stencil shadows (See <a class="el" href="_shadows.html#The-Silhouette-Edge">The Silhouette Edge</a>).</p>
<p><a class="anchor" id="Shadow-Colour"></a><a class="anchor" id="Shadow-Colour-1"></a></p>
<h2><a class="anchor" id="autotoc_md53"></a>
Shadow Colour</h2>
<p>The colour which is used to darken the areas in shadow is set by <a class="el" href="class_ogre_1_1_scene_manager.html#a81238e49e69e53ccbc650413410f3f92" title="Set the colour used to modulate areas in shadow.">Ogre::SceneManager::setShadowColour</a>; it defaults to a dark grey (so that the underlying colour still shows through a bit).</p>
<p>Note that if you’re using texture shadows you have the additional option of using <a class="el" href="_shadows.html#Integrated-Texture-Shadows">Integrated Texture Shadows</a> rather than being forced to have a separate pass of the scene to render shadows. In this case the ’modulative’ aspect of the shadow technique just affects the colour of the shadow texture.</p>
<h1><a class="anchor" id="Additive-Light-Masking"></a>
Additive Light Masking</h1>
<p>Additive light masking is about rendering the scene many times, each time representing a single light contribution whose influence is masked out in areas of shadow. Each pass is combined with (added to) the previous one such that when all the passes are complete, all the light contribution has correctly accumulated in the scene, and each light has been prevented from affecting areas which it should not be able to because of shadow casters. This is an effective technique which results in very realistic looking lighting, but it comes at a price: more rendering passes.</p>
<p>As many technical papers (and game marketing) will tell you, rendering realistic lighting like this requires multiple passes. Being a friendly sort of engine, <a class="el" href="namespace_ogre.html">Ogre</a> frees you from most of the hard work though, and will let you use the exact same material definitions whether you use this lighting technique or not (for the most part, see <a class="el" href="_shadows.html#Pass-Classification-and-Vertex-Programs">Pass Classification and Vertex Programs</a>). In order to do this technique, <a class="el" href="namespace_ogre.html">Ogre</a> automatically categorises the <a class="el" href="_material-_scripts.html#Passes">Passes</a> you define in your materials into 3 types:</p>
<ol type="1">
<li>ambient Passes categorised as ’ambient’ include any base pass which is not lit by any particular light, i.e. it occurs even if there is no ambient light in the scene. The ambient pass always happens first, and sets up the initial depth value of the fragments, and the ambient colour if applicable. It also includes any emissive / self illumination contribution. Only textures which affect ambient light (e.g. ambient occlusion maps) should be rendered in this pass.</li>
<li>diffuse/specular Passes categorised as ’diffuse/specular’ (or ’per-light’) are rendered once per light, and each pass contributes the diffuse and specular colour from that single light as reflected by the diffuse / specular terms in the pass. Areas in shadow from that light are masked and are thus not updated. The resulting masked colour is added to the existing colour in the scene. Again, no textures are used in this pass (except for textures used for lighting calculations such as normal maps).</li>
<li>decal Passes categorised as ’decal’ add the final texture colour to the scene, which is modulated by the accumulated light built up from all the ambient and diffuse/specular passes.</li>
</ol>
<p>In practice, <a class="el" href="_material-_scripts.html#Passes">Passes</a> rarely fall nicely into just one of these categories. For each Technique, <a class="el" href="namespace_ogre.html">Ogre</a> compiles a list of ’Illumination Passes’, which are derived from the user defined passes, but can be split, to ensure that the divisions between illumination pass categories can be maintained. For example, if we take a very simple material definition:</p>
<div class="fragment"><div class="line">material TestIllumination</div>
<div class="line">{</div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            ambient 0.5 0.2 0.2 </div>
<div class="line">            diffuse 1 0 0  </div>
<div class="line">            specular 1 0.8 0.8 15</div>
<div class="line">            texture_unit</div>
<div class="line">            {</div>
<div class="line">                texture grass.png</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="namespace_ogre.html">Ogre</a> will split this into 3 illumination passes, which will be the equivalent of this:</p>
<div class="fragment"><div class="line">material TestIlluminationSplitIllumination</div>
<div class="line">{</div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Ambient pass</span></div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            ambient 0.5 0.2 0.2 </div>
<div class="line">            diffuse 0 0 0</div>
<div class="line">            specular 0 0 0</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Diffuse / specular pass</span></div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            scene_blend add</div>
<div class="line">            iteration once_per_light</div>
<div class="line">            diffuse 1 0 0  </div>
<div class="line">            specular 1 0.8 0.8 15</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Decal pass</span></div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            scene_blend modulate</div>
<div class="line">            lighting off</div>
<div class="line">            texture_unit</div>
<div class="line">            {</div>
<div class="line">                texture grass.png</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>So as you can see, even a simple material requires a minimum of 3 passes when using this shadow technique, and in fact it requires (num_lights + 2) passes in the general sense. You can use more passes in your original material and <a class="el" href="namespace_ogre.html">Ogre</a> will cope with that too, but be aware that each pass may turn into multiple ones if it uses more than one type of light contribution (ambient vs diffuse/specular) and / or has texture units. The main nice thing is that you get the full multipass lighting behaviour even if you don’t define your materials in terms of it, meaning that your material definitions can remain the same no matter what lighting approach you decide to use.</p>
<h2><a class="anchor" id="Manually-Categorising-Illumination-Passes"></a>
Manually Categorising Illumination Passes</h2>
<p>Alternatively, if you want more direct control over the categorisation of your passes, you can use the <a class="el" href="_material-_scripts.html#illumination_005fstage">illumination_stage</a> option in your pass to explicitly assign a pass unchanged to an illumination stage. This way you can make sure you know precisely how your material will be rendered under additive lighting conditions.</p>
<h2><a class="anchor" id="Pass-Classification-and-Vertex-Programs"></a>
Pass Classification and Vertex Programs</h2>
<p><a class="el" href="namespace_ogre.html">Ogre</a> is pretty good at classifying and splitting your passes to ensure that the multipass rendering approach required by additive lighting works correctly without you having to change your material definitions. However, there is one exception; when you use vertex programs, the normal lighting attributes ambient, diffuse, specular etc are not used, because all of that is determined by the vertex program. <a class="el" href="namespace_ogre.html">Ogre</a> has no way of knowing what you’re doing inside that vertex program, so you have to tell it.</p>
<p>In practice this is very easy. Even though your vertex program could be doing a lot of complex, highly customised processing, it can still be classified into one of the 3 types listed above. All you need to do to tell <a class="el" href="namespace_ogre.html">Ogre</a> what you’re doing is to use the pass attributes ambient, diffuse, specular and self_illumination, just as if you were not using a vertex program. Sure, these attributes do nothing (as far as rendering is concerned) when you’re using vertex programs, but it’s the easiest way to indicate to <a class="el" href="namespace_ogre.html">Ogre</a> which light components you’re using in your vertex program. <a class="el" href="namespace_ogre.html">Ogre</a> will then classify and potentially split your programmable pass based on this information - it will leave the vertex program as-is (so that any split passes will respect any vertex modification that is being done).</p>
<p>Note that when classifying a diffuse/specular programmable pass, <a class="el" href="namespace_ogre.html">Ogre</a> checks to see whether you have indicated the pass can be run once per light (iteration once_per_light). If so, the pass is left intact, including its vertex and fragment programs. However, if this attribute is not included in the pass, <a class="el" href="namespace_ogre.html">Ogre</a> tries to split off the per-light part, and in doing so it will disable the fragment program, since in the absence of the ’iteration once_per_light’ attribute it can only assume that the fragment program is performing decal work and hence must not be used per light.</p>
<p>So clearly, when you use additive light masking as a shadow technique, you need to make sure that programmable passes you use are properly set up so that they can be classified correctly. However, also note that the changes you have to make to ensure the classification is correct does not affect the way the material renders when you choose not to use additive lighting, so the principle that you should be able to use the same material definitions for all lighting scenarios still holds. Here is an example of a programmable material which will be classified correctly by the illumination pass classifier:</p>
<div class="fragment"><div class="line"><span class="comment">// Per-pixel normal mapping. Any number of lights, diffuse only</span></div>
<div class="line">material Examples/BumpMapping/MultiLight</div>
<div class="line">{</div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        shadow_receiver_material Examples/BumpMapping/MultiLight/Rcv</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Base ambient pass</span></div>
<div class="line">        pass ambient</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div>
<div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div>
<div class="line">            diffuse 0 0 0</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Now do the lighting pass</span></div>
<div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div>
<div class="line">        pass perlight</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// do this for each light</span></div>
<div class="line">            iteration once_per_light</div>
<div class="line">            scene_blend add</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div>
<div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div>
<div class="line">            ambient 0 0 0</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Vertex program reference</span></div>
<div class="line">            vertex_program_ref Examples/BumpMapVP</div>
<div class="line">            {</div>
<div class="line">                param_named_auto lightPosition light_position_object_space 0</div>
<div class="line">                param_named_auto worldViewProj worldviewproj_matrix</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Fragment program</span></div>
<div class="line">            fragment_program_ref Examples/BumpMapFP</div>
<div class="line">            {</div>
<div class="line">                param_named_auto lightDiffuse light_diffuse_colour 0 </div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Base bump map</span></div>
<div class="line">            texture_unit normalmap</div>
<div class="line">            {</div>
<div class="line">                texture NMBumpsOut.png</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Decal pass</span></div>
<div class="line">        pass decal</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// hint to pass categorisation routine, that this is decal only</span></div>
<div class="line">            lighting off</div>
<div class="line">            scene_blend dest_colour zero</div>
<div class="line">            texture_unit decalmap</div>
<div class="line">            {</div>
<div class="line">                texture RustedMetal.jpg </div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">material Examples/BumpMapping/MultiLight/Rcv</div>
<div class="line">{</div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            scene_blend add</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// texture shadow receiver program</span></div>
<div class="line">            vertex_program_ref Examples/BumpMapVPShadowRcv</div>
<div class="line">            {</div>
<div class="line">                param_named_auto lightPosition light_position_object_space 0</div>
<div class="line">                param_named_auto worldViewProj worldviewproj_matrix</div>
<div class="line">                param_named_auto worldMatrix world_matrix</div>
<div class="line">                param_named_auto texViewProj texture_viewproj_matrix</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// Additive texture shadow receiver program</span></div>
<div class="line">            fragment_program_ref Examples/BumpMapFPShadowRcv</div>
<div class="line">            {</div>
<div class="line">                param_named_auto lightDiffuse light_diffuse_colour 0</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            texture_unit shadowmap</div>
<div class="line">            {</div>
<div class="line">                content_type shadow</div>
<div class="line">            }</div>
<div class="line">            texture_unit normalmap</div>
<div class="line">            {</div>
<div class="line">                texture NMBumpsOut.png</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that if you’re using texture shadows you have the additional option of using <a class="el" href="_shadows.html#Integrated-Texture-Shadows">Integrated Texture Shadows</a> rather than being forced to use this explicit sequence - allowing you to compress the number of passes into a much smaller number at the expense of defining an upper number of shadow casting lights. In this case the ’additive’ aspect of the shadow technique just affects the colour of the shadow texture and it’s up to you to combine the shadow textures in your receivers however you like.</p>
<h2><a class="anchor" id="Static-Lighting"></a>
Static Lighting</h2>
<p>Despite their power, additive lighting techniques have an additional limitation; they do not combine well with pre-calculated static lighting in the scene. This is because they are based on the principle that shadow is an absence of light, but since static lighting in the scene already includes areas of light and shadow, additive lighting cannot remove light to create new shadows. Therefore, if you use the additive lighting technique you must either use it exclusively as your lighting solution (and you can combine it with per-pixel lighting to create a very impressive dynamic lighting solution), or you must use <a class="el" href="_shadows.html#Integrated-Texture-Shadows">Integrated Texture Shadows</a> to combine the static lighting according to your chosen approach. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
