<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Shadow Mapping in Ogre</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non) Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a><ul><li class="level2"><a href="#autotoc_md59">Caster</a></li>
<li class="level2"><a href="#autotoc_md60">Receiver</a></li>
<li class="level2"><a href="#autotoc_md61">Debugging Shadows</a></li>
<li class="level2"><a href="#autotoc_md62">Improving Shadow Quality</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[16]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<dl class="section note"><dt>Note</dt><dd>This tutorial is more explicit and in depth than required to merely render shadows in OGRE as to teach you the theory behind the rendering shadows as well.</dd></dl>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 16-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[
    \begin{aligned}
    \left[ \begin{array}{c}
        u_1  w_l \\
        u_2  w_l \\
        u_3  w_l \\
        w_l     \end{array} \right] =  P_l M_l \left[ \begin{array}{c}
        x_1 \\
        x_2 \\
        x_3 \\
        1     \end{array} \right]\end{aligned}
\]
</p>
<p class="formulaDsp">
\[\begin{aligned}
    \left[ \begin{array}{c}
        y_1  w_c \\
        y_2  w_c \\
        y_3  w_c \\
        w_c     \end{array} \right] =  P_c M_c \left[ \begin{array}{c}
        x_1 \\
        x_2 \\
        x_3 \\
        1     \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<p><img src="depthbias.svg" alt="" style="pointer-events: none;" class="inline"/>     Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</p>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span><em>ad hoc</em></span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direction lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span><em>light space</em></span> and compute what the offset for a particular sample should be in <span><em>light image space</em></span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned}
\label{eqn:dxqdu}
  \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned}
\label{eqn:dxdu}
  \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\
\label{eqn:du3du}
  \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned}
\label{eqn:duwdX3}
  \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\
\label{eqn:dudX3}
  \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[13]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>Those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>Those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[8]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[5]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>The inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>The inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps <a class="el" href="citelist.html#CITEREF_FFB01">[6]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[2]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<p><img src="optfrust.svg" alt="" style="pointer-events: none;" class="inline"/>     Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</p>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[3]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[2]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non) Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[9]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[14]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[3]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html">Ogre</a>, we turn on custom shadow mapping through the scene manager. It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_scene_manager.html">Ogre::SceneManager</a> *mSceneMgr = ...;</div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_material_manager.html">Ogre::MaterialManager</a> *materialMgr = <a class="code hl_function" href="class_ogre_1_1_material_manager.html#a59f93c2d8ee5924ff0e2ccad8c36d690">Ogre::MaterialManager::getSingletonPtr</a>();</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#a3f2c4ffe2ab173848c0cff67789d530e">setShadowTexturePixelFormat</a>(PF_DEPTH16);</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>( SHADOWTYPE_TEXTURE_ADDITIVE );</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#aa22c0af6835b4a0524b4122756cdd93c">setShadowTextureCasterMaterial</a>(materialMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_material_manager.html#a82561096b59b160acae196163402a7be">getByName</a>(<span class="stringliteral">&quot;PSSM/shadow_caster&quot;</span>));</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#a69310c322ea5f58d9c38c13a971f8125">setShadowTextureReceiverMaterial</a>(materialMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_material_manager.html#a82561096b59b160acae196163402a7be">getByName</a>(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/RockWall&quot;</span>));</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#a1963d4af77db29c6419737c1c1ee9a31">setShadowTextureSelfShadow</a>(<span class="keyword">true</span>);</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#aa55e7f4482a2860c6378d97d8b5dfb57">setShadowTextureSize</a>(1024);</div>
<div class="ttc" id="aclass_ogre_1_1_material_manager_html"><div class="ttname"><a href="class_ogre_1_1_material_manager.html">Ogre::MaterialManager</a></div><div class="ttdoc">Class for managing Material settings for Ogre.</div><div class="ttdef"><b>Definition</b> OgreMaterialManager.h:79</div></div>
<div class="ttc" id="aclass_ogre_1_1_material_manager_html_a59f93c2d8ee5924ff0e2ccad8c36d690"><div class="ttname"><a href="class_ogre_1_1_material_manager.html#a59f93c2d8ee5924ff0e2ccad8c36d690">Ogre::MaterialManager::getSingletonPtr</a></div><div class="ttdeci">static MaterialManager * getSingletonPtr(void)</div><div class="ttdoc">Get the singleton instance.</div></div>
<div class="ttc" id="aclass_ogre_1_1_material_manager_html_a82561096b59b160acae196163402a7be"><div class="ttname"><a href="class_ogre_1_1_material_manager.html#a82561096b59b160acae196163402a7be">Ogre::MaterialManager::getByName</a></div><div class="ttdeci">MaterialPtr getByName(const String &amp;name, const String &amp;groupName=ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME) const</div><div class="ttdoc">Get a material by name.</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html">Ogre::SceneManager</a></div><div class="ttdoc">Manages the organisation and rendering of a 'scene': a collection of objects and potentially world ge...</div><div class="ttdef"><b>Definition</b> OgreSceneManager.h:245</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_a1963d4af77db29c6419737c1c1ee9a31"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#a1963d4af77db29c6419737c1c1ee9a31">Ogre::SceneManager::setShadowTextureSelfShadow</a></div><div class="ttdeci">void setShadowTextureSelfShadow(bool selfShadow)</div><div class="ttdoc">Sets whether or not texture shadows should attempt to self-shadow.</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_a3f2c4ffe2ab173848c0cff67789d530e"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#a3f2c4ffe2ab173848c0cff67789d530e">Ogre::SceneManager::setShadowTexturePixelFormat</a></div><div class="ttdeci">void setShadowTexturePixelFormat(PixelFormat fmt)</div><div class="ttdoc">Set the pixel format of the textures used for texture-based shadows.</div><div class="ttdef"><b>Definition</b> OgreSceneManager.h:2798</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_a69310c322ea5f58d9c38c13a971f8125"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#a69310c322ea5f58d9c38c13a971f8125">Ogre::SceneManager::setShadowTextureReceiverMaterial</a></div><div class="ttdeci">void setShadowTextureReceiverMaterial(const MaterialPtr &amp;mat)</div><div class="ttdoc">Sets the default material to use for rendering shadow receivers.</div><div class="ttdef"><b>Definition</b> OgreSceneManager.h:2969</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_aa22c0af6835b4a0524b4122756cdd93c"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#aa22c0af6835b4a0524b4122756cdd93c">Ogre::SceneManager::setShadowTextureCasterMaterial</a></div><div class="ttdeci">void setShadowTextureCasterMaterial(const MaterialPtr &amp;mat)</div><div class="ttdoc">Sets the default material to use for rendering shadow casters.</div><div class="ttdef"><b>Definition</b> OgreSceneManager.h:2946</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_aa55e7f4482a2860c6378d97d8b5dfb57"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#aa55e7f4482a2860c6378d97d8b5dfb57">Ogre::SceneManager::setShadowTextureSize</a></div><div class="ttdeci">void setShadowTextureSize(unsigned short size)</div><div class="ttdoc">Set the size of the texture used for all texture-based shadows.</div><div class="ttdef"><b>Definition</b> OgreSceneManager.h:2755</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_ad716d3752418408f073d9be9bbfe62d0"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">Ogre::SceneManager::setShadowTechnique</a></div><div class="ttdeci">void setShadowTechnique(ShadowTechnique technique)</div><div class="ttdoc">Sets the general shadow technique to be used in this scene.</div></div>
</div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html">Ogre</a> to use a 16-bit depth texture. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a material script. They tell <a class="el" href="namespace_ogre.html">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>We’ll present the GLSL code below. Note that the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
Caster</h2>
<div class="fragment"><div class="line">uniform mat4 worldViewProjMatrix;</div>
<div class="line">attribute vec4 vertex;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    gl_Position = worldViewProjMatrix * vertex;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    gl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Just write out the depth values here. The bias and derivatives are handled by the <code>depth_bias</code> set in the pass.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
Receiver</h2>
<div class="fragment"><div class="line">uniform mat4 world;</div>
<div class="line">uniform mat4 worldIT;</div>
<div class="line">uniform mat4 worldViewProj;</div>
<div class="line">uniform mat4 texViewProj;</div>
<div class="line">uniform vec4 lightPosition;</div>
<div class="line">uniform vec4 lightColour;</div>
<div class="line"> </div>
<div class="line">attribute vec4 vertex;</div>
<div class="line">attribute vec3 normal;</div>
<div class="line"> </div>
<div class="line">varying vec4 oUv;</div>
<div class="line">varying vec4 outColor;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    gl_Position = worldViewProj * vertex;</div>
<div class="line">    </div>
<div class="line">    vec4 worldPos = world * vertex;</div>
<div class="line"> </div>
<div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div>
<div class="line">    vec3 lightDir = normalize(</div>
<div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div>
<div class="line"> </div>
<div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// calculate shadow map coords</span></div>
<div class="line">    oUv = texViewProj * worldPos;</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define PCF</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PCF</span></div>
<div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">uniform sampler2D shadowMap;</div>
<div class="line"> </div>
<div class="line">varying vec4 oUv;</div>
<div class="line">varying vec4 outColor;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    vec4 shadowUV = oUv;</div>
<div class="line">    <span class="comment">// point on shadowmap</span></div>
<div class="line">    shadowUV = shadowUV / shadowUV.w;</div>
<div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef OGRE_REVERSED_Z</span></div>
<div class="line">    shadowUV.z = shadowUV.z * 0.5 + 0.5; <span class="comment">// convert -1..1 to 0..1</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div>
<div class="line"><span class="preprocessor">#ifdef PCF</span></div>
<div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div>
<div class="line">    vec4 depths = vec4(</div>
<div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0.0)).x,</div>
<div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0.0)).x,</div>
<div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0.0, -pixeloffset)).x,</div>
<div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0.0, +pixeloffset)).x);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (centerdepth &gt; shadowUV.z) ? 1.0 : 0.0;</div>
<div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div>
<div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div>
<div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div>
<div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">final</span> *= 0.2;</div>
<div class="line"> </div>
<div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1.0);</div>
<div class="line">    </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF define.</p>
<h2><a class="anchor" id="autotoc_md61"></a>
Debugging Shadows</h2>
<p>Since shadows are a difficult subject, so it is a good idea to have the Shadow Map projected on a Mini-Screen where it is possible to see how the Depth Caster is performing.</p>
<p>Material definition: <code>shadow_debug.material</code> </p><div class="fragment"><div class="line">material ShadowDebug</div>
<div class="line">{</div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            lighting off</div>
<div class="line"> </div>
<div class="line">            texture_unit ShadowMap</div>
<div class="line">            {</div>
<div class="line">                tex_address_mode clamp</div>
<div class="line">                filtering none</div>
<div class="line">                content_type shadow</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>With only this material definition the <a class="el" href="rtss.html">RTSS (Realtime Shader System)</a> takes care of generating the proper shader to project the Shadow Map on the Mini Screen.</p>
<p>Source code to create a Rectangle on the screen and project the Shadow Map texture: </p><div class="fragment"><div class="line"><span class="comment">// Create rectangle for the Mini-Screen and attach to node</span></div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_rectangle2_d.html">Ogre::Rectangle2D</a>* miniScreen = mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#ac52887c4c70b39dcaaab5f0785d4b43b">createScreenSpaceRect</a>(<span class="keyword">true</span>);</div>
<div class="line">miniScreen-&gt;<a class="code hl_function" href="class_ogre_1_1_rectangle2_d.html#aed40fe896d3057e028d56c86bea2af4b">setCorners</a>(.5, 1.0, 1.0, .5);</div>
<div class="line">miniScreen-&gt;<a class="code hl_function" href="class_ogre_1_1_simple_renderable.html#a29048e3cee8fa41f3129f79dc5f61988">setBoundingBox</a>(<a class="code hl_variable" href="class_ogre_1_1_axis_aligned_box.html#ad1b10226c7dd82d5714f8d50c5fd4e04">Ogre::AxisAlignedBox::BOX_INFINITE</a>);</div>
<div class="line">miniScreen-&gt;<a class="code hl_function" href="class_ogre_1_1_simple_renderable.html#a8008f933439df61c42c2c4b7a243459c">setMaterial</a>(<a class="code hl_function" href="class_ogre_1_1_material_manager.html#a59f93c2d8ee5924ff0e2ccad8c36d690">Ogre::MaterialManager::getSingletonPtr</a>()-&gt;getByName(<span class="stringliteral">&quot;ShadowDebug&quot;</span>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* miniScreenNode = mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#a7924f5a9ac983d29a5876d633f8a971d">getRootSceneNode</a>()-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_node.html#a15ffc965117fa8c9e3406d54c3cc52d2">createChildSceneNode</a>();</div>
<div class="line">miniScreenNode-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(miniScreen);</div>
<div class="ttc" id="aclass_ogre_1_1_axis_aligned_box_html_ad1b10226c7dd82d5714f8d50c5fd4e04"><div class="ttname"><a href="class_ogre_1_1_axis_aligned_box.html#ad1b10226c7dd82d5714f8d50c5fd4e04">Ogre::AxisAlignedBox::BOX_INFINITE</a></div><div class="ttdeci">static const AxisAlignedBox BOX_INFINITE</div><div class="ttdef"><b>Definition</b> OgreAxisAlignedBox.h:803</div></div>
<div class="ttc" id="aclass_ogre_1_1_rectangle2_d_html"><div class="ttname"><a href="class_ogre_1_1_rectangle2_d.html">Ogre::Rectangle2D</a></div><div class="ttdoc">Allows the rendering of a simple 2D rectangle This class renders a simple 2D rectangle; this rectangl...</div><div class="ttdef"><b>Definition</b> OgreRectangle2D.h:50</div></div>
<div class="ttc" id="aclass_ogre_1_1_rectangle2_d_html_aed40fe896d3057e028d56c86bea2af4b"><div class="ttname"><a href="class_ogre_1_1_rectangle2_d.html#aed40fe896d3057e028d56c86bea2af4b">Ogre::Rectangle2D::setCorners</a></div><div class="ttdeci">void setCorners(float left, float top, float right, float bottom, bool updateAABB=false)</div><div class="ttdoc">Sets the corners of the rectangle, in relative coordinates.</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_a7924f5a9ac983d29a5876d633f8a971d"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#a7924f5a9ac983d29a5876d633f8a971d">Ogre::SceneManager::getRootSceneNode</a></div><div class="ttdeci">SceneNode * getRootSceneNode(void)</div><div class="ttdoc">Gets the SceneNode at the root of the scene hierarchy.</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_ac52887c4c70b39dcaaab5f0785d4b43b"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#ac52887c4c70b39dcaaab5f0785d4b43b">Ogre::SceneManager::createScreenSpaceRect</a></div><div class="ttdeci">Rectangle2D * createScreenSpaceRect(const String &amp;name, bool includeTextureCoords=false)</div><div class="ttdoc">Creates a Rectangle2D that can be displayed for screen space effects or showing a basic GUI.</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_node_html"><div class="ttname"><a href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a></div><div class="ttdoc">Class representing a node in the scene graph.</div><div class="ttdef"><b>Definition</b> OgreSceneNode.h:61</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_node_html_a15ffc965117fa8c9e3406d54c3cc52d2"><div class="ttname"><a href="class_ogre_1_1_scene_node.html#a15ffc965117fa8c9e3406d54c3cc52d2">Ogre::SceneNode::createChildSceneNode</a></div><div class="ttdeci">virtual SceneNode * createChildSceneNode(const Vector3 &amp;translate=Vector3::ZERO, const Quaternion &amp;rotate=Quaternion::IDENTITY)</div><div class="ttdoc">Creates an unnamed new SceneNode as a child of this node.</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_node_html_a51052c58747a77a6cf7451b700e7eb87"><div class="ttname"><a href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">Ogre::SceneNode::attachObject</a></div><div class="ttdeci">virtual void attachObject(MovableObject *obj)</div><div class="ttdoc">Adds an instance of a scene object to this node.</div></div>
<div class="ttc" id="aclass_ogre_1_1_simple_renderable_html_a29048e3cee8fa41f3129f79dc5f61988"><div class="ttname"><a href="class_ogre_1_1_simple_renderable.html#a29048e3cee8fa41f3129f79dc5f61988">Ogre::SimpleRenderable::setBoundingBox</a></div><div class="ttdeci">void setBoundingBox(const AxisAlignedBox &amp;box)</div></div>
<div class="ttc" id="aclass_ogre_1_1_simple_renderable_html_a8008f933439df61c42c2c4b7a243459c"><div class="ttname"><a href="class_ogre_1_1_simple_renderable.html#a8008f933439df61c42c2c4b7a243459c">Ogre::SimpleRenderable::setMaterial</a></div><div class="ttdeci">virtual void setMaterial(const MaterialPtr &amp;mat)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md62"></a>
Improving Shadow Quality</h2>
<p>The default projection used when rendering shadow textures is a uniform frustum. This is pretty straight forward but doesn't make the best use of the space in the shadow map since texels closer to the camera will be larger, resulting in 'jaggies'. There are several ways to distribute the texels in the shadow texture differently. <a class="el" href="namespace_ogre.html">Ogre</a> is provided with several alternative shadow camera setups:</p><ul>
<li><a class="el" href="class_ogre_1_1_focused_shadow_camera_setup.html" title="Implements the uniform shadow mapping algorithm in focused mode.">Ogre::FocusedShadowCameraSetup</a>: Implements the uniform shadow mapping algorithm in focused mode.</li>
<li><a class="el" href="class_ogre_1_1_li_s_p_s_m_shadow_camera_setup.html" title="Implements the Light Space Perspective Shadow Mapping Algorithm .">Ogre::LiSPSMShadowCameraSetup</a>: Implements the Light Space Perspective Shadow Mapping Algorithm.</li>
<li><a class="el" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html" title="Parallel Split Shadow Map (PSSM) shadow camera setup.">Ogre::PSSMShadowCameraSetup</a>: Parallel Split Shadow Map (PSSM) shadow camera setup.</li>
<li><a class="el" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html" title="Implements the plane optimal shadow camera algorithm.">Ogre::PlaneOptimalShadowCameraSetup</a>: Implements the plane optimal shadow camera algorithm.</li>
</ul>
<p>These Shadow Camera Setups can be enabled for the whole Scene with <a class="el" href="class_ogre_1_1_scene_manager.html#acd2de135b378c048c4c4a2dff4c73ac8" title="Set the shadow camera setup to use for all lights which don&#39;t have their own shadow camera setup.">Ogre::SceneManager::setShadowCameraSetup</a> or per light with <a class="el" href="class_ogre_1_1_light.html#a4a6f664fade2ac14d1ed5910b0d1a21a" title="Set this light to use a custom shadow camera when rendering texture shadows.">Ogre::Light::setCustomShadowCameraSetup</a></p>
<p>The following shows how to activate Plane Optimal Shadow Mapping given some pointer to a MovablePlane and a pointer to a light. </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_ogre_1_1_movable_plane.html">Ogre::MovablePlane</a> *movablePlane = <span class="keyword">new</span> <a class="code hl_class" href="class_ogre_1_1_movable_plane.html">Ogre::MovablePlane</a>( Ogre::Vector3::UNIT_Y, 0 );</div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#a7bb6387adbaaac0ff9119e3a85931505">createEntity</a>( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;Floor.mesh&quot;</span> );</div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#a7924f5a9ac983d29a5876d633f8a971d">getRootSceneNode</a>()-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_node.html#a15ffc965117fa8c9e3406d54c3cc52d2">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div>
<div class="line">movablePlaneNode-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div>
<div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code hl_function" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html#aaab9fdf433d40a446a78c67828291812">Ogre::PlaneOptimalShadowCameraSetup::create</a>(movablePlane));</div>
<div class="ttc" id="aclass_ogre_1_1_entity_html"><div class="ttname"><a href="class_ogre_1_1_entity.html">Ogre::Entity</a></div><div class="ttdoc">Defines an instance of a discrete, movable object based on a Mesh.</div><div class="ttdef"><b>Definition</b> OgreEntity.h:80</div></div>
<div class="ttc" id="aclass_ogre_1_1_movable_plane_html"><div class="ttname"><a href="class_ogre_1_1_movable_plane.html">Ogre::MovablePlane</a></div><div class="ttdoc">Definition of a Plane that may be attached to a node, and the derived details of it retrieved simply.</div><div class="ttdef"><b>Definition</b> OgreMovablePlane.h:55</div></div>
<div class="ttc" id="aclass_ogre_1_1_plane_optimal_shadow_camera_setup_html_aaab9fdf433d40a446a78c67828291812"><div class="ttname"><a href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html#aaab9fdf433d40a446a78c67828291812">Ogre::PlaneOptimalShadowCameraSetup::create</a></div><div class="ttdeci">static ShadowCameraSetupPtr create(const MovablePlane *plane)</div><div class="ttdoc">Constructor – requires a plane of interest.</div><div class="ttdef"><b>Definition</b> OgreShadowCameraSetupPlaneOptimal.h:79</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_a7bb6387adbaaac0ff9119e3a85931505"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#a7bb6387adbaaac0ff9119e3a85931505">Ogre::SceneManager::createEntity</a></div><div class="ttdeci">Entity * createEntity(const String &amp;entityName, const String &amp;meshName, const String &amp;groupName=ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)</div><div class="ttdoc">Create an Entity (instance of a discrete mesh).</div></div>
</div><!-- fragment --><p>Another example, using LiSPSM Camera Setup: </p><div class="fragment"><div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#acd2de135b378c048c4c4a2dff4c73ac8">setShadowCameraSetup</a>(<a class="code hl_function" href="class_ogre_1_1_default_shadow_camera_setup.html#a9341b479af2dda3b8ff36a5dd1a1d613">Ogre::LiSPSMShadowCameraSetup::create</a>());</div>
<div class="ttc" id="aclass_ogre_1_1_default_shadow_camera_setup_html_a9341b479af2dda3b8ff36a5dd1a1d613"><div class="ttname"><a href="class_ogre_1_1_default_shadow_camera_setup.html#a9341b479af2dda3b8ff36a5dd1a1d613">Ogre::DefaultShadowCameraSetup::create</a></div><div class="ttdeci">static ShadowCameraSetupPtr create()</div><div class="ttdef"><b>Definition</b> OgreShadowCameraSetup.h:90</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_acd2de135b378c048c4c4a2dff4c73ac8"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#acd2de135b378c048c4c4a2dff4c73ac8">Ogre::SceneManager::setShadowCameraSetup</a></div><div class="ttdeci">void setShadowCameraSetup(const ShadowCameraSetupPtr &amp;shadowSetup)</div><div class="ttdoc">Set the shadow camera setup to use for all lights which don't have their own shadow camera setup.</div></div>
</div><!-- fragment --><p>For big scenes with directional lights one of the better performing Shadow Camera Setups is PSSM. A PSSM shadow system uses multiple shadow maps per light and maps each texture into a region of space, progressing away from the camera. As such it is most appropriate for directional light setups. A more in depth explanation can be found in the wiki: <a href="https://wiki.ogre3d.org/Parallel+Split+Shadow+Mapping">Parallel Split Shadow Mapping</a></p>
<div class="fragment"><div class="line"><span class="comment">// General scene setup</span></div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code hl_enumvalue" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6ac29b9727942e113575ea3947a89ae047">Ogre::SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED</a>);</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#aa22c0af6835b4a0524b4122756cdd93c">setShadowTextureCasterMaterial</a>(<a class="code hl_function" href="class_ogre_1_1_material_manager.html#a59f93c2d8ee5924ff0e2ccad8c36d690">Ogre::MaterialManager::getSingletonPtr</a>()-&gt;getByName(<span class="stringliteral">&quot;PSSMCaster&quot;</span>));</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#a1963d4af77db29c6419737c1c1ee9a31">setShadowTextureSelfShadow</a>(<span class="keyword">true</span>);</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#a103f475cd458b8bbdbf5ff679eeb20a8">setShadowFarDistance</a>(3000);</div>
<div class="line"><span class="comment">// 3 textures per directional light (PSSM)</span></div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#a70f8eddf9b8617783fb7d0995b985a9a">setShadowTextureCountPerLightType</a>(<a class="code hl_enumvalue" href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345a4c5582d28848ce40c2b652488494b4a3">Ogre::Light::LT_DIRECTIONAL</a>, 3);</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#a85c3a0d9755dfdfa841ec1383b20687c">setShadowTextureCount</a>(3);</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#adcbf0f49de53a7b67574481703d4fc03">setShadowTextureConfig</a>(0, 2048, 2048, <a class="code hl_enumvalue" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf57a48d6f90676eb2d9230127960412b">Ogre::PF_DEPTH16</a>);</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#adcbf0f49de53a7b67574481703d4fc03">setShadowTextureConfig</a>(1, 1024, 1024, <a class="code hl_enumvalue" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf57a48d6f90676eb2d9230127960412b">Ogre::PF_DEPTH16</a>);</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#adcbf0f49de53a7b67574481703d4fc03">setShadowTextureConfig</a>(2, 512, 512, <a class="code hl_enumvalue" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf57a48d6f90676eb2d9230127960412b">Ogre::PF_DEPTH16</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html">Ogre::PSSMShadowCameraSetup</a>* pssmSetup = <span class="keyword">new</span> <a class="code hl_class" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html">Ogre::PSSMShadowCameraSetup</a>();</div>
<div class="line">pssmSetup-&gt;<a class="code hl_function" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a5000b20f43bea556bcdd994550f1f0ab">setSplitPadding</a>(1);</div>
<div class="line">pssmSetup-&gt;<a class="code hl_function" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a1038abc3af65c1177d192ecc5bebf04a">calculateSplitPoints</a>(3, 1, mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#abd8b3284334279f65fa12b5ff2571eca">getShadowFarDistance</a>());</div>
<div class="line">pssmSetup-&gt;<a class="code hl_function" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a4f16797f8c4fcee30141e5dd0690e647">setOptimalAdjustFactor</a>(0, 2);</div>
<div class="line">pssmSetup-&gt;<a class="code hl_function" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a4f16797f8c4fcee30141e5dd0690e647">setOptimalAdjustFactor</a>(1, 1);</div>
<div class="line">pssmSetup-&gt;<a class="code hl_function" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a4f16797f8c4fcee30141e5dd0690e647">setOptimalAdjustFactor</a>(2, 0.5);</div>
<div class="line">mSceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#acd2de135b378c048c4c4a2dff4c73ac8">setShadowCameraSetup</a>(<a class="code hl_class" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(pssmSetup));</div>
<div class="ttc" id="aclass_ogre_1_1_light_html_af20fe2bb87447be7a9a5327c65dee345a4c5582d28848ce40c2b652488494b4a3"><div class="ttname"><a href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345a4c5582d28848ce40c2b652488494b4a3">Ogre::Light::LT_DIRECTIONAL</a></div><div class="ttdeci">@ LT_DIRECTIONAL</div><div class="ttdoc">Directional lights simulate parallel light beams from a distant source, hence have direction but no p...</div><div class="ttdef"><b>Definition</b> OgreLight.h:108</div></div>
<div class="ttc" id="aclass_ogre_1_1_p_s_s_m_shadow_camera_setup_html"><div class="ttname"><a href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html">Ogre::PSSMShadowCameraSetup</a></div><div class="ttdoc">Parallel Split Shadow Map (PSSM) shadow camera setup.</div><div class="ttdef"><b>Definition</b> OgreShadowCameraSetupPSSM.h:57</div></div>
<div class="ttc" id="aclass_ogre_1_1_p_s_s_m_shadow_camera_setup_html_a1038abc3af65c1177d192ecc5bebf04a"><div class="ttname"><a href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a1038abc3af65c1177d192ecc5bebf04a">Ogre::PSSMShadowCameraSetup::calculateSplitPoints</a></div><div class="ttdeci">void calculateSplitPoints(uint splitCount, Real nearDist, Real farDist, Real lambda=0.95f)</div><div class="ttdoc">Calculate a new splitting scheme.</div></div>
<div class="ttc" id="aclass_ogre_1_1_p_s_s_m_shadow_camera_setup_html_a4f16797f8c4fcee30141e5dd0690e647"><div class="ttname"><a href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a4f16797f8c4fcee30141e5dd0690e647">Ogre::PSSMShadowCameraSetup::setOptimalAdjustFactor</a></div><div class="ttdeci">void setOptimalAdjustFactor(size_t splitIndex, Real factor)</div><div class="ttdoc">Set the LiSPSM optimal adjust factor for a given split (call after configuring splits).</div></div>
<div class="ttc" id="aclass_ogre_1_1_p_s_s_m_shadow_camera_setup_html_a5000b20f43bea556bcdd994550f1f0ab"><div class="ttname"><a href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a5000b20f43bea556bcdd994550f1f0ab">Ogre::PSSMShadowCameraSetup::setSplitPadding</a></div><div class="ttdeci">void setSplitPadding(Real pad)</div><div class="ttdoc">Set the padding factor to apply to the near &amp; far distances when matching up splits to one another,...</div><div class="ttdef"><b>Definition</b> OgreShadowCameraSetupPSSM.h:106</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_a103f475cd458b8bbdbf5ff679eeb20a8"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#a103f475cd458b8bbdbf5ff679eeb20a8">Ogre::SceneManager::setShadowFarDistance</a></div><div class="ttdeci">void setShadowFarDistance(Real distance)</div><div class="ttdoc">Sets the default maximum distance away from the camera that shadows will be visible.</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_a70f8eddf9b8617783fb7d0995b985a9a"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#a70f8eddf9b8617783fb7d0995b985a9a">Ogre::SceneManager::setShadowTextureCountPerLightType</a></div><div class="ttdeci">void setShadowTextureCountPerLightType(Light::LightTypes type, size_t count)</div><div class="ttdoc">Set the number of shadow textures a light type uses.</div><div class="ttdef"><b>Definition</b> OgreSceneManager.h:2831</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_a85c3a0d9755dfdfa841ec1383b20687c"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#a85c3a0d9755dfdfa841ec1383b20687c">Ogre::SceneManager::setShadowTextureCount</a></div><div class="ttdeci">void setShadowTextureCount(size_t count)</div><div class="ttdoc">Set the number of textures allocated for texture-based shadows.</div><div class="ttdef"><b>Definition</b> OgreSceneManager.h:2817</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_abd8b3284334279f65fa12b5ff2571eca"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#abd8b3284334279f65fa12b5ff2571eca">Ogre::SceneManager::getShadowFarDistance</a></div><div class="ttdeci">Real getShadowFarDistance(void) const</div><div class="ttdoc">Gets the default maximum distance away from the camera that shadows will be visible.</div><div class="ttdef"><b>Definition</b> OgreSceneManager.h:2737</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_adcbf0f49de53a7b67574481703d4fc03"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#adcbf0f49de53a7b67574481703d4fc03">Ogre::SceneManager::setShadowTextureConfig</a></div><div class="ttdeci">void setShadowTextureConfig(size_t shadowIndex, uint16 width, uint16 height, PixelFormat format, uint16 fsaa=0, uint16 depthBufferPoolId=1)</div><div class="ttdoc">Set the detailed configuration for a shadow texture.</div><div class="ttdef"><b>Definition</b> OgreSceneManager.h:2766</div></div>
<div class="ttc" id="aclass_ogre_1_1_shared_ptr_html"><div class="ttname"><a href="class_ogre_1_1_shared_ptr.html">Ogre::SharedPtr&lt; ShadowCameraSetup &gt;</a></div></div>
<div class="ttc" id="agroup___general_html_gga79dcd426d291c31072c1ad6f183715d6ac29b9727942e113575ea3947a89ae047"><div class="ttname"><a href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6ac29b9727942e113575ea3947a89ae047">Ogre::SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED</a></div><div class="ttdeci">@ SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED</div><div class="ttdoc">Texture-based shadow technique which involves a render-to-texture of the shadow caster and a projecti...</div><div class="ttdef"><b>Definition</b> OgreCommon.h:276</div></div>
<div class="ttc" id="agroup___image_html_gga7e0353e7d36d4c2e8468641b7303d39caf57a48d6f90676eb2d9230127960412b"><div class="ttname"><a href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf57a48d6f90676eb2d9230127960412b">Ogre::PF_DEPTH16</a></div><div class="ttdeci">@ PF_DEPTH16</div><div class="ttdoc">Depth texture format, with 16-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> OgrePixelFormat.h:118</div></div>
</div><!-- fragment --><p>The Shadow Caster Vertex and Fragment programs are the same as the regular shadow mapping techniques.</p>
<p>But some changes have to be made to the shaders of the Shadow Receiver as well as the program definition, because now we are sending three shadow map splits (in this example).</p>
<p>Material definition: </p><div class="fragment"><div class="line">sampler DepthSampler</div>
<div class="line">{</div>
<div class="line">    filtering none</div>
<div class="line">    tex_address_mode clamp</div>
<div class="line">    tex_border_colour 1.0 1.0 1.0 1.0</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">material PSSMShadowReceiver</div>
<div class="line">{</div>
<div class="line">    technique default</div>
<div class="line">    {</div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            vertex_program_ref PSSMShadowReceiverVP {}</div>
<div class="line">            fragment_program_ref PSSMShadowReceiverFP {}</div>
<div class="line"> </div>
<div class="line">            texture_unit ShadowMap0</div>
<div class="line">            {</div>
<div class="line">                content_type shadow</div>
<div class="line">                sampler_ref DepthSampler</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            texture_unit ShadowMap1</div>
<div class="line">            {</div>
<div class="line">                content_type shadow</div>
<div class="line">                sampler_ref DepthSampler</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            texture_unit ShadowMap2</div>
<div class="line">            {</div>
<div class="line">                content_type shadow</div>
<div class="line">                sampler_ref DepthSampler</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Program definition: </p><div class="fragment"><div class="line">vertex_program PSSMShadowReceiverVP glsl</div>
<div class="line">{</div>
<div class="line">    source PSSMShadowReceiver.vert</div>
<div class="line"> </div>
<div class="line">    default_params</div>
<div class="line">    {</div>
<div class="line">        param_named_auto world world_matrix</div>
<div class="line">        param_named_auto worldIT inverse_transpose_world_matrix</div>
<div class="line">        param_named_auto worldViewProj worldviewproj_matrix</div>
<div class="line">        param_named_auto lightPosition light_position 0</div>
<div class="line">        param_named_auto lightColour light_diffuse_colour 0</div>
<div class="line"> </div>
<div class="line">        param_named_auto texViewProj0 texture_viewproj_matrix 0</div>
<div class="line">        param_named_auto texViewProj1 texture_viewproj_matrix 1</div>
<div class="line">        param_named_auto texViewProj2 texture_viewproj_matrix 2</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment_program PSSMShadowReceiverFP glsl</div>
<div class="line">{</div>
<div class="line">    source PSSMShadowReceiver.frag</div>
<div class="line"> </div>
<div class="line">    default_params</div>
<div class="line">    {</div>
<div class="line">        param_named shadowMap0 int 0</div>
<div class="line">        param_named shadowMap1 int 1</div>
<div class="line">        param_named shadowMap2 int 2</div>
<div class="line"> </div>
<div class="line">        param_named pssmSplitPoints float4 0 0 0 0</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The vertex shader now includes three texture projection matrixes </p><div class="fragment"><div class="line"><span class="preprocessor">#version 330 core</span></div>
<div class="line"> </div>
<div class="line">layout (location = 0) in vec4 vertex;</div>
<div class="line">layout (location = 2) in vec3 normal;</div>
<div class="line"> </div>
<div class="line">uniform mat4 world;</div>
<div class="line">uniform mat4 worldIT;</div>
<div class="line">uniform mat4 worldViewProj;</div>
<div class="line">uniform vec4 lightPosition;</div>
<div class="line">uniform vec4 lightColour;</div>
<div class="line"> </div>
<div class="line">uniform mat4 texViewProj0;</div>
<div class="line">uniform mat4 texViewProj1;</div>
<div class="line">uniform mat4 texViewProj2;</div>
<div class="line"> </div>
<div class="line">out vec4 outColor;</div>
<div class="line"> </div>
<div class="line">out vec4 oUv0;</div>
<div class="line">out vec4 oUv1;</div>
<div class="line">out vec4 oUv2;</div>
<div class="line"> </div>
<div class="line">out <span class="keywordtype">float</span> depth;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    gl_Position = worldViewProj * vertex;</div>
<div class="line">    depth = gl_Position.z;</div>
<div class="line"> </div>
<div class="line">    vec4 worldPos = world * vertex;</div>
<div class="line"> </div>
<div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div>
<div class="line">    vec3 lightDir = normalize(lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div>
<div class="line"> </div>
<div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// calculate shadow map coords</span></div>
<div class="line">    oUv0 = texViewProj0 * worldPos;</div>
<div class="line">    oUv1 = texViewProj1 * worldPos;</div>
<div class="line">    oUv2 = texViewProj2 * worldPos;</div>
<div class="line">}</div>
</div><!-- fragment --><p>And the fragment shader has to be accommodated to select the correct Shadow Map according to the camera distance </p><div class="fragment"><div class="line"><span class="preprocessor">#version 330 core</span></div>
<div class="line"> </div>
<div class="line">in vec4 oUv0;</div>
<div class="line">in vec4 oUv1;</div>
<div class="line">in vec4 oUv2;</div>
<div class="line"> </div>
<div class="line">in vec4 outColor;</div>
<div class="line"> </div>
<div class="line">in <span class="keywordtype">float</span> depth;</div>
<div class="line"> </div>
<div class="line">uniform sampler2D shadowMap0;</div>
<div class="line">uniform sampler2D shadowMap1;</div>
<div class="line">uniform sampler2D shadowMap2;</div>
<div class="line"> </div>
<div class="line">uniform vec4 pssmSplitPoints;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> shadowFilter( sampler2D shadowMap, vec4 oUv, vec3 splitColour )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Perform perspective divide</span></div>
<div class="line">    vec4 shadowUV = oUv;</div>
<div class="line">    shadowUV = shadowUV / shadowUV.w;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Transform [-1, 1] to [0, 1] range</span></div>
<div class="line">    shadowUV.z = shadowUV.z * 0.5 + 0.5;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get closest depth value from light&#39;s perspective (using [0,1] range fragPosLight as coords)</span></div>
<div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Check whether current frag pos is in shadow</span></div>
<div class="line">    gl_FragColor = (finalCenterDepth &gt; shadowUV.z) ? vec4(outColor.xyz * splitColour, 1.0) : vec4(0.0, 0.0, 0.0, 1.0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>( depth &lt;= pssmSplitPoints.y )</div>
<div class="line">    {</div>
<div class="line">        shadowFilter( shadowMap0, oUv0, vec3( 1.0, 0.0, 0.0 ) );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( depth &lt;= pssmSplitPoints.z )</div>
<div class="line">    {</div>
<div class="line">        shadowFilter( shadowMap1, oUv1, vec3( 0.0, 1.0, 0.0 ) );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( depth &lt;= pssmSplitPoints.w )</div>
<div class="line">    {</div>
<div class="line">        shadowFilter( shadowMap2, oUv2, vec3( 0.0, 0.0, 1.0 ) );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        discard;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
