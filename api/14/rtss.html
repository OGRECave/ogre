<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Runtime Shader Generation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('rtss.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Runtime Shader Generation</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#rtss_custom_mat">RTSS Pass properties</a><ul><li class="level2"><a href="#autotoc_md244">transform_stage</a></li>
<li class="level2"><a href="#autotoc_md245">lighting_stage</a></li>
<li class="level2"><a href="#autotoc_md246">image_based_lighting</a></li>
<li class="level2"><a href="#autotoc_md247">gbuffer</a></li>
<li class="level2"><a href="#autotoc_md248">normal_map</a></li>
<li class="level2"><a href="#autotoc_md249">metal_roughness</a></li>
<li class="level2"><a href="#autotoc_md250">fog_stage</a></li>
<li class="level2"><a href="#autotoc_md251">light_count</a></li>
<li class="level2"><a href="#autotoc_md252">triplanarTexturing</a></li>
<li class="level2"><a href="#autotoc_md253">integrated_pssm4</a></li>
<li class="level2"><a href="#shadow_mapping">shadow_mapping</a></li>
<li class="level2"><a href="#autotoc_md254">hardware_skinning</a></li>
</ul>
</li>
<li class="level1"><a href="#rtss_tu_props">RTSS Texture Unit properties</a><ul><li class="level2"><a href="#normal_map">normal_map</a></li>
<li class="level2"><a href="#autotoc_md255">layered_blend</a></li>
<li class="level2"><a href="#autotoc_md256">source_modifier</a></li>
</ul>
</li>
<li class="level1"><a href="#RTSS-Props-API">Setting properties programmatically</a></li>
<li class="level1"><a href="#rtss_overview">System overview</a><ul><li class="level2"><a href="#core-feats">Core features of the system</a></li>
<li class="level2"><a href="#autotoc_md257">Controlling shader re-generation</a></li>
</ul>
</li>
<li class="level1"><a href="#rtss_indepth">The RTSS in Depth</a><ul><li class="level2"><a href="#rtss__components">Main components</a></li>
<li class="level2"><a href="#autotoc_md258">Initializing the system</a></li>
<li class="level2"><a href="#rtss_custom_api">Customizing the default RenderState</a></li>
<li class="level2"><a href="#rtssTech">Creating the shader based technique</a></li>
<li class="level2"><a href="#rtssGenerate">Shader generation at runtime</a></li>
<li class="level2"><a href="#creating-extensions">Creating custom shader extensions</a></li>
<li class="level2"><a href="#debugging">Tips for debugging shaders</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>With D3D11 and GL3, support for fixed pipeline functionality was removed. Meaning you can only render objects using shaders.</p>
<p>While <a class="el" href="_high-level-_programs.html">GPU Program Scripts</a> offer you maximal control and flexibility over how your objects are rendered, writing and maintaining them is also a very time consuming task.</p>
<p>The Run Time Shader System or RTSS for short is the Ogre way of managing Shaders and their variations. Initially it was created as a drop-in-replacement to the Fixed-Function Pipeline (FFP) for RenderSystems that lacked it. However, since then it grew to a general way to express shader functionality in <a class="el" href="_material-_scripts.html">Material Scripts</a> without having to manually write shaders.</p>
<p>While the resulting shaders are less optimized, they offer the following advantages:</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes.</li>
</ul>
<p>For fixed function function properties, the RTSS will read the standard <code>pass</code> and <code>texture_unit</code> definitions, so no changes are required. To enable features that go beyond the possibilities of the FFP, you have to define an additional <code>rtshader_system</code> block with the respective properties.</p>
<p>For instance, the FFP only allows per-vertex lighting. To request per-pixel lighting, you would add the following block to a pass:</p>
<div class="fragment"><div class="line">            <span class="comment">// RT Shader system section.</span></div>
<div class="line">            rtshader_system</div>
<div class="line">            {       </div>
<div class="line">                <span class="comment">// Override lighting stage with per pixel lighting.             </span></div>
<div class="line">                lighting_stage per_pixel                </div>
<div class="line">            }   </div>
</div><!-- fragment --><p>To modify the default lighting stage <a class="el" href="rtss.html#rtss_custom_api">see below</a>. For more examples see <code>Media/RTShaderLib/materials/RTShaderSystem.material</code>.</p>
<h1><a class="anchor" id="rtss_custom_mat"></a>
RTSS Pass properties</h1>
<p>Here are the attributes you can use in a <code>rtshader_system</code> block of a <code>pass {}</code>:</p>
<ul>
<li><a class="el" href="rtss.html#transform_stage">transform_stage</a></li>
<li><a class="el" href="rtss.html#lighting_stage">lighting_stage</a></li>
<li><a class="el" href="rtss.html#image_based_lighting">image_based_lighting</a></li>
<li><a class="el" href="rtss.html#gbuffer">gbuffer</a></li>
<li><a class="el" href="rtss.html#normal_map_pass">normal_map</a></li>
<li><a class="el" href="rtss.html#metal_roughness">metal_roughness</a></li>
<li><a class="el" href="rtss.html#fog_stage">fog_stage</a></li>
<li><a class="el" href="rtss.html#light_count">light_count</a></li>
<li><a class="el" href="rtss.html#triplanarTexturing">triplanarTexturing</a></li>
<li><a class="el" href="rtss.html#shadow_mapping">shadow_mapping</a></li>
<li><a class="el" href="rtss.html#integrated_pssm4">integrated_pssm4</a></li>
<li><a class="el" href="rtss.html#hardware_skinning">hardware_skinning</a></li>
<li><a class="el" href="rtss.html#layered_blend">layered_blend</a></li>
<li><a class="el" href="rtss.html#source_modifier">source_modifier</a></li>
</ul>
<p><a class="anchor" id="transform_stage"></a></p>
<h2><a class="anchor" id="autotoc_md244"></a>
transform_stage</h2>
<p>Computes the position of the vertex in projection space, allows using instancing.  </p>
<dl class="section user"><dt></dt><dd>Format: <code>transform_stage &lt;type&gt; [attrIndex]</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Example: <code>transform_stage instanced 1</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>either <code>ffp</code> or <code>instanced</code> </td></tr>
    <tr><td class="paramname">attrIndex</td><td>the start texcoord attribute index to read the instanced world matrix from. Must be greater than 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_high-level-_programs.html#Instancing-in-Vertex-Programs">Instancing in Vertex Programs</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_instance_batch_h_w.html" title="This is technique requires true instancing hardware support.">Ogre::InstanceBatchHW</a></dd></dl>
<p><a class="anchor" id="lighting_stage"></a></p>
<h2><a class="anchor" id="autotoc_md245"></a>
lighting_stage</h2>
<p>Force a specific lighting model.</p>
<dl class="section user"><dt></dt><dd>Format: <code>lighting_stage &lt;ffp|per_pixel&gt; [two_sided] [normalised]</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Example: <code>lighting_stage ffp two_sided</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">two_sided</td><td>compute lighting on both sides of the surface, when culling is disabled. </td></tr>
    <tr><td class="paramname">normalised</td><td>normalise the blinn-phong reflection model to make it energy conserving - see <a href="http://www.rorydriscoll.com/2009/01/25/energy-conservation-in-games/">this for details</a></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="image_based_lighting"></a></p>
<h2><a class="anchor" id="autotoc_md246"></a>
image_based_lighting</h2>
<p>Adds calculations for indirect image based lighting (IBL)  </p>
<dl class="section user"><dt></dt><dd>Format: <code>image_based_lighting texture &lt;texture&gt; [luminance &lt;luminance&gt;]</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Example: <code>image_based_lighting texture ibl_cubemap.ktx</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">luminance</td><td>factor to scale the IBL influence by</td></tr>
  </table>
  </dd>
</dl>
<p>For best results, generate the cubemaps using <a href="https://github.com/google/filament/tree/main/tools/cmgen">cmgen</a> from the filament project.</p>
<p><a class="anchor" id="gbuffer"></a></p>
<h2><a class="anchor" id="autotoc_md247"></a>
gbuffer</h2>
<p>Redirects rendering results into gbuffers for e.g. deferred shading.  </p>
<dl class="section user"><dt></dt><dd>Format: <code>lighting_stage gbuffer &lt;target_layout&gt; [target_layout]</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Example: <code>lighting_stage gbuffer normal_viewdepth diffuse_specular</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_layout</td><td>with <code>gbuffer</code>, this specifies the data to be written into one or two MRT targets. Possible values are <code>depth</code>, <code>normal</code>, <code>viewpos</code>, <code>normal_viewdepth</code> and <code>diffuse_specular</code> </td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="normal_map_pass"></a></p>
<h2><a class="anchor" id="autotoc_md248"></a>
normal_map</h2>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000295">Deprecated:</a></b></dt><dd>use <a class="el" href="rtss.html#normal_map">normal_map</a> instead</dd></dl>
<p>Use a normal map to derive normals.  </p>
<dl class="section user"><dt></dt><dd>Format: <code>lighting_stage normal_map &lt;texture&gt; [normalmap_space] [texcoord_index] [sampler]</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 SamplerToUse</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>normal map name to use </td></tr>
    <tr><td class="paramname">normalmap_space</td><td>see <a class="el" href="rtss.html#normal_map">normal_map</a> </td></tr>
    <tr><td class="paramname">texcoord_index</td><td>the start texcoord attribute index to read the uv coordinates from </td></tr>
    <tr><td class="paramname">sampler</td><td>the <a class="el" href="_material-_scripts.html#Samplers">Sampler</a> to use for the normal map</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="metal_roughness"></a></p>
<h2><a class="anchor" id="autotoc_md249"></a>
metal_roughness</h2>
<p>Use metal roughness parametrisation for lighting calulations.  </p>
<p>By default, roughness is read from <code>specular[0]</code> and metalness from <code>specular[1]</code>.</p>
<dl class="section user"><dt></dt><dd>Format: <code>lighting_stage metal_roughness [texture &lt;texturename&gt;]</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Example: <code>lighting_stage metal_roughness texture Default_metalRoughness.jpg</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texturename</td><td>texture for spatially varying parametrization. <a href="https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#_material_pbrmetallicroughness_metallicroughnesstexture">In accordance to the glTF2.0 specification</a>, roughness is sampled from the G channel and metalness from the B channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Using this option switches the lighting equations from Blinn-Phong to the Cook-Torrance PBR model <a href="https://google.github.io/filament/Filament.html#materialsystem/standardmodelsummary">using the equations described by Filament</a>.</dd></dl>
<p><a class="anchor" id="fog_stage"></a></p>
<h2><a class="anchor" id="autotoc_md250"></a>
fog_stage</h2>
<p>Modulates the color of a pixel based on the scene or object fog parameters.  </p>
<dl class="section user"><dt></dt><dd>Format: <code>fog_stage ffp &lt;calc_mode&gt;</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Example: <code>fog_stage ffp per_pixel</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">calc_mode</td><td>either <code>per_vertex</code> or <code>per_pixel</code></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="light_count"></a></p>
<h2><a class="anchor" id="autotoc_md251"></a>
light_count</h2>
<p>Override dynamic light count. Fix the number of lights to be used in the shader. Avoids shader recompilation when the number of lights changes. </p><dl class="section user"><dt></dt><dd>Format: <code>light_count &lt;count&gt;</code></dd></dl>
<p><a class="anchor" id="triplanarTexturing"></a></p>
<h2><a class="anchor" id="autotoc_md252"></a>
triplanarTexturing</h2>
<p>enable <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texture mapping</a>  </p>
<dl class="section user"><dt></dt><dd>Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureScale</td><td>texture coordinates are multiplied by this. </td></tr>
    <tr><td class="paramname">plateauSize</td><td>plateau on which small components of the normal have no influence. </td></tr>
    <tr><td class="paramname">transitionSpeed</td><td>transitions speed between the three textures Valid values are [0; 0.57] not bigger to avoid division by zero </td></tr>
    <tr><td class="paramname">textureFromX</td><td>Texture for the x-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromY</td><td>Texture for the y-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromZ</td><td>Texture for the z-direction planar mapping</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="integrated_pssm4"></a></p>
<h2><a class="anchor" id="autotoc_md253"></a>
integrated_pssm4</h2>
<dl class="section user"><dt></dt><dd>Format: <code>integrated_pssm4 &lt;znear&gt; &lt;sp0&gt; &lt;sp1&gt; &lt;zfar&gt; [debug] [filter]</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">debug</td><td>visualize the active shadow-splits in the scene </td></tr>
    <tr><td class="paramname">filter</td><td>one of <code>pcf4, pcf16</code> (default: <code>pcf4</code>)</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="shadow_mapping"></a>
shadow_mapping</h2>
<p>shadow mapping receiver with multiple lights or single PSSM light with up to 3 custom splits.  </p>
<dl class="section user"><dt></dt><dd>Format: <code>shadow_mapping [light_count &lt;num&gt;] [filter &lt;type&gt;]</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>one of <code>pcf4, pcf16</code> (default: <code>pcf4</code>) </td></tr>
    <tr><td class="paramname">light_count</td><td>number of lights to support (default: 1)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="hardware_skinning"></a></p>
<h2><a class="anchor" id="autotoc_md254"></a>
hardware_skinning</h2>
<p>Include skinning calculations for Skeletal Animation in the shader to move computations to the GPU.  </p>
<dl class="section user"><dt></dt><dd>Format: <code>hardware_skinning &lt;max_bone_count&gt; &lt;weight_count&gt; [type] [correct_antipodality scale_shearing]</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Example: <code>hardware_skinning 24 2 dual_quaternion true false</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>either <code>dual_quaternion</code> or <code>linear</code> (default: <code>linear</code>) </td></tr>
    <tr><td class="paramname">correct_antipodality</td><td>Correctly handle rotations &gt; 180° in dual quaternion computation </td></tr>
    <tr><td class="paramname">scale_shearing</td><td>add scaling and shearing support to dual quaternion computation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>You can also use <a class="el" href="class_ogre_1_1_r_t_shader_1_1_hardware_skinning_factory.html#aa9bea1d58428c16f0dce7b3074937d43" title="Prepares an entity&#39;s material for use in the hardware skinning (HS).">Ogre::RTShader::HardwareSkinningFactory::prepareEntityForSkinning</a> to derive this information automatically.</dd></dl>
<h1><a class="anchor" id="rtss_tu_props"></a>
RTSS Texture Unit properties</h1>
<p>Here are the attributes you can use in a <code>rtshader_system</code> block of a <code>texture_unit {}</code>:</p>
<ul>
<li><a class="el" href="rtss.html#normal_map">normal_map</a></li>
<li><a class="el" href="rtss.html#layered_blend">layered_blend</a></li>
<li><a class="el" href="rtss.html#source_modifier">source_modifier</a></li>
</ul>
<h2><a class="anchor" id="normal_map"></a>
normal_map</h2>
<p>Use a normal map to derive normals.  </p>
<dl class="section user"><dt></dt><dd>Format: <code>normal_map &lt;normalmap_space&gt; [height_scale scale] [texcoord_index idx]</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Example: <code>normal_map parallax_occlusion height_scale 0.1</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalmap_space</td><td><dl compact="compact">
<dt>tangent_space </dt>
<dd>Normal map contains normal data in tangent space. This is the default normal mapping behavior and it requires that the target mesh will have valid tangents within its vertex data. </dd>
<dt>object_space </dt>
<dd>Normal map contains normal data in object local space. This normal mapping technique has the advantages of better visualization results, lack of artifacts that comes from texture mirroring usage, it doesn't requires tangent and it also saves some instruction in the vertex shader stage. The main drawback of using this kind of normal map is that the target object must be static in terms of local space rotations and translations. </dd>
<dt>parallax </dt>
<dd>Normal map contains normal data in parallax corrected tangent space The restrictions of <code>tangent_space</code> apply. Additionally the alpha channel of the normal texture is expected to contain height displacement data. This is used for parallax corrected rendering. </dd>
<dt>parallax_occlusion </dt>
<dd>An extension of <code>parallax</code>, which samples the texture multiple times to allow using a larger displacement value without getting artifacts. </dd>
</dl>
</td></tr>
    <tr><td class="paramname">height_scale</td><td>displacement scale factor, when using <code>parallax</code> or <code>parallax_occlusion</code> </td></tr>
    <tr><td class="paramname">texcoord_index</td><td>the texcoord attribute index to read the uv coordinates from</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="layered_blend"></a></p>
<h2><a class="anchor" id="autotoc_md255"></a>
layered_blend</h2>
<p>Apply photoshop-like blend effects to texture layers.   </p><dl class="section user"><dt></dt><dd>Format: <code>layered_blend &lt;effect&gt;</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Example: layered_blend luminosity</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">effect</td><td>one of <code>default, normal, lighten, darken, multiply, average, add, subtract, difference, negation, exclusion, screen, overlay, hard_light, soft_light, color_dodge, color_burn, linear_dodge, linear_burn, linear_light, vivid_light, pin_light, hard_mix, reflect, glow, phoenix, saturation, color, luminosity</code></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="source_modifier"></a></p>
<h2><a class="anchor" id="autotoc_md256"></a>
source_modifier</h2>
<p>Apply custom modulate effect to texture layer </p><dl class="section user"><dt></dt><dd>Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Example: <code>source_modifier src1_inverse_modulate custom 2</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>one of <code>src1_modulate, src2_modulate, src1_inverse_modulate, src2_inverse_modulate</code> </td></tr>
    <tr><td class="paramname">parameterNum</td><td>number of the custom shader parameter that controls the operation</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="RTSS-Props-API"></a>
Setting properties programmatically</h1>
<p>In case you need to set the properties programmatically, see the following example for how the script is mapped to the API.</p>
<div class="fragment"><div class="line">rtshader_system</div>
<div class="line">{</div>
<div class="line">    normal_map height_scale 0.1</div>
<div class="line">}</div>
</div><!-- fragment --><p> becomes </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ogre_1_1_r_t_shader.html">Ogre::RTShader</a>;</div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html">ShaderGenerator</a>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">shaderGen</a> = ShaderGenerator::getSingletonPtr();</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">shaderGen</a>-&gt;createShaderBasedTechnique(<a class="code hl_struct" href="struct_ogre_1_1vector.html">mat</a>-&gt;getTechnique(0), MSN_SHADERGEN);</div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">RenderState</a>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">rs</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">shaderGen</a>-&gt;getRenderState(MSN_SHADERGEN, *<a class="code hl_struct" href="struct_ogre_1_1vector.html">mat</a>, 0);</div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">SubRenderState</a>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">srs</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">shaderGen</a>-&gt;createSubRenderState(SRS_NORMALMAP);</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">rs</a>-&gt;addTemplateSubRenderState(<a class="code hl_struct" href="struct_ogre_1_1vector.html">srs</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">srs</a>-&gt;setParameter(<span class="stringliteral">&quot;height_scale&quot;</span>, <span class="stringliteral">&quot;0.1&quot;</span>);</div>
<div class="ttc" id="aclass_ogre_1_1_r_t_shader_1_1_render_state_html"><div class="ttname"><a href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a></div><div class="ttdoc">This is a container class for sub render state class.</div><div class="ttdef"><b>Definition</b> OgreShaderRenderState.h:51</div></div>
<div class="ttc" id="aclass_ogre_1_1_r_t_shader_1_1_shader_generator_html"><div class="ttname"><a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html">Ogre::RTShader::ShaderGenerator</a></div><div class="ttdoc">Shader generator system main interface.</div><div class="ttdef"><b>Definition</b> OgreShaderGenerator.h:63</div></div>
<div class="ttc" id="aclass_ogre_1_1_r_t_shader_1_1_sub_render_state_html"><div class="ttname"><a href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">Ogre::RTShader::SubRenderState</a></div><div class="ttdoc">This class is the base interface of sub part from a shader based rendering pipeline.</div><div class="ttdef"><b>Definition</b> OgreShaderSubRenderState.h:86</div></div>
<div class="ttc" id="anamespace_ogre_1_1_r_t_shader_html"><div class="ttname"><a href="namespace_ogre_1_1_r_t_shader.html">Ogre::RTShader</a></div><div class="ttdef"><b>Definition</b> OgreShaderExHardwareSkinning.h:36</div></div>
<div class="ttc" id="astruct_ogre_1_1vector_html"><div class="ttname"><a href="struct_ogre_1_1vector.html">Ogre::vector</a></div><div class="ttdef"><b>Definition</b> OgreDeprecated.h:54</div></div>
</div><!-- fragment --><h1><a class="anchor" id="rtss_overview"></a>
System overview</h1>
<p>The RTSS manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <code>SGX_Light_Directional_Diffuse()</code>, <code>SGX_Light_Point_Diffuse()</code>.</p>
<p>Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.</p>
<p>To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga7d20b2397c3eab2b52ec405863c6f274a04f47ef20926c0a10951eb3d6fa9af91">Ogre::RTShader::FFP_VS_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga06b7172046e21956b5eb485dbd7fc29aab325d310fd56d8564be69550b319ecc5">Ogre::RTShader::FFP_PS_TEXTURING</a>. It then queries each registered <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline.">Ogre::RTShader::SubRenderState</a> to attach its functions to these stages. Then it generates the entry function (e.g. <code>main()</code> for GLSL) by sequentially calling these functions.</p>
<p>You can think of stages as a way to group shader "effects" inside a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Ogre::Pass</a> - similarly to how a <a class="el" href="class_ogre_1_1_render_queue_group.html" title="A grouping level underneath RenderQueue which groups renderables to be issued at coarsely the same ti...">Ogre::RenderQueueGroup</a> groups <a class="el" href="class_ogre_1_1_renderable.html">renderables</a> for rendering.</p>
<p>Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">$global_parameters</a></div>
<div class="line"><span class="comment">// FUNCTION</span></div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">$input_parameters</a></div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">$output_parameters</a></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_struct" href="struct_ogre_1_1vector.html">main</a>() {</div>
<div class="line">    <a class="code hl_struct" href="struct_ogre_1_1vector.html">$local_parameters</a></div>
<div class="line">    <a class="code hl_struct" href="struct_ogre_1_1vector.html">$FFP_VS_TRANSFORM</a></div>
<div class="line">    (...)</div>
<div class="line">    <a class="code hl_struct" href="struct_ogre_1_1vector.html">$FFP_VS_TEXTURING</a></div>
<div class="line">}</div>
</div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_Transform()]</code>, <code>$FFP_VS_TEXTURING = [FFP_TransformTexCoord()]</code>, it generates</p>
<div class="fragment"><div class="line"><span class="comment">// PROGRAM DEPENDENCIES</span></div>
<div class="line"><span class="preprocessor">#include &lt;FFPLib_Transform.glsl&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FFPLib_Texturing.glsl&gt;</span></div>
<div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">uniform</a> mat4    <a class="code hl_struct" href="struct_ogre_1_1vector.html">worldviewproj_matrix</a>;</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">uniform</a> mat4    <a class="code hl_struct" href="struct_ogre_1_1vector.html">texture_matrix1</a>;</div>
<div class="line"><span class="comment">// FUNCTION</span></div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">in</a>  vec4    vertex;</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">in</a>  vec4    <a class="code hl_struct" href="struct_ogre_1_1vector.html">uv0</a>;</div>
<div class="line">out vec4    <a class="code hl_struct" href="struct_ogre_1_1vector.html">oTexcoord4_0</a>;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_struct" href="struct_ogre_1_1vector.html">main</a>() {</div>
<div class="line">    <a class="code hl_struct" href="struct_ogre_1_1vector.html">FFP_Transform</a>(<a class="code hl_struct" href="struct_ogre_1_1vector.html">worldviewproj_matrix</a>, vertex, <a class="code hl_struct" href="struct_ogre_1_1vector.html">gl_Position</a>);</div>
<div class="line">    <a class="code hl_struct" href="struct_ogre_1_1vector.html">FFP_TransformTexCoord</a>(<a class="code hl_struct" href="struct_ogre_1_1vector.html">texture_matrix1</a>, <a class="code hl_struct" href="struct_ogre_1_1vector.html">uv0</a>.xy, <a class="code hl_struct" href="struct_ogre_1_1vector.html">oTexcoord4_0</a>.xy);</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you can see the RTSS also resolved the required parameters and routed them into the correct functions. See <a class="el" href="rtss.html#creating-extensions">Creating custom shader extensions</a> for details about parameter resolution.</p>
<p>Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage. Let's say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.</p>
<p>The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.</p>
<h2><a class="anchor" id="core-feats"></a>
Core features of the system</h2>
<ul>
<li>Runtime shader generation synchronized with scene state. Each time scene settings change, a new set of shaders is generated.</li>
<li>Full Fixed Function Pipeline (FFP) emulation. This feature is most useful combined with render systems that don't provide any FFP functionality (OpenGL ES 2.0, D3D11 etc).</li>
<li>Shader language independent interface: the logic representation of the shader programs is completely independent from the target shader language. You can generate code for different shader languages from the same program.</li>
<li>Pluggable interface for different shader languages.</li>
<li>Pluggable interface for shader based functions in a seamless way. Each function will be automatically combined with the rest of the shader code.</li>
<li>Smart program caching: each shader program is created only once and may be used by multiple passes.</li>
<li>Automatic vertex shader output register compacting: no more compacting variables by hand. In case the amount of used vertex shader outputs exceeds the maximum allowed (12 to 32, depending on <a href="http://msdn.microsoft.com/en-us/library/bb172918%28v=VS.85%29.aspx">D3DPSHADERCAPS2_0.NumTemps</a>), a compacting algorithm packs the vertex shader outputs and adds unpack code in the fragment shader side.</li>
<li>Material script support, for both export and import.</li>
</ul>
<h2><a class="anchor" id="autotoc_md257"></a>
Controlling shader re-generation</h2>
<p>By default the RTSS synchronizes with the active SceneManager regarding the fog settings and the number of active lights. This can result in frame-drops when new lights are added, as all managed Materials are updated for the new light-count. On the other hand, the generated shaders might include too many lights for the targeted budget.</p>
<p>To get more fine-grained control, you can use:</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#acd05f1eaf224a41f89b4c94823b96877" title="Set the light count auto update state.">Ogre::RTShader::RenderState::setLightCountAutoUpdate</a> and</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#aafc13c2857e26c83732a6fe6e804cc32" title="Set the maximal light count to consider.">Ogre::RTShader::RenderState::setLightCount</a></li>
</ul>
<p>to set a fixed number of lights the materials should consider.</p>
<h1><a class="anchor" id="rtss_indepth"></a>
The RTSS in Depth</h1>
<p>When the user asks the system to generate shaders for a given technique he has to provide a name for the target technique scheme. The system then creates a new technique based on the source technique but with a different scheme name.</p>
<p>The idea behind this concept is to use <a class="el" href="namespace_ogre.html">Ogre</a>'s built-in mechanism of material schemes, so all the user has to do in order to use the new technique is to call <a class="el" href="class_ogre_1_1_viewport.html#a8e8577fd81c45b05de880106f364a281" title="Set the material scheme which the viewport should use.">Ogre::Viewport::setMaterialScheme</a>.</p>
<p>Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.</p>
<p>The following steps are executed in order to generate shaders for a given technique:</p>
<ul>
<li>For each pass in the technique the system builds a set of sub render states that describe the logic process of the rendering pipeline from the draw call submission until the final pixel color.</li>
<li>Each render state is translated into a set of logic shader programs (currently only pixel and vertex shader). The logic programs are then sent to specific shader language writers that produce source code for the respective shader language. The source code is used to create the GPU programs that are applied to the destination pass. Before rendering of an object that uses generated shaders the system allows each sub render state to update the GPU constants associated with it.</li>
</ul>
<h2><a class="anchor" id="rtss__components"></a>
Main components</h2>
<p>The following is a partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.</p>
<dl class="section user"><dt>ShaderGenerator</dt><dd>The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.</dd></dl>
<dl class="section user"><dt>RenderState classes</dt><dd>The RenderState is the core component of the system. It aggregates the stages that the final shader will be created from. These stages are referred to as SubRenderStates. It is possible to bypass the rest of the RTSS and use RenderStates directly to manually generate shaders for arbitrary passes. </dd></dl>
<dl class="section user"><dt></dt><dd>RenderStates exist on two levels:<ol type="1">
<li>SGScheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme.</li>
<li>SGPass <em>Target</em>RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. </li>
</ol>
</dd></dl>
<dl class="section user"><dt></dt><dd>When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.</dd></dl>
<dl class="section user"><dt>SubRenderState classes</dt><dd>Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities. </dd></dl>
<dl class="section user"><dt></dt><dd>By default, Ogre adds the following 5 SRSs to every scheme RenderState to recreate the functionality provided by the fixed pipeline<ol type="1">
<li><a class="el" href="group___r_t_shader.html#ga8cb98be9db81aa08483836d3cda49c31">Ogre::RTShader::SRS_TRANSFORM</a> -  Computes the position of the vertex in projection space, allows using instancing.  </li>
<li><a class="el" href="group___r_t_shader.html#gaaedbac186ba67be460c9ff2609104d89">Ogre::RTShader::SRS_VERTEX_COLOUR</a> - Calculate the base diffuse and specular color of the object regardless of lights or textures. The color is calculated based on the ambient, diffuse, specular and emissive properties of the object and scene and the specified color tracking.</li>
<li><a class="el" href="group___r_t_shader.html#gaeaa32a701498564aaf74ad6a03ee007f">Ogre::RTShader::SRS_PER_PIXEL_LIGHTING</a> -  Adds per-pixel lighting calulations (Phong Shading)  </li>
<li><a class="el" href="group___r_t_shader.html#gaf78d62646d139c60af9f8cd7daa8136c">Ogre::RTShader::SRS_TEXTURING</a> -  Computes FFP texture transform and blending based on the assigned textures.  </li>
<li><a class="el" href="group___r_t_shader.html#ga1198bbdd726ff91909afccbbb9538b9d">Ogre::RTShader::SRS_FOG</a> -  Modulates the color of a pixel based on the scene or object fog parameters.  </li>
</ol>
</dd></dl>
<dl class="section user"><dt>SubRenderStateFactory</dt><dd>As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS. </dd></dl>
<dl class="section user"><dt></dt><dd>These type of components are noteworthy for two reasons. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.</dd></dl>
<h2><a class="anchor" id="autotoc_md258"></a>
Initializing the system</h2>
<dl class="section note"><dt>Note</dt><dd>If you are using the <a class="el" href="group___bites.html#ga579bb62eef4503f5d9bc93c0fb613a6f">OgreBites::ApplicationContext</a>, the following steps will be taken automatically for you.</dd></dl>
<p>Initializing the system is composed of the following steps:</p><ul>
<li>Create the internal managers and structures via the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260" title="Initialize the Shader Generator System.">Ogre::RTShader::ShaderGenerator::initialize()</a> method.</li>
<li>Assign the target scene manager to the shader generator.</li>
<li>Listen for SchemeNotFound events via <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events.">Ogre::MaterialManager::Listener</a> and use the RTSS to handle them</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a>())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Register the scene manager.</span></div>
<div class="line">    <a class="code hl_function" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af9645f81b0a544158976392aed1be423">Ogre::RTShader::ShaderGenerator::getSingleton</a>().addSceneManager(<a class="code hl_struct" href="struct_ogre_1_1vector.html">sceneMgr</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// forward scheme not found events to the RTSS</span></div>
<div class="line">    <a class="code hl_class" href="class_ogre_bites_1_1_s_g_technique_resolver_listener.html">OgreBites::SGTechniqueResolverListener</a>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">schemeNotFoundHandler</a> = ...</div>
<div class="line">    <a class="code hl_function" href="class_ogre_1_1_material_manager.html#ae755a83a5d2d1dea391d8c1c74371e4f">Ogre::MaterialManager::getSingleton</a>().addListener(<a class="code hl_struct" href="struct_ogre_1_1vector.html">schemeNotFoundHandler</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_ogre_1_1_material_manager_html_ae755a83a5d2d1dea391d8c1c74371e4f"><div class="ttname"><a href="class_ogre_1_1_material_manager.html#ae755a83a5d2d1dea391d8c1c74371e4f">Ogre::MaterialManager::getSingleton</a></div><div class="ttdeci">static MaterialManager &amp; getSingleton(void)</div><div class="ttdoc">Get the singleton instance.</div></div>
<div class="ttc" id="aclass_ogre_1_1_r_t_shader_1_1_shader_generator_html_ad206fa320c81f6482dbe6898a2aec260"><div class="ttname"><a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a></div><div class="ttdeci">static bool initialize()</div><div class="ttdoc">Initialize the Shader Generator System.</div></div>
<div class="ttc" id="aclass_ogre_1_1_r_t_shader_1_1_shader_generator_html_af9645f81b0a544158976392aed1be423"><div class="ttname"><a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af9645f81b0a544158976392aed1be423">Ogre::RTShader::ShaderGenerator::getSingleton</a></div><div class="ttdeci">static ShaderGenerator &amp; getSingleton()</div><div class="ttdoc">Override standard Singleton retrieval.</div></div>
<div class="ttc" id="aclass_ogre_bites_1_1_s_g_technique_resolver_listener_html"><div class="ttname"><a href="class_ogre_bites_1_1_s_g_technique_resolver_listener.html">OgreBites::SGTechniqueResolverListener</a></div><div class="ttdoc">Default implementation of a Listener to use with the Ogre::RTShader system.</div><div class="ttdef"><b>Definition</b> OgreSGTechniqueResolverListener.h:46</div></div>
</div><!-- fragment --><h2><a class="anchor" id="rtss_custom_api"></a>
Customizing the default RenderState</h2>
<p>Let's say, you wanted to globally change the default per-pixel lighting mode of the RTSS back to the FFP style per-vertex lighting. For this you have to grab the global RenderState associated with the active material scheme, as</p>
<div class="fragment"><div class="line">        <span class="comment">// Grab the scheme render state.</span></div>
<div class="line">        <a class="code hl_class" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">schemRenderState</a> = mShaderGenerator-&gt;getRenderState(<a class="code hl_variable" href="group___materials.html#ga6c915cd9f3cc09a3edfb2c0ca7a27952">Ogre::MSN_SHADERGEN</a>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Add per vertex lighting sub render state to the global scheme render state.</span></div>
<div class="line">        <span class="comment">// It will override the default lighting sub render state.</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_struct" href="struct_ogre_1_1vector.html">useFFPLighting</a>) {</div>
<div class="line">            <span class="keyword">auto</span> <a class="code hl_struct" href="struct_ogre_1_1vector.html">perPixelLightModel</a> = mShaderGenerator-&gt;createSubRenderState(<a class="code hl_variable" href="group___r_t_shader.html#ga9df9782a53f184e3ec6a81926443afc4">Ogre::RTShader::SRS_PER_VERTEX_LIGHTING</a>);</div>
<div class="line"> </div>
<div class="line">            <a class="code hl_struct" href="struct_ogre_1_1vector.html">schemRenderState</a>-&gt;addTemplateSubRenderState(<a class="code hl_struct" href="struct_ogre_1_1vector.html">perPixelLightModel</a>);</div>
<div class="line">        }</div>
<div class="ttc" id="agroup___materials_html_ga6c915cd9f3cc09a3edfb2c0ca7a27952"><div class="ttname"><a href="group___materials.html#ga6c915cd9f3cc09a3edfb2c0ca7a27952">Ogre::MSN_SHADERGEN</a></div><div class="ttdeci">_OgreExport const String MSN_SHADERGEN</div><div class="ttdoc">Material scheme of the shader generator.</div></div>
<div class="ttc" id="agroup___r_t_shader_html_ga9df9782a53f184e3ec6a81926443afc4"><div class="ttname"><a href="group___r_t_shader.html#ga9df9782a53f184e3ec6a81926443afc4">Ogre::RTShader::SRS_PER_VERTEX_LIGHTING</a></div><div class="ttdeci">_OgreRTSSExport const String SRS_PER_VERTEX_LIGHTING</div><div class="ttdoc">Adds per-vertex (FFP) lighting calulations (Gouraud Shading)</div></div>
</div><!-- fragment --><p>Next, you have to create the FFPLighting SRS that should be used for shader generation and <em>add</em> to the set.</p>
<dl class="section note"><dt>Note</dt><dd>adding a SRS will automatically override the default SRS for the same stage. In the example we override the <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> stage.</dd></dl>
<h2><a class="anchor" id="rtssTech"></a>
Creating the shader based technique</h2>
<p>This step will create a new, shader-based, technique based on the given technique. Calling <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique.">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a> will cause the system to generate SubRenderStates based on the source technique and add a new technique using the given scheme name to the material. The passes of this new technique will receive shaders generated and updated by the system during as described in the <a class="el" href="rtss.html#rtssGenerate">Shader generation at runtime</a> section below.</p>
<div class="image">
<object type="image/svg+xml" data="CreateShaderBasedTech.svg" style="pointer-events: none;"></object>
</div>
    <p>To use the generated technique, change the material scheme of your viewport(s) to the scheme name you passed as argument to this method.</p>
<div class="fragment"><div class="line"><span class="comment">// Create shader based technique from the default technique of the given material.</span></div>
<div class="line">mShaderGenerator-&gt;createShaderBasedTechnique(<span class="stringliteral">&quot;Examples/BeachStones&quot;</span>, <a class="code hl_variable" href="group___materials.html#ga3b1bfc62cf049311f1452b86badeb566">Ogre::MSN_DEFAULT</a>, <a class="code hl_variable" href="group___materials.html#ga6c915cd9f3cc09a3edfb2c0ca7a27952">Ogre::MSN_SHADERGEN</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Apply the shader generated based techniques.</span></div>
<div class="line">mViewport-&gt;setMaterialScheme(<a class="code hl_variable" href="group___materials.html#ga6c915cd9f3cc09a3edfb2c0ca7a27952">Ogre::MSN_SHADERGEN</a>);</div>
<div class="ttc" id="agroup___materials_html_ga3b1bfc62cf049311f1452b86badeb566"><div class="ttname"><a href="group___materials.html#ga3b1bfc62cf049311f1452b86badeb566">Ogre::MSN_DEFAULT</a></div><div class="ttdeci">_OgreExport const String MSN_DEFAULT</div><div class="ttdoc">Default material scheme name.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events.">Ogre::MaterialManager::Listener</a></code> implementing <code>handleSchemeNotFound()</code> - e.g. <a class="el" href="class_ogre_bites_1_1_s_g_technique_resolver_listener.html" title="Default implementation of a Listener to use with the Ogre::RTShader system.">OgreBites::SGTechniqueResolverListener</a></dd></dl>
<h2><a class="anchor" id="rtssGenerate"></a>
Shader generation at runtime</h2>
<p>During the application runtime the <code>ShaderGenerator</code> instance receives notifications on a per frame basis from its target <code>SceneManager</code>. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The <code>SGScheme</code> validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques.</p><ol type="1">
<li>The first step is to loop over every <code>SGTechnique</code> associated with this <code>SGScheme</code> and build its <code>RenderStates</code> - one for each pass.</li>
<li>The second step is to loop again on every <code>SGTechnique</code> and acquire a program set for each <code>SGPass</code>.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The shaders are only automatically updated for lights and fog changes. If you change the source pass after initial shader creation, you must call <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a93b8687cb9654f03c7480b587723b39a" title="Invalidate specific material scheme.">Ogre::RTShader::ShaderGenerator::invalidateMaterial</a> manually.</dd></dl>
<p>The actual acquiring process is done by the <code>TargetRenderState</code> that generates CPU program representation, send them to a matching <code>ProgramWriter</code> that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the <code>SGScheme</code> has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.</p>
<div class="image">
<object type="image/svg+xml" data="RuntimeShaderGeneration.svg" style="pointer-events: none;"></object>
</div>
    <h2><a class="anchor" id="creating-extensions"></a>
Creating custom shader extensions</h2>
<p>Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.</p>
<p>In order to extend the system with your own shader effects you'll have to follow these steps:</p><ul>
<li>Implement the SubRenderState interface - This is the main class that is responsible for the actual effect processing such as preparing the destination pass, updating the CPU shader programs, updating the GPU shader parameters etc.</li>
<li>Implement the SubRenderStateFactory interface: This class will allow the RTSS to create instances of the previous class via code or script as well as export it to material script file.</li>
<li>Register the factory to the RTSS using the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9" title="Add sub render state factory.">Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory</a> method.</li>
<li>Add shader files that will supply all the actual shader functions your SubRenderState needs. In order to support multiple shader languages, <a class="el" href="_cross-platform-_shaders.html#OgreUnifiedShader">Cross-platform macros</a> are provided. These shaders should be placed in a resource location known to the resource manager.</li>
</ul>
<p>Implementing the SubRenderState requires overriding the pure methods of the base class.</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a33a6bfe77d6b958bd044fd81a7f50fc4" title="Get the type of this sub render state.">Ogre::RTShader::SubRenderState::getType()</a> should return a unique string that identifies the sub class implementation. That value is shared among all instances and can be stored in a static string variable. It is used by the system to match between the SubRenderState instance and the factory that should destroy it.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#acb48c34ee231f0220f68c967fb32f1e5" title="Get the execution order of this sub render state.">Ogre::RTShader::SubRenderState::getExecutionOrder()</a> should return integer value that will use the system to sort all SubRenderState instances of the same render state before each one of them will create its part in the CPU shader programs. Note that:<ul>
<li>The execution order does not imply the order of the parameter definitions and function calls within the generated shader.</li>
<li>If an execution number is set to be the same as one of the basic fixed pipeline SRSs, then that SRS will be built <b>instead</b> of the fixed pipeline SRS.</li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a5dfe9f03413e0fe99ea2640f06c1f13c" title="Copy details from a given sub render state to this one.">Ogre::RTShader::SubRenderState::copyFrom()</a> a simple copy method that uses the system when copying one instance to another. <b>Note:</b> Only configuration data attributes should be copied here.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4b43c261946926ebbc6456deccc6697a" title="Create sub programs that represents this sub render state as part of a program set.">Ogre::RTShader::SubRenderState::createCpuSubPrograms</a> - This is the heart of this interface. This method should update the CPU shader programs with the specific details of the overriding class.</li>
</ul>
<p>The SubRenderState supplies default implementation for this method which breaks down this method into three stages:</p>
<dl class="section user"><dt>Resolving parameters</dt><dd>this stage should grab all the needed parameters for this SubRenderState. Typically there are several SubRenderStates working on a common set of Parameters - either to cooperate or because they use the same inputs. Therefore parameters are not resolved by name (except for local variables), but rather by symbolic constants. These can either be of <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters,...">Ogre::GpuProgramParameters::AutoConstantType</a>, which should already be familiar to you or of <a class="el" href="class_ogre_1_1_r_t_shader_1_1_parameter.html#a4fa6286f097d19e92a8ed91645fbfbe7" title="Shader parameter content.">Ogre::RTShader::Parameter::Content</a>. </dd></dl>
<dl class="section user"><dt></dt><dd>You can think of the latter as an extension of the Cg/ HLSL Semantics to the actual content of the parameter. </dd></dl>
<dl class="section user"><dt></dt><dd>In case of the Ogre::RTShader::FFPTransform we need the world view projection matrix and vertex shader input and output position parameters. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">    <a class="code hl_class" href="class_ogre_1_1_r_t_shader_1_1_program.html">Program</a>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">vsProgram</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">programSet</a>-&gt;getCpuProgram(GPT_VERTEX_PROGRAM);</div>
<div class="line">    <a class="code hl_class" href="class_ogre_1_1_r_t_shader_1_1_function.html">Function</a>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">vsEntry</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">vsProgram</a>-&gt;getEntryPointFunction();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Resolve World View Projection Matrix.</span></div>
<div class="line">    <a class="code hl_typedef" href="namespace_ogre_1_1_r_t_shader.html#a492843278bb5c3f7c535cc2a516c436f">UniformParameterPtr</a> <a class="code hl_struct" href="struct_ogre_1_1vector.html">wvpMatrix</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">vsProgram</a>-&gt;resolveParameter(GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Resolve input position parameter.</span></div>
<div class="line">    <a class="code hl_typedef" href="namespace_ogre_1_1_r_t_shader.html#a0073f878d77367ce3ccea68a6a44a1e9">ParameterPtr</a> <a class="code hl_struct" href="struct_ogre_1_1vector.html">positionIn</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">vsEntry</a>-&gt;resolveInputParameter(Parameter::SPC_POSITION_OBJECT_SPACE);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Resolve output position parameter.</span></div>
<div class="line">    <a class="code hl_typedef" href="namespace_ogre_1_1_r_t_shader.html#a0073f878d77367ce3ccea68a6a44a1e9">ParameterPtr</a> <a class="code hl_struct" href="struct_ogre_1_1vector.html">positionOut</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">vsEntry</a>-&gt;resolveOutputParameter(Parameter::SPC_POSITION_PROJECTIVE_SPACE);</div>
<div class="ttc" id="aclass_ogre_1_1_r_t_shader_1_1_function_html"><div class="ttname"><a href="class_ogre_1_1_r_t_shader_1_1_function.html">Ogre::RTShader::Function</a></div><div class="ttdoc">A class that represents a shader based program function.</div><div class="ttdef"><b>Definition</b> OgreShaderFunction.h:116</div></div>
<div class="ttc" id="aclass_ogre_1_1_r_t_shader_1_1_program_html"><div class="ttname"><a href="class_ogre_1_1_r_t_shader_1_1_program.html">Ogre::RTShader::Program</a></div><div class="ttdoc">A class that represents a shader based program.</div><div class="ttdef"><b>Definition</b> OgreShaderProgram.h:49</div></div>
<div class="ttc" id="anamespace_ogre_1_1_r_t_shader_html_a0073f878d77367ce3ccea68a6a44a1e9"><div class="ttname"><a href="namespace_ogre_1_1_r_t_shader.html#a0073f878d77367ce3ccea68a6a44a1e9">Ogre::RTShader::ParameterPtr</a></div><div class="ttdeci">shared_ptr&lt; Parameter &gt; ParameterPtr</div><div class="ttdef"><b>Definition</b> OgreShaderPrerequisites.h:70</div></div>
<div class="ttc" id="anamespace_ogre_1_1_r_t_shader_html_a492843278bb5c3f7c535cc2a516c436f"><div class="ttname"><a href="namespace_ogre_1_1_r_t_shader.html#a492843278bb5c3f7c535cc2a516c436f">Ogre::RTShader::UniformParameterPtr</a></div><div class="ttdeci">shared_ptr&lt; UniformParameter &gt; UniformParameterPtr</div><div class="ttdef"><b>Definition</b> OgreShaderPrerequisites.h:71</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Resolving dependencies</dt><dd>this stage should provide the name of the external shader library files that contains the actual shader code needed by this SubRenderState. In case of the <a class="el" href="group___r_t_shader.html#gaf78d62646d139c60af9f8cd7daa8136c" title="Computes FFP texture transform and blending based on the assigned textures.">Ogre::RTShader::SRS_TEXTURING</a> it will add the common and texturing library for both vertex and pixel shader program. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">    <a class="code hl_class" href="class_ogre_1_1_r_t_shader_1_1_program.html">Program</a>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">vsProgram</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">programSet</a>-&gt;getCpuProgram(GPT_VERTEX_PROGRAM);</div>
<div class="line">    <a class="code hl_class" href="class_ogre_1_1_r_t_shader_1_1_program.html">Program</a>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">psProgram</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">programSet</a>-&gt;getCpuProgram(GPT_FRAGMENT_PROGRAM);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="struct_ogre_1_1vector.html">vsProgram</a>-&gt;addDependency(<a class="code hl_struct" href="struct_ogre_1_1vector.html">FFP_LIB_TEXTURING</a>);</div>
<div class="line">    <a class="code hl_struct" href="struct_ogre_1_1vector.html">psProgram</a>-&gt;addDependency(<a class="code hl_struct" href="struct_ogre_1_1vector.html">FFP_LIB_TEXTURING</a>);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Adding function invocations</dt><dd>this stage creates the function calls within this SubRenderState requires. To add function invocations, you first need to obtain a <a class="el" href="class_ogre_1_1_r_t_shader_1_1_function_stage_ref.html" title="represents a FFPShaderStage, part of a Function">Ogre::RTShader::FunctionStageRef</a> for the respective stage. In case of the <a class="el" href="group___r_t_shader.html#ga1198bbdd726ff91909afccbbb9538b9d" title="Modulates the color of a pixel based on the scene or object fog parameters.">Ogre::RTShader::SRS_FOG</a> it will add vertex depth calculation to the vertex shader program. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">        <span class="keyword">auto</span> <a class="code hl_struct" href="struct_ogre_1_1vector.html">vsFogStage</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">vsMain</a>-&gt;getStage(FFP_VS_FOG);</div>
<div class="line">        <a class="code hl_struct" href="struct_ogre_1_1vector.html">vsFogStage</a>.callFunction(<span class="stringliteral">&quot;FFP_FogFactor&quot;</span>, <a class="code hl_struct" href="struct_ogre_1_1_r_t_shader_1_1_in.html">In</a>(<a class="code hl_struct" href="struct_ogre_1_1vector.html">mVSOutPos</a>).w(), mFogParams, <a class="code hl_struct" href="struct_ogre_1_1vector.html">mVSOutFogFactor</a>);</div>
<div class="ttc" id="astruct_ogre_1_1_r_t_shader_1_1_in_html"><div class="ttname"><a href="struct_ogre_1_1_r_t_shader_1_1_in.html">Ogre::RTShader::In</a></div><div class="ttdef"><b>Definition</b> OgreShaderFunctionAtom.h:155</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>The arguments to the function are the ones you resolved in the first step and the function name must be available in one of the libraries you provided in the second step. You can add call as many functions as you need. The calls will appear in the same order in the generates shader source code. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The ordering of the function invocation is crucial. Use the <a class="el" href="group___r_t_shader.html#ga7d20b2397c3eab2b52ec405863c6f274">Ogre::RTShader::FFPVertexShaderStage</a> and <a class="el" href="group___r_t_shader.html#ga06b7172046e21956b5eb485dbd7fc29a">Ogre::RTShader::FFPFragmentShaderStage</a> enumerations to place your invocations in the desired global order.</li>
<li>Make sure the parameter semantic (in/out) in the SubRenderState code matches to your shader code implementation you supplied in the library file. GLSL will fail to link to library functions if it won't be able to find a perfect function declaration match.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4e7f1ead52ab9eda034441d0f3225af9" title="Update GPU programs parameters before a rendering operation occurs.">Ogre::RTShader::SubRenderState::updateGpuProgramsParams</a> - As the name suggest this method should be overridden only in case your SubRenderState should update some parameter it created before.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#afd08043cfad43a1ae470c3c1be341ba1" title="Called before adding this sub render state to the given render state.">Ogre::RTShader::SubRenderState::preAddToRenderState()</a>: this method called before adding this SubRenderState to a parent RenderState instances. It allows this SubRenderState to exclude itself from the list in case the source pass is not matching. I.E in case of SubRenderState that perform lighting calculations it can return false when the given source pass specifies that lighting calculations disabled for it. <div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!<a class="code hl_struct" href="struct_ogre_1_1vector.html">srcPass</a>-&gt;getLightingEnabled())</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
</div><!-- fragment --> This method also let the SubRenderState to opportunity to modify the destination pass. I.E the Ogre::RTShader::NormalMapLighting instance adds the normal map texture unit in this context.</li>
</ul>
</dd></dl>
<p>Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances.">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods</p><ul>
<li>Ogre::RTShader::SubRenderStateFactory::createInstanceImpl(): This method should return instance for the SubRenderState sub class.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#adbc886fee2e4369520aaed1ce7592e62" title="Create an instance of the SubRenderState sub class it suppose to create.">Ogre::RTShader::SubRenderStateFactory::createInstance()</a>: This method should return instance for the SubRenderState sub class using the given script compiler parameters. Implement this method if you want to be able to create your custom shader extension from material script.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#ada31909080bae96784504be42d9bd77c" title="Write the given sub-render state instance using the material serializer.">Ogre::RTShader::SubRenderStateFactory::writeInstance()</a>: This method should write down the parameters of a given SubRenderState instance to material script file. Implement this method if you want to be able to export a material that contains your custom shader extension.</li>
</ul>
<h2><a class="anchor" id="debugging"></a>
Tips for debugging shaders</h2>
<p>A couple of notes on debugging shaders coming from the RTSS:</p><ul>
<li>Call <a class="el" href="class_ogre_bites_1_1_application_context_base.html#ace75364125a967496ab315f012e7acdf" title="make the RTSS write out the generated shaders for caching and debugging">OgreBites::ApplicationContext::setRTSSWriteShadersToDisk</a>. This will cache the generated shaders onto the disk under the directory <a class="el" href="class_ogre_1_1_file_system_layer.html#a0e606f77e2deb5961b8001cbdfe35e22">WRITABLE_PATH</a><code>/RTShaderLib/cache</code>. This is important for two reasons:<ul>
<li>It will make compilation problems easier to detect.</li>
<li>Once a shader is written to the disk, as long as you don't change the code behind it, the same shader will be picked up in the next application run even if its content has changed. If you have compilation or visual problems with the shader you can try to manually tinker with it without compiling the code again and again.</li>
</ul>
</li>
<li>Other common problems with creating shaders in RTSS usually occur from defining vertex shader parameters and using them in the pixel shader and vice versa. So watch out for those. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
