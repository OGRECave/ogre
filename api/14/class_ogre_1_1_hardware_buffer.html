<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::HardwareBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_hardware_buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_hardware_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::HardwareBuffer Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___render_system.html">RenderSystem</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Abstract class defining common features of hardware buffers.  
 <a href="class_ogre_1_1_hardware_buffer.html#details">More...</a></p>

<p><code>#include &lt;OgreHardwareBuffer.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::HardwareBuffer:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_hardware_buffer__inherit__graph.svg" width="578" height="184"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afa30cb566683a34a7c0e8aaf772553d5" id="r_afa30cb566683a34a7c0e8aaf772553d5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5">LockOptions</a> : uint8 { <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5ae11601d29cd56aad7ea7a1b23a688b0e">HBL_NORMAL</a>
, <a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5a176ad39ac15fc0a6028d820a6fe228ae">HBL_DISCARD</a>
, <a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5aa364c1511514cd4d7ee1e7092eb41288">HBL_READ_ONLY</a>
, <a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5a32a2f7b1c3430cc9c3f0f665934d0c4a">HBL_NO_OVERWRITE</a>
, <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5af4acad29e302c7c02ce72c3fce8990df">HBL_WRITE_ONLY</a>
<br />
 }</td></tr>
<tr class="memdesc:afa30cb566683a34a7c0e8aaf772553d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locking options.  <a href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5">More...</a><br /></td></tr>
<tr class="separator:afa30cb566683a34a7c0e8aaf772553d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c7a563d8a33c8ef21fb70913412a17" id="r_a81c7a563d8a33c8ef21fb70913412a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">typedef</a> <a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a81c7a563d8a33c8ef21fb70913412a17">Usage</a></td></tr>
<tr class="separator:a81c7a563d8a33c8ef21fb70913412a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa837426d9671cb04316c13aaf56a5dd0" id="r_aa837426d9671cb04316c13aaf56a5dd0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#aa837426d9671cb04316c13aaf56a5dd0">UsageEnum</a> { <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_hardware_buffer.html#aa837426d9671cb04316c13aaf56a5dd0a6f26f67ab31d60248314c9c6c77c9edb">HBU_STATIC</a> = HBU_GPU_TO_CPU
, <a class="el" href="class_ogre_1_1_hardware_buffer.html#aa837426d9671cb04316c13aaf56a5dd0abec61c14b13652a06566a79afd6f7518">HBU_DYNAMIC</a> = HBU_CPU_ONLY
, <a class="el" href="class_ogre_1_1_hardware_buffer.html#aa837426d9671cb04316c13aaf56a5dd0a2fe20ff00e9acb928a2d9680f0c505e2">HBU_WRITE_ONLY</a> = HBU_DETAIL_WRITE_ONLY
, <a class="el" href="class_ogre_1_1_hardware_buffer.html#aa837426d9671cb04316c13aaf56a5dd0a246699879ba7647973a2d8ed86acf76f">HBU_DISCARDABLE</a> = 8
, <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_hardware_buffer.html#aa837426d9671cb04316c13aaf56a5dd0a5ffbb339becd31435c5f616be4c28996">HBU_STATIC_WRITE_ONLY</a> = HBU_GPU_ONLY
, <a class="el" href="class_ogre_1_1_hardware_buffer.html#aa837426d9671cb04316c13aaf56a5dd0aa0c82d1b27d6cc04e4b5f6d47a22a74c">HBU_DYNAMIC_WRITE_ONLY</a> = HBU_CPU_TO_GPU
, <a class="el" href="class_ogre_1_1_hardware_buffer.html#aa837426d9671cb04316c13aaf56a5dd0a29ff2e0fd2b408359e84291b27282516">HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE</a> = HBU_CPU_TO_GPU
<br />
 }</td></tr>
<tr class="memdesc:aa837426d9671cb04316c13aaf56a5dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rather use HardwareBufferUsage.  <a href="class_ogre_1_1_hardware_buffer.html#aa837426d9671cb04316c13aaf56a5dd0">More...</a><br /></td></tr>
<tr class="separator:aa837426d9671cb04316c13aaf56a5dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1439ad5022b4900f080a58fced500fa9" id="r_a1439ad5022b4900f080a58fced500fa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a1439ad5022b4900f080a58fced500fa9">HardwareBuffer</a> (<a class="el" href="class_ogre_1_1_hardware_buffer.html#a81c7a563d8a33c8ef21fb70913412a17">Usage</a> <a class="el" href="struct_ogre_1_1vector.html">usage</a>, <a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">useShadowBuffer</a>)</td></tr>
<tr class="memdesc:a1439ad5022b4900f080a58fced500fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, to be called by <a class="el" href="class_ogre_1_1_hardware_buffer_manager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> only.  <br /></td></tr>
<tr class="separator:a1439ad5022b4900f080a58fced500fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2514db557f1562eef2b7a70a1b2d8344" id="r_a2514db557f1562eef2b7a70a1b2d8344"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a2514db557f1562eef2b7a70a1b2d8344">~HardwareBuffer</a> ()</td></tr>
<tr class="separator:a2514db557f1562eef2b7a70a1b2d8344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5600a434a495ecf70b7da38ee7f168" id="r_a0f5600a434a495ecf70b7da38ee7f168"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="struct_ogre_1_1vector.html">typename</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </td></tr>
<tr class="memitem:a0f5600a434a495ecf70b7da38ee7f168"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">T</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a0f5600a434a495ecf70b7da38ee7f168">_getImpl</a> ()</td></tr>
<tr class="separator:a0f5600a434a495ecf70b7da38ee7f168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344c52f2214eaff097d5fbc390e7684b" id="r_a344c52f2214eaff097d5fbc390e7684b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a344c52f2214eaff097d5fbc390e7684b">_updateFromShadow</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>)</td></tr>
<tr class="memdesc:a344c52f2214eaff097d5fbc390e7684b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the real buffer from the shadow buffer, if required.  <br /></td></tr>
<tr class="separator:a344c52f2214eaff097d5fbc390e7684b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4b4f798a789499fc152765d81abca5" id="r_a0a4b4f798a789499fc152765d81abca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a0a4b4f798a789499fc152765d81abca5">copyData</a> (<a class="el" href="class_ogre_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">srcBuffer</a>)</td></tr>
<tr class="memdesc:a0a4b4f798a789499fc152765d81abca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all data from another buffer into this one.  <br /></td></tr>
<tr class="separator:a0a4b4f798a789499fc152765d81abca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721891f0c0bd391dd5848c8a585ba054" id="r_a721891f0c0bd391dd5848c8a585ba054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a721891f0c0bd391dd5848c8a585ba054">copyData</a> (<a class="el" href="class_ogre_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">srcBuffer</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">srcOffset</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">dstOffset</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> length, <a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">discardWholeBuffer</a>=<a class="el" href="struct_ogre_1_1vector.html">false</a>)</td></tr>
<tr class="memdesc:a721891f0c0bd391dd5848c8a585ba054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from another buffer into this one.  <br /></td></tr>
<tr class="separator:a721891f0c0bd391dd5848c8a585ba054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9194c7e8b536f4825b15b9e6a6912ce8" id="r_a9194c7e8b536f4825b15b9e6a6912ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a9194c7e8b536f4825b15b9e6a6912ce8">getSizeInBytes</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a9194c7e8b536f4825b15b9e6a6912ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of this buffer in bytes.  <br /></td></tr>
<tr class="separator:a9194c7e8b536f4825b15b9e6a6912ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5ee6468dcb269e422e213b82726e4f" id="r_a9c5ee6468dcb269e422e213b82726e4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a81c7a563d8a33c8ef21fb70913412a17">Usage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a9c5ee6468dcb269e422e213b82726e4f">getUsage</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a9c5ee6468dcb269e422e213b82726e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Usage flags with which this buffer was created.  <br /></td></tr>
<tr class="separator:a9c5ee6468dcb269e422e213b82726e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a623d95552d9b1858e5c300a3ad68c" id="r_a40a623d95552d9b1858e5c300a3ad68c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a40a623d95552d9b1858e5c300a3ad68c">hasShadowBuffer</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a40a623d95552d9b1858e5c300a3ad68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this buffer has a system memory shadow for quicker reading.  <br /></td></tr>
<tr class="separator:a40a623d95552d9b1858e5c300a3ad68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c874c6b30c39aa38ae0d6abe2ba42bc" id="r_a7c874c6b30c39aa38ae0d6abe2ba42bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a7c874c6b30c39aa38ae0d6abe2ba42bc">isLocked</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a7c874c6b30c39aa38ae0d6abe2ba42bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this buffer is currently locked.  <br /></td></tr>
<tr class="separator:a7c874c6b30c39aa38ae0d6abe2ba42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e76b8af153f633e9ad691d6fb4a95c4" id="r_a2e76b8af153f633e9ad691d6fb4a95c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a2e76b8af153f633e9ad691d6fb4a95c4">isSystemMemory</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a2e76b8af153f633e9ad691d6fb4a95c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this buffer is held in system memory.  <br /></td></tr>
<tr class="separator:a2e76b8af153f633e9ad691d6fb4a95c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada444f1fc1972be69a29c473fdf23068" id="r_ada444f1fc1972be69a29c473fdf23068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#ada444f1fc1972be69a29c473fdf23068">lock</a> (<a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5">LockOptions</a> <a class="el" href="struct_ogre_1_1vector.html">options</a>)</td></tr>
<tr class="memdesc:ada444f1fc1972be69a29c473fdf23068"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ada444f1fc1972be69a29c473fdf23068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a01b547a3b0bd705230759a246a2a43" id="r_a7a01b547a3b0bd705230759a246a2a43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a7a01b547a3b0bd705230759a246a2a43">lock</a> (<a class="el" href="struct_ogre_1_1vector.html">size_t</a> offset, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> length, <a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5">LockOptions</a> <a class="el" href="struct_ogre_1_1vector.html">options</a>)</td></tr>
<tr class="memdesc:a7a01b547a3b0bd705230759a246a2a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the buffer for (potentially) reading / writing.  <br /></td></tr>
<tr class="separator:a7a01b547a3b0bd705230759a246a2a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163b6256d4e4006eefbf787e697256a8" id="r_a163b6256d4e4006eefbf787e697256a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a163b6256d4e4006eefbf787e697256a8">readData</a> (<a class="el" href="struct_ogre_1_1vector.html">size_t</a> offset, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> length, <a class="el" href="struct_ogre_1_1vector.html">void</a> *<a class="el" href="struct_ogre_1_1vector.html">pDest</a>)</td></tr>
<tr class="memdesc:a163b6256d4e4006eefbf787e697256a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the buffer and places it in the memory pointed to by pDest.  <br /></td></tr>
<tr class="separator:a163b6256d4e4006eefbf787e697256a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688e1be4a913099ce5e06172771e2d45" id="r_a688e1be4a913099ce5e06172771e2d45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a688e1be4a913099ce5e06172771e2d45">suppressHardwareUpdate</a> (<a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">suppress</a>)</td></tr>
<tr class="memdesc:a688e1be4a913099ce5e06172771e2d45"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> true to suppress hardware upload of shadow buffer changes.  <br /></td></tr>
<tr class="separator:a688e1be4a913099ce5e06172771e2d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ceba7c5cf1aa873f2bd26f2d718dba" id="r_a60ceba7c5cf1aa873f2bd26f2d718dba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a60ceba7c5cf1aa873f2bd26f2d718dba">unlock</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>)</td></tr>
<tr class="memdesc:a60ceba7c5cf1aa873f2bd26f2d718dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on this buffer.  <br /></td></tr>
<tr class="separator:a60ceba7c5cf1aa873f2bd26f2d718dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad310f05bf1a2d5cff6250ba13160c645" id="r_ad310f05bf1a2d5cff6250ba13160c645"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer.html#ad310f05bf1a2d5cff6250ba13160c645">writeData</a> (<a class="el" href="struct_ogre_1_1vector.html">size_t</a> offset, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> length, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> *<a class="el" href="struct_ogre_1_1vector.html">pSource</a>, <a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">discardWholeBuffer</a>=<a class="el" href="struct_ogre_1_1vector.html">false</a>)</td></tr>
<tr class="memdesc:ad310f05bf1a2d5cff6250ba13160c645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the buffer from an area of system memory; note that you must ensure that your buffer is big enough.  <br /></td></tr>
<tr class="separator:ad310f05bf1a2d5cff6250ba13160c645"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract class defining common features of hardware buffers. </p>
<p>A 'hardware buffer' is any area of memory held outside of core system ram, and in our case refers mostly to video ram, although in theory this class could be used with other memory areas such as sound card memory, custom coprocessor memory etc. </p><dl class="section user"><dt></dt><dd>This reflects the fact that memory held outside of main system RAM must be interacted with in a more formal fashion in order to promote cooperative and optimal usage of the buffers between the various processing units which manipulate them. </dd></dl>
<dl class="section user"><dt></dt><dd>This abstract class defines the core interface which is common to all buffers, whether it be vertex buffers, index buffers, texture memory or framebuffer memory etc. </dd></dl>
<dl class="section user"><dt></dt><dd>Buffers have the ability to be 'shadowed' in system memory, this is because the kinds of access allowed on hardware buffers is not always as flexible as that allowed for areas of system memory - for example it is often either impossible, or extremely undesirable from a performance standpoint to read from a hardware buffer; when writing to hardware buffers, you should also write every byte and do it sequentially. In situations where this is too restrictive, it is possible to create a hardware, write-only buffer (the most efficient kind) and to back it with a system memory 'shadow' copy which can be read and updated arbitrarily. <a class="el" href="namespace_ogre.html">Ogre</a> handles synchronising this buffer with the real hardware buffer (which should still be created with the HBU_DYNAMIC flag if you intend to update it very frequently). Whilst this approach does have its own costs, such as increased memory overhead, these costs can often be outweighed by the performance benefits of using a more hardware efficient buffer. You should look for the 'useShadowBuffer' parameter on the creation methods used to create the buffer of the type you require (see <a class="el" href="class_ogre_1_1_hardware_buffer_manager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a>) to enable this feature. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a81c7a563d8a33c8ef21fb70913412a17" name="a81c7a563d8a33c8ef21fb70913412a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c7a563d8a33c8ef21fb70913412a17">&#9670;&#160;</a></span>Usage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">typedef</a> <a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a> <a class="el" href="class_ogre_1_1_hardware_buffer.html#a81c7a563d8a33c8ef21fb70913412a17">Ogre::HardwareBuffer::Usage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa837426d9671cb04316c13aaf56a5dd0" name="aa837426d9671cb04316c13aaf56a5dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa837426d9671cb04316c13aaf56a5dd0">&#9670;&#160;</a></span>UsageEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">enum</a> <a class="el" href="class_ogre_1_1_hardware_buffer.html#aa837426d9671cb04316c13aaf56a5dd0">Ogre::HardwareBuffer::UsageEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rather use HardwareBufferUsage. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa837426d9671cb04316c13aaf56a5dd0a6f26f67ab31d60248314c9c6c77c9edb" name="aa837426d9671cb04316c13aaf56a5dd0a6f26f67ab31d60248314c9c6c77c9edb"></a>HBU_STATIC&#160;</td><td class="fielddoc"><p>same as <a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532a7b557a1b8b48aaa825e2301f14924e6d" title="Memory mappable on host and cached.">HBU_GPU_TO_CPU</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="aa837426d9671cb04316c13aaf56a5dd0abec61c14b13652a06566a79afd6f7518" name="aa837426d9671cb04316c13aaf56a5dd0abec61c14b13652a06566a79afd6f7518"></a>HBU_DYNAMIC&#160;</td><td class="fielddoc"><p>same as <a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532a5639696a2f8d640b328d22decbe637ac" title="CPU (system) memory This is the least optimal buffer setting.">HBU_CPU_ONLY</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="aa837426d9671cb04316c13aaf56a5dd0a2fe20ff00e9acb928a2d9680f0c505e2" name="aa837426d9671cb04316c13aaf56a5dd0a2fe20ff00e9acb928a2d9680f0c505e2"></a>HBU_WRITE_ONLY&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000060">Deprecated:</a></b></dt><dd>use <a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532a3130140031e3c7b4932ae4ae0faa519c" title="Indicates the application will never read the contents of the buffer back, it will only ever write da...">HBU_DETAIL_WRITE_ONLY</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="aa837426d9671cb04316c13aaf56a5dd0a246699879ba7647973a2d8ed86acf76f" name="aa837426d9671cb04316c13aaf56a5dd0a246699879ba7647973a2d8ed86acf76f"></a>HBU_DISCARDABLE&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000061">Deprecated:</a></b></dt><dd>do not use </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="aa837426d9671cb04316c13aaf56a5dd0a5ffbb339becd31435c5f616be4c28996" name="aa837426d9671cb04316c13aaf56a5dd0a5ffbb339becd31435c5f616be4c28996"></a>HBU_STATIC_WRITE_ONLY&#160;</td><td class="fielddoc"><p>same as <a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532ad4ea5a32caed7bbb643f6536606dba64" title="Device-local GPU (video) memory.">HBU_GPU_ONLY</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="aa837426d9671cb04316c13aaf56a5dd0aa0c82d1b27d6cc04e4b5f6d47a22a74c" name="aa837426d9671cb04316c13aaf56a5dd0aa0c82d1b27d6cc04e4b5f6d47a22a74c"></a>HBU_DYNAMIC_WRITE_ONLY&#160;</td><td class="fielddoc"><p>same as <a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532acbb4350fbecafb42887765883469fe6f" title="Mappable on host and preferably fast to access by GPU.">HBU_CPU_TO_GPU</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="aa837426d9671cb04316c13aaf56a5dd0a29ff2e0fd2b408359e84291b27282516" name="aa837426d9671cb04316c13aaf56a5dd0a29ff2e0fd2b408359e84291b27282516"></a>HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000062">Deprecated:</a></b></dt><dd>do not use </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="afa30cb566683a34a7c0e8aaf772553d5" name="afa30cb566683a34a7c0e8aaf772553d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa30cb566683a34a7c0e8aaf772553d5">&#9670;&#160;</a></span>LockOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">enum</a> <a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5">Ogre::HardwareBuffer::LockOptions</a> : <a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locking options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afa30cb566683a34a7c0e8aaf772553d5ae11601d29cd56aad7ea7a1b23a688b0e" name="afa30cb566683a34a7c0e8aaf772553d5ae11601d29cd56aad7ea7a1b23a688b0e"></a>HBL_NORMAL&#160;</td><td class="fielddoc"><p>Normal mode, ie allows read/write and contents are preserved. </p>
<p>This kind of lock allows reading and writing from the buffer - it’s also the least optimal because basically you’re telling the card you could be doing anything at all. If you’re not using a shadow buffer, it requires the buffer to be transferred from the card and back again. If you’re using a shadow buffer the effect is minimal. </p>
</td></tr>
<tr><td class="fieldname"><a id="afa30cb566683a34a7c0e8aaf772553d5a176ad39ac15fc0a6028d820a6fe228ae" name="afa30cb566683a34a7c0e8aaf772553d5a176ad39ac15fc0a6028d820a6fe228ae"></a>HBL_DISCARD&#160;</td><td class="fielddoc"><p>Discards the <em>entire</em> buffer while locking. </p>
<p>This means you are happy for the card to discard the entire current contents of the buffer. Implicitly this means you are not going to read the data - it also means that the card can avoid any stalls if the buffer is currently being rendered from, because it will actually give you an entirely different one. Use this wherever possible when you are locking a buffer which was not created with a shadow buffer. If you are using a shadow buffer it matters less, although with a shadow buffer it’s preferable to lock the entire buffer at once, because that allows the shadow buffer to use HBL_DISCARD when it uploads the updated contents to the real buffer. </p><dl class="section note"><dt>Note</dt><dd>Only useful on buffers created with the HBU_CPU_TO_GPU flag. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="afa30cb566683a34a7c0e8aaf772553d5aa364c1511514cd4d7ee1e7092eb41288" name="afa30cb566683a34a7c0e8aaf772553d5aa364c1511514cd4d7ee1e7092eb41288"></a>HBL_READ_ONLY&#160;</td><td class="fielddoc"><p>Lock the buffer for reading only. </p>
<p>Not allowed in buffers which are created with HBU_GPU_ONLY. Mandatory on static buffers, i.e. those created without the HBU_DYNAMIC flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="afa30cb566683a34a7c0e8aaf772553d5a32a2f7b1c3430cc9c3f0f665934d0c4a" name="afa30cb566683a34a7c0e8aaf772553d5a32a2f7b1c3430cc9c3f0f665934d0c4a"></a>HBL_NO_OVERWRITE&#160;</td><td class="fielddoc"><p>As HBL_WRITE_ONLY, except the application guarantees not to overwrite any region of the buffer which has already been used in this frame, can allow some optimisation on some APIs. </p>
<dl class="section note"><dt>Note</dt><dd>Only useful on buffers with no shadow buffer. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="afa30cb566683a34a7c0e8aaf772553d5af4acad29e302c7c02ce72c3fce8990df" name="afa30cb566683a34a7c0e8aaf772553d5af4acad29e302c7c02ce72c3fce8990df"></a>HBL_WRITE_ONLY&#160;</td><td class="fielddoc"><p>Lock the buffer for writing only. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1439ad5022b4900f080a58fced500fa9" name="a1439ad5022b4900f080a58fced500fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1439ad5022b4900f080a58fced500fa9">&#9670;&#160;</a></span>HardwareBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::HardwareBuffer::HardwareBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a81c7a563d8a33c8ef21fb70913412a17">Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor, to be called by <a class="el" href="class_ogre_1_1_hardware_buffer_manager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> only. </p>

<p class="reference">References <a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532a5639696a2f8d640b328d22decbe637ac">Ogre::HBU_CPU_ONLY</a>, <a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532acbb4350fbecafb42887765883469fe6f">Ogre::HBU_CPU_TO_GPU</a>, <a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532ad4ea5a32caed7bbb643f6536606dba64">Ogre::HBU_GPU_ONLY</a>, and <a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532a7b557a1b8b48aaa825e2301f14924e6d">Ogre::HBU_GPU_TO_CPU</a>.</p>

</div>
</div>
<a id="a2514db557f1562eef2b7a70a1b2d8344" name="a2514db557f1562eef2b7a70a1b2d8344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2514db557f1562eef2b7a70a1b2d8344">&#9670;&#160;</a></span>~HardwareBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> Ogre::HardwareBuffer::~HardwareBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7a01b547a3b0bd705230759a246a2a43" name="a7a01b547a3b0bd705230759a246a2a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a01b547a3b0bd705230759a246a2a43">&#9670;&#160;</a></span>lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> * Ogre::HardwareBuffer::lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5">LockOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the buffer for (potentially) reading / writing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The byte offset from the start of the buffer to lock </td></tr>
    <tr><td class="paramname">length</td><td>The size of the area to lock, in bytes </td></tr>
    <tr><td class="paramname">options</td><td>Locking options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the locked memory </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hardware_pixel_buffer.html#a7a01b547a3b0bd705230759a246a2a43">Ogre::HardwarePixelBuffer</a>, and <a class="el" href="class_ogre_1_1_hardware_pixel_buffer.html#a9f218c28ad14c2b9106c440c64ac8d62">Ogre::HardwarePixelBuffer</a>.</p>

<p class="reference">References <a class="el" href="_ogre_exception_8h.html#ab64188d2d6f4a02714a8f02e23a491d2">OgreAssert</a>.</p>

<p class="reference">Referenced by <a class="el" href="struct_ogre_1_1_hardware_buffer_lock_guard.html#a7635f390d29e3cfbd690c06e59b8c063">Ogre::HardwareBufferLockGuard::lock()</a>, and <a class="el" href="struct_ogre_1_1_hardware_buffer_lock_guard.html#a175906e7402f06dd4f5cfe1713ee3009">Ogre::HardwareBufferLockGuard::lock()</a>.</p>

</div>
</div>
<a id="ada444f1fc1972be69a29c473fdf23068" name="ada444f1fc1972be69a29c473fdf23068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada444f1fc1972be69a29c473fdf23068">&#9670;&#160;</a></span>lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> * Ogre::HardwareBuffer::lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5">LockOptions</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a60ceba7c5cf1aa873f2bd26f2d718dba" name="a60ceba7c5cf1aa873f2bd26f2d718dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ceba7c5cf1aa873f2bd26f2d718dba">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBuffer::unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock on this buffer. </p>
<p>Locking and unlocking a buffer can, in some rare circumstances such as switching video modes whilst the buffer is locked, corrupt the contents of a buffer. This is pretty rare, but if it occurs, this method will throw an exception, meaning you must re-upload the data. </p><dl class="section user"><dt></dt><dd>Note that using the 'read' and 'write' forms of updating the buffer does not suffer from this problem, so if you want to be 100% sure your data will not be lost, use the 'read' and 'write' forms instead. </dd></dl>

<p class="reference">References <a class="el" href="_ogre_exception_8h.html#ab64188d2d6f4a02714a8f02e23a491d2">OgreAssert</a>.</p>

<p class="reference">Referenced by <a class="el" href="struct_ogre_1_1_hardware_buffer_lock_guard.html#ac91557604cdd46df51157fbeabb750ef">Ogre::HardwareBufferLockGuard::unlock()</a>.</p>

</div>
</div>
<a id="a163b6256d4e4006eefbf787e697256a8" name="a163b6256d4e4006eefbf787e697256a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163b6256d4e4006eefbf787e697256a8">&#9670;&#160;</a></span>readData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBuffer::readData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a> *&#160;</td>
          <td class="paramname"><em>pDest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from the buffer and places it in the memory pointed to by pDest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The byte offset from the start of the buffer to read </td></tr>
    <tr><td class="paramname">length</td><td>The size of the area to read, in bytes </td></tr>
    <tr><td class="paramname">pDest</td><td>The area of memory in which to place the data, must be large enough to accommodate the data! </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_default_hardware_buffer.html#a3b7d53524bb4efc2aa1b9ebf608dcea2">Ogre::DefaultHardwareBuffer</a>, and <a class="el" href="class_ogre_1_1_hardware_pixel_buffer.html#ac22574a29056d258f3d4e5accb020da5">Ogre::HardwarePixelBuffer</a>.</p>

</div>
</div>
<a id="ad310f05bf1a2d5cff6250ba13160c645" name="ad310f05bf1a2d5cff6250ba13160c645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad310f05bf1a2d5cff6250ba13160c645">&#9670;&#160;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBuffer::writeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>discardWholeBuffer</em> = <code><a class="el" href="struct_ogre_1_1vector.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to the buffer from an area of system memory; note that you must ensure that your buffer is big enough. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The byte offset from the start of the buffer to start writing </td></tr>
    <tr><td class="paramname">length</td><td>The size of the data to write to, in bytes </td></tr>
    <tr><td class="paramname">pSource</td><td>The source of the data to be written </td></tr>
    <tr><td class="paramname">discardWholeBuffer</td><td>If true, this allows the driver to discard the entire buffer when writing, such that DMA stalls can be avoided; use if you can. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_default_hardware_buffer.html#a050c9b25ac465441a52837bb75ebc60f">Ogre::DefaultHardwareBuffer</a>, and <a class="el" href="class_ogre_1_1_hardware_pixel_buffer.html#a204679259d3aa0159e12e8efaff9e3a2">Ogre::HardwarePixelBuffer</a>.</p>

</div>
</div>
<a id="a721891f0c0bd391dd5848c8a585ba054" name="a721891f0c0bd391dd5848c8a585ba054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721891f0c0bd391dd5848c8a585ba054">&#9670;&#160;</a></span>copyData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBuffer::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>srcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>dstOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>discardWholeBuffer</em> = <code><a class="el" href="struct_ogre_1_1vector.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from another buffer into this one. </p>
<p>Note that the source buffer must not be created with the usage HBU_WRITE_ONLY otherwise this will fail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuffer</td><td>The buffer from which to read the copied data </td></tr>
    <tr><td class="paramname">srcOffset</td><td>Offset in the source buffer at which to start reading </td></tr>
    <tr><td class="paramname">dstOffset</td><td>Offset in the destination buffer to start writing </td></tr>
    <tr><td class="paramname">length</td><td>Length of the data to copy, in bytes. </td></tr>
    <tr><td class="paramname">discardWholeBuffer</td><td>If true, will discard the entire contents of this buffer before copying </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a4b4f798a789499fc152765d81abca5" name="a0a4b4f798a789499fc152765d81abca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4b4f798a789499fc152765d81abca5">&#9670;&#160;</a></span>copyData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBuffer::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all data from another buffer into this one. </p>
<p>Normally these buffers should be of identical size, but if they're not, the routine will use the smallest of the two sizes. </p>

</div>
</div>
<a id="a344c52f2214eaff097d5fbc390e7684b" name="a344c52f2214eaff097d5fbc390e7684b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344c52f2214eaff097d5fbc390e7684b">&#9670;&#160;</a></span>_updateFromShadow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBuffer::_updateFromShadow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the real buffer from the shadow buffer, if required. </p>

</div>
</div>
<a id="a9194c7e8b536f4825b15b9e6a6912ce8" name="a9194c7e8b536f4825b15b9e6a6912ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9194c7e8b536f4825b15b9e6a6912ce8">&#9670;&#160;</a></span>getSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">size_t</a> Ogre::HardwareBuffer::getSizeInBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of this buffer in bytes. </p>

</div>
</div>
<a id="a9c5ee6468dcb269e422e213b82726e4f" name="a9c5ee6468dcb269e422e213b82726e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5ee6468dcb269e422e213b82726e4f">&#9670;&#160;</a></span>getUsage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a81c7a563d8a33c8ef21fb70913412a17">Usage</a> Ogre::HardwareBuffer::getUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Usage flags with which this buffer was created. </p>

</div>
</div>
<a id="a2e76b8af153f633e9ad691d6fb4a95c4" name="a2e76b8af153f633e9ad691d6fb4a95c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e76b8af153f633e9ad691d6fb4a95c4">&#9670;&#160;</a></span>isSystemMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">bool</a> Ogre::HardwareBuffer::isSystemMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this buffer is held in system memory. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_default_hardware_buffer.html#aa2e1f53f6c37b0bb57bc38e4fe4d8fef">Ogre::DefaultHardwareBuffer</a>.</p>

</div>
</div>
<a id="a40a623d95552d9b1858e5c300a3ad68c" name="a40a623d95552d9b1858e5c300a3ad68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a623d95552d9b1858e5c300a3ad68c">&#9670;&#160;</a></span>hasShadowBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">bool</a> Ogre::HardwareBuffer::hasShadowBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this buffer has a system memory shadow for quicker reading. </p>

</div>
</div>
<a id="a7c874c6b30c39aa38ae0d6abe2ba42bc" name="a7c874c6b30c39aa38ae0d6abe2ba42bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c874c6b30c39aa38ae0d6abe2ba42bc">&#9670;&#160;</a></span>isLocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">bool</a> Ogre::HardwareBuffer::isLocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this buffer is currently locked. </p>

</div>
</div>
<a id="a688e1be4a913099ce5e06172771e2d45" name="a688e1be4a913099ce5e06172771e2d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688e1be4a913099ce5e06172771e2d45">&#9670;&#160;</a></span>suppressHardwareUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBuffer::suppressHardwareUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>suppress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> true to suppress hardware upload of shadow buffer changes. </p>

</div>
</div>
<a id="a0f5600a434a495ecf70b7da38ee7f168" name="a0f5600a434a495ecf70b7da38ee7f168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5600a434a495ecf70b7da38ee7f168">&#9670;&#160;</a></span>_getImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1vector.html">typename</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">T</a> * Ogre::HardwareBuffer::_getImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_hardware_buffer_8h.html">OgreHardwareBuffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_hardware_buffer.html">HardwareBuffer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
