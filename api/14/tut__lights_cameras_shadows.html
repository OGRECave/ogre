<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Lights, Cameras, and Shadows</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a><ul><li class="level2"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
</ul>
</li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a><ul><li class="level2"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level2"><a href="#CreatingMoreLights">Creating More Lights</a></li>
</ul>
</li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial can be found in samples directory <b>Samples/Tutorials/BasicTutorial2.cpp</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered.">Ogre::Camera</a> is a special object that must be attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph.">Ogre::SceneNode</a>. You can then use that for movement and rotation. For example, you might want to use a SceneNode that follows a path in the sky to create an impressive aerial cutscene</p>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remember that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();</div>
<div class="line">    Camera* cam = scnMgr-&gt;createCamera(<span class="stringliteral">&quot;myCam&quot;</span>);</div>
</div><!-- fragment --><p> You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div>
<div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div>
</div><!-- fragment --><p> The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space.">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart from attaching camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div>
<div class="line">    camNode-&gt;attachObject(cam);</div>
</div><!-- fragment --><h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e., a rendering region on a render target.">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h2><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h2>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div>
</div><!-- fragment --><p> getRenderWindow() is a method defined for us in <a class="el" href="group___bites.html#ga579bb62eef4503f5d9bc93c0fb613a6f">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window.">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div>
</div><!-- fragment --><p>We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(Real(vp-&gt;getActualWidth()) / Real(vp-&gt;getActualHeight()));</div>
</div><!-- fragment --><p>We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;createEntity(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div>
<div class="line">    ninjaEntity-&gt;setCastShadows(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode()-&gt;attachObject(ninjaEntity);</div>
</div><!-- fragment --><p>This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources.">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div>
</div><!-- fragment --><p>We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt=""/>
</div>
    <p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div>
<div class="line">            <span class="stringliteral">&quot;ground&quot;</span>, RGN_DEFAULT,</div>
<div class="line">            plane,</div>
<div class="line">            1500, 1500, 20, 20,</div>
<div class="line">            <span class="keyword">true</span>,</div>
<div class="line">            1, 5, 5,</div>
<div class="line">            Vector3::UNIT_Z);</div>
</div><!-- fragment --><p> This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources.">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;createEntity(<span class="stringliteral">&quot;ground&quot;</span>);</div>
<div class="line">    scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode()-&gt;attachObject(groundEntity);</div>
</div><!-- fragment --><p>Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div>
</div><!-- fragment --><p>And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div>
</div><!-- fragment --><p>Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene.">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call <a class="el" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675" title="Sets whether or not this object will cast shadows.">Ogre::Entity::setCastShadows</a> to choose which ones will cast shadows. setShadowTechnique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques.">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;setAmbientLight(ColourValue(0, 0, 0));</div>
<div class="line">    scnMgr-&gt;setShadowTechnique(ShadowTechnique::SHADOWTYPE_STENCIL_ADDITIVE);</div>
</div><!-- fragment --><p>Now the SceneManager will use shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p>Ogre provides different types of lights as listed in <a class="el" href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345" title="Defines the type of light.">Ogre::Light::LightTypes</a>.</p>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene.">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="https://learn.microsoft.com/en-us/windows/win32/direct3d9/diffuse-lighting#example">diffuse</a> and <a href="https://learn.microsoft.com/en-us/windows/win32/direct3d9/specular-lighting#example">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h2><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h2>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#a829e11cca3dfaf8142578930e1da6844" title="Creates a light for use in the scene.">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;createLight(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div>
</div><!-- fragment --><p>We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div>
<div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div>
</div><!-- fragment --><p>Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div>
</div><!-- fragment --><p>The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();</div>
<div class="line">    spotLightNode-&gt;attachObject(spotLight);</div>
<div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div>
<div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div>
</div><!-- fragment --><div class="image">
<img src="bt2_light_dir_1.png" alt=""/>
</div>
    <p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div>
</div><!-- fragment --><p> Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt=""/>
</div>
    <h2><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h2>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;createLight(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div>
<div class="line">    directionalLight-&gt;setType(Light::LT_DIRECTIONAL);</div>
</div><!-- fragment --><p>Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div>
<div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div>
</div><!-- fragment --><p>Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();</div>
<div class="line">    directionalLightNode-&gt;attachObject(directionalLight);</div>
<div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div>
</div><!-- fragment --><div class="image">
<img src="bt2_light_dir_2.png" alt=""/>
</div>
    <p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a43f763d809bc7da9a85fec15f57380f4" title="Sets the attenuation parameters of the light source i.e.">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt=""/>
</div>
    <p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;createLight(<span class="stringliteral">&quot;PointLight&quot;</span>);</div>
<div class="line">    pointLight-&gt;setType(Light::LT_POINT);</div>
</div><!-- fragment --><p>We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div>
<div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div>
</div><!-- fragment --><p>A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();</div>
<div class="line">    pointLightNode-&gt;attachObject(pointLight);</div>
<div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div>
</div><!-- fragment --><p>Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt=""/>
</div>
    <h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques.">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
