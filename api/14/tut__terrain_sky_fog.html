<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Terrain, Sky and Fog</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('tut__terrain_sky_fog.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Terrain, Sky and Fog</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tut_terrain">An Introduction to Terrain</a><ul><li class="level2"><a href="#autotoc_md16">Setting Up the Camera</a></li>
<li class="level2"><a href="#autotoc_md17">Setting Up a Light</a></li>
<li class="level2"><a href="#bt3Overview">Loading overview</a></li>
<li class="level2"><a href="#bt3Appearance">Appearance</a></li>
<li class="level2"><a href="#bt3MergingTextures">Merging textures</a></li>
<li class="level2"><a href="#bt3TerrainChunk">Defining a terrain chunk</a></li>
<li class="level2"><a href="#bt3Heightmap">Loading a heightmap</a></li>
<li class="level2"><a href="#bt3Blendmap">Height based blending</a></li>
<li class="level2"><a href="#bt3StoringChanges">Storing changes</a></li>
<li class="level2"><a href="#bt3LoadingLabel">Loading Label</a></li>
</ul>
</li>
<li class="level1"><a href="#bt3sky">Simulating a sky</a><ul><li class="level2"><a href="#autotoc_md18">SkyBoxes</a></li>
<li class="level2"><a href="#autotoc_md19">SkyDomes</a></li>
<li class="level2"><a href="#autotoc_md20">SkyPlanes</a></li>
</ul>
</li>
<li class="level1"><a href="#tut_fog">Fog</a><ul><li class="level2"><a href="#autotoc_md21">Adding Fog to Our Scene</a></li>
</ul>
</li>
<li class="level1"><a href="#conclusion3">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will focus on rendering terrain in a scene. We will cover the basic set up that needs to be done, and we will introduce the use of lighting with terrains. We will also give a brief introduction to simulating a sky using Skyboxes, Skydomes, and Skyplanes. Finally, we will explain how to add a fog effect to the scene.</p>
<p>The full source for this tutorial can be found in samples directory <b>Samples/Simple/include/Terrain.h</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html">Ogre</a> project and compile it successfully.</dd></dl>
<div class="image">
<img src="bt3_fog_visual.png" alt="" width="70%"/>
</div>
<p>Ignore the FPS stats in the screenshots. They were rendered on an ancient computer.</p>
<h1><a class="anchor" id="tut_terrain"></a>
An Introduction to Terrain</h1>
<p>With older versions of Ogre, we had to use the "Terrain Scene Manager" to render terrain in a scene. This is a separate SceneManager that runs alongside your other managers. The new <a class="el" href="namespace_ogre.html">Ogre</a> Terrain Component doesn't require using a separate manager. Since Ogre 1.7, there are two terrain components: Terrain and Paging. The Paging component is used optimize large terrains. It will be covered in later tutorials. This tutorial will focus largely on the Terrain component.</p>
<p>To set up the terrain we will focus on two main classes:</p><ul>
<li><a class="el" href="class_ogre_1_1_terrain.html" title="The main containing class for a chunk of terrain.">Ogre::Terrain</a>, representing one piece of terrain and</li>
<li><a class="el" href="class_ogre_1_1_terrain_group.html" title="Helper class to assist you in managing multiple terrain instances that are connected to each other.">Ogre::TerrainGroup</a>, holding a series of Terrain pieces.</li>
</ul>
<p>This separation is used for LOD (Level of Detail) rendering. LOD rendering reduces the resolution for terrain that is farther away from the camera. An individual Terrain object consists of tiles with a material mapped on to them. We will use a single TerrainGroup without paging. Paging will be covered in later tutorials.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Setting Up the Camera</h2>
<p>Let's first set up our Camera. Add the following to the beginning of <code>setup</code>:</p>
<div class="fragment"><div class="line">        mCameraNode-&gt;setPosition(mTerrainPos + Vector3(1683, 50, 2116));</div>
<div class="line">        mCameraNode-&gt;lookAt(Vector3(1963, 50, 1660), Node::TS_PARENT);</div>
<div class="line">        mCamera-&gt;setNearClipDistance(40); <span class="comment">// tight near plane important for shadows</span></div>
<div class="line">        mCamera-&gt;setFarClipDistance(50000);</div>
</div><!-- fragment --><p>This should look familiar from the previous tutorial.</p>
<div class="fragment"><div class="line">        mCamera-&gt;setFarClipDistance(0); <span class="comment">// enable infinite far clip distance</span></div>
</div><!-- fragment --><p>The last thing we do is to set the far clip distance to zero (which means ''no'' far clipping). </p>
<h2><a class="anchor" id="autotoc_md17"></a>
Setting Up a Light</h2>
<p>The Terrain component can use a directional light to compute a lightmap. Let's add a Light for this purpose and add some ambient light to the scene while we're at it.</p>
<div class="fragment"><div class="line">        <a class="code hl_class" href="class_ogre_1_1_light.html">Ogre::Light</a>* l = mSceneMgr-&gt;createLight();</div>
<div class="line">        l-&gt;<a class="code hl_function" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(<a class="code hl_enumvalue" href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345a4c5582d28848ce40c2b652488494b4a3">Ogre::Light::LT_DIRECTIONAL</a>);</div>
<div class="line">        l-&gt;<a class="code hl_function" href="class_ogre_1_1_light.html#ae7ade1a5befac759d77fa3fe9a399e5c">setDiffuseColour</a>(ColourValue::White);</div>
<div class="line">        l-&gt;<a class="code hl_function" href="class_ogre_1_1_light.html#a8ae9c19d6fd9d0d3a961225abd29126e">setSpecularColour</a>(ColourValue(0.4, 0.4, 0.4));</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ln = mSceneMgr-&gt;getRootSceneNode()-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_node.html#a15ffc965117fa8c9e3406d54c3cc52d2">createChildSceneNode</a>();</div>
<div class="line">        ln-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_node.html#a001600f7c9d1ca43ebe1486e265131ab">setDirection</a>(Vector3(0.55, -0.3, 0.75).normalisedCopy());</div>
<div class="line">        ln-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(l);</div>
<div class="ttc" id="aclass_ogre_1_1_light_html"><div class="ttname"><a href="class_ogre_1_1_light.html">Ogre::Light</a></div><div class="ttdoc">Representation of a dynamic light source in the scene.</div><div class="ttdef"><b>Definition</b> OgreLight.h:95</div></div>
<div class="ttc" id="aclass_ogre_1_1_light_html_a6019f7fa89624e35316ba444e519d8f8"><div class="ttname"><a href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">Ogre::Light::setType</a></div><div class="ttdeci">void setType(LightTypes type)</div><div class="ttdoc">Sets the type of light - see LightTypes for more info.</div></div>
<div class="ttc" id="aclass_ogre_1_1_light_html_a8ae9c19d6fd9d0d3a961225abd29126e"><div class="ttname"><a href="class_ogre_1_1_light.html#a8ae9c19d6fd9d0d3a961225abd29126e">Ogre::Light::setSpecularColour</a></div><div class="ttdeci">void setSpecularColour(float red, float green, float blue)</div><div class="ttdoc">Sets the colour of the specular light given off by this source.</div></div>
<div class="ttc" id="aclass_ogre_1_1_light_html_ae7ade1a5befac759d77fa3fe9a399e5c"><div class="ttname"><a href="class_ogre_1_1_light.html#ae7ade1a5befac759d77fa3fe9a399e5c">Ogre::Light::setDiffuseColour</a></div><div class="ttdeci">void setDiffuseColour(float red, float green, float blue)</div><div class="ttdoc">Sets the colour of the diffuse light given off by this source.</div></div>
<div class="ttc" id="aclass_ogre_1_1_light_html_af20fe2bb87447be7a9a5327c65dee345a4c5582d28848ce40c2b652488494b4a3"><div class="ttname"><a href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345a4c5582d28848ce40c2b652488494b4a3">Ogre::Light::LT_DIRECTIONAL</a></div><div class="ttdeci">@ LT_DIRECTIONAL</div><div class="ttdoc">Directional lights simulate parallel light beams from a distant source, hence have direction but no p...</div><div class="ttdef"><b>Definition</b> OgreLight.h:108</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_node_html"><div class="ttname"><a href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a></div><div class="ttdoc">Class representing a node in the scene graph.</div><div class="ttdef"><b>Definition</b> OgreSceneNode.h:61</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_node_html_a001600f7c9d1ca43ebe1486e265131ab"><div class="ttname"><a href="class_ogre_1_1_scene_node.html#a001600f7c9d1ca43ebe1486e265131ab">Ogre::SceneNode::setDirection</a></div><div class="ttdeci">void setDirection(Real x, Real y, Real z, TransformSpace relativeTo=TS_PARENT, const Vector3 &amp;localDirectionVector=Vector3::NEGATIVE_UNIT_Z)</div><div class="ttdoc">Sets the node's direction vector ie it's local -z.</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_node_html_a15ffc965117fa8c9e3406d54c3cc52d2"><div class="ttname"><a href="class_ogre_1_1_scene_node.html#a15ffc965117fa8c9e3406d54c3cc52d2">Ogre::SceneNode::createChildSceneNode</a></div><div class="ttdeci">virtual SceneNode * createChildSceneNode(const Vector3 &amp;translate=Vector3::ZERO, const Quaternion &amp;rotate=Quaternion::IDENTITY)</div><div class="ttdoc">Creates an unnamed new SceneNode as a child of this node.</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_node_html_a51052c58747a77a6cf7451b700e7eb87"><div class="ttname"><a href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">Ogre::SceneNode::attachObject</a></div><div class="ttdeci">virtual void attachObject(MovableObject *obj)</div><div class="ttdoc">Adds an instance of a scene object to this node.</div></div>
</div><!-- fragment --><p>This was also covered in the previous tutorial if you're confused by any of it. The <code>normalise</code> method will make the vector's length equal to one while maintaining its direction. This is something that you will see a lot of when working with vectors. It is done to avoid extra factors showing up in calculations. </p>
<h2><a class="anchor" id="bt3Overview"></a>
Loading overview</h2>
<p>Now we'll get into the actual terrain setup. First, we create TerrainGlobalOptions.</p>
<div class="fragment"><div class="line">        mTerrainGlobals = <span class="keyword">new</span> <a class="code hl_class" href="class_ogre_1_1_terrain_global_options.html">Ogre::TerrainGlobalOptions</a>();</div>
<div class="ttc" id="aclass_ogre_1_1_terrain_global_options_html"><div class="ttname"><a href="class_ogre_1_1_terrain_global_options.html">Ogre::TerrainGlobalOptions</a></div><div class="ttdoc">Options class which just stores default options for the terrain.</div><div class="ttdef"><b>Definition</b> OgreTerrain.h:1835</div></div>
</div><!-- fragment --><p>This is a class that holds information for all of the terrains we might create - that is why they are called ''global'' options. It also provides a few getters and setters. There are also local options for each TerrainGroup that we will see later in this tutorial.</p>
<p>Next we construct our TerrainGroup object. This will manage a grid of Terrains.</p>
<div class="fragment"><div class="line">        mTerrainGroup = <span class="keyword">new</span> <a class="code hl_class" href="class_ogre_1_1_terrain_group.html">Ogre::TerrainGroup</a>(mSceneMgr, <a class="code hl_enumvalue" href="class_ogre_1_1_terrain.html#aca4fcebfb7ed4684682347d325477e91ac4699c4f99bea344a309d5544b33c140">Ogre::Terrain::ALIGN_X_Z</a>, TERRAIN_SIZE, TERRAIN_WORLD_SIZE);</div>
<div class="line">        mTerrainGroup-&gt;setOrigin(mTerrainPos);</div>
<div class="ttc" id="aclass_ogre_1_1_terrain_group_html"><div class="ttname"><a href="class_ogre_1_1_terrain_group.html">Ogre::TerrainGroup</a></div><div class="ttdoc">Helper class to assist you in managing multiple terrain instances that are connected to each other.</div><div class="ttdef"><b>Definition</b> OgreTerrainGroup.h:73</div></div>
<div class="ttc" id="aclass_ogre_1_1_terrain_html_aca4fcebfb7ed4684682347d325477e91ac4699c4f99bea344a309d5544b33c140"><div class="ttname"><a href="class_ogre_1_1_terrain.html#aca4fcebfb7ed4684682347d325477e91ac4699c4f99bea344a309d5544b33c140">Ogre::Terrain::ALIGN_X_Z</a></div><div class="ttdeci">@ ALIGN_X_Z</div><div class="ttdoc">Terrain is in the X/Z plane.</div><div class="ttdef"><b>Definition</b> OgreTerrain.h:311</div></div>
</div><!-- fragment --><p>The TerrainGroup constructor takes the SceneManager as its first parameter. It then takes an alignment option, terrain size, and terrain world size. You can read the <a class="el" href="class_ogre_1_1_terrain_group.html" title="Helper class to assist you in managing multiple terrain instances that are connected to each other.">Ogre::TerrainGroup</a> for more information. Finally, we set the origin to be used for our terrain.</p>
<p>The next thing we will do is call our terrain configuration method, which we will fill in soon. Make sure to pass the Light we created as a parameter. </p><div class="fragment"><div class="line">configureTerrainDefaults(light);</div>
</div><!-- fragment --><p> The next thing we do is define our terrains and ask the TerrainGroup to load them all.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">long</span> x = TERRAIN_PAGE_MIN_X; x &lt;= TERRAIN_PAGE_MAX_X; ++x)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">long</span> y = TERRAIN_PAGE_MIN_Y; y &lt;= TERRAIN_PAGE_MAX_Y; ++y)</div>
<div class="line">                defineTerrain(x, y);</div>
<div class="line">        <span class="comment">// sync load since we want everything in place when we start</span></div>
<div class="line">        mTerrainGroup-&gt;loadAllTerrains(<span class="keyword">true</span>);</div>
</div><!-- fragment --><p>We are only using a single terrain, so the method will only be called once. The for loops are just for demonstration in our case. Again, we will fill in the <code>defineTerrain</code> method soon.</p>
<p>We will now initialize the blend maps for our terrain.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> (mTerrainsImported)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; ti : mTerrainGroup-&gt;getTerrainSlots())</div>
<div class="line">            {</div>
<div class="line">                initBlendMaps(ti.second-&gt;instance);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        mTerrainGroup-&gt;freeTemporaryResources();</div>
</div><!-- fragment --><p>We get a TerrainIterator from our TerrainGroup and then loop through any Terrain elements and initialize their blend maps - <code>initBlendMaps</code> will also be written soon. The <code>mTerrainsImported</code> variable will be set during the <code>configureTerrainDefaults</code> function when we complete it.</p>
<p>The last thing we will do is make sure to cleanup any temporary resources that were created while configuring our terrain.</p>
<p>That completes our <code>setupContent</code> method. Now we just have to complete all of the methods we jumped over. </p>
<h2><a class="anchor" id="bt3Appearance"></a>
Appearance</h2>
<p>The Ogre Terrain component has a large number of options that can be set to change how the terrain is rendered. To start out, we configure the level of detail (LOD). There are two LOD approaches in the Terrain component, one controlling the geometry and the other controlling the texture.</p>
<div class="fragment"><div class="line">        mTerrainGlobals-&gt;setMaxPixelError(8);</div>
<div class="line">        mTerrainGlobals-&gt;setCompositeMapDistance(3000);</div>
</div><!-- fragment --><p>The first call sets the largest allowed error for geometry. It controls the distance in pixels allowed between our ideal terrain and the mesh that is created to render it. A smaller number will mean a more accurate terrain, because it will require more vertices to reduce the error.</p>
<p>The second call determines the distance at which Ogre will reduce the texture resolution. For this, Ogre automatically creates a composite map, where the terrain textures, the blending textures and lighting information are "baked" together at a lower resolution. This way only a single texture lookup is needed when using the low LOD setting. If you increase the distance, then Ogre will use the high LOD setting out to a farther distance, where it computes all lighting effects per-pixel.</p>
<p>In order to generate composite map correctly, we have to pass our lighting information to the terrain.</p>
<div class="fragment"><div class="line">        <span class="comment">// Important to set these so that the terrain knows what to use for baked (non-realtime) data</span></div>
<div class="line">        mTerrainGlobals-&gt;setLightMapDirection(l-&gt;<a class="code hl_function" href="class_ogre_1_1_light.html#ad36544a14b5c9c0c2fff82e5a94abdf8">getDerivedDirection</a>());</div>
<div class="line">        mTerrainGlobals-&gt;setCompositeMapAmbient(mSceneMgr-&gt;getAmbientLight());</div>
<div class="line">        mTerrainGlobals-&gt;setCompositeMapDiffuse(l-&gt;<a class="code hl_function" href="class_ogre_1_1_light.html#aff98b9ed31a64b4801740ff400ac8e85">getDiffuseColour</a>());</div>
<div class="ttc" id="aclass_ogre_1_1_light_html_ad36544a14b5c9c0c2fff82e5a94abdf8"><div class="ttname"><a href="class_ogre_1_1_light.html#ad36544a14b5c9c0c2fff82e5a94abdf8">Ogre::Light::getDerivedDirection</a></div><div class="ttdeci">const Vector3 &amp; getDerivedDirection(void) const</div><div class="ttdoc">Retrieves the direction of the light including any transform from nodes it is attached to.</div></div>
<div class="ttc" id="aclass_ogre_1_1_light_html_aff98b9ed31a64b4801740ff400ac8e85"><div class="ttname"><a href="class_ogre_1_1_light.html#aff98b9ed31a64b4801740ff400ac8e85">Ogre::Light::getDiffuseColour</a></div><div class="ttdeci">const ColourValue &amp; getDiffuseColour(void) const</div><div class="ttdoc">Returns the colour of the diffuse light given off by this light source (see setDiffuseColour for more...</div></div>
</div><!-- fragment --><p>In the first call, <code>getDerivedDirection</code> will apply all transforms by the parent SceneNodes to our Light's direction. The next two calls should be pretty self-explanatory. We simply set the ambient light and diffuse color for our terrain to match our scene lighting.</p>
<p>The next thing we do is get a reference to the import settings of our TerrainGroup and set some basic values.</p>
<div class="fragment"><div class="line">        <a class="code hl_struct" href="struct_ogre_1_1_terrain_1_1_import_data.html">Ogre::Terrain::ImportData</a>&amp; defaultimp = mTerrainGroup-&gt;getDefaultImportSettings();</div>
<div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#ae97c725c89e0c789e5099fd387953020">inputScale</a> = 600;</div>
<div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#a60b1682048188053cc885097eb2383c6">minBatchSize</a> = 33;</div>
<div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#acebf6cfa7dcb63b4725ed1dc2e63a9f2">maxBatchSize</a> = 65;</div>
<div class="ttc" id="astruct_ogre_1_1_terrain_1_1_import_data_html"><div class="ttname"><a href="struct_ogre_1_1_terrain_1_1_import_data.html">Ogre::Terrain::ImportData</a></div><div class="ttdoc">Structure encapsulating import data that you may use to bootstrap the terrain without loading from a ...</div><div class="ttdef"><b>Definition</b> OgreTerrain.h:322</div></div>
<div class="ttc" id="astruct_ogre_1_1_terrain_1_1_import_data_html_a60b1682048188053cc885097eb2383c6"><div class="ttname"><a href="struct_ogre_1_1_terrain_1_1_import_data.html#a60b1682048188053cc885097eb2383c6">Ogre::Terrain::ImportData::minBatchSize</a></div><div class="ttdeci">uint16 minBatchSize</div><div class="ttdoc">Minimum batch size (along one edge) in vertices; must be 2^n+1.</div><div class="ttdef"><b>Definition</b> OgreTerrain.h:343</div></div>
<div class="ttc" id="astruct_ogre_1_1_terrain_1_1_import_data_html_acebf6cfa7dcb63b4725ed1dc2e63a9f2"><div class="ttname"><a href="struct_ogre_1_1_terrain_1_1_import_data.html#acebf6cfa7dcb63b4725ed1dc2e63a9f2">Ogre::Terrain::ImportData::maxBatchSize</a></div><div class="ttdeci">uint16 maxBatchSize</div><div class="ttdoc">Maximum batch size (along one edge) in vertices; must be 2^n+1 and &lt;= 65.</div><div class="ttdef"><b>Definition</b> OgreTerrain.h:332</div></div>
<div class="ttc" id="astruct_ogre_1_1_terrain_1_1_import_data_html_ae97c725c89e0c789e5099fd387953020"><div class="ttname"><a href="struct_ogre_1_1_terrain_1_1_import_data.html#ae97c725c89e0c789e5099fd387953020">Ogre::Terrain::ImportData::inputScale</a></div><div class="ttdeci">Real inputScale</div><div class="ttdoc">How to scale the input values provided (if any)</div><div class="ttdef"><b>Definition</b> OgreTerrain.h:382</div></div>
</div><!-- fragment --><p>We are not going to cover the exact meaning of these options in this tutorial. The <code>inputScale</code> determines how the heightmap image will be scaled up for the scene. We are using a somewhat large scale because our heightmap image is a 8bit grayscale bitmap, that is normalised to the <code>[0; 1]</code> range on loading. You can use floating point raw heightmaps to avoid applying any input scaling and gain a higher precision, but such images require more storage and are not supported by common image viewers.</p>
<p>The last step is adding the textures our terrain will use. First, we resize the list to hold three textures. After that, we set each texture's <code>worldSize</code> and add them to the list.</p>
<div class="fragment"><div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#a3d892ce610f8e6aec873528d042fe72b">layerList</a>.resize(3);</div>
<div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#a3d892ce610f8e6aec873528d042fe72b">layerList</a>[0].worldSize = 200;</div>
<div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#a3d892ce610f8e6aec873528d042fe72b">layerList</a>[0].textureNames.push_back(<span class="stringliteral">&quot;Ground37_diffspec.dds&quot;</span>);</div>
<div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#a3d892ce610f8e6aec873528d042fe72b">layerList</a>[0].textureNames.push_back(<span class="stringliteral">&quot;Ground37_normheight.dds&quot;</span>);</div>
<div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#a3d892ce610f8e6aec873528d042fe72b">layerList</a>[1].worldSize = 200;</div>
<div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#a3d892ce610f8e6aec873528d042fe72b">layerList</a>[1].textureNames.push_back(<span class="stringliteral">&quot;Ground23_diffspec&quot;</span>); <span class="comment">// loaded from memory</span></div>
<div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#a3d892ce610f8e6aec873528d042fe72b">layerList</a>[1].textureNames.push_back(<span class="stringliteral">&quot;Ground23_normheight.dds&quot;</span>);</div>
<div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#a3d892ce610f8e6aec873528d042fe72b">layerList</a>[2].worldSize = 400;</div>
<div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#a3d892ce610f8e6aec873528d042fe72b">layerList</a>[2].textureNames.push_back(<span class="stringliteral">&quot;Rock20_diffspec.dds&quot;</span>);</div>
<div class="line">        defaultimp.<a class="code hl_variable" href="struct_ogre_1_1_terrain_1_1_import_data.html#a3d892ce610f8e6aec873528d042fe72b">layerList</a>[2].textureNames.push_back(<span class="stringliteral">&quot;Rock20_normheight.dds&quot;</span>);</div>
<div class="ttc" id="astruct_ogre_1_1_terrain_1_1_import_data_html_a3d892ce610f8e6aec873528d042fe72b"><div class="ttname"><a href="struct_ogre_1_1_terrain_1_1_import_data.html#a3d892ce610f8e6aec873528d042fe72b">Ogre::Terrain::ImportData::layerList</a></div><div class="ttdeci">LayerInstanceList layerList</div><div class="ttdoc">List of layer structures, one for each layer required.</div><div class="ttdef"><b>Definition</b> OgreTerrain.h:395</div></div>
</div><!-- fragment --><p>The texture's <code>worldSize</code> determines how big each splat of texture is going to be when applied to the terrain. A smaller value will increase the resolution of the rendered texture layer because each piece will be stretched less to fill in the terrain.</p>
<h2><a class="anchor" id="bt3MergingTextures"></a>
Merging textures</h2>
<p>The default material generator requires two textures maps per layer:</p><ol type="1">
<li>one containing diffuse + specular data and</li>
<li>another containing normal + displacement data.</li>
</ol>
<p>It is recommended that you pre-merge your textures accordingly e.g. using <a href="https://imagemagick.org/">ImageMagick</a> like this: </p><div class="fragment"><div class="line">convert Ground37_col.jpg Ground37_spec.png -compose copy-opacity -composite Ground37_diffspec.dds</div>
</div><!-- fragment --><p> This way you save storage space and speed up loading.</p>
<p>However if you want more flexibility, you can also make Ogre combine the images at loading accordingly as shown below</p>
<div class="fragment"><div class="line">        <a class="code hl_class" href="class_ogre_1_1_image.html">Ogre::Image</a> combined;</div>
<div class="line">        combined.<a class="code hl_function" href="class_ogre_1_1_image.html#a9637f7e84d6869469842dd693fa0a23b">loadTwoImagesAsRGBA</a>(<span class="stringliteral">&quot;Ground23_col.jpg&quot;</span>, <span class="stringliteral">&quot;Ground23_spec.png&quot;</span>, <span class="stringliteral">&quot;General&quot;</span>);</div>
<div class="line">        TextureManager::getSingleton().loadImage(<span class="stringliteral">&quot;Ground23_diffspec&quot;</span>, <span class="stringliteral">&quot;General&quot;</span>, combined);</div>
<div class="ttc" id="aclass_ogre_1_1_image_html"><div class="ttname"><a href="class_ogre_1_1_image.html">Ogre::Image</a></div><div class="ttdoc">Class representing an image file.</div><div class="ttdef"><b>Definition</b> OgreImage.h:61</div></div>
<div class="ttc" id="aclass_ogre_1_1_image_html_a9637f7e84d6869469842dd693fa0a23b"><div class="ttname"><a href="class_ogre_1_1_image.html#a9637f7e84d6869469842dd693fa0a23b">Ogre::Image::loadTwoImagesAsRGBA</a></div><div class="ttdeci">Image &amp; loadTwoImagesAsRGBA(const String &amp;rgbFilename, const String &amp;alphaFilename, const String &amp;groupName, PixelFormat format=PF_BYTE_RGBA)</div><div class="ttdoc">Utility method to combine 2 separate images into this one, with the first image source supplying the ...</div></div>
</div><!-- fragment --><h2><a class="anchor" id="bt3TerrainChunk"></a>
Defining a terrain chunk</h2>
<p>Now we will tackle our <code>defineTerrain</code> method. The first thing we do is ask the TerrainGroup to define a unique filename for this Terrain. If it has already been generated, then we can call <code>TerrainGroup::defineTerrain</code> method to set up this grid location with the previously generated filename automatically. If it has not been generated, then we generate an image with <code>getTerrainImage</code> and then call a different overload of <code>TerrainGroup::defineTerrain</code> that takes a reference to our generated image. Finally, we set the <code>mTerrainsImported</code> flag to true.</p>
<div class="fragment"><div class="line">        String filename = mTerrainGroup-&gt;generateFilename(x, y);</div>
<div class="line">        <span class="keywordflow">if</span> (ResourceGroupManager::getSingleton().resourceExists(mTerrainGroup-&gt;getResourceGroup(), filename))</div>
<div class="line">        {</div>
<div class="line">            mTerrainGroup-&gt;defineTerrain(x, y, filename);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            Image img;</div>
<div class="line">            getTerrainImage(x % 2 != 0, y % 2 != 0, img);</div>
<div class="line">            mTerrainGroup-&gt;defineTerrain(x, y, &amp;img);</div>
<div class="line">            mTerrainsImported = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
</div><!-- fragment --><p>You might have to look at this method for a little while to fully understand it. Make sure you notice that there are ''three'' different <code>defineTerrain</code> methods in use. One of them from TutorialApplication and two of them from TerrainGroup. </p>
<h2><a class="anchor" id="bt3Heightmap"></a>
Loading a heightmap</h2>
<p>We need to write the helper function that was used by <code>defineTerrain</code> in the last step. This will load our <code>terrain.png</code> heightmap. Make sure it has been added to one of your resource loading paths. It is also included in the <a class="el" href="namespace_ogre.html">Ogre</a> Samples directory.</p>
<div class="fragment"><div class="line">        img.load(<span class="stringliteral">&quot;terrain.png&quot;</span>, mTerrainGroup-&gt;getResourceGroup());</div>
<div class="line">        <span class="keywordflow">if</span> (flipX)</div>
<div class="line">            img.flipAroundY();</div>
<div class="line">        <span class="keywordflow">if</span> (flipY)</div>
<div class="line">            img.flipAroundX();</div>
</div><!-- fragment --><p>Flipping is used to create seamless terrain so that unlimited terrain can be created using a single heightmap. If your terrain's heightmap is already seamless, then you don't need to use this trick. In our case, the flipping code is also useless, because we are using a 1x1 TerrainGroup. Flipping a 1x1 tile doesn't change anything. It is just for demonstration. </p>
<h2><a class="anchor" id="bt3Blendmap"></a>
Height based blending</h2>
<p>Finally, we will finish up our configuration methods by completing the <code>initBlendMaps</code> method. This method sets up <a href="https://en.wikipedia.org/wiki/Texture_splatting">texture-splatting</a> for the different layers we defined in <code>configureTerrainDefaults</code>. For now, you should pretty much view this method as a magic. The details will not be covered in this tutorial. Basically, the method blends the textures based on the height of the terrain at that point. This is not the only way of doing blending. It's a complicated topic and sits right at the verge between <a class="el" href="namespace_ogre.html">Ogre</a> and the things it tries to abstract away.</p>
<div class="fragment"><div class="line">        <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ogre.html">Ogre</a>;</div>
<div class="line">        <a class="code hl_class" href="class_ogre_1_1_terrain_layer_blend_map.html">TerrainLayerBlendMap</a>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">blendMap0</a> = terrain-&gt;getLayerBlendMap(1);</div>
<div class="line">        <a class="code hl_class" href="class_ogre_1_1_terrain_layer_blend_map.html">TerrainLayerBlendMap</a>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">blendMap1</a> = terrain-&gt;getLayerBlendMap(2);</div>
<div class="line">        <span class="keywordtype">float</span> <a class="code hl_struct" href="struct_ogre_1_1vector.html">minHeight0</a> = 20;</div>
<div class="line">        <span class="keywordtype">float</span> <a class="code hl_struct" href="struct_ogre_1_1vector.html">fadeDist0</a> = 15;</div>
<div class="line">        <span class="keywordtype">float</span> <a class="code hl_struct" href="struct_ogre_1_1vector.html">minHeight1</a> = 70;</div>
<div class="line">        <span class="keywordtype">float</span> <a class="code hl_struct" href="struct_ogre_1_1vector.html">fadeDist1</a> = 15;</div>
<div class="line">        <span class="keywordtype">float</span>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">pBlend0</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">blendMap0</a>-&gt;getBlendPointer();</div>
<div class="line">        <span class="keywordtype">float</span>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">pBlend1</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">blendMap1</a>-&gt;getBlendPointer();</div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code hl_struct" href="struct_ogre_1_1vector.html">uint16</a> y = 0; y &lt; terrain-&gt;getLayerBlendMapSize(); ++y)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">for</span> (<a class="code hl_struct" href="struct_ogre_1_1vector.html">uint16</a> x = 0; x &lt; terrain-&gt;getLayerBlendMapSize(); ++x)</div>
<div class="line">            {</div>
<div class="line">                <a class="code hl_struct" href="struct_ogre_1_1vector.html">Real</a> <a class="code hl_struct" href="struct_ogre_1_1vector.html">tx</a>, <a class="code hl_struct" href="struct_ogre_1_1vector.html">ty</a>;</div>
<div class="line"> </div>
<div class="line">                <a class="code hl_struct" href="struct_ogre_1_1vector.html">blendMap0</a>-&gt;convertImageToTerrainSpace(x, y, &amp;<a class="code hl_struct" href="struct_ogre_1_1vector.html">tx</a>, &amp;<a class="code hl_struct" href="struct_ogre_1_1vector.html">ty</a>);</div>
<div class="line">                <span class="keywordtype">float</span> height = terrain-&gt;getHeightAtTerrainPosition(<a class="code hl_struct" href="struct_ogre_1_1vector.html">tx</a>, <a class="code hl_struct" href="struct_ogre_1_1vector.html">ty</a>);</div>
<div class="line"> </div>
<div class="line">                *<a class="code hl_struct" href="struct_ogre_1_1vector.html">pBlend0</a>++ = Math::saturate((height - <a class="code hl_struct" href="struct_ogre_1_1vector.html">minHeight0</a>) / <a class="code hl_struct" href="struct_ogre_1_1vector.html">fadeDist0</a>);</div>
<div class="line">                *<a class="code hl_struct" href="struct_ogre_1_1vector.html">pBlend1</a>++ = Math::saturate((height - <a class="code hl_struct" href="struct_ogre_1_1vector.html">minHeight1</a>) / <a class="code hl_struct" href="struct_ogre_1_1vector.html">fadeDist1</a>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <a class="code hl_struct" href="struct_ogre_1_1vector.html">blendMap0</a>-&gt;dirty();</div>
<div class="line">        <a class="code hl_struct" href="struct_ogre_1_1vector.html">blendMap1</a>-&gt;dirty();</div>
<div class="line">        <a class="code hl_struct" href="struct_ogre_1_1vector.html">blendMap0</a>-&gt;update();</div>
<div class="line">        <a class="code hl_struct" href="struct_ogre_1_1vector.html">blendMap1</a>-&gt;update();</div>
<div class="ttc" id="aclass_ogre_1_1_terrain_layer_blend_map_html"><div class="ttname"><a href="class_ogre_1_1_terrain_layer_blend_map.html">Ogre::TerrainLayerBlendMap</a></div><div class="ttdoc">Class exposing an interface to a blend map for a given layer.</div><div class="ttdef"><b>Definition</b> OgreTerrainLayerBlendMap.h:62</div></div>
<div class="ttc" id="anamespace_ogre_html"><div class="ttname"><a href="namespace_ogre.html">Ogre</a></div><div class="ttdef"><b>Definition</b> OgreAlignedAllocator.h:34</div></div>
<div class="ttc" id="astruct_ogre_1_1vector_html"><div class="ttname"><a href="struct_ogre_1_1vector.html">Ogre::vector</a></div><div class="ttdef"><b>Definition</b> OgreDeprecated.h:54</div></div>
</div><!-- fragment --><h2><a class="anchor" id="bt3StoringChanges"></a>
Storing changes</h2>
<p>Next, we'll implement the ability to save terrain modifications. The first step is to specify the storage location for the terrain data by adding a writable path to the terrain resource group, configured as follows:</p>
<div class="fragment"><div class="line">        ResourceGroupManager::getSingleton().addResourceLocation(<span class="stringliteral">&quot;.&quot;</span>, <span class="stringliteral">&quot;FileSystem&quot;</span>, mTerrainGroup-&gt;getResourceGroup(),</div>
<div class="line">                                                                 <span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line">        mTerrainGroup-&gt;setFilenameConvention(<span class="stringliteral">&quot;TerrainSample&quot;</span>, <span class="stringliteral">&quot;bin&quot;</span>);</div>
</div><!-- fragment --><p>The <code>setFilenameConvention</code> method lets us define the naming pattern for terrain files. We've opted for a straightforward format that generates filenames like <code>TerrainSample_00000000.bin</code>, where the numeric portion corresponds to the terrain's index within the TerrainGroup.</p>
<p>To control when terrain saving occurs, we'll tie it to the Ctrl+S keyboard shortcut by adding this logic to the <code>keyPressed</code> handler:</p>
<div class="fragment"><div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;s&#39;</span>:</div>
<div class="line">            <span class="comment">// CTRL-S to save</span></div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code hl_struct" href="struct_ogre_1_1vector.html">e</a>.keysym.mod &amp; KMOD_CTRL)</div>
<div class="line">            {</div>
<div class="line">                mTerrainGroup-&gt;saveAllTerrains(<span class="keyword">true</span>);</div>
<div class="line">            }</div>
</div><!-- fragment --><p>Saving the terrain serves two purposes: it preserves user modifications and optimizes future loading. When reloaded, the terrain will use the pre-saved data rather than regenerating it, resulting in faster load times.</p>
<h2><a class="anchor" id="bt3LoadingLabel"></a>
Loading Label</h2>
<p>We will add a label to the overlay that allows us to see when the terrain generation has finished. Let's construct this label in the <code>createFrameListener</code> method.</p>
<div class="fragment"><div class="line">        <a class="code hl_struct" href="struct_ogre_1_1vector.html">mInfoLabel</a> = mTrayMgr-&gt;createLabel(TL_TOP, <span class="stringliteral">&quot;TInfo&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, 350);</div>
</div><!-- fragment --><p>We use the TrayManager pointer that was defined in SdkSample to request the creation of a new label. This method takes a TrayLocation, a name for the label, a caption to display, and a width.</p>
<p>Next we will add logic to <code>frameRenderingQueued</code> that tracks whether the terrain is still loading or not. Add the following to <code>frameRenderingQueued</code> right after the call to the parent method:</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> (mTerrainGroup-&gt;isDerivedDataUpdateInProgress())</div>
<div class="line">        {</div>
<div class="line">            mTrayMgr-&gt;moveWidgetToTray(<a class="code hl_struct" href="struct_ogre_1_1vector.html">mInfoLabel</a>, TL_TOP, 0);</div>
<div class="line">            <a class="code hl_struct" href="struct_ogre_1_1vector.html">mInfoLabel</a>-&gt;show();</div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code hl_struct" href="struct_ogre_1_1vector.html">mTerrainsImported</a>)</div>
<div class="line">            {</div>
<div class="line">                <a class="code hl_struct" href="struct_ogre_1_1vector.html">mInfoLabel</a>-&gt;setCaption(<span class="stringliteral">&quot;Building terrain...&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                <a class="code hl_struct" href="struct_ogre_1_1vector.html">mInfoLabel</a>-&gt;setCaption(<span class="stringliteral">&quot;Updating textures...&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            mTrayMgr-&gt;removeWidgetFromTray(<a class="code hl_struct" href="struct_ogre_1_1vector.html">mInfoLabel</a>);</div>
<div class="line">            <a class="code hl_struct" href="struct_ogre_1_1vector.html">mInfoLabel</a>-&gt;hide();</div>
<div class="line">            <a class="code hl_struct" href="struct_ogre_1_1vector.html">mTerrainsImported</a> = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
</div><!-- fragment --><p>The first thing we do is determine if our terrain is still being built. If it is, then we add our Label to the tray and ask for it to be shown. Then we check to see if any new terrains have been imported. If they have, then we display text saying that the terrain is still being built. Otherwise we assume the textures are being updated. If the terrain is no longer being updated, then we ask the <a class="el" href="class_ogre_bites_1_1_tray_manager.html" title="Main class to manage a cursor, backdrop, trays and widgets.">OgreBites::TrayManager</a> to remove the our Label widget and hide the Label.</p>
<p>Compile and run your application again. You should now see a Label at the top of the screen while the terrain is being built. While the terrain is loading, you will not be able to press escape to exit and your movement controls will be choppy. This is what loading screens are for in games.</p>
<div class="image">
<img src="bt3_building_terrain_label_visual.png" alt=""/>
</div>
    <h1><a class="anchor" id="bt3sky"></a>
Simulating a sky</h1>
<h2><a class="anchor" id="autotoc_md18"></a>
SkyBoxes</h2>
<p>A SkyBox is basically a huge textured cube that surrounds all of the objects in your scene. It is one of the methods for simulating a sky. We will need six textures to cover all of the interior faces of the SkyBox.</p>
<p>It is very easy to include a SkyBox in your scene. Add the following to the end of <code>setupContent</code>:</p>
<div class="fragment"><div class="line">        mSceneMgr-&gt;setSkyBox(<span class="keyword">true</span>, <span class="stringliteral">&quot;Examples/CloudyNoonSkyBox&quot;</span>);</div>
</div><!-- fragment --><p>Compile and run your application. That's all there is to it. The SkyBox will look really grainy because we are using a rather low resolution collection of textures.</p>
<p>The first parameter of this method determines whether or not to immediately enable the SkyBox. If you want to later disable the SkyBox you can call <code>mSceneMgr-&gt;setSkyBox(false, "")</code>. This disables the SkyBox.</p>
<p>The third and fourth parameters to <code>setSkyBox</code> are important to understand. We have allowed them to take their default values in our call. The third parameter is the distance between the Camera and the SkyBox. Make this change to your call: </p><div class="fragment"><div class="line">mSceneMgr-&gt;setSkyBox(<span class="keyword">true</span>, <span class="stringliteral">&quot;Examples/SpaceSkyBox&quot;</span>, 300);</div>
</div><!-- fragment --><p> Compile and run your application. Nothing has changed. This is because the fourth parameter sets whether or not to render the SkyBox before the rest of the scene. If the SkyBox is rendered first, then no matter how close it is the rest of your scene objects will be rendered on top of it. Now try this call: </p><div class="fragment"><div class="line">mSceneMgr-&gt;setSkyBox(<span class="keyword">true</span>, <span class="stringliteral">&quot;Examples/SpaceSkyBox&quot;</span>, 300, <span class="keyword">false</span>);</div>
</div><!-- fragment --><p> Compile and run your application again. This time you should definitely see something different. Only a small patch of terrain should exist below the camera. Move around and notice what is happening. The SkyBox is being rendered only 300 units away from the Camera and it is no longer being rendered before everything else. This means the SkyBox is drawn over terrain that is farther than 300 units away from the Camera.</p>
<p>You can get a modest performance boost by not rendering the SkyBox first, but as you can see, you'll need to make sure not to cause strange problems like this when doing it. For the most part, leaving these additional parameters at their defaults is good enough. Although you may want to purposely use this strange culling behavior in your application. Try not to get to locked into how things are "supposed to work". If something catches your eye, then play around with it. </p>
<h2><a class="anchor" id="autotoc_md19"></a>
SkyDomes</h2>
<p>Another method of simulating a sky is the SkyDome. The sky texture is still applied to a huge cube that surrounds the scene, but the textures is projected in such a way that it appears to create a dome over the scene. The best way to understand this is to see it in practice. Comment out our call to <code>setSkyBox</code> and add the following line: </p><div class="fragment"><div class="line">mSceneMgr-&gt;setSkyDome(<span class="keyword">true</span>, <span class="stringliteral">&quot;Examples/CloudySky&quot;</span>, 5, 8);</div>
</div><!-- fragment --><p> Compile and run your application. Make sure to move the Camera to the edge of the terrain so you can better idea of what is being done. The main drawback to this method is that the texture won't cover the bottom face of the cube. You would need to make sure a user could not accidentally see behind the curtain.</p>
<p>The first two parameters of the <code>setSkyDome</code> method are the same as <code>setSkyBox</code>. You can disable the SkyDome in the same way as well. The third parameter is the curvature for the dome projection. It is suggested to use values between 2 and 65. Lower values will produce a better effect at far distances, but higher values will cause less distortion of the texture. The fourth parameter is the number of times the texture will be tiled. This parameter is a <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d" title="Software floating point type.">Ogre::Real</a> value. You can tile your texture 3.14 times if you want. The last two parameters are the distance and whether or not to draw the SkyDome first. These are the same last two parameters we had with <code>setSkyBox</code>.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
SkyPlanes</h2>
<p>The third method for simulating sky is rather different from the first two. This method will use a single plane. The first thing we need to do is create a Plane object. Comment out our call to <code>setSkyDome</code> and add the following: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_ogre_1_1_plane.html">Ogre::Plane</a> plane;</div>
<div class="line">plane.<a class="code hl_variable" href="class_ogre_1_1_plane.html#a8e7de1712320968bee111002bc2938b8">d</a> = 1000;</div>
<div class="line">plane.<a class="code hl_variable" href="class_ogre_1_1_plane.html#a3f97462d3822f6add8c070048f6c2d92">normal</a> = Ogre::Vector3::NEGATIVE_UNIT_Y;</div>
<div class="ttc" id="aclass_ogre_1_1_plane_html"><div class="ttname"><a href="class_ogre_1_1_plane.html">Ogre::Plane</a></div><div class="ttdoc">Defines a plane in 3D space.</div><div class="ttdef"><b>Definition</b> OgrePlane.h:65</div></div>
<div class="ttc" id="aclass_ogre_1_1_plane_html_a3f97462d3822f6add8c070048f6c2d92"><div class="ttname"><a href="class_ogre_1_1_plane.html#a3f97462d3822f6add8c070048f6c2d92">Ogre::Plane::normal</a></div><div class="ttdeci">Vector3 normal</div><div class="ttdef"><b>Definition</b> OgrePlane.h:67</div></div>
<div class="ttc" id="aclass_ogre_1_1_plane_html_a8e7de1712320968bee111002bc2938b8"><div class="ttname"><a href="class_ogre_1_1_plane.html#a8e7de1712320968bee111002bc2938b8">Ogre::Plane::d</a></div><div class="ttdeci">Real d</div><div class="ttdef"><b>Definition</b> OgrePlane.h:68</div></div>
</div><!-- fragment --><p> We've defined a plane by providing a distance from the origin (d) and a vector that is normal to our plane (normal). By choosing the the ''negative'' unit vector along the y-axis we have a plane that is parallel to the ground and facing downwards.</p>
<p>Now we can create the SkyPlane. </p><div class="fragment"><div class="line">mSceneMgr-&gt;setSkyPlane(<span class="keyword">true</span>, plane, <span class="stringliteral">&quot;Examples/SpaceSkyPlane&quot;</span>, 1500, 75);</div>
</div><!-- fragment --><p> The fourth parameter is the size of the SkyPlane (1500x1500 units), and the fifth parameter is number of times to tile the texture.</p>
<p>Compile and run your application. Again, the texture we are using is rather low-resolution. A high definition texture would look much better. It also doesn't tile very well. These issues can both be fixed by using higher quality resources. The real problem is that it is very likely a user will be able to see the end of the SkyPlane as soon as they move anywhere near the edge of the terrain. For this reason, a SkyPlane is often used most in scenes that have high walls. In these cases, a SkyPlane offers a decent increase in performance over the other techniques.</p>
<p>The SkyPlane has some other attributes that can be used to produce a better effect. The sixth parameter of the <code>setSkyPlane</code> method is the "renderFirst" parameter we covered for the past two methods. The seventh parameter allows us to specify a curvature for the SkyPlane. This will pull down the corners of the SkyPlane turning it into a curved surface instead of a flat plane. If we set the curvature to something other flat, we also need to set the number of segments <a class="el" href="namespace_ogre.html">Ogre</a> should use to render the SkyPlane. When the SkyPlane was a flat plane, everything was one large square, but if we add curvature, then it will require a more complicated geometry. The eighth and ninth parameters to the function are the number of segments for each dimension of the plane.</p>
<p>Let's test this out. Make these changes to our call: </p><div class="fragment"><div class="line">mSceneMgr-&gt;setSkyPlane(</div>
<div class="line">  <span class="keyword">true</span>, plane, <span class="stringliteral">&quot;Examples/SpaceSkyPlane&quot;</span>, 1500, 50, <span class="keyword">true</span>, 1.5, 150, 150);</div>
</div><!-- fragment --><p> Compile and run the application. This should help the look of our SkyPlane a bit. Go to the edge of the terrain to get a better look at what was done with the curvature. </p>
<h1><a class="anchor" id="tut_fog"></a>
Fog</h1>
<p>Like practically everything in graphics programming, the fog effect in <a class="el" href="namespace_ogre.html">Ogre</a> is an illusion. <a class="el" href="namespace_ogre.html">Ogre</a> does not render a fog object into our scene. Instead, it simply applies a filter to our scene. This filter allows the Viewport's background color to show through our scenery to varying degrees based on the object's distance from the Camera. What this means is that your fog will have the same color has your Viewport's background color.</p>
<p>There are two basic types of fog in <a class="el" href="namespace_ogre.html">Ogre</a>: linear and exponential. The difference is the rate at which the fog gets thicker as you move away from the Camera.</p>
<div class="image">
<img src="bt3_linear_exp_visual.png" alt=""/>
</div>
    <h2><a class="anchor" id="autotoc_md21"></a>
Adding Fog to Our Scene</h2>
<p>We will first add linear fog to our scene. We need to make sure to set our Viewport's background color to our desired fog color. Add the following to <code>setupContent</code> right before our code for setting up the terrain: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_ogre_1_1_colour_value.html">Ogre::ColourValue</a> fadeColour(0.9, 0.9, 0.9);</div>
<div class="line">mWindow-&gt;getViewport(0)-&gt;setBackgroundColour(fadeColour);</div>
<div class="ttc" id="aclass_ogre_1_1_colour_value_html"><div class="ttname"><a href="class_ogre_1_1_colour_value.html">Ogre::ColourValue</a></div><div class="ttdoc">Class representing colour.</div><div class="ttdef"><b>Definition</b> OgreColourValue.h:58</div></div>
</div><!-- fragment --><p> Make sure you add this before the terrain code otherwise it won't work. If you were using more than one Viewport, then you may have to iterate through them all by using <a class="el" href="class_ogre_1_1_render_target.html#aff766c0862f20c8dcf1590748dc857b6" title="Returns the number of viewports attached to this target.">Ogre::RenderTarget::getNumViewports</a>.</p>
<p>Now we can create the fog.</p>
<div class="fragment"><div class="line">        mSceneMgr-&gt;setFog(<a class="code hl_enumvalue" href="group___general.html#gga6467b107ce81cc71b8f2960409f7d897acd90839d2d222db939530a9fba6f9dad">Ogre::FOG_LINEAR</a>, <a class="code hl_struct" href="struct_ogre_1_1vector.html">fadeColour</a>, 0, 2000, 10000);</div>
<div class="ttc" id="agroup___general_html_gga6467b107ce81cc71b8f2960409f7d897acd90839d2d222db939530a9fba6f9dad"><div class="ttname"><a href="group___general.html#gga6467b107ce81cc71b8f2960409f7d897acd90839d2d222db939530a9fba6f9dad">Ogre::FOG_LINEAR</a></div><div class="ttdeci">@ FOG_LINEAR</div><div class="ttdoc">Fog density increases linearly between the start and end distances.</div><div class="ttdef"><b>Definition</b> OgreCommon.h:150</div></div>
</div><!-- fragment --><p>The first parameter is the fog type. The second parameter is the color we used to set our Viewport's background color. The third parameter is not used for linear fog. The fourth and fifth parameters specify the beginning and the end of the range for the fog. In our example, the fog will begin at 600 units out from the Camera, and it will end at 900 units. The reason this is called linear fog is because the thickness increases between these two values in a linear fashion. Compile and run your application.</p>
<p>The next type of fog is exponential fog. Like the picture suggests, exponential fog grows slowly at first and then gets dense very quickly. We do not set a range for this fog, instead we simply supply a desired density. </p><div class="fragment"><div class="line">mSceneMgr-&gt;setFog(<a class="code hl_enumvalue" href="group___general.html#gga6467b107ce81cc71b8f2960409f7d897a5c51ab0c88827f1f30b6c08a32f282a2">Ogre::FOG_EXP</a>, fadeColour, 0.002);</div>
<div class="ttc" id="agroup___general_html_gga6467b107ce81cc71b8f2960409f7d897a5c51ab0c88827f1f30b6c08a32f282a2"><div class="ttname"><a href="group___general.html#gga6467b107ce81cc71b8f2960409f7d897a5c51ab0c88827f1f30b6c08a32f282a2">Ogre::FOG_EXP</a></div><div class="ttdeci">@ FOG_EXP</div><div class="ttdoc">Fog density increases exponentially from the camera (fog = 1/e^(distance * density))</div><div class="ttdef"><b>Definition</b> OgreCommon.h:146</div></div>
</div><!-- fragment --><p> Compile and run the application. You can see this creates a different kind of fog effect. It is more like a haze that fills the area surrounding the Camera. There is a variation of the exponential fog that increases at a faster rate. </p><div class="fragment"><div class="line">mSceneMgr-&gt;setFog(<a class="code hl_enumvalue" href="group___general.html#gga6467b107ce81cc71b8f2960409f7d897ac3413d47a9e6c30ba39da21339bd1d7f">Ogre::FOG_EXP2</a>, fadeColour, 0.002);</div>
<div class="ttc" id="agroup___general_html_gga6467b107ce81cc71b8f2960409f7d897ac3413d47a9e6c30ba39da21339bd1d7f"><div class="ttname"><a href="group___general.html#gga6467b107ce81cc71b8f2960409f7d897ac3413d47a9e6c30ba39da21339bd1d7f">Ogre::FOG_EXP2</a></div><div class="ttdeci">@ FOG_EXP2</div><div class="ttdoc">Fog density increases at the square of FOG_EXP, i.e. even quicker (fog = 1/e^(distance * density)^2)</div><div class="ttdef"><b>Definition</b> OgreCommon.h:148</div></div>
</div><!-- fragment --><p> Compile and run your application to see the difference this makes. </p>
<h1><a class="anchor" id="conclusion3"></a>
Conclusion</h1>
<p>This tutorial covered the basics of using the <a class="el" href="namespace_ogre.html">Ogre</a> Terrain Component. We gave a brief overview of the setup that needs to be done to allow the importing of a terrain heightmap into our scene. We mentioned the notion of a <a class="el" href="class_ogre_1_1_terrain_group.html" title="Helper class to assist you in managing multiple terrain instances that are connected to each other.">Ogre::TerrainGroup</a> although we only used one <a class="el" href="class_ogre_1_1_terrain.html" title="The main containing class for a chunk of terrain.">Ogre::Terrain</a> object in our "group" for this tutorial. We also made sure to initialize our terrain with a directional light so that we would get specular reflections and shadows cast across our terrain.</p>
<p>We also covered the different methods <a class="el" href="namespace_ogre.html">Ogre</a> offers to simulate a sky in your scene. These included: SkyBoxes, SkyDomes, and SkyPlanes. Finally, we introduced <a class="el" href="namespace_ogre.html">Ogre</a>'s fog effects. Fog is rendered by applying a filter to our scene that allows the Viewport's background color to bleed through our scene based on distance from our Camera.</p>
<p>This is a tutorial that you should spend a lot of time experimenting with. All of these features can be configured a great deal, and you can create some very convincing scenes with just what we've covered so far. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
