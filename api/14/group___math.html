<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Math</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group___math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Math<div class="ingroups"><a class="el" href="group___core.html">Core</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_affine3.html">Ogre::Affine3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform specialization for 3D Affine - encapsulating a 3x4 Matrix.  <a href="class_ogre_1_1_affine3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_angle.html">Ogre::Angle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class which identifies a value as the currently default angle type, as defined by <a class="el" href="class_ogre_1_1_math.html#afb791263d1e8508fc75f698a20d96b87" title="These functions used to set the assumed angle units (radians or degrees) expected when using the Angl...">Math::setAngleUnit</a>.  <a href="class_ogre_1_1_angle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_axis_aligned_box.html">Ogre::AxisAlignedBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D box aligned with the x/y/z axes.  <a href="class_ogre_1_1_axis_aligned_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bitwise.html">Ogre::Bitwise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for manipulating bit patterns.  <a href="class_ogre_1_1_bitwise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_convex_body.html">Ogre::ConvexBody</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a solid representation of a convex body.  <a href="class_ogre_1_1_convex_body.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_degree.html">Ogre::Degree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class which indicates a given angle value is in Degrees.  <a href="class_ogre_1_1_degree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_dual_quaternion.html">Ogre::DualQuaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a dual quaternion, i.e.  <a href="class_ogre_1_1_dual_quaternion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_edge_data.html">Ogre::EdgeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the information required to describe the edge connectivity of a given set of vertices and indexes.  <a href="class_ogre_1_1_edge_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_edge_list_builder.html">Ogre::EdgeListBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General utility class for building edge lists for geometry.  <a href="class_ogre_1_1_edge_list_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_math.html">Ogre::Math</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to provide access to common mathematical functions.  <a href="class_ogre_1_1_math.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_matrix3.html">Ogre::Matrix3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix which can represent rotations around axes.  <a href="class_ogre_1_1_matrix3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_matrix4.html">Ogre::Matrix4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform specialization for projective - encapsulating a 4x4 Matrix.  <a href="class_ogre_1_1_matrix4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_optimised_util.html">Ogre::OptimisedUtil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for provides optimised functions.  <a href="class_ogre_1_1_optimised_util.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_plane.html">Ogre::Plane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a plane in 3D space.  <a href="class_ogre_1_1_plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_plane_bounded_volume.html">Ogre::PlaneBoundedVolume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a convex volume bounded by planes.  <a href="class_ogre_1_1_plane_bounded_volume.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_polygon.html">Ogre::Polygon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class represents a polygon in 3D space.  <a href="class_ogre_1_1_polygon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_quaternion.html">Ogre::Quaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a <a class="el" href="class_ogre_1_1_quaternion.html" title="Implementation of a Quaternion, i.e.">Quaternion</a>, i.e.  <a href="class_ogre_1_1_quaternion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_radian.html">Ogre::Radian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class which indicates a given angle value is in Radians.  <a href="class_ogre_1_1_radian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_ray.html">Ogre::Ray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a ray in space, i.e.  <a href="class_ogre_1_1_ray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_rotational_spline.html">Ogre::RotationalSpline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class interpolates orientations (rotations) along a spline using derivatives of quaternions.  <a href="class_ogre_1_1_rotational_spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_simple_spline.html">Ogre::SimpleSpline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very simple spline class which implements the Catmull-Rom class of splines.  <a href="class_ogre_1_1_simple_spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_sphere.html">Ogre::Sphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sphere primitive, mostly used for bounds checking.  <a href="class_ogre_1_1_sphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_tangent_space_calc.html">Ogre::TangentSpaceCalc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for calculating a tangent space basis.  <a href="class_ogre_1_1_tangent_space_calc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_transform_base.html">Ogre::TransformBase&lt; rows, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class encapsulating a standard 4x4 homogeneous matrix.  <a href="class_ogre_1_1_transform_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_transform_base_real.html">Ogre::TransformBaseReal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vector.html">Ogre::Vector&lt; dims, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard N-dimensional vector.  <a href="class_ogre_1_1_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase&lt; dims, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class to implement legacy API. Notably x, y, z access  <a href="struct_ogre_1_1_vector_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_vector_base_3_012_00_01_real_01_4.html">Ogre::VectorBase&lt; 2, Real &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_vector_base_3_013_00_01_real_01_4.html">Ogre::VectorBase&lt; 3, Real &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_vector_base_3_014_00_01_real_01_4.html">Ogre::VectorBase&lt; 4, Real &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf6bda7879d1ac92561a02cbd1833e1b1" id="r_gaf6bda7879d1ac92561a02cbd1833e1b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">typedef</a> std::vector&lt; <a class="el" href="class_ogre_1_1_plane_bounded_volume.html">PlaneBoundedVolume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaf6bda7879d1ac92561a02cbd1833e1b1">Ogre::PlaneBoundedVolumeList</a></td></tr>
<tr class="separator:gaf6bda7879d1ac92561a02cbd1833e1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cfa65f236aec1767fc85022e87059a0" id="r_ga4cfa65f236aec1767fc85022e87059a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">typedef</a> std::vector&lt; <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga4cfa65f236aec1767fc85022e87059a0">Ogre::PlaneList</a></td></tr>
<tr class="separator:ga4cfa65f236aec1767fc85022e87059a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f791f5ff19bd8395f0008085e68bf10" id="r_ga3f791f5ff19bd8395f0008085e68bf10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">typedef</a> std::pair&lt; <a class="el" href="struct_ogre_1_1vector.html">bool</a>, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">Ogre::RayTestResult</a></td></tr>
<tr class="memdesc:ga3f791f5ff19bd8395f0008085e68bf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair structure where the first element indicates whether an intersection occurs.  <br /></td></tr>
<tr class="separator:ga3f791f5ff19bd8395f0008085e68bf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae928a6c0bafde7b018e386ed94d76a84" id="r_gae928a6c0bafde7b018e386ed94d76a84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gae928a6c0bafde7b018e386ed94d76a84">Ogre::Radian::Radian</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;d)</td></tr>
<tr class="separator:gae928a6c0bafde7b018e386ed94d76a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga088106a9fc8539d9e0912c04a11f4ee6" id="r_ga088106a9fc8539d9e0912c04a11f4ee6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="struct_ogre_1_1vector.html">class</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </td></tr>
<tr class="memitem:ga088106a9fc8539d9e0912c04a11f4ee6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga088106a9fc8539d9e0912c04a11f4ee6">Ogre::advanceRawPointer</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> *&amp;ptr, <a class="el" href="struct_ogre_1_1vector.html">ptrdiff_t</a> offset)</td></tr>
<tr class="memdesc:ga088106a9fc8539d9e0912c04a11f4ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the pointer with raw offset.  <br /></td></tr>
<tr class="separator:ga088106a9fc8539d9e0912c04a11f4ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11dd7b55041c012f5d6e82d98d39cce1" id="r_ga11dd7b55041c012f5d6e82d98d39cce1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="struct_ogre_1_1vector.html">class</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </td></tr>
<tr class="memitem:ga11dd7b55041c012f5d6e82d98d39cce1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga11dd7b55041c012f5d6e82d98d39cce1">Ogre::advanceRawPointer</a> (<a class="el" href="struct_ogre_1_1vector.html">T</a> *&amp;ptr, <a class="el" href="struct_ogre_1_1vector.html">ptrdiff_t</a> offset)</td></tr>
<tr class="separator:ga11dd7b55041c012f5d6e82d98d39cce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a92915df275eae8161441024d88c815" id="r_ga7a92915df275eae8161441024d88c815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga7a92915df275eae8161441024d88c815">Ogre::VectorBase&lt; 2, Real &gt;::angleTo</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> &amp;other) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ga7a92915df275eae8161441024d88c815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the oriented angle between 2 vectors.  <br /></td></tr>
<tr class="separator:ga7a92915df275eae8161441024d88c815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga813d02a0ee4c69dab452767fba1cef8a" id="r_ga813d02a0ee4c69dab452767fba1cef8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga813d02a0ee4c69dab452767fba1cef8a">Ogre::Math::calculateBasicFaceNormal</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v1, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v2, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">v3</a>)</td></tr>
<tr class="memdesc:ga813d02a0ee4c69dab452767fba1cef8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a face normal, no w-information.  <br /></td></tr>
<tr class="separator:ga813d02a0ee4c69dab452767fba1cef8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcc5bd946f4c1fb73b851493e17b11b3" id="r_gabcc5bd946f4c1fb73b851493e17b11b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gabcc5bd946f4c1fb73b851493e17b11b3">Ogre::Math::calculateBasicFaceNormalWithoutNormalize</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v1, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v2, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">v3</a>)</td></tr>
<tr class="memdesc:gabcc5bd946f4c1fb73b851493e17b11b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a face normal without normalize, no w-information.  <br /></td></tr>
<tr class="separator:gabcc5bd946f4c1fb73b851493e17b11b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ba1fde5b6a0056fd637d4e6b781a2a" id="r_gae5ba1fde5b6a0056fd637d4e6b781a2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gae5ba1fde5b6a0056fd637d4e6b781a2a">Ogre::Math::calculateFaceNormal</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v1, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v2, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">v3</a>)</td></tr>
<tr class="memdesc:gae5ba1fde5b6a0056fd637d4e6b781a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a face normal, including the w component which is the offset from the origin.  <br /></td></tr>
<tr class="separator:gae5ba1fde5b6a0056fd637d4e6b781a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc24b5e11a3a613f60dc44f6056dc61c" id="r_gabc24b5e11a3a613f60dc44f6056dc61c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gabc24b5e11a3a613f60dc44f6056dc61c">Ogre::Math::calculateFaceNormalWithoutNormalize</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v1, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v2, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">v3</a>)</td></tr>
<tr class="memdesc:gabc24b5e11a3a613f60dc44f6056dc61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a face normal without normalize, including the w component which is the offset from the origin.  <br /></td></tr>
<tr class="separator:gabc24b5e11a3a613f60dc44f6056dc61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe9157bbe30e69645edd5c3eddea141f" id="r_gafe9157bbe30e69645edd5c3eddea141f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gafe9157bbe30e69645edd5c3eddea141f">Ogre::VectorBase&lt; 3, Real &gt;::crossProduct</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">rkVector</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:gafe9157bbe30e69645edd5c3eddea141f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cross-product of 2 vectors, i.e.  <br /></td></tr>
<tr class="separator:gafe9157bbe30e69645edd5c3eddea141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67db81d99c63e2483ff8bc314bfd36c" id="r_gad67db81d99c63e2483ff8bc314bfd36c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gad67db81d99c63e2483ff8bc314bfd36c">Ogre::VectorBase&lt; 3, Real &gt;::directionEquals</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">rhs</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">tolerance</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:gad67db81d99c63e2483ff8bc314bfd36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this vector is within a directional tolerance of another vector.  <br /></td></tr>
<tr class="separator:gad67db81d99c63e2483ff8bc314bfd36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ef79da21101ef5a671b0473b849bc3" id="r_gac6ef79da21101ef5a671b0473b849bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gac6ef79da21101ef5a671b0473b849bc3">Ogre::VectorBase&lt; 3, Real &gt;::getRotationTo</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">dest</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">fallbackAxis</a>=<a class="el" href="struct_ogre_1_1_vector_base_3_013_00_01_real_01_4.html#a3353094e7989fcd4774b9147750990bc">ZERO</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:gac6ef79da21101ef5a671b0473b849bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shortest arc quaternion to rotate this vector to the destination vector.  <br /></td></tr>
<tr class="separator:gac6ef79da21101ef5a671b0473b849bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e9b9df69bd3255f3b64254e66c3321" id="r_gab3e9b9df69bd3255f3b64254e66c3321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gab3e9b9df69bd3255f3b64254e66c3321">Ogre::Math::intersects</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;plane, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">box</a>)</td></tr>
<tr class="memdesc:gab3e9b9df69bd3255f3b64254e66c3321"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_plane.html" title="Defines a plane in 3D space.">Plane</a> / box intersection test.  <br /></td></tr>
<tr class="separator:gab3e9b9df69bd3255f3b64254e66c3321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc5955de7b6ba0dfa860cc751c6321db" id="r_gafc5955de7b6ba0dfa860cc751c6321db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">RayTestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gafc5955de7b6ba0dfa860cc751c6321db">Ogre::Math::intersects</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_ray.html">Ray</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">ray</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;plane)</td></tr>
<tr class="memdesc:gafc5955de7b6ba0dfa860cc751c6321db"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_ray.html" title="Representation of a ray in space, i.e.">Ray</a> / plane intersection.  <br /></td></tr>
<tr class="separator:gafc5955de7b6ba0dfa860cc751c6321db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64ed9272da4fcaccd8b1009a31358c61" id="r_ga64ed9272da4fcaccd8b1009a31358c61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">RayTestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga64ed9272da4fcaccd8b1009a31358c61">Ogre::Math::intersects</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_ray.html">Ray</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">ray</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">sphere</a>, <a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">discardInside</a>=<a class="el" href="struct_ogre_1_1vector.html">true</a>)</td></tr>
<tr class="memdesc:ga64ed9272da4fcaccd8b1009a31358c61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_ray.html" title="Representation of a ray in space, i.e.">Ray</a> / sphere intersection.  <br /></td></tr>
<tr class="separator:ga64ed9272da4fcaccd8b1009a31358c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04786a5e338650d6eafc987b394d221c" id="r_ga04786a5e338650d6eafc987b394d221c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga04786a5e338650d6eafc987b394d221c">Ogre::Math::intersects</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">sphere</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;plane)</td></tr>
<tr class="memdesc:ga04786a5e338650d6eafc987b394d221c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_sphere.html" title="A sphere primitive, mostly used for bounds checking.">Sphere</a> / plane intersection test.  <br /></td></tr>
<tr class="separator:ga04786a5e338650d6eafc987b394d221c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40391520c06bafb34a8647931fab8e1" id="r_gae40391520c06bafb34a8647931fab8e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gae40391520c06bafb34a8647931fab8e1">Ogre::Math::lookRotation</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">direction</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;yaw)</td></tr>
<tr class="memdesc:gae40391520c06bafb34a8647931fab8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rotation matrix from direction and yaw.  <br /></td></tr>
<tr class="separator:gae40391520c06bafb34a8647931fab8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4345346666fd54473efb51a8d194f5e0" id="r_ga4345346666fd54473efb51a8d194f5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga4345346666fd54473efb51a8d194f5e0">Ogre::VectorBase&lt; 2, Real &gt;::midPoint</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">vec</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ga4345346666fd54473efb51a8d194f5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector at a point half way between this and the passed in vector.  <br /></td></tr>
<tr class="separator:ga4345346666fd54473efb51a8d194f5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929562516cfb30c38030d9df84945bf3" id="r_ga929562516cfb30c38030d9df84945bf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga929562516cfb30c38030d9df84945bf3">Ogre::VectorBase&lt; 3, Real &gt;::midPoint</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">vec</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ga929562516cfb30c38030d9df84945bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector at a point half way between this and the passed in vector.  <br /></td></tr>
<tr class="separator:ga929562516cfb30c38030d9df84945bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166c0b2a2264eac93345461f93005b6e" id="r_ga166c0b2a2264eac93345461f93005b6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga166c0b2a2264eac93345461f93005b6e">Ogre::Angle::operator Degree</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="separator:ga166c0b2a2264eac93345461f93005b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f6b1190c20ab261874497f6bbb7dfd" id="r_gaf5f6b1190c20ab261874497f6bbb7dfd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaf5f6b1190c20ab261874497f6bbb7dfd">Ogre::Angle::operator Radian</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="separator:gaf5f6b1190c20ab261874497f6bbb7dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ad543ded2a895ca3cb655acde809d6f" id="r_ga4ad543ded2a895ca3cb655acde809d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_affine3.html">Affine3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga4ad543ded2a895ca3cb655acde809d6f">Ogre::operator*</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;m, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">m2</a>)</td></tr>
<tr class="separator:ga4ad543ded2a895ca3cb655acde809d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b5572666ec9a5a8c199d5289cd93bc" id="r_ga15b5572666ec9a5a8c199d5289cd93bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga15b5572666ec9a5a8c199d5289cd93bc">Ogre::operator*</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;m, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v)</td></tr>
<tr class="memdesc:ga15b5572666ec9a5a8c199d5289cd93bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ga15b5572666ec9a5a8c199d5289cd93bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3edf0891dcf445e20821a0504f53b5c4" id="r_ga3edf0891dcf445e20821a0504f53b5c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga3edf0891dcf445e20821a0504f53b5c4">Ogre::operator*</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;m, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> &amp;v)</td></tr>
<tr class="separator:ga3edf0891dcf445e20821a0504f53b5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4194c1302dc1f5f13904688d5aa0bc1c" id="r_ga4194c1302dc1f5f13904688d5aa0bc1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga4194c1302dc1f5f13904688d5aa0bc1c">Ogre::operator*</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;m, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v)</td></tr>
<tr class="memdesc:ga4194c1302dc1f5f13904688d5aa0bc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix * vector [3x3 * 3x1 = 3x1].  <br /></td></tr>
<tr class="separator:ga4194c1302dc1f5f13904688d5aa0bc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8283a37796cfb2426008099ba8a46e5f" id="r_ga8283a37796cfb2426008099ba8a46e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga8283a37796cfb2426008099ba8a46e5f">Ogre::operator*</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">m2</a>)</td></tr>
<tr class="separator:ga8283a37796cfb2426008099ba8a46e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fec6369363b2abbb7a66f363c25c765" id="r_ga0fec6369363b2abbb7a66f363c25c765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga0fec6369363b2abbb7a66f363c25c765">Ogre::operator*</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v)</td></tr>
<tr class="memdesc:ga0fec6369363b2abbb7a66f363c25c765"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_vector.html" title="Standard N-dimensional vector.">Vector</a> transformation using '*'.  <br /></td></tr>
<tr class="separator:ga0fec6369363b2abbb7a66f363c25c765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74f8fe372c36a629f723be7ad92b9573" id="r_ga74f8fe372c36a629f723be7ad92b9573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga74f8fe372c36a629f723be7ad92b9573">Ogre::operator*</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> &amp;v)</td></tr>
<tr class="separator:ga74f8fe372c36a629f723be7ad92b9573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a819ee09ac0c63510f0079ba2bf2a3f" id="r_ga2a819ee09ac0c63510f0079ba2bf2a3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_plane.html">Plane</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga2a819ee09ac0c63510f0079ba2bf2a3f">Ogre::operator*</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">mat</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">p</a>)</td></tr>
<tr class="separator:ga2a819ee09ac0c63510f0079ba2bf2a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98d9fe8e0bd1f28f9fed1009cd745dd" id="r_gab98d9fe8e0bd1f28f9fed1009cd745dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gab98d9fe8e0bd1f28f9fed1009cd745dd">Ogre::operator*</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> &amp;v, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">mat</a>)</td></tr>
<tr class="separator:gab98d9fe8e0bd1f28f9fed1009cd745dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a0c74584c55abd8651c0e87321a485" id="r_ga98a0c74584c55abd8651c0e87321a485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_degree.html">Degree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga98a0c74584c55abd8651c0e87321a485">Ogre::operator*</a> (<a class="el" href="struct_ogre_1_1vector.html">float</a> a, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;b)</td></tr>
<tr class="separator:ga98a0c74584c55abd8651c0e87321a485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2866120e163a6ec8c8b03d2c9ca3951" id="r_gaa2866120e163a6ec8c8b03d2c9ca3951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaa2866120e163a6ec8c8b03d2c9ca3951">Ogre::operator*</a> (<a class="el" href="struct_ogre_1_1vector.html">float</a> a, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;b)</td></tr>
<tr class="separator:gaa2866120e163a6ec8c8b03d2c9ca3951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aee68f4913cf646f4fa3c046a18ee60" id="r_ga6aee68f4913cf646f4fa3c046a18ee60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga6aee68f4913cf646f4fa3c046a18ee60">Ogre::Radian::operator+</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;d) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="separator:ga6aee68f4913cf646f4fa3c046a18ee60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd40f27f78ed1fe8e59df586b53be488" id="r_gadd40f27f78ed1fe8e59df586b53be488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gadd40f27f78ed1fe8e59df586b53be488">Ogre::operator+</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">m2</a>)</td></tr>
<tr class="memdesc:gadd40f27f78ed1fe8e59df586b53be488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix addition.  <br /></td></tr>
<tr class="separator:gadd40f27f78ed1fe8e59df586b53be488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5147935125e28f53cb19d70055bc88" id="r_gaed5147935125e28f53cb19d70055bc88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaed5147935125e28f53cb19d70055bc88">Ogre::Radian::operator+=</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;d)</td></tr>
<tr class="separator:gaed5147935125e28f53cb19d70055bc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05fd614aac352a71e17d8eb559578d7b" id="r_ga05fd614aac352a71e17d8eb559578d7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga05fd614aac352a71e17d8eb559578d7b">Ogre::Radian::operator-</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;d) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="separator:ga05fd614aac352a71e17d8eb559578d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6c12700fc4b4d2d5947166ef459ae3" id="r_ga7c6c12700fc4b4d2d5947166ef459ae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga7c6c12700fc4b4d2d5947166ef459ae3">Ogre::operator-</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">m2</a>)</td></tr>
<tr class="memdesc:ga7c6c12700fc4b4d2d5947166ef459ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix subtraction.  <br /></td></tr>
<tr class="separator:ga7c6c12700fc4b4d2d5947166ef459ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223a82b9ff74351959eee91a335e7cdb" id="r_ga223a82b9ff74351959eee91a335e7cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga223a82b9ff74351959eee91a335e7cdb">Ogre::Radian::operator-=</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;d)</td></tr>
<tr class="separator:ga223a82b9ff74351959eee91a335e7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec05237e1f0696cbd0f50393e4aea0e" id="r_ga5ec05237e1f0696cbd0f50393e4aea0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_degree.html">Degree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga5ec05237e1f0696cbd0f50393e4aea0e">Ogre::operator/</a> (<a class="el" href="struct_ogre_1_1vector.html">float</a> a, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;b)</td></tr>
<tr class="separator:ga5ec05237e1f0696cbd0f50393e4aea0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c940df49c0d61086dfe8525247a15ab" id="r_ga6c940df49c0d61086dfe8525247a15ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga6c940df49c0d61086dfe8525247a15ab">Ogre::operator/</a> (<a class="el" href="struct_ogre_1_1vector.html">float</a> a, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;b)</td></tr>
<tr class="separator:ga6c940df49c0d61086dfe8525247a15ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafab8ce89cde3034f3cc5c2537d5ea6fd" id="r_gafab8ce89cde3034f3cc5c2537d5ea6fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gafab8ce89cde3034f3cc5c2537d5ea6fd">Ogre::Radian::operator=</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;d)</td></tr>
<tr class="separator:gafab8ce89cde3034f3cc5c2537d5ea6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00e57f3eda32e31277c439e6a9c929a1" id="r_ga00e57f3eda32e31277c439e6a9c929a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga00e57f3eda32e31277c439e6a9c929a1">Ogre::VectorBase&lt; 2, Real &gt;::perpendicular</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ga00e57f3eda32e31277c439e6a9c929a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a vector perpendicular to this vector (eg an 'up' vector).  <br /></td></tr>
<tr class="separator:ga00e57f3eda32e31277c439e6a9c929a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b50a2b2697ec1ac684d66af82a03296" id="r_ga5b50a2b2697ec1ac684d66af82a03296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga5b50a2b2697ec1ac684d66af82a03296">Ogre::VectorBase&lt; 3, Real &gt;::perpendicular</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ga5b50a2b2697ec1ac684d66af82a03296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a vector perpendicular to this vector (eg an 'up' vector).  <br /></td></tr>
<tr class="separator:ga5b50a2b2697ec1ac684d66af82a03296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24dd46458beb0ea8175bfbf916f09e47" id="r_ga24dd46458beb0ea8175bfbf916f09e47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga24dd46458beb0ea8175bfbf916f09e47">Ogre::VectorBase&lt; 3, Real &gt;::positionCloses</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">rhs</a>, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="struct_ogre_1_1vector.html">tolerance</a>=1<a class="el" href="struct_ogre_1_1vector.html">e</a>-03<a class="el" href="struct_ogre_1_1vector.html">f</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ga24dd46458beb0ea8175bfbf916f09e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this vector is within a positional tolerance of another vector, also take scale of the vectors into account.  <br /></td></tr>
<tr class="separator:ga24dd46458beb0ea8175bfbf916f09e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad52e72c687842e8475a5f24cde8cd858" id="r_gad52e72c687842e8475a5f24cde8cd858"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gad52e72c687842e8475a5f24cde8cd858">Ogre::VectorBase&lt; 3, Real &gt;::primaryAxis</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:gad52e72c687842e8475a5f24cde8cd858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the primary (dominant) axis from this direction vector.  <br /></td></tr>
<tr class="separator:gad52e72c687842e8475a5f24cde8cd858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f54a2dd6b60dd327fcc8347fc4d853d" id="r_ga4f54a2dd6b60dd327fcc8347fc4d853d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga4f54a2dd6b60dd327fcc8347fc4d853d">Ogre::VectorBase&lt; 3, Real &gt;::randomDeviant</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">angle</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">up</a>=<a class="el" href="struct_ogre_1_1_vector_base_3_013_00_01_real_01_4.html#a3353094e7989fcd4774b9147750990bc">ZERO</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ga4f54a2dd6b60dd327fcc8347fc4d853d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new random vector which deviates from this vector by a given angle in a random direction.  <br /></td></tr>
<tr class="separator:ga4f54a2dd6b60dd327fcc8347fc4d853d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba43517feb82c40ccf1cc571f519866c" id="r_gaba43517feb82c40ccf1cc571f519866c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaba43517feb82c40ccf1cc571f519866c">Ogre::VectorBase&lt; 2, Real &gt;::randomDeviant</a> (<a class="el" href="class_ogre_1_1_radian.html">Radian</a> <a class="el" href="struct_ogre_1_1vector.html">angle</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:gaba43517feb82c40ccf1cc571f519866c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new random vector which deviates from this vector by a given angle in a random direction.  <br /></td></tr>
<tr class="separator:gaba43517feb82c40ccf1cc571f519866c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab35701a51537a7a1591982f4ca68ec9" id="r_gaab35701a51537a7a1591982f4ca68ec9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="struct_ogre_1_1vector.html">class</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </td></tr>
<tr class="memitem:gaab35701a51537a7a1591982f4ca68ec9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gaab35701a51537a7a1591982f4ca68ec9">Ogre::rawOffsetPointer</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> *ptr, <a class="el" href="struct_ogre_1_1vector.html">ptrdiff_t</a> offset)</td></tr>
<tr class="memdesc:gaab35701a51537a7a1591982f4ca68ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns raw offsetted of the given pointer.  <br /></td></tr>
<tr class="separator:gaab35701a51537a7a1591982f4ca68ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc626df0e0e3cd90836235d97a2b90e9" id="r_gabc626df0e0e3cd90836235d97a2b90e9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="struct_ogre_1_1vector.html">class</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </td></tr>
<tr class="memitem:gabc626df0e0e3cd90836235d97a2b90e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gabc626df0e0e3cd90836235d97a2b90e9">Ogre::rawOffsetPointer</a> (<a class="el" href="struct_ogre_1_1vector.html">T</a> *ptr, <a class="el" href="struct_ogre_1_1vector.html">ptrdiff_t</a> offset)</td></tr>
<tr class="separator:gabc626df0e0e3cd90836235d97a2b90e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebc7c568cc1d6f13405a756be1af73fa" id="r_gaebc7c568cc1d6f13405a756be1af73fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaebc7c568cc1d6f13405a756be1af73fa">Ogre::TransformBaseReal::transpose</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="separator:gaebc7c568cc1d6f13405a756be1af73fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0e1b281e33d85e3364aeaa49c8ef2f5" id="r_gae0e1b281e33d85e3364aeaa49c8ef2f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gae0e1b281e33d85e3364aeaa49c8ef2f5">Ogre::Radian::valueAngleUnits</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="separator:gae0e1b281e33d85e3364aeaa49c8ef2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fd64f1fc097bf4724b4713ff76cdfcd" id="r_ga1fd64f1fc097bf4724b4713ff76cdfcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga1fd64f1fc097bf4724b4713ff76cdfcd">Ogre::Degree::valueAngleUnits</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="separator:ga1fd64f1fc097bf4724b4713ff76cdfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac273cad14f6c100d692d7235919fe7f" id="r_gaac273cad14f6c100d692d7235919fe7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaac273cad14f6c100d692d7235919fe7f">Ogre::Radian::valueDegrees</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="separator:gaac273cad14f6c100d692d7235919fe7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01235157bea1375e48ed73634a6f9a18" id="r_ga01235157bea1375e48ed73634a6f9a18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga01235157bea1375e48ed73634a6f9a18">Ogre::Degree::valueRadians</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="separator:ga01235157bea1375e48ed73634a6f9a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga3f791f5ff19bd8395f0008085e68bf10" name="ga3f791f5ff19bd8395f0008085e68bf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f791f5ff19bd8395f0008085e68bf10">&#9670;&#160;</a></span>RayTestResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">typedef</a> std::pair&lt;<a class="el" href="struct_ogre_1_1vector.html">bool</a>, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&gt; <a class="el" href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">Ogre::RayTestResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pair structure where the first element indicates whether an intersection occurs. </p>
<p>if true, the second element will indicate the distance along the ray at which it intersects. This can be converted to a point in space by calling <a class="el" href="class_ogre_1_1_ray.html#a81a7ec16f410cedf5c279152230bf67b" title="Gets the position of a point t units along the ray.">Ray::getPoint()</a>. </p>

</div>
</div>
<a id="ga4cfa65f236aec1767fc85022e87059a0" name="ga4cfa65f236aec1767fc85022e87059a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cfa65f236aec1767fc85022e87059a0">&#9670;&#160;</a></span>PlaneList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">typedef</a> std::vector&lt;<a class="el" href="class_ogre_1_1_plane.html">Plane</a>&gt; <a class="el" href="group___math.html#ga4cfa65f236aec1767fc85022e87059a0">Ogre::PlaneList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf6bda7879d1ac92561a02cbd1833e1b1" name="gaf6bda7879d1ac92561a02cbd1833e1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6bda7879d1ac92561a02cbd1833e1b1">&#9670;&#160;</a></span>PlaneBoundedVolumeList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">typedef</a> std::vector&lt;<a class="el" href="class_ogre_1_1_plane_bounded_volume.html">PlaneBoundedVolume</a>&gt; <a class="el" href="group___math.html#gaf6bda7879d1ac92561a02cbd1833e1b1">Ogre::PlaneBoundedVolumeList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa2866120e163a6ec8c8b03d2c9ca3951" name="gaa2866120e163a6ec8c8b03d2c9ca3951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2866120e163a6ec8c8b03d2c9ca3951">&#9670;&#160;</a></span>operator*() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">float</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_radian.html#accbf4796a0cf6d9703fc8dff822933c9">Ogre::Radian::valueRadians()</a>.</p>

</div>
</div>
<a id="ga6c940df49c0d61086dfe8525247a15ab" name="ga6c940df49c0d61086dfe8525247a15ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c940df49c0d61086dfe8525247a15ab">&#9670;&#160;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">float</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_radian.html#accbf4796a0cf6d9703fc8dff822933c9">Ogre::Radian::valueRadians()</a>.</p>

</div>
</div>
<a id="ga98a0c74584c55abd8651c0e87321a485" name="ga98a0c74584c55abd8651c0e87321a485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98a0c74584c55abd8651c0e87321a485">&#9670;&#160;</a></span>operator*() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_degree.html">Degree</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">float</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_degree.html#ae7ec7b667395a6e9fb79a92c55a9c5ec">Ogre::Degree::valueDegrees()</a>.</p>

</div>
</div>
<a id="ga5ec05237e1f0696cbd0f50393e4aea0e" name="ga5ec05237e1f0696cbd0f50393e4aea0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ec05237e1f0696cbd0f50393e4aea0e">&#9670;&#160;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_degree.html">Degree</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">float</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_degree.html#ae7ec7b667395a6e9fb79a92c55a9c5ec">Ogre::Degree::valueDegrees()</a>.</p>

</div>
</div>
<a id="ga4194c1302dc1f5f13904688d5aa0bc1c" name="ga4194c1302dc1f5f13904688d5aa0bc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4194c1302dc1f5f13904688d5aa0bc1c">&#9670;&#160;</a></span>operator*() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix * vector [3x3 * 3x1 = 3x1]. </p>

</div>
</div>
<a id="ga8283a37796cfb2426008099ba8a46e5f" name="ga8283a37796cfb2426008099ba8a46e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8283a37796cfb2426008099ba8a46e5f">&#9670;&#160;</a></span>operator*() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gadd40f27f78ed1fe8e59df586b53be488" name="gadd40f27f78ed1fe8e59df586b53be488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd40f27f78ed1fe8e59df586b53be488">&#9670;&#160;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix addition. </p>

</div>
</div>
<a id="ga7c6c12700fc4b4d2d5947166ef459ae3" name="ga7c6c12700fc4b4d2d5947166ef459ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c6c12700fc4b4d2d5947166ef459ae3">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix subtraction. </p>

</div>
</div>
<a id="ga4ad543ded2a895ca3cb655acde809d6f" name="ga4ad543ded2a895ca3cb655acde809d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ad543ded2a895ca3cb655acde809d6f">&#9670;&#160;</a></span>operator*() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0fec6369363b2abbb7a66f363c25c765" name="ga0fec6369363b2abbb7a66f363c25c765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fec6369363b2abbb7a66f363c25c765">&#9670;&#160;</a></span>operator*() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_vector.html" title="Standard N-dimensional vector.">Vector</a> transformation using '*'. </p>
<p>Transforms the given 3-D vector by the matrix, projecting the result back into <em>w</em> = 1. </p><dl class="section note"><dt>Note</dt><dd>This means that the initial <em>w</em> is considered to be 1.0, and then all the tree elements of the resulting 3-D vector are divided by the resulting <em>w</em>. </dd></dl>

</div>
</div>
<a id="ga15b5572666ec9a5a8c199d5289cd93bc" name="ga15b5572666ec9a5a8c199d5289cd93bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15b5572666ec9a5a8c199d5289cd93bc">&#9670;&#160;</a></span>operator*() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga74f8fe372c36a629f723be7ad92b9573" name="ga74f8fe372c36a629f723be7ad92b9573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74f8fe372c36a629f723be7ad92b9573">&#9670;&#160;</a></span>operator*() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3edf0891dcf445e20821a0504f53b5c4" name="ga3edf0891dcf445e20821a0504f53b5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3edf0891dcf445e20821a0504f53b5c4">&#9670;&#160;</a></span>operator*() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gab98d9fe8e0bd1f28f9fed1009cd745dd" name="gab98d9fe8e0bd1f28f9fed1009cd745dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab98d9fe8e0bd1f28f9fed1009cd745dd">&#9670;&#160;</a></span>operator*() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaab35701a51537a7a1591982f4ca68ec9" name="gaab35701a51537a7a1591982f4ca68ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab35701a51537a7a1591982f4ca68ec9">&#9670;&#160;</a></span>rawOffsetPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1vector.html">class</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> * Ogre::rawOffsetPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">ptrdiff_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns raw offsetted of the given pointer. </p>
<dl class="section note"><dt>Note</dt><dd>The offset are in bytes, no matter what type of the pointer. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group___math.html#ga088106a9fc8539d9e0912c04a11f4ee6">Ogre::advanceRawPointer()</a>, and <a class="el" href="group___math.html#ga11dd7b55041c012f5d6e82d98d39cce1">Ogre::advanceRawPointer()</a>.</p>

</div>
</div>
<a id="gabc626df0e0e3cd90836235d97a2b90e9" name="gabc626df0e0e3cd90836235d97a2b90e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc626df0e0e3cd90836235d97a2b90e9">&#9670;&#160;</a></span>rawOffsetPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1vector.html">class</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> * Ogre::rawOffsetPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">T</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">ptrdiff_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga088106a9fc8539d9e0912c04a11f4ee6" name="ga088106a9fc8539d9e0912c04a11f4ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga088106a9fc8539d9e0912c04a11f4ee6">&#9670;&#160;</a></span>advanceRawPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1vector.html">class</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::advanceRawPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">ptrdiff_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance the pointer with raw offset. </p>
<dl class="section note"><dt>Note</dt><dd>The offset are in bytes, no matter what type of the pointer. </dd></dl>

<p class="reference">References <a class="el" href="group___math.html#gaab35701a51537a7a1591982f4ca68ec9">Ogre::rawOffsetPointer()</a>.</p>

</div>
</div>
<a id="ga11dd7b55041c012f5d6e82d98d39cce1" name="ga11dd7b55041c012f5d6e82d98d39cce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11dd7b55041c012f5d6e82d98d39cce1">&#9670;&#160;</a></span>advanceRawPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1vector.html">class</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::advanceRawPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">T</a> *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">ptrdiff_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group___math.html#gaab35701a51537a7a1591982f4ca68ec9">Ogre::rawOffsetPointer()</a>.</p>

</div>
</div>
<a id="ga2a819ee09ac0c63510f0079ba2bf2a3f" name="ga2a819ee09ac0c63510f0079ba2bf2a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a819ee09ac0c63510f0079ba2bf2a3f">&#9670;&#160;</a></span>operator*() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_plane.html">Plane</a> <a class="el" href="struct_ogre_1_1vector.html">Ogre::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gae928a6c0bafde7b018e386ed94d76a84" name="gae928a6c0bafde7b018e386ed94d76a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae928a6c0bafde7b018e386ed94d76a84">&#9670;&#160;</a></span>Radian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Radian::Radian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gafab8ce89cde3034f3cc5c2537d5ea6fd" name="gafab8ce89cde3034f3cc5c2537d5ea6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafab8ce89cde3034f3cc5c2537d5ea6fd">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp; Ogre::Radian::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group___math.html#ga01235157bea1375e48ed73634a6f9a18">Ogre::Degree::valueRadians()</a>.</p>

</div>
</div>
<a id="ga6aee68f4913cf646f4fa3c046a18ee60" name="ga6aee68f4913cf646f4fa3c046a18ee60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aee68f4913cf646f4fa3c046a18ee60">&#9670;&#160;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> Ogre::Radian::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group___math.html#ga01235157bea1375e48ed73634a6f9a18">Ogre::Degree::valueRadians()</a>.</p>

</div>
</div>
<a id="gaed5147935125e28f53cb19d70055bc88" name="gaed5147935125e28f53cb19d70055bc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed5147935125e28f53cb19d70055bc88">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp; Ogre::Radian::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group___math.html#ga01235157bea1375e48ed73634a6f9a18">Ogre::Degree::valueRadians()</a>.</p>

</div>
</div>
<a id="ga05fd614aac352a71e17d8eb559578d7b" name="ga05fd614aac352a71e17d8eb559578d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05fd614aac352a71e17d8eb559578d7b">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> Ogre::Radian::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group___math.html#ga01235157bea1375e48ed73634a6f9a18">Ogre::Degree::valueRadians()</a>.</p>

</div>
</div>
<a id="ga223a82b9ff74351959eee91a335e7cdb" name="ga223a82b9ff74351959eee91a335e7cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga223a82b9ff74351959eee91a335e7cdb">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp; Ogre::Radian::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group___math.html#ga01235157bea1375e48ed73634a6f9a18">Ogre::Degree::valueRadians()</a>.</p>

</div>
</div>
<a id="gaac273cad14f6c100d692d7235919fe7f" name="gaac273cad14f6c100d692d7235919fe7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac273cad14f6c100d692d7235919fe7f">&#9670;&#160;</a></span>valueDegrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">float</a> Ogre::Radian::valueDegrees </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#a157a69d3d7d991975dd3b000842156b2">Ogre::Math::RadiansToDegrees()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_degree.html#a77fbb11439e3b9f3ce56af331737484d">Ogre::Degree::operator+()</a>, <a class="el" href="class_ogre_1_1_degree.html#a7f2eded374257421684267738fb476a4">Ogre::Degree::operator+=()</a>, <a class="el" href="class_ogre_1_1_degree.html#a830559610ea7662565d6ea1107952e51">Ogre::Degree::operator-()</a>, <a class="el" href="class_ogre_1_1_degree.html#acd2201c018ae74f013542664c2086be0">Ogre::Degree::operator-=()</a>, and <a class="el" href="class_ogre_1_1_degree.html#a8cf6e7cea4ceba86260f0a00e10843a7">Ogre::Degree::operator=()</a>.</p>

</div>
</div>
<a id="gae0e1b281e33d85e3364aeaa49c8ef2f5" name="gae0e1b281e33d85e3364aeaa49c8ef2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0e1b281e33d85e3364aeaa49c8ef2f5">&#9670;&#160;</a></span>valueAngleUnits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">float</a> Ogre::Radian::valueAngleUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#ac9ce627d71a4d3f824c585339c0a0a0b">Ogre::Math::RadiansToAngleUnits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_string_converter.html#aa331e97f9c49e38ac4951c6643f02fbf">Ogre::StringConverter::toString()</a>.</p>

</div>
</div>
<a id="ga01235157bea1375e48ed73634a6f9a18" name="ga01235157bea1375e48ed73634a6f9a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01235157bea1375e48ed73634a6f9a18">&#9670;&#160;</a></span>valueRadians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">float</a> Ogre::Degree::valueRadians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#ab346b48871b04bd46ae9d877fe30b416">Ogre::Math::DegreesToRadians()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group___math.html#ga6aee68f4913cf646f4fa3c046a18ee60">Ogre::Radian::operator+()</a>, <a class="el" href="group___math.html#gaed5147935125e28f53cb19d70055bc88">Ogre::Radian::operator+=()</a>, <a class="el" href="group___math.html#ga05fd614aac352a71e17d8eb559578d7b">Ogre::Radian::operator-()</a>, <a class="el" href="group___math.html#ga223a82b9ff74351959eee91a335e7cdb">Ogre::Radian::operator-=()</a>, and <a class="el" href="group___math.html#gafab8ce89cde3034f3cc5c2537d5ea6fd">Ogre::Radian::operator=()</a>.</p>

</div>
</div>
<a id="ga1fd64f1fc097bf4724b4713ff76cdfcd" name="ga1fd64f1fc097bf4724b4713ff76cdfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fd64f1fc097bf4724b4713ff76cdfcd">&#9670;&#160;</a></span>valueAngleUnits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">float</a> Ogre::Degree::valueAngleUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#a27e1b2fedaf091309de50261765b8c88">Ogre::Math::DegreesToAngleUnits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_string_converter.html#ad52e12f6ae6c1b1fec0a9bbaeff4b83d">Ogre::StringConverter::toString()</a>.</p>

</div>
</div>
<a id="gaf5f6b1190c20ab261874497f6bbb7dfd" name="gaf5f6b1190c20ab261874497f6bbb7dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5f6b1190c20ab261874497f6bbb7dfd">&#9670;&#160;</a></span>operator Radian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Angle::operator <a class="el" href="class_ogre_1_1_radian.html">Radian</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#a983534f23650772465406a8c40cef903">Ogre::Math::AngleUnitsToRadians()</a>.</p>

</div>
</div>
<a id="ga166c0b2a2264eac93345461f93005b6e" name="ga166c0b2a2264eac93345461f93005b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga166c0b2a2264eac93345461f93005b6e">&#9670;&#160;</a></span>operator Degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Angle::operator <a class="el" href="class_ogre_1_1_degree.html">Degree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#acb4fc64359cf3081588bf8a99e0492a6">Ogre::Math::AngleUnitsToDegrees()</a>.</p>

</div>
</div>
<a id="gae40391520c06bafb34a8647931fab8e1" name="gae40391520c06bafb34a8647931fab8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40391520c06bafb34a8647931fab8e1">&#9670;&#160;</a></span>lookRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> Ogre::Math::lookRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rotation matrix from direction and yaw. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>the direction to look in. Must be normalised. </td></tr>
    <tr><td class="paramname">yaw</td><td>the yaw axis to use </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_vector.html#a43169cee2146a35d14ef47016f565d23">Ogre::Vector&lt; dims, T &gt;::normalisedCopy()</a>.</p>

</div>
</div>
<a id="gaebc7c568cc1d6f13405a756be1af73fa" name="gaebc7c568cc1d6f13405a756be1af73fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebc7c568cc1d6f13405a756be1af73fa">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> Ogre::TransformBaseReal::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gab3e9b9df69bd3255f3b64254e66c3321" name="gab3e9b9df69bd3255f3b64254e66c3321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3e9b9df69bd3255f3b64254e66c3321">&#9670;&#160;</a></span>intersects() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">bool</a> Ogre::Math::intersects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_plane.html" title="Defines a plane in 3D space.">Plane</a> / box intersection test. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_plane.html#aa5d44b14d6f032f3e0a26e83589180bca44420e1c49338ae721f298826e164935">Ogre::Plane::BOTH_SIDE</a>, and <a class="el" href="class_ogre_1_1_plane.html#a519225d752a20f3459d2f0cc20346468">Ogre::Plane::getSide()</a>.</p>

</div>
</div>
<a id="gafc5955de7b6ba0dfa860cc751c6321db" name="gafc5955de7b6ba0dfa860cc751c6321db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc5955de7b6ba0dfa860cc751c6321db">&#9670;&#160;</a></span>intersects() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">RayTestResult</a> Ogre::Math::intersects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_ray.html" title="Representation of a ray in space, i.e.">Ray</a> / plane intersection. </p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_ray.html#af4a15c54cf07c7f0980918390c7f0c7d">Ogre::Ray::intersects()</a>, <a class="el" href="class_ogre_1_1_sphere.html#a77798ca00493f6b1f9da7f3eff782642">Ogre::Sphere::intersects()</a>, <a class="el" href="class_ogre_1_1_axis_aligned_box.html#aca408c7b88cfc2bcddde8bac8095f0ef">Ogre::AxisAlignedBox::intersects()</a>, <a class="el" href="class_ogre_1_1_ray.html#a45ddd7bccb4269f11a9bfebe5bc767c3">Ogre::Ray::intersects()</a>, <a class="el" href="class_ogre_1_1_plane_bounded_volume.html#a477b753b9fda0c99ccce3e5195b2d7a8">Ogre::PlaneBoundedVolume::intersects()</a>, and <a class="el" href="class_ogre_1_1_axis_aligned_box.html#a5a508f817edab7a8d084cffe051d08a7">Ogre::AxisAlignedBox::intersects()</a>.</p>

</div>
</div>
<a id="ga64ed9272da4fcaccd8b1009a31358c61" name="ga64ed9272da4fcaccd8b1009a31358c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64ed9272da4fcaccd8b1009a31358c61">&#9670;&#160;</a></span>intersects() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">RayTestResult</a> Ogre::Math::intersects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>discardInside</em> = <code><a class="el" href="struct_ogre_1_1vector.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_ray.html" title="Representation of a ray in space, i.e.">Ray</a> / sphere intersection. </p>

</div>
</div>
<a id="ga04786a5e338650d6eafc987b394d221c" name="ga04786a5e338650d6eafc987b394d221c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04786a5e338650d6eafc987b394d221c">&#9670;&#160;</a></span>intersects() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">bool</a> Ogre::Math::intersects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_sphere.html" title="A sphere primitive, mostly used for bounds checking.">Sphere</a> / plane intersection test. </p>
<dl class="section remark"><dt>Remarks</dt><dd>NB just do a plane.getDistance(sphere.getCenter()) for more detail! </dd></dl>

</div>
</div>
<a id="ga4345346666fd54473efb51a8d194f5e0" name="ga4345346666fd54473efb51a8d194f5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4345346666fd54473efb51a8d194f5e0">&#9670;&#160;</a></span>midPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 2, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::midPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector at a point half way between this and the passed in vector. </p>

</div>
</div>
<a id="gaba43517feb82c40ccf1cc571f519866c" name="gaba43517feb82c40ccf1cc571f519866c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba43517feb82c40ccf1cc571f519866c">&#9670;&#160;</a></span>randomDeviant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 2, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::randomDeviant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_radian.html">Radian</a>&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a new random vector which deviates from this vector by a given angle in a random direction. </p>
<p>This method assumes that the random number generator has already been seeded appropriately. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle at which to deviate in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random vector which deviates from this vector by angle. This vector will not be normalised, normalise it if you wish afterwards. </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#a8070c3fc4eea76025ce9a9072087e540">Ogre::Math::Cos()</a>, <a class="el" href="class_ogre_1_1_math.html#afedce6fa2a819ea7a2420e10fb00a189">Ogre::Math::RangeRandom()</a>, and <a class="el" href="class_ogre_1_1_math.html#a4bf7e39baab4d061f052a9e193d61a1f">Ogre::Math::Sin()</a>.</p>

</div>
</div>
<a id="ga7a92915df275eae8161441024d88c815" name="ga7a92915df275eae8161441024d88c815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a92915df275eae8161441024d88c815">&#9670;&#160;</a></span>angleTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 2, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::angleTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the oriented angle between 2 vectors. </p>
<p>Vectors do not have to be unit-length but must represent directions. The angle is comprised between 0 and 2 PI. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#a284c156c5effd4b0d222e4e75ef54af2">Ogre::Math::TWO_PI</a>.</p>

</div>
</div>
<a id="ga00e57f3eda32e31277c439e6a9c929a1" name="ga00e57f3eda32e31277c439e6a9c929a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00e57f3eda32e31277c439e6a9c929a1">&#9670;&#160;</a></span>perpendicular() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 2, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::perpendicular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a vector perpendicular to this vector (eg an 'up' vector). </p>
<p>This method will return a vector which is perpendicular to this vector. There are an infinite number of possibilities but this method will guarantee to generate one of them. If you need more control you should use the <a class="el" href="class_ogre_1_1_quaternion.html" title="Implementation of a Quaternion, i.e.">Quaternion</a> class. </p>

</div>
</div>
<a id="ga5b50a2b2697ec1ac684d66af82a03296" name="ga5b50a2b2697ec1ac684d66af82a03296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b50a2b2697ec1ac684d66af82a03296">&#9670;&#160;</a></span>perpendicular() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::perpendicular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a vector perpendicular to this vector (eg an 'up' vector). </p>
<p>This method will return a vector which is perpendicular to this vector. There are an infinite number of possibilities but this method will guarantee to generate one of them. If you need more control you should use the <a class="el" href="class_ogre_1_1_quaternion.html" title="Implementation of a Quaternion, i.e.">Quaternion</a> class. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#ae9e2434f05aed3c19b600af6b48c59b7">Ogre::Math::Abs()</a>.</p>

</div>
</div>
<a id="gafe9157bbe30e69645edd5c3eddea141f" name="gafe9157bbe30e69645edd5c3eddea141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe9157bbe30e69645edd5c3eddea141f">&#9670;&#160;</a></span>crossProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::crossProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rkVector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cross-product of 2 vectors, i.e. </p>
<p>the vector that lies perpendicular to them both.</p>
<p>The cross-product is normally used to calculate the normal vector of a plane, by calculating the cross-product of 2 non-equivalent vectors which lie on the plane (e.g. 2 edges of a triangle). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rkVector</td><td><a class="el" href="class_ogre_1_1_vector.html" title="Standard N-dimensional vector.">Vector</a> which, together with this one, will be used to calculate the cross-product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector which is the result of the cross-product. This vector will <b>NOT</b> be normalised, to maximise efficiency<ul>
<li>call <a class="el" href="class_ogre_1_1_vector.html#a2d9b321bec779fc06de480897cda2027" title="Normalises the vector.">Vector3::normalise</a> on the result if you wish this to be done. As for which side the resultant vector will be on, the returned vector will be on the side from which the arc from 'this' to rkVector is anticlockwise, e.g. UNIT_Y.crossProduct(UNIT_Z) = UNIT_X, whilst UNIT_Z.crossProduct(UNIT_Y) = -UNIT_X. This is because OGRE uses a right-handed coordinate system. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>For a clearer explanation, look a the left and the bottom edges of your monitor's screen. Assume that the first vector is the left edge and the second vector is the bottom edge, both of them starting from the lower-left corner of the screen. The resulting vector is going to be perpendicular to both of them and will go <em>inside</em> the screen, towards the cathode tube (assuming you're using a CRT monitor, of course). </dd></dl>

</div>
</div>
<a id="ga929562516cfb30c38030d9df84945bf3" name="ga929562516cfb30c38030d9df84945bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga929562516cfb30c38030d9df84945bf3">&#9670;&#160;</a></span>midPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::midPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector at a point half way between this and the passed in vector. </p>

</div>
</div>
<a id="ga4f54a2dd6b60dd327fcc8347fc4d853d" name="ga4f54a2dd6b60dd327fcc8347fc4d853d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f54a2dd6b60dd327fcc8347fc4d853d">&#9670;&#160;</a></span>randomDeviant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::randomDeviant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>up</em> = <code><a class="el" href="struct_ogre_1_1_vector_base_3_013_00_01_real_01_4.html#a3353094e7989fcd4774b9147750990bc">ZERO</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a new random vector which deviates from this vector by a given angle in a random direction. </p>
<p>This method assumes that the random number generator has already been seeded appropriately. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle at which to deviate </td></tr>
    <tr><td class="paramname">up</td><td><a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> vector perpendicular to this one (which could generated by cross-product of this vector and any other non-colinear vector). If you choose not to provide this the function will derive one on it's own, however if you provide one yourself the function will be faster (this allows you to reuse up vectors if you call this method more than once) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random vector which deviates from this vector by angle. This vector will not be normalised, normalise it if you wish afterwards. </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#a284c156c5effd4b0d222e4e75ef54af2">Ogre::Math::TWO_PI</a>, and <a class="el" href="class_ogre_1_1_math.html#ac59f83c8d52180fb9e408bb92d808533">Ogre::Math::UnitRandom()</a>.</p>

</div>
</div>
<a id="gac6ef79da21101ef5a671b0473b849bc3" name="gac6ef79da21101ef5a671b0473b849bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6ef79da21101ef5a671b0473b849bc3">&#9670;&#160;</a></span>getRotationTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::getRotationTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>fallbackAxis</em> = <code><a class="el" href="struct_ogre_1_1_vector_base_3_013_00_01_real_01_4.html#a3353094e7989fcd4774b9147750990bc">ZERO</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the shortest arc quaternion to rotate this vector to the destination vector. </p>
<p>If you call this with a dest vector that is close to the inverse of this vector, we will rotate 180 degrees around the 'fallbackAxis' (if specified, or a generated axis if not) since in this case ANY axis of rotation is valid. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#ae9e2434f05aed3c19b600af6b48c59b7">Ogre::Math::Abs()</a>, <a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Ogre::Quaternion::IDENTITY</a>, <a class="el" href="class_ogre_1_1_math.html#a890336e0e4b6914024bfefd79c08f432">Ogre::Math::RealEqual()</a>, and <a class="el" href="class_ogre_1_1_math.html#ab1ee8b71699ce68bd8cf91113ead793e">Ogre::Math::Sqrt()</a>.</p>

</div>
</div>
<a id="ga24dd46458beb0ea8175bfbf916f09e47" name="ga24dd46458beb0ea8175bfbf916f09e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24dd46458beb0ea8175bfbf916f09e47">&#9670;&#160;</a></span>positionCloses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::positionCloses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1<a class="el" href="struct_ogre_1_1vector.html">e</a>-03<a class="el" href="struct_ogre_1_1vector.html">f</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this vector is within a positional tolerance of another vector, also take scale of the vectors into account. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The vector to compare with </td></tr>
    <tr><td class="paramname">tolerance</td><td>The amount (related to the scale of vectors) that distance of the vector may vary by and still be considered close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad67db81d99c63e2483ff8bc314bfd36c" name="gad67db81d99c63e2483ff8bc314bfd36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad67db81d99c63e2483ff8bc314bfd36c">&#9670;&#160;</a></span>directionEquals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::directionEquals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this vector is within a directional tolerance of another vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The vector to compare with </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum angle by which the vectors may vary and still be considered equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Both vectors should be normalised. </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#ae9e2434f05aed3c19b600af6b48c59b7">Ogre::Math::Abs()</a>, and <a class="el" href="class_ogre_1_1_math.html#a53869f3197b0f991aea7f5edf6b620e2">Ogre::Math::ACos()</a>.</p>

</div>
</div>
<a id="gad52e72c687842e8475a5f24cde8cd858" name="gad52e72c687842e8475a5f24cde8cd858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad52e72c687842e8475a5f24cde8cd858">&#9670;&#160;</a></span>primaryAxis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp; <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::primaryAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the primary (dominant) axis from this direction vector. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#ae9e2434f05aed3c19b600af6b48c59b7">Ogre::Math::Abs()</a>.</p>

</div>
</div>
<a id="ga813d02a0ee4c69dab452767fba1cef8a" name="ga813d02a0ee4c69dab452767fba1cef8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga813d02a0ee4c69dab452767fba1cef8a">&#9670;&#160;</a></span>calculateBasicFaceNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> Ogre::Math::calculateBasicFaceNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a face normal, no w-information. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_vector.html#a2d9b321bec779fc06de480897cda2027">Ogre::Vector&lt; dims, T &gt;::normalise()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group___math.html#gae5ba1fde5b6a0056fd637d4e6b781a2a">Ogre::Math::calculateFaceNormal()</a>, and <a class="el" href="class_ogre_1_1_plane.html#a93b10ba23a8142123cbcac6e4094f15c">Ogre::Plane::redefine()</a>.</p>

</div>
</div>
<a id="gae5ba1fde5b6a0056fd637d4e6b781a2a" name="gae5ba1fde5b6a0056fd637d4e6b781a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5ba1fde5b6a0056fd637d4e6b781a2a">&#9670;&#160;</a></span>calculateFaceNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> Ogre::Math::calculateFaceNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a face normal, including the w component which is the offset from the origin. </p>

<p class="reference">References <a class="el" href="group___math.html#ga813d02a0ee4c69dab452767fba1cef8a">Ogre::Math::calculateBasicFaceNormal()</a>, and <a class="el" href="class_ogre_1_1_vector.html#ae610ff4982860298852e56af6b2fe36c">Ogre::Vector&lt; dims, T &gt;::dotProduct()</a>.</p>

</div>
</div>
<a id="gabcc5bd946f4c1fb73b851493e17b11b3" name="gabcc5bd946f4c1fb73b851493e17b11b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcc5bd946f4c1fb73b851493e17b11b3">&#9670;&#160;</a></span>calculateBasicFaceNormalWithoutNormalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> Ogre::Math::calculateBasicFaceNormalWithoutNormalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a face normal without normalize, no w-information. </p>

<p class="reference">Referenced by <a class="el" href="group___math.html#gabc24b5e11a3a613f60dc44f6056dc61c">Ogre::Math::calculateFaceNormalWithoutNormalize()</a>.</p>

</div>
</div>
<a id="gabc24b5e11a3a613f60dc44f6056dc61c" name="gabc24b5e11a3a613f60dc44f6056dc61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc24b5e11a3a613f60dc44f6056dc61c">&#9670;&#160;</a></span>calculateFaceNormalWithoutNormalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> Ogre::Math::calculateFaceNormalWithoutNormalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a face normal without normalize, including the w component which is the offset from the origin. </p>

<p class="reference">References <a class="el" href="group___math.html#gabcc5bd946f4c1fb73b851493e17b11b3">Ogre::Math::calculateBasicFaceNormalWithoutNormalize()</a>, and <a class="el" href="class_ogre_1_1_vector.html#ae610ff4982860298852e56af6b2fe36c">Ogre::Vector&lt; dims, T &gt;::dotProduct()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
