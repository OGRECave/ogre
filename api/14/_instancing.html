<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Instancing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_instancing.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Instancing</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Static-Geometry">Static Geometry</a></li>
<li class="level1"><a href="#Instance-Manager">Instance Manager</a></li>
<li class="level1"><a href="#Static-Geometry-vs-Instancing">Static Geometry vs Instancing</a></li>
</ul>
</div>
<div class="textblock"><p>Instancing significantly reduces the CPU overhead of submitting many separate draw calls and is a great technique for rendering trees, rocks, grass, RTS units and other groups of similar (but necessarily identical) objects.</p>
<p>OGRE supports a variety of techniques to speed up the rendering of many objects in the Scene.</p>
<dl compact="compact">
<dt><a class="el" href="_instancing.html#Static-Geometry">Static Geometry</a> </dt>
<dd>Pre-transforms and batches up meshes for efficient use as static geometry in a scene. </dd>
<dt><a class="el" href="_instancing.html#Instance-Manager">Instance Manager</a> </dt>
<dd>Instancing is a way of batching up geometry into a much more efficient form, but with some limitations, and still be able to move &amp; animate it. </dd>
</dl>
<h1><a class="anchor" id="Static-Geometry"></a>
Static Geometry</h1>
<p>Modern graphics cards (GPUs) prefer to receive geometry in large batches. It is orders of magnitude faster to render 10 batches of 10,000 triangles than it is to render 10,000 batches of 10 triangles, even though both result in the same number of on-screen triangles.</p>
<p>Therefore it is important when you are rendering a lot of geometry to batch things up into as few rendering calls as possible. This class allows you to build a batched object from a series of entities in order to benefit from this behaviour. Batching has implications of it's own though:</p><ul>
<li>A geometry region cannot be subdivided; that means that the whole group will be displayed, or none of it will. This obivously has culling issues.</li>
<li>A single world transform must apply to the entire batch. Therefore once you have batched things, you can't move them around relative to each other. That's why this class is most useful when dealing with static geometry (hence the name). In addition, geometry is effectively duplicated, so if you add 3 entities based on the same mesh in different positions, they will use 3 times the geometry space than the movable version (which re-uses the same geometry). So you trade memory and flexibility of movement for pure speed when using this class.</li>
<li>A single material must apply for each batch. In fact this class allows you to use multiple materials, but you should be aware that internally this means that there is one batch per material. Therefore you won't gain as much benefit from the batching if you use many different materials; try to keep the number down.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_static_geometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene.">Ogre::StaticGeometry</a> </dd>
<dd>
<a class="el" href="tut__static_geom.html">Tutorial - Static Geometry</a></dd></dl>
<h1><a class="anchor" id="Instance-Manager"></a>
Instance Manager</h1>
<p>Instancing is a rendering technique to draw multiple instances of the same mesh using just one render call. There are two kinds of instancing:</p>
<dl class="section user"><dt>Software</dt><dd>Two larges vertex &amp; index buffers are created and the mesh vertices/indices are duplicated N number of times. When rendering, invisible instances receive a transform matrix filled with 0s. This technique can take a lot of VRAM and has limited culling capabilities. </dd></dl>
<dl class="section user"><dt>Hardware</dt><dd>The hardware supports an extra param which allows <a class="el" href="namespace_ogre.html">Ogre</a> to tell the GPU to repeat the drawing of vertices N number of times; thus taking considerably less VRAM. Because N can be controlled at runtime, individual instances can be culled before sending the data to the GPU. Hardware techniques are almost always superior to Software techniques, but Software are more compatible, where as Hardware techniques require D3D9 or GL3, and is not supported in GLES2</dd></dl>
<p>All instancing techniques require shaders. It is possible to have the <a class="el" href="rtss.html">RTSS (Realtime Shader System)</a> generate the shaders for you.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_instance_manager.html" title="This is the main starting point for the new instancing system.">Ogre::InstanceManager</a> </dd>
<dd>
<a class="el" href="_what_is_instancing.html">Instancing User-Guide</a></dd></dl>
<h1><a class="anchor" id="Static-Geometry-vs-Instancing"></a>
Static Geometry vs Instancing</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Static Geometry   </th><th class="markdownTableHeadNone">Instancing    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Any sort of mesh is grouped in a minimal number of meshes, and cannot be updated (each mesh cannot move independently, only all the static geometry would be able to do so.)   </td><td class="markdownTableBodyNone">The same mesh used many times, so Instanced geometry can be updated (each mesh can move independently)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">You have a scene with many unique meshes   </td><td class="markdownTableBodyNone">Reuse the same mesh many times without the draw call cost.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Batches up small static detail fragments like grass without shaders.   </td><td class="markdownTableBodyNone">One mesh is repeated many times without the performance hit of having them as individual meshes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Geometry that doesn't move and has low in GPU requirements   </td><td class="markdownTableBodyNone">Dynamic geometry (animated or moving) and better GPU (sm2.0+)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Batches separate sets of polygons together, as long as they have the same properties such as material. These batches are then automatically split into regions for better culling. You can control the region size. This is a good way to reduce batches for static elements.   </td><td class="markdownTableBodyNone">Good for large numbers of the same exact object. You can have multiple instances of one object that can dynamically move but that are drawn in one draw call.   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
