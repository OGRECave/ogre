<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Instancing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.5</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_instancing.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Instancing</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Static-Geometry">Static Geometry</a></li>
<li class="level1"><a href="#Instance-Manager">Explicit Instance Manager</a></li>
<li class="level1"><a href="#Static-Geometry-vs-Instancing">Static Geometry vs Instancing</a></li>
</ul>
</div>
<div class="textblock"><p>Modern graphics cards (GPUs) prefer to receive geometry in large batches. It is orders of magnitude faster to render 10 batches of 10,000 triangles than it is to render 10,000 batches of 10 triangles, even though both result in the same number of on-screen triangles.</p>
<p>Therefore it is important when you are rendering a lot of geometry to batch things up into as few rendering calls as possible.</p>
<p>Ogre supports a variety of techniques to speed up the rendering of many objects in the Scene.</p>
<dl compact="compact">
<dt><a class="el" href="_instancing.html#Static-Geometry">Static Geometry</a> </dt>
<dd>Pre-transforms and batches up meshes on the CPU for efficient use as static geometry in a scene.    </dd>
<dt><a class="el" href="_instancing.html#Instance-Manager">Explicit Instance Manager</a> </dt>
<dd>Choose from different algorithms to batch up geometry and still be able to move &amp; animate it. Requires manual setup and the algorithms have some limitations. </dd>
<dt><a class="el" href="_high-level-_programs.html#Instancing-in-Vertex-Programs">Auto-Instancing</a> </dt>
<dd>You can advertise instancing in you shaders and <a class="el" href="namespace_ogre.html">Ogre</a> will batch the draw calls for you. Does not support animation.This is less efficient than the Explicit Instance Manager but requires no code changes and can be used with the RTSS. </dd>
</dl>
<h1><a class="anchor" id="Static-Geometry"></a>
Static Geometry</h1>
<p>This class allows you to build a batched object from a series of entities. Batching has implications of it's own though:</p><ul>
<li>Batched geometry cannot be subdivided; that means that the whole group will be displayed, or none of it will. This obivously has culling issues.</li>
<li>A single world transform must apply to the entire batch. Therefore once you have batched things, you can't move them around relative to each other. That's why this class is most useful when dealing with static geometry (hence the name). In addition, geometry is effectively duplicated, so if you add 3 entities based on the same mesh in different positions, they will use 3 times the geometry space than the movable version (which re-uses the same geometry). So you trade memory and flexibility of movement for pure speed when using this class.</li>
<li>A single material must apply for each batch. In fact this class allows you to use multiple materials, but you should be aware that internally this means that there is one batch per material. Therefore you won't gain as much benefit from the batching if you use many different materials; try to keep the number down.</li>
</ul>
<p>In order to retain some sort of culling, this class will batch up meshes in localised regions. The size and shape of these blocks is controlled by the SceneManager which constructs this object, since it makes sense to batch things up in the most appropriate way given the existing partitioning of the scene.</p>
<p>The LOD settings of both the Mesh and the Materials used in constructing this static geometry will be respected. This means that if you use meshes/materials which have LOD, batches in the distance will have a lower polygon count or material detail to those in the foreground. Since each mesh might have different LOD distances, during build the furthest distance at each LOD level from all meshes <br  />
 in that region is used. This means all the LOD levels change at the same time, but at the furthest distance of any of them (so quality is not degraded). Be aware that using Mesh LOD in this class will further increase the memory required. Only generated LOD is supported for meshes.</p>
<p>There are 2 ways you can add geometry to this class; you can add Entity objects directly with predetermined positions, scales and orientations, or you can add an entire SceneNode and it's subtree, including all the objects attached to it. Once you've added everything you need to, you have to call build() the fix the geometry in place. </p><dl class="section note"><dt>Note</dt><dd>This class is not a replacement for world geometry (<a class="el" href="class_ogre_1_1_scene_manager.html#accb0fdfbd1f61aa4d3d6e1f4625e1f9c">Ogre::SceneManager::setWorldGeometry</a>). The single most efficient way to render large amounts of static geometry is to use a SceneManager which is specialised for dealing with that particular world structure. However, this class does provide you with a good 'halfway house' between generalised movable geometry (Entity) which works with all SceneManagers but isn't efficient when using very large numbers, and highly specialised world geometry which is extremely fast but not generic and typically requires custom world editors. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>this class only works with indexed triangle lists at the moment, do not pass it triangle strips, fans or lines / points, or unindexed geometry.  </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="tut__static_geom.html">Tutorial - Static Geometry</a></dd></dl>
<h1><a class="anchor" id="Instance-Manager"></a>
Explicit Instance Manager</h1>
<p>Instancing is a rendering technique to draw multiple instances of the same mesh using just one render call. There are two kinds of instancing:</p>
<dl class="section user"><dt>Software</dt><dd>Two larges vertex &amp; index buffers are created and the mesh vertices/indices are duplicated N number of times. When rendering, invisible instances receive a transform matrix filled with 0s. This technique can take a lot of VRAM and has limited culling capabilities. </dd></dl>
<dl class="section user"><dt>Hardware</dt><dd>The hardware supports an extra param which allows <a class="el" href="namespace_ogre.html">Ogre</a> to tell the GPU to repeat the drawing of vertices N number of times; thus taking considerably less VRAM. Because N can be controlled at runtime, individual instances can be culled before sending the data to the GPU. Hardware techniques are almost always superior to Software techniques, but Software are more compatible, where as Hardware techniques require D3D9 or GL3, and is not supported in GLES2</dd></dl>
<p>All instancing techniques require shaders. It is possible to have the <a class="el" href="rtss.html">RTSS (Realtime Shader System)</a> generate the shaders for you.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_instance_manager.html" title="This is the main starting point for the manual instancing system.">Ogre::InstanceManager</a> </dd>
<dd>
<a class="el" href="_what_is_instancing.html">Instancing User-Guide</a></dd></dl>
<h1><a class="anchor" id="Static-Geometry-vs-Instancing"></a>
Static Geometry vs Instancing</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Static Geometry   </th><th class="markdownTableHeadNone">Instancing    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Any sort of mesh is grouped in a minimal number of meshes, and cannot be updated (each mesh cannot move independently, only all the static geometry would be able to do so.)   </td><td class="markdownTableBodyNone">The same mesh used many times, so Instanced geometry can be updated (each mesh can move independently)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">You have a scene with many unique meshes   </td><td class="markdownTableBodyNone">Reuse the same mesh many times without the draw call cost.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Batches up small static detail fragments like grass without shaders.   </td><td class="markdownTableBodyNone">One mesh is repeated many times without the performance hit of having them as individual meshes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Geometry that doesn't move and has low in GPU requirements   </td><td class="markdownTableBodyNone">Dynamic geometry (animated or moving) and better GPU (sm2.0+)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Batches separate sets of polygons together, as long as they have the same properties such as material. These batches are then automatically split into regions for better culling. You can control the region size. This is a good way to reduce batches for static elements.   </td><td class="markdownTableBodyNone">Good for large numbers of the same exact object. You can have multiple instances of one object that can dynamically move but that are drawn in one draw call.   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
