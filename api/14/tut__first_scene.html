<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('tut__first_scene.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Your First Scene</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">Plugins</a><ul><li class="level2"><a href="#autotoc_md15">Testing vs Release</a></li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph.">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Ogre::Entity</a>. An Entity is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph.">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial can be found in samples directory <b>Samples/Tutorials/BasicTutorial1.cpp</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a>. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. They differ in how they partition the scene for culling and searching nodes. There are managers implementing the <a href="https://en.wikipedia.org/wiki/Octree">Octtree</a> scheme and others using portals. For now, you can use the default SceneManager, which is best suited for scenes where most of the objects are visible most of the time.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;setAmbientLight(ColourValue(0.5, 0.5, 0.5));</div>
</div><!-- fragment --><p>The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour.">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="group___bites.html#ga579bb62eef4503f5d9bc93c0fb613a6f">OgreBites::ApplicationContext</a>. There are a number of features available, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;createLight(<span class="stringliteral">&quot;MainLight&quot;</span>);</div>
<div class="line">    SceneNode* lightNode = scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();</div>
<div class="line">    lightNode-&gt;attachObject(light);</div>
</div><!-- fragment --><p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div>
</div><!-- fragment --><p>Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create the camera</span></div>
<div class="line">    Camera* cam = scnMgr-&gt;createCamera(<span class="stringliteral">&quot;myCam&quot;</span>);</div>
<div class="line">    cam-&gt;setNearClipDistance(5); <span class="comment">// specific to this sample</span></div>
<div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div>
<div class="line">    camNode-&gt;attachObject(cam);</div>
<div class="line">    camNode-&gt;setPosition(0, 0, 140);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// and tell it to render into the main window</span></div>
<div class="line">    getRenderWindow()-&gt;addViewport(cam);</div>
</div><!-- fragment --><p>Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;createEntity(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div>
</div><!-- fragment --><p>The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="group___bites.html#ga579bb62eef4503f5d9bc93c0fb613a6f">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();</div>
</div><!-- fragment --><p>We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div>
</div><!-- fragment --><p>We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt=""/>
</div>
    <h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html">Ogre</a> is using a <a href="https://en.wikipedia.org/wiki/Right-hand_rule">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt=""/>
</div>
    <p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html">Ogre</a> as well, but it will require <a href="https://paroj.github.io/gltut/Positioning/Tut08%20Quaternions.html">some knowledge of quaternions</a>.</p>
<p><a class="el" href="namespace_ogre.html">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Ogre::Vector2</a>, <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Ogre::Vector3</a>, and <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="https://paroj.github.io/gltut/Positioning/Tutorial%2006.html">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div>
</div><!-- fragment --><p>Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;createEntity(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div>
<div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(Vector3(84, 48, 0));</div>
<div class="line">    ogreNode2-&gt;attachObject(ogreEntity2);</div>
</div><!-- fragment --><p>This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt=""/>
</div>
    <h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph.">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve <a href="https://paroj.github.io/gltut/Positioning/Tut08%20Quaternions.html">the use of quaternions</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a130bb1457a8e0402b72988e66e05ee01" title="Retrieves a pointer to an attached object by index.">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;getRootSceneNode()-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_node.html#a15ffc965117fa8c9e3406d54c3cc52d2">createChildSceneNode</a>(<a class="code hl_class" href="class_ogre_1_1_vector.html">Ogre::Vector3</a>(84, 48, 0));</div>
<div class="ttc" id="aclass_ogre_1_1_scene_node_html"><div class="ttname"><a href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a></div><div class="ttdoc">Class representing a node in the scene graph.</div><div class="ttdef"><b>Definition</b> OgreSceneNode.h:61</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_node_html_a15ffc965117fa8c9e3406d54c3cc52d2"><div class="ttname"><a href="class_ogre_1_1_scene_node.html#a15ffc965117fa8c9e3406d54c3cc52d2">Ogre::SceneNode::createChildSceneNode</a></div><div class="ttdeci">virtual SceneNode * createChildSceneNode(const Vector3 &amp;translate=Vector3::ZERO, const Quaternion &amp;rotate=Quaternion::IDENTITY)</div><div class="ttdoc">Creates an unnamed new SceneNode as a child of this node.</div></div>
<div class="ttc" id="aclass_ogre_1_1_vector_html"><div class="ttname"><a href="class_ogre_1_1_vector.html">Ogre::Vector&lt; 3, Real &gt;</a></div></div>
</div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_node.html#a15ffc965117fa8c9e3406d54c3cc52d2">createChildSceneNode</a>(<a class="code hl_class" href="class_ogre_1_1_vector.html">Ogre::Vector3</a>(84, 48, 0));</div>
</div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div>
<div class="line">  ogreNode        ogreNode2</div>
<div class="line">   parent           child</div>
</div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div>
<div class="line">   root        ogreNode2</div>
<div class="line">  parent         child</div>
</div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;createEntity(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div>
<div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();</div>
<div class="line">    ogreNode3-&gt;setPosition(0, 104, 0);</div>
<div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div>
<div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div>
</div><!-- fragment --><p>Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt=""/>
</div>
    <h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt=""/>
</div>
    <p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees.">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians.">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;createEntity(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div>
<div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();</div>
<div class="line">    ogreNode4-&gt;setPosition(-84, 48, 0);</div>
<div class="line">    ogreNode4-&gt;roll(Degree(-90));</div>
<div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div>
</div><!-- fragment --><p>Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt=""/>
</div>
    <h1><a class="anchor" id="TheOgreEnvironment"></a>
Plugins</h1>
<p>Third-party plugins make it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The SDK includes some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia Layer</a> is used to manage input events and distribute them to <a class="el" href="namespace_ogre.html">Ogre</a>. You can also make use of <a href="https://www.assimp.org/">Assimp</a> through the <a class="el" href="group___assimp_codec.html">AssimpCodec</a>. This library allows you to load many popular geometry formats like .obj. There are other libraries (not included with the SDK) that offer functionality such as sound and physics.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Testing vs Release</h2>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph.">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph.">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
