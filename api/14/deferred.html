<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Deferred Shading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('deferred.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Deferred Shading</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#what">What is Deferred Shading?</a><ul><li class="level2"><a href="#autotoc_md273">Deferred Shading Advantages</a></li>
<li class="level2"><a href="#autotoc_md274">Deferred Shading Disadvantages</a></li>
</ul>
</li>
<li class="level1"><a href="#creating">Creating the G-Buffer</a><ul><li class="level2"><a href="#autotoc_md275">Deciding on the GBuffer format</a></li>
<li class="level2"><a href="#autotoc_md276">Preparing the objects for G-Buffer rendering</a><ul><li class="level3"><a href="#autotoc_md277">Inspect the classic technique</a></li>
<li class="level3"><a href="#autotoc_md278">Generate the G-Buffer technique</a></li>
<li class="level3"><a href="#autotoc_md279">Add the G-Buffer technique to the original material</a></li>
<li class="level3"><a href="#autotoc_md280">Putting it all together</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md281">Overriding the automatic process</a></li>
<li class="level2"><a href="#autotoc_md282">Seeing it in action</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md283">Lighting the scene</a><ul><li class="level2"><a href="#lightgeom">Rendering the light geometry</a><ul><li class="level3"><a href="#autotoc_md284">Prepare ambient colour and rebuild original depth buffer</a></li>
<li class="level3"><a href="#autotoc_md285">Render the light geometries</a></li>
<li class="level3"><a href="#autotoc_md286">Rendering shadow casting lights</a></li>
<li class="level3"><a href="#autotoc_md287">Putting it all together</a></li>
<li class="level3"><a href="#autotoc_md288">Seeing it in action</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#post">Post Processing</a><ul><li class="level2"><a href="#autotoc_md289">Screen Space Ambient Occlusion</a></li>
</ul>
</li>
<li class="level1"><a href="#realprojects">Integration in real projects</a><ul><li class="level2"><a href="#autotoc_md290">Integration steps</a></li>
<li class="level2"><a href="#autotoc_md291">Adapting the framework</a></li>
<li class="level2"><a href="#autotoc_md292">Adding features to the framework</a></li>
</ul>
</li>
<li class="level1"><a href="#summary">Summary</a><ul><li class="level2"><a href="#further">Further reading</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This tutorial is complementary to the deferred shading sample that is part of <a class="el" href="namespace_ogre.html">Ogre</a>. It will reference the code quite a bit and explain some of the decisions made when implementing the deferred shading framework for the demo.</p>
<h1><a class="anchor" id="what"></a>
What is Deferred Shading?</h1>
<p>Deferred shading is an alternative approach to rendering 3d scenes. The classic rendering approach involves rendering each object and applying lighting passes to it. So, if an ogre head is affected by 6 lights, it will be rendered 6 times, once for each light, in order to accumulate the affection of each light. Deferred shading takes another approach : In the beginning, all of the objects render their "lighting related info" to a texture, often called the G-Buffer. This means their colours, normals, depths and any other info that might be relevant to calculating their final colour. Afterwards, the lights in the scene are rendered as geometry (sphere for point light, cone for spotlight and full screen quad for directional light), and they use the G-buffer to calculate the colour contribution of that light to that pixel.</p>
<p>See the links in <a class="el" href="deferred.html#further">Further reading</a> to read more about it. It is recommended to understand deferred shading before reading this article, as the article focuses on implementing it in ogre, and not explaining how it works.</p>
<h2><a class="anchor" id="autotoc_md273"></a>
Deferred Shading Advantages</h2>
<p>The main reason for using deferred shading is performance related. Classing rendering (also called forward rendering) can, in the worst case, require num_objects * num_lights batches to render a scene. Deferred shading changes that to num_objects + num_lights, which can often be a lot less. Another reason is that some new post-processing effects are easily achievable using the G-Buffer as input. If you wanted to perform these effects without deferred shading, you would've had to render the whole scene again.</p>
<h2><a class="anchor" id="autotoc_md274"></a>
Deferred Shading Disadvantages</h2>
<p>There are several algorithmic drawbacks with deferred shading - transparent objects are hard to handle, anti aliasing can not be used in DX9 class hardware, additional memory consumption because of the G-Buffer. In addition to that, deferred shading is harder to implement - it overrides the entire fixed function pipeline. Pretty much everything is rendered using manual shaders - which probably means a lot of shader code.</p>
<h1><a class="anchor" id="creating"></a>
Creating the G-Buffer</h1>
<p>The first part of the deferred shading pipeline involves rendering all the (non-transparent) objects of the scene to the G-Buffer. This is done using a compositor :</p>
<div class="fragment"><div class="line">compositor DeferredShading/GBuffer</div>
<div class="line">{</div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// GBuffer textures</span></div>
<div class="line">        <span class="comment">// PF_BYTE_RGBA would be sufficient for color, but D3D9 requires same bitdepth for all MRTs</span></div>
<div class="line">        texture mrt_output target_width target_height PF_FLOAT16_RGBA PF_FLOAT16_RGBA chain_scope</div>
<div class="line">        </div>
<div class="line">        target mrt_output</div>
<div class="line">        {</div>
<div class="line">            input none</div>
<div class="line">            pass clear</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            shadows off</div>
<div class="line">            material_scheme GBuffer</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// everything but the lights and their meshes</span></div>
<div class="line">            <span class="comment">// could do this with something like a visibility mask too</span></div>
<div class="line">            pass render_scene</div>
<div class="line">            {</div>
<div class="line">                first_render_queue 10</div>
<div class="line">                last_render_queue  80</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Things to note about this compositor :</p><ul>
<li>mrt_output (the GBuffer) is an MRT because there are two pixel formats defined.</li>
<li>mrt_output will be accessible to the next compositors in the chain because it is marked as chain_scope, meaning it is visible to the next compositors in the chain.</li>
<li>The material scheme tells ogre that objects shouldn't be rendered in normal fashion, but in some other way (we'll get to that soon)</li>
<li>Not all the objects are rendered to the GBuffer. Skies and 'late objects' (which can be specified manually using render queues) will be forward rendered.</li>
<li>This compositor does NOT have a target_output pass, because it does not contribute directly to the final image.</li>
</ul>
<h2><a class="anchor" id="autotoc_md275"></a>
Deciding on the GBuffer format</h2>
<p>This in an important decision in deferred shading, as it has performance and visual implications.</p>
<p>Also, the entire pipeline has to be coordinated with this format - all the writing shaders have to write the same data to the same places, and all the reading shaders (for lighting later) have to be synchronized with it.</p>
<p>We chose two PF_FLOAT16_RGBA textures. The first one will contain the colour in RGB, specular intensity in A.</p>
<p>The second one will contain the view-space-normal in RGB (we keep all 3 coordinates) and the (linear) depth in A.</p>
<p>See the references for other possibilities.</p>
<h2><a class="anchor" id="autotoc_md276"></a>
Preparing the objects for G-Buffer rendering</h2>
<p>The only indicator that ogre has when rendering the scene is that the material scheme is different. Material schemes in ogre allow materials to specify different rendering techniques for different scenarios. In this case, we would like to output the lighting related information instead of the lighting calculation result.</p>
<p>Materials that have a technique associated with the GBuffer scheme will render using that, but we don't want to modify the materials of all the objects in our art pipeline to use them in deferred shading.</p>
<p>The solution is to use scheme listeners! The material manager has a method for registering listeners when objects don't have a technique defined for the current scheme: <a class="el" href="class_ogre_1_1_material_manager.html#a8ac18f4bd2e6302f1d92ae8f64195694" title="Add a listener to handle material events.">Ogre::MaterialManager::addListener()</a>.</p>
<p>The listener has a callback method that gets called whenever an object is about to be rendered without a matching technique: <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html#aefe59620e9a345442740cfae43a86f02" title="Called if a technique for a given scheme is not found within a material, allows the application to sp...">Ogre::MaterialManager::Listener::handleSchemeNotFound()</a>.</p>
<p>We will implement such a listener for the GBuffer scheme. It is GBufferSchemeHandler from the demo. The GBufferSchemeHandlers works like this :</p>
<h3><a class="anchor" id="autotoc_md277"></a>
Inspect the classic technique</h3>
<p>For each pass in the technique that would have been used normally, the GBufferSchemeHandler::inspectPass is called, inspects the pass, and returns the PassProperties - does this pass have a texture? a normal map? is it skinned? transparent? Etc. The PassProperties (should) contain all the information required to build a GBuffer technique for an object.</p>
<h3><a class="anchor" id="autotoc_md278"></a>
Generate the G-Buffer technique</h3>
<p>After a pass has been inspected and understood, the next stage is to generate the G-Buffer-writing technique. This is done using the RTSS GBuffer lighting stage. This greatly reduces the number of shaders that you need to manage when using deferred shading, as most of them are created on the fly. Here is an example of what they look like :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ToGBufferVP(</div>
<div class="line">         float4 iPosition : POSITION,</div>
<div class="line">         float3 iNormal   : NORMAL,</div>
<div class="line">         float2 iUV0 : TEXCOORD0,</div>
<div class="line"> </div>
<div class="line">         out float4 oPosition : POSITION,</div>
<div class="line">         out float3 oViewPos : TEXCOORD0,</div>
<div class="line">         out float3 oNormal : TEXCOORD1,</div>
<div class="line">         out float2 oUV0 : TEXCOORD2,</div>
<div class="line"> </div>
<div class="line">         uniform float4x4 cWorldViewProj,</div>
<div class="line">         uniform float4x4 cWorldView</div>
<div class="line">         )</div>
<div class="line"> {</div>
<div class="line">         oPosition = mul(cWorldViewProj, iPosition);</div>
<div class="line">         oNormal = mul(cWorldView, float4(iNormal,0)).xyz;</div>
<div class="line">         oViewPos = mul(cWorldView, iPosition).xyz;</div>
<div class="line">         oUV0 = iUV0;</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">void</span> ToGBufferFP(</div>
<div class="line">         float3 iViewPos : TEXCOORD0,</div>
<div class="line">         float3 iNormal   : TEXCOORD1,</div>
<div class="line">         float3 iTangent : TEXCOORD2,</div>
<div class="line">         float3 iBiNormal : TEXCOORD3,</div>
<div class="line">         float2 iUV0 : TEXCOORD4,</div>
<div class="line"> </div>
<div class="line">         out float4 oColor0 : COLOR0,</div>
<div class="line">         out float4 oColor1 : COLOR1,</div>
<div class="line"> </div>
<div class="line">         uniform sampler sNormalMap : register(s0),</div>
<div class="line">         uniform sampler sTex0 : register(s1),</div>
<div class="line">         uniform float4 cDiffuseColour,</div>
<div class="line">         uniform float cFarDistance,</div>
<div class="line">         uniform float cSpecularity</div>
<div class="line">         )</div>
<div class="line"> {</div>
<div class="line">         oColor0.rgb = tex2D(sTex0, iUV0);</div>
<div class="line">         oColor0.rgb *= cDiffuseColour.rgb;</div>
<div class="line">         oColor0.a = cSpecularity;</div>
<div class="line">         float3 texNormal = (tex2D(sNormalMap, iUV0)-0.5)*2;</div>
<div class="line">         float3x3 normalRotation = float3x3(iTangent, iBiNormal, iNormal);</div>
<div class="line">         oColor1.rgb = normalize(mul(texNormal, normalRotation));</div>
<div class="line">         oColor1.a = length(iViewPos) / cFarDistance;</div>
<div class="line"> }</div>
</div><!-- fragment --><p> (This is for an object with a texture and a normal map)</p>
<h3><a class="anchor" id="autotoc_md279"></a>
Add the G-Buffer technique to the original material</h3>
<p>We don't want to inspect the passes and generate the material each time an object is rendered, so we create a technique in the original material, and fill it with the auto-generated information. The next time the object will be rendered, it WILL have a technique for the GBuffer scheme, so the listener won't get called.</p>
<h3><a class="anchor" id="autotoc_md280"></a>
Putting it all together</h3>
<p>This is how <code>GBufferSchemeHandler::handleSchemeNotFound</code> works:</p>
<div class="fragment"><div class="line">Technique* GBufferSchemeHandler::handleSchemeNotFound(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> schemeIndex, </div>
<div class="line">        <span class="keyword">const</span> String&amp; schemeName, Material* originalMaterial, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> lodIndex, </div>
<div class="line">        <span class="keyword">const</span> Renderable* rend)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_ogre_1_1_material_manager.html">Ogre::MaterialManager</a>&amp; matMgr = <a class="code hl_function" href="class_ogre_1_1_material_manager.html#ae755a83a5d2d1dea391d8c1c74371e4f">Ogre::MaterialManager::getSingleton</a>();</div>
<div class="line">    String curSchemeName = matMgr.<a class="code hl_function" href="class_ogre_1_1_material_manager.html#ab4c6960d8effed1a36f9fc0387b8e967">getActiveScheme</a>();</div>
<div class="line">    matMgr.<a class="code hl_function" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(MSN_DEFAULT);</div>
<div class="line">    Technique* originalTechnique = originalMaterial-&gt;getBestTechnique(lodIndex, rend);</div>
<div class="line">    matMgr.<a class="code hl_function" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(curSchemeName);</div>
<div class="line"> </div>
<div class="line">    RTShader::ShaderGenerator&amp; rtShaderGen = RTShader::ShaderGenerator::getSingleton();</div>
<div class="line">    rtShaderGen.createShaderBasedTechnique(originalTechnique, <span class="stringliteral">&quot;GBuffer&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i=0; i&lt;originalTechnique-&gt;getNumPasses(); i++)</div>
<div class="line">    {</div>
<div class="line">        rtShaderGen.validateMaterial(<span class="stringliteral">&quot;GBuffer&quot;</span>, *originalMaterial);</div>
<div class="line">        <span class="comment">// Grab the generated technique.</span></div>
<div class="line">        <span class="keywordflow">for</span>(Technique* curTech : originalMaterial-&gt;getTechniques())</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (curTech-&gt;getSchemeName() == schemeName)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">return</span> curTech;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_ogre_1_1_material_manager_html"><div class="ttname"><a href="class_ogre_1_1_material_manager.html">Ogre::MaterialManager</a></div><div class="ttdoc">Class for managing Material settings for Ogre.</div><div class="ttdef"><b>Definition</b> OgreMaterialManager.h:79</div></div>
<div class="ttc" id="aclass_ogre_1_1_material_manager_html_a95decc3900f547bb68b74ba28d3013e0"><div class="ttname"><a href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">Ogre::MaterialManager::setActiveScheme</a></div><div class="ttdeci">virtual void setActiveScheme(const String &amp;schemeName)</div><div class="ttdoc">Sets the name of the active material scheme.</div></div>
<div class="ttc" id="aclass_ogre_1_1_material_manager_html_ab4c6960d8effed1a36f9fc0387b8e967"><div class="ttname"><a href="class_ogre_1_1_material_manager.html#ab4c6960d8effed1a36f9fc0387b8e967">Ogre::MaterialManager::getActiveScheme</a></div><div class="ttdeci">const String &amp; getActiveScheme(void) const</div><div class="ttdoc">Returns the name of the active material scheme.</div><div class="ttdef"><b>Definition</b> OgreMaterialManager.h:257</div></div>
<div class="ttc" id="aclass_ogre_1_1_material_manager_html_ae755a83a5d2d1dea391d8c1c74371e4f"><div class="ttname"><a href="class_ogre_1_1_material_manager.html#ae755a83a5d2d1dea391d8c1c74371e4f">Ogre::MaterialManager::getSingleton</a></div><div class="ttdeci">static MaterialManager &amp; getSingleton(void)</div><div class="ttdoc">Get the singleton instance.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md281"></a>
Overriding the automatic process</h2>
<p>In some cases the automatic material generation will not be good enough. We want to keep the option of manually writing GBuffer materials and shaders.</p>
<p>How do we do this? Easily! Since GBufferSchemeHandler::handleSchemeNotFound only gets called when an object doesn't already have a GBuffer scheme, adding a 'GBuffer' technique to the material will cause it to not get passed to the listener even once.</p>
<h2><a class="anchor" id="autotoc_md282"></a>
Seeing it in action</h2>
<p>Using tools like <a href="https://renderdoc.org/">RenderDoc</a>, we can see the texture being built during the frame:</p>
<div class="image">
<img src="GBufferRenderdoc.jpg" alt="" width="90%"/>
</div>
<p>Note that nothing has been written to the final output yet and that two output textures are being written to (see right hand side).</p>
<h1><a class="anchor" id="autotoc_md283"></a>
Lighting the scene</h1>
<p>In the GBuffer compositor, we built the G-Buffer for the current frame. It is now the time to use it to calculate the final lighting of the scene. This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/ShowLit</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Reference the main Gbuffer texture</span></div>
<div class="line">        texture_ref mrt_output DeferredShading/GBuffer mrt_output</div>
<div class="line">        </div>
<div class="line">        target_output</div>
<div class="line">        {</div>
<div class="line">            input none</div>
<div class="line">            <span class="comment">//We will dispatch the shadow texture rendering ourselves</span></div>
<div class="line">            shadows off</div>
<div class="line">            </div>
<div class="line">            pass clear</div>
<div class="line">            {</div>
<div class="line">                </div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// render skies and other pre-gbuffer objects</span></div>
<div class="line">            pass render_scene</div>
<div class="line">            {</div>
<div class="line">                first_render_queue 1</div>
<div class="line">                last_render_queue  9            </div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">//Render the lights and their meshes</span></div>
<div class="line">            pass render_custom DeferredLight</div>
<div class="line">            {</div>
<div class="line">                input 0 mrt_output 0</div>
<div class="line">                input 1 mrt_output 1</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">//Render transparents and other post-GBuffer render queue objects</span></div>
<div class="line">            pass render_scene</div>
<div class="line">            {</div>
<div class="line">                first_render_queue 90</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Yes, it's a long one. Here is a breakdown of the compositor :</p><ul>
<li>The 'texture_ref' definition means that we are referencing a texture from another compositor. In the case of a chain-scoped texture (like the GBuffer), this means that we can only apply this compositor on chains that have the GBuffer creating compositor earlier in the chain than this one. <a class="el" href="namespace_ogre.html">Ogre</a> will check that this is the case.</li>
</ul>
<p>There are four target passes in this compositor.</p><ol type="1">
<li>Render the skies and then the lights using the render_custom directive (more on this later)</li>
<li>Render the objects that are in the GBuffer render queues but didn't get rendered to the GBuffer</li>
<li>Render the post-GBuffer render queue objects</li>
<li>Output the result</li>
</ol>
<h2><a class="anchor" id="lightgeom"></a>
Rendering the light geometry</h2>
<p>The geometry that we want to render to calculate lighting information doesn't really fit in any classic category. It is not really a part of the scene, as the light geometry aren't objects in the world. But it is geometry (not always a quad) that needs to be rendered.</p>
<p>For these kind of operations, the render_custom target pass was introduced into <a class="el" href="namespace_ogre.html">Ogre</a>. It is possible to register custom (named) composition passes that will be performed in the compositor. In this case, it is 'DeferredLight'. The composition pass will receive a call each frame telling it 'it's your turn, do your thing'. The class in the demo is DeferredLightCP.</p>
<p>The registration of the custom composition pass has to be done once, using <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass.">Ogre::CompositorManager::registerCustomCompositionPass()</a>.</p>
<p>CustomCompositionPass is essentially just a factory for RenderSystemOperations, which are the operations that get executed during a compositor chain. This is the single API call: <a class="el" href="class_ogre_1_1_custom_composition_pass.html#a4f04b76126f4b667f4d4e62de1087044" title="Create a custom composition operation.">Ogre::CustomCompositionPass::createOperation()</a>.</p>
<p>So, now we get called exactly when we want, after the G-Buffer has been built and the (early) skies have been rendered. What will we do?</p>
<h3><a class="anchor" id="autotoc_md284"></a>
Prepare ambient colour and rebuild original depth buffer</h3>
<p>Since we rendered the original scene to a different RTT, the depth buffer won't necessarily get reused for the output target, so we need to rebuild it so that future objects (lights and non-g-buffer objects) will be able to interact with the depth naturally.</p>
<p>Also, we need to apply the ambient light to the scene. For the purpose of the demo, the ambient light is not a separate colour channel, just the object's original textures applied with the scene's global ambient light factor. In theory, you could set up a different G-Buffer to allow more flexibility, but we didn't do that.</p>
<p>These two actions happen in a single full-screen quad render, that comes from the AmbientLight class.</p>
<h3><a class="anchor" id="autotoc_md285"></a>
Render the light geometries</h3>
<p>The most important stage is the light geometry. The code scans the original scene's lights, builds a matching DLight (deferred light) instance for each light in the scene, and renders away using the G-Buffer.</p>
<p>These lights use pretty sophisticated shaders, since they perform the lighting calculations of the fixed function pipeline themselves, and have to account for many options (specularity, attenuation, different light types and shadows, which will get talked about soon). In contrast to the G-Buffer building stage, the shaders here do not get generated on the fly. There is one big shader (sometimes referred to as an Uber-Shader) with many preprocessor options that account for all the options. (See LightMaterial_ps.cg) Note that the shaders have to be synchronized with the G-Buffer layout. A change in the layout would need a parallel change in the deferred lighting shaders.</p>
<p>The material generator for this section (LightMaterialGenerator class) just scans the flags of input and generates the correct preprocessor defines for the uber-shader. Some people prefer to use this approach for the G-Buffer stage as well, but I wanted to show both options in the demo.</p>
<p>In order to dispatch render operations manually, the following call exists in SceneManager: <a class="el" href="class_ogre_1_1_scene_manager.html#a1593fab748d1b0820e93e49d5732350b" title="Render something as if it came from the current queue.">Ogre::SceneManager::_injectRenderWithPass()</a>.</p>
<p>When rendering a light, we pass the light we are rendering as the manual light list in order to have the auto params for that light available in the shader.</p>
<h3><a class="anchor" id="autotoc_md286"></a>
Rendering shadow casting lights</h3>
<p>The 'classic' approach to rendering texture shadows is to prepare all of them before the scene rendering starts, and then apply them to the rendered objects using shadow receiver passes or integrated shaders. The downside of this approach is that you need to allocate a texture per-light (5 shadow casting lights -&gt; 5 shadow textures) and that if you don't integrate it in your shaders you also contribute even more passes to the scene.</p>
<p>One of the advantages of deferred shading is that we render the lights completely, and one by one. So, we can generate the shadow texture for a light just before the light's geometry is rendered, allowing us to reuse the same texture for as many lights as we want. (We still have an overhead of rendering the scene from the light's perspective per-light).</p>
<p>The API call that prepares shadow textures on demand is <a class="el" href="class_ogre_1_1_scene_manager.html#a95cd8ff86a7178c2e37b2fcb485f64fa" title="Method for preparing shadow textures ready for use in a regular render Do not call manually unless be...">Ogre::SceneManager::prepareShadowTextures()</a>. The lightList parameter allows specification of which lights to prepare shadow textures for.</p>
<p>Important note - RenderSystemOperations get executed in the middle of scene rendering. This means that there is an active render target being rendered to. In order to render the shadow texture we need to be able to pause rendering mid frame, render the shadow texture, and resume rendering immediately afterwards. For this, SceneManager has two methods that do just that <a class="el" href="class_ogre_1_1_scene_manager.html#a5c9816798bda78389efc4f071051c739" title="Pause rendering of the frame.">Ogre::SceneManager::_pauseRendering()</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a794e03ea25dd798346414c1dba31337d" title="Resume rendering of the frame.">Ogre::SceneManager::_resumeRendering()</a>, so the prepareShadowTextures call has to be inside this.</p>
<p>The demo currently supports just spotlight shadow casting (since it is the cheapest to implement) but the other options can be supported as well.</p>
<h3><a class="anchor" id="autotoc_md287"></a>
Putting it all together</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DeferredLightRenderOperation::execute(SceneManager *sm, RenderSystem *rs)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_ogre_1_1_camera.html">Ogre::Camera</a>* cam = mViewport-&gt;getCamera();</div>
<div class="line"> </div>
<div class="line">    mAmbientLight-&gt;updateFromCamera(cam);</div>
<div class="line">    Technique* tech = mAmbientLight-&gt;getMaterial()-&gt;getBestTechnique();</div>
<div class="line">    injectTechnique(sm, tech, mAmbientLight, 0);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> LightList&amp; lightList = sm-&gt;_getLightsAffectingFrustum();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> *l : lightList)</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_typedef" href="group___general.html#gab82c6299605910b4051ebb3cc3e5539e">Ogre::LightList</a> ll;</div>
<div class="line">        ll.push_back(l);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//if (++i != 2) continue;</span></div>
<div class="line">        <span class="comment">//if (light-&gt;getType() != Light::LT_DIRECTIONAL) continue;</span></div>
<div class="line">        <span class="comment">//if (light-&gt;getDiffuseColour() != ColourValue::Red) continue;</span></div>
<div class="line"> </div>
<div class="line">        LightsMap::iterator dLightIt = mLights.find(l);</div>
<div class="line">        DLight* dLight = 0;</div>
<div class="line">        <span class="keywordflow">if</span> (dLightIt == mLights.end())</div>
<div class="line">        {</div>
<div class="line">            dLight = createDLight(l);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            dLight = dLightIt-&gt;second;</div>
<div class="line">            dLight-&gt;updateFromParent();</div>
<div class="line">        }</div>
<div class="line">        dLight-&gt;updateFromCamera(cam);</div>
<div class="line">        tech = dLight-&gt;getMaterial()-&gt;getBestTechnique();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//Update shadow texture</span></div>
<div class="line">        <span class="keywordflow">if</span> (dLight-&gt;getCastChadows())</div>
<div class="line">        {</div>
<div class="line">            SceneManager::RenderContext* context = sm-&gt;_pauseRendering();</div>
<div class="line"> </div>
<div class="line">            sm-&gt;prepareShadowTextures(cam, mViewport, &amp;ll);</div>
<div class="line">            sm-&gt;_resumeRendering(context);</div>
<div class="line"> </div>
<div class="line">            Pass* pass = tech-&gt;getPass(0);</div>
<div class="line">            TextureUnitState* tus = pass-&gt;getTextureUnitState(<span class="stringliteral">&quot;ShadowMap&quot;</span>);</div>
<div class="line">            assert(tus);</div>
<div class="line">            <span class="keyword">const</span> TexturePtr&amp; shadowTex = sm-&gt;getShadowTexture(0);</div>
<div class="line">            <span class="keywordflow">if</span> (tus-&gt;_getTexturePtr() != shadowTex)</div>
<div class="line">            {</div>
<div class="line">                tus-&gt;_setTexturePtr(shadowTex);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        injectTechnique(sm, tech, dLight, &amp;ll);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_ogre_1_1_camera_html"><div class="ttname"><a href="class_ogre_1_1_camera.html">Ogre::Camera</a></div><div class="ttdoc">A viewpoint from which the scene will be rendered.</div><div class="ttdef"><b>Definition</b> OgreCamera.h:86</div></div>
<div class="ttc" id="agroup___general_html_gab82c6299605910b4051ebb3cc3e5539e"><div class="ttname"><a href="group___general.html#gab82c6299605910b4051ebb3cc3e5539e">Ogre::LightList</a></div><div class="ttdeci">std::vector&lt; Light * &gt; LightList</div><div class="ttdef"><b>Definition</b> OgreCommon.h:364</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md288"></a>
Seeing it in action</h3>
<p>Here is a screenshot from RenderDoc of the draw call that renders a spotlight that casts shadows. See the two G-Buffer textures and one shadow texture on the right:</p>
<div class="image">
<img src="DeferredCone.jpg" alt="" width="90%"/>
</div>
<p>After all the lights are rendered, the scene is fully lit!</p>
<h1><a class="anchor" id="post"></a>
Post Processing</h1>
<p>The compositor framework used to be a post processing framework, but as this article shows - it is now a 'custom render pipeline' framework, allowing different rendering approaches. However, it can still be used to post process the scene, even under deferred rendering.</p>
<h2><a class="anchor" id="autotoc_md289"></a>
Screen Space Ambient Occlusion</h2>
<p>'Screen Space Ambient Occlusion' is a global illumination technique that adds a bit of realism to the scene, where classic lighting often fails. However, it requires the normals and depths of the scene in order to calculate its contribution. Normally, the SSAO compositor would have a render_scene directive that does that.</p>
<p>However, with deferred shading, we already have that information from the G-Buffer stage, so we just need to access it!</p>
<p>This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/SSAO</div>
<div class="line">{</div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        compositor_logic SSAOLogic</div>
<div class="line">        </div>
<div class="line">        texture_ref geom DeferredShading/GBuffer mrt_output</div>
<div class="line">        texture scene target_width target_height PF_BYTE_RGBA</div>
<div class="line">        texture ssao target_width_scaled 0.5 target_height_scaled 0.5 PF_BYTE_RGB</div>
<div class="line">        texture ssaoBlurX target_width target_height PF_BYTE_RGB</div>
<div class="line">        texture ssaoBlurY target_width target_height PF_BYTE_RGB</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// the scene we want to modulate</span></div>
<div class="line">        target scene</div>
<div class="line">        {</div>
<div class="line">            input previous</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        </div>
<div class="line"> </div>
<div class="line">        target ssao</div>
<div class="line">        {</div>
<div class="line">            input none</div>
<div class="line"> </div>
<div class="line">            pass clear</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            pass render_quad</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// our SSAO listener number</span></div>
<div class="line">                identifier 42</div>
<div class="line"> </div>
<div class="line">                quad_normals camera_far_corners_view_space</div>
<div class="line"> </div>
<div class="line">                material ssao</div>
<div class="line">                <span class="comment">// pass in the &quot;geometry map&quot;</span></div>
<div class="line">                input 0 geom 1</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        target ssaoBlurX</div>
<div class="line">        {</div>
<div class="line">            input none</div>
<div class="line"> </div>
<div class="line">            pass clear</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            pass render_quad</div>
<div class="line">            {</div>
<div class="line">                identifier 43</div>
<div class="line"> </div>
<div class="line">                material ssaoBlurX</div>
<div class="line">                input 0 ssao</div>
<div class="line">                input 1 geom 1</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        target ssaoBlurY</div>
<div class="line">        {</div>
<div class="line">            input none</div>
<div class="line"> </div>
<div class="line">            pass clear</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            pass render_quad</div>
<div class="line">            {</div>
<div class="line">                identifier 43</div>
<div class="line"> </div>
<div class="line">                material ssaoBlurY</div>
<div class="line">                input 0 ssaoBlurX</div>
<div class="line">                input 1 geom 1</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        target_output</div>
<div class="line">        {</div>
<div class="line">            input none</div>
<div class="line"> </div>
<div class="line">            pass render_quad</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// just output something, for example, use a modulate</span></div>
<div class="line">                <span class="comment">// material to just multiply the scene by the ssao</span></div>
<div class="line">                material modulate</div>
<div class="line">                input 0 scene</div>
<div class="line">                input 1 ssaoBlurY</div>
<div class="line">                <span class="comment">//input 1 ssao</span></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Some notes :</p><ul>
<li>Again, texture_ref is used to access a chain_scoped texture from the GBuffer compositor</li>
<li>compositor_logic is used to couple between the compositor and some code that it requires to run. A CompositorLogic class is created and registered with the CompositorManager with <a class="el" href="class_ogre_1_1_compositor_manager.html#a9c7d4168d56868599badb2789d54157c" title="Register a compositor logic for listening in to expecting composition techniques.">Ogre::CompositorManager::registerCompositorLogic()</a>. Which will cause the binding code to run whenever an instance of this compositor is created.</li>
<li>'Regular' compositors that don't use the GBuffer are also still possible of course, they can be used regularly, as long as they are placed after the DeferredShading/ShowLit compositor.</li>
</ul>
<h1><a class="anchor" id="realprojects"></a>
Integration in real projects</h1>
<p>The framework that this demo uses was designed to be pluggable into other projects. Some of the design considerations that contribute to that are :</p><ol type="1">
<li>The scene setup does not change in any way. You still set the scene up with normal lights and modify their parameters just like you would regularly.</li>
<li>The GBuffer scheme handler and shader generator allow existing materials to work in a deferred shading pipeline unmodified. It might not cover all the cases, but it can.</li>
<li>Easy to integrate - see next section</li>
</ol>
<h2><a class="anchor" id="autotoc_md290"></a>
Integration steps</h2>
<p>The framework created for a demo fits the plugin architecture pretty well. The GBufferSchemeHandler and DeferredLightCompositionPass classes could be instantiated once on plugin setup and registered with ogre's systems. This is not the case currently just to keep the SDK build simpler.</p>
<p>So, the steps are :</p><ol type="1">
<li>Register GBufferSchemeHandler and DeferredLightCompositionPass with their respective managers.</li>
<li>Add the GBuffer and ShowLit compositors to the viewports you want deferred shaded.</li>
</ol>
<p>And that's it! In the demo, the DeferredShading class takes care of that.</p>
<h2><a class="anchor" id="autotoc_md291"></a>
Adapting the framework</h2>
<p>The deferred shading framework in the demo was designed to be usable in real applications. Where would one want to modify it ?</p><ol type="1">
<li>GBufferSchemeHandler / MaterialGenerator - support more options out of the box. Skinning, specular maps, and whatever you have in your project that can be solved in a generic fashion.</li>
<li>LightMaterialGenerator - support more lighting options (fog, etc), more shadow types, different shadow techniques (currently using very basic depth shadow mapping)</li>
<li>Tweak the framework to your pipeline - The material inspection relies on naming (among other things) to decide what its looking at. Just modify it to fit your art pipeline's conventions! (For example, how does a texture get flagged as a normal map?)</li>
</ol>
<p>Indeed, it means that the framework is not 100% plug and play. But, if understood correctly, it can be adapted to real life scenarios with relative ease.</p>
<h2><a class="anchor" id="autotoc_md292"></a>
Adding features to the framework</h2>
<p>Post processing compositors that rely on certain aspects of the scene (like SSAO does) are now much easier to create and integrate with the earlier processes. An example could be edge-based anti aliasing, to address the lack of anti aliasing in DX9-based deferred shading systems.</p>
<p>In addition to that, the deferred shading implementation was focused on simplicity. There are many optimization options and most of them were not done, mainly to keep the demo as simple and understandable as possible.</p>
<h1><a class="anchor" id="summary"></a>
Summary</h1>
<p>Deferred Shading is an advanced rendering technique, that brings a pretty big implementation challenge along with it. This article, along with the demo, shows that it is possible to implement without relying on hacks and bypassing ogre's systems. Yes, it involves more advanced usage of ogre's APIs and requires a bit of knowledge about what happens behind the scenes, but is in no way impossible.</p>
<h2><a class="anchor" id="further"></a>
Further reading</h2>
<ul>
<li><a href="https://d1z4o56rleaq4j.cloudfront.net/downloads/assets/Develop07_Valient_DeferredRenderingInKillzone2.pdf">KillZone 2 Deferred Shading overview</a> - Great resource for understanding deferred shading in general before diving into implementing it in <a class="el" href="namespace_ogre.html">Ogre</a>.</li>
<li><a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SoC2009+Compositor">Improving Ogre's Compositor Framework GSoC project page</a></li>
<li><a href="https://www.gamedev.net/articles/programming/graphics/deferred-rendering-demystified-r2746/">Deferred Rendering Demystified</a> - An article written around this project that explains the design behind the deferred renderer. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
