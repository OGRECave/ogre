<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Manual mesh creation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('manual-mesh-creation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Manual mesh creation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>There are two ways to create your own mesh. The first way is to create a <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Ogre::Mesh</a> instance and provide it with the vertex and index buffers directly.</p>
<p>The second way is the high level <a class="el" href="class_ogre_1_1_manual_object.html" title="Class providing a much simplified interface to generating manual objects with custom geometry.">Ogre::ManualObject</a> interface. Instead of filling position and color buffers, you simply call the "position" and "colour" functions.</p>
<h1><a class="anchor" id="autotoc_md298"></a>
Using Manual Object</h1>
<p>Building one-off geometry objects manually usually requires getting down and dirty with the vertex buffer and vertex declaration API, which some people find a steep learning curve. This class gives you a simpler interface specifically for the purpose of building a 3D object simply and quickly. Note that if you intend to instance your object you will still need to become familiar with the Mesh class.</p>
<p>This class draws heavily on the interface for OpenGL immediate-mode (<code>glBegin</code>, <code>glVertex</code>, <code>glNormal</code> etc), since this is generally well-liked by people. There are a couple of differences in the results though - internally this class still builds hardware buffers which can be re-used, so you can render the resulting object multiple times without re-issuing all the same commands again. Secondly, the rendering is not immediate, it is still queued just like all OGRE objects. This makes this object more efficient than the equivalent GL immediate-mode commands, so it's feasible to use it for large objects if you really want to.</p>
<p>To construct some geometry with this object:</p><ol type="1">
<li>If you know roughly how many vertices (and indices, if you use them) you're going to submit, call estimateVertexCount() and estimateIndexCount(). This is not essential but will make the process more efficient by saving memory reallocations.</li>
<li>Call begin() to begin entering data</li>
<li>For each vertex, call position(), normal(), textureCoord(), colour() to define your vertex data. Note that each time you call position() you start a new vertex. Note that the first vertex defines the components of the vertex - you can't add more after that. For example if you didn't call normal() in the first vertex, you cannot call it in any others. You ought to call the same combination of methods per vertex.</li>
<li>If you want to define triangles (or lines/points) by indexing into the vertex list, you can call index() as many times as you need to define them. If you don't do this, the class will assume you want triangles drawn directly as defined by the vertex list, i.e. non-indexed geometry. Note that stencil shadows are only supported on indexed geometry, and that indexed geometry is a little faster; so you should try to use it.</li>
<li>Call end() to finish entering data.</li>
<li>Optionally repeat the begin-end cycle if you want more geometry using different rendering operation types, or different materials After calling end(), the class will organise the data for that section internally and make it ready to render with. Like any other MovableObject you should attach the object to a SceneNode to make it visible. Other aspects like the relative render order can be controlled using standard MovableObject methods like setRenderQueueGroup.</li>
</ol>
<p>You can also use beginUpdate() to alter the geometry later on if you wish. If you do this, you should call setDynamic(true) before your first call to begin(), and also consider using estimateVertexCount() / estimateIndexCount() if your geometry is going to be growing, to avoid buffer recreation during growth.</p>
<dl class="section note"><dt>Note</dt><dd>like all OGRE geometry, triangles should be specified in anti-clockwise winding order (whether you're doing it with just vertices, or using indexes too). That is to say that the front of the face is the one where the vertices are listed in anti-clockwise order.  </dd></dl>
<h2><a class="anchor" id="autotoc_md299"></a>
Example</h2>
<p>We will use the ManualObject to create a single textured plane. After creating the object, we start a new geometry block that will use the given material</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="class_ogre_1_1_manual_object.html">Ogre::ManualObject</a>* man = mSceneMgr-&gt;createManualObject(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#a70d5945478fbc7fa056cecd88fdf2781">begin</a>(<span class="stringliteral">&quot;Examples/OgreLogo&quot;</span>, <a class="code hl_enumvalue" href="class_ogre_1_1_render_operation.html#ab8b780ec18ee4675e85f475b21f77c82a8c00ee152b44fe8000c2fd675437c087">Ogre::RenderOperation::OT_TRIANGLE_LIST</a>);</div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html"><div class="ttname"><a href="class_ogre_1_1_manual_object.html">Ogre::ManualObject</a></div><div class="ttdoc">Class providing a much simplified interface to generating manual objects with custom geometry.</div><div class="ttdef"><b>Definition</b> OgreManualObject.h:107</div></div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html_a70d5945478fbc7fa056cecd88fdf2781"><div class="ttname"><a href="class_ogre_1_1_manual_object.html#a70d5945478fbc7fa056cecd88fdf2781">Ogre::ManualObject::begin</a></div><div class="ttdeci">virtual void begin(const String &amp;materialName, RenderOperation::OperationType opType=RenderOperation::OT_TRIANGLE_LIST, const String &amp;groupName=ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)</div><div class="ttdoc">Start defining a part of the object.</div></div>
<div class="ttc" id="aclass_ogre_1_1_render_operation_html_ab8b780ec18ee4675e85f475b21f77c82a8c00ee152b44fe8000c2fd675437c087"><div class="ttname"><a href="class_ogre_1_1_render_operation.html#ab8b780ec18ee4675e85f475b21f77c82a8c00ee152b44fe8000c2fd675437c087">Ogre::RenderOperation::OT_TRIANGLE_LIST</a></div><div class="ttdeci">@ OT_TRIANGLE_LIST</div><div class="ttdoc">A list of triangles, 3 vertices per triangle.</div><div class="ttdef"><b>Definition</b> OgreRenderOperation.h:56</div></div>
</div><!-- fragment --><p>Next we specify the vertices of the plane</p>
<div class="fragment"><div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#a187c45061916977737747db37e2d17dd">position</a>(-20, 20, 20);</div>
<div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#ae4e167780418393dcfe2f1832c0b3d04">normal</a>(0, 0, 1);</div>
<div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#a66932d232441c8fa8208d46343ff526b">textureCoord</a>(0, 0);</div>
<div class="line"> </div>
<div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#a187c45061916977737747db37e2d17dd">position</a>(-20, -20, 20);</div>
<div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#ae4e167780418393dcfe2f1832c0b3d04">normal</a>(0, 0, 1);</div>
<div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#a66932d232441c8fa8208d46343ff526b">textureCoord</a>(0, 1);</div>
<div class="line"> </div>
<div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#a187c45061916977737747db37e2d17dd">position</a>(20, -20, 20);</div>
<div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#ae4e167780418393dcfe2f1832c0b3d04">normal</a>(0, 0, 1);</div>
<div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#a66932d232441c8fa8208d46343ff526b">textureCoord</a>(1, 1);</div>
<div class="line"> </div>
<div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#a187c45061916977737747db37e2d17dd">position</a>(20, 20, 20);</div>
<div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#ae4e167780418393dcfe2f1832c0b3d04">normal</a>(0, 0, 1);</div>
<div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#a66932d232441c8fa8208d46343ff526b">textureCoord</a>(1, 0);</div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html_a187c45061916977737747db37e2d17dd"><div class="ttname"><a href="class_ogre_1_1_manual_object.html#a187c45061916977737747db37e2d17dd">Ogre::ManualObject::position</a></div><div class="ttdeci">void position(const Vector3 &amp;pos)</div><div class="ttdoc">Add a vertex position, starting a new vertex at the same time.</div><div class="ttdef"><b>Definition</b> OgreManualObject.h:199</div></div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html_a66932d232441c8fa8208d46343ff526b"><div class="ttname"><a href="class_ogre_1_1_manual_object.html#a66932d232441c8fa8208d46343ff526b">Ogre::ManualObject::textureCoord</a></div><div class="ttdeci">void textureCoord(float u)</div><div class="ttdoc">Add a texture coordinate to the current vertex.</div><div class="ttdef"><b>Definition</b> OgreManualObject.h:273</div></div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html_ae4e167780418393dcfe2f1832c0b3d04"><div class="ttname"><a href="class_ogre_1_1_manual_object.html#ae4e167780418393dcfe2f1832c0b3d04">Ogre::ManualObject::normal</a></div><div class="ttdeci">void normal(const Vector3 &amp;norm)</div><div class="ttdoc">Add a vertex normal to the current vertex.</div><div class="ttdef"><b>Definition</b> OgreManualObject.h:233</div></div>
</div><!-- fragment --><p>Now we can define the face. Ogre will split the quad into triangles for us.</p>
<div class="fragment"><div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#a27ae16d1c958d097a6faa58495e43a22">quad</a>(0, 1, 2, 3);</div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html_a27ae16d1c958d097a6faa58495e43a22"><div class="ttname"><a href="class_ogre_1_1_manual_object.html#a27ae16d1c958d097a6faa58495e43a22">Ogre::ManualObject::quad</a></div><div class="ttdeci">void quad(uint32 i1, uint32 i2, uint32 i3, uint32 i4)</div><div class="ttdoc">Add a set of 4 vertex indices to construct a quad (out of 2 triangles); this is a shortcut to calling...</div><div class="ttdef"><b>Definition</b> OgreManualObject.h:400</div></div>
</div><!-- fragment --><p>Calling <code>end()</code> creates the actual Hardware Buffers to be used for rendering and we can attach the Object to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph.">Ogre::SceneNode</a>.</p>
<div class="fragment"><div class="line">    man-&gt;<a class="code hl_function" href="class_ogre_1_1_manual_object.html#a97f92950a31390de53be9f7d7edd5eb4">end</a>();</div>
<div class="line">    mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode()-&gt;attachObject(man);</div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html_a97f92950a31390de53be9f7d7edd5eb4"><div class="ttname"><a href="class_ogre_1_1_manual_object.html#a97f92950a31390de53be9f7d7edd5eb4">Ogre::ManualObject::end</a></div><div class="ttdeci">virtual ManualObjectSection * end(void)</div><div class="ttdoc">Finish defining the object and compile the final renderable version.</div></div>
</div><!-- fragment --><p>In case you need multiple Ogre::Entities of the plane, you should call <a class="el" href="class_ogre_1_1_manual_object.html#a657275e617d9558951a3037f02b07efe" title="Convert this object to a Mesh.">Ogre::ManualObject::convertToMesh</a> first and then use <a class="el" href="class_ogre_1_1_scene_manager.html#a7bb6387adbaaac0ff9119e3a85931505" title="Create an Entity (instance of a discrete mesh).">Ogre::SceneManager::createEntity</a> as usual.</p>
<h1><a class="anchor" id="autotoc_md300"></a>
Using vertex and index buffers directly</h1>
<p>This time we are going to create a plane using the lower level <a class="el" href="class_ogre_1_1_hardware_buffer.html" title="Abstract class defining common features of hardware buffers.">Ogre::HardwareBuffer</a> primitives.</p>
<p>We start by creating a Mesh object. As this is a manual Mesh, we have to set the bounds of it explicitly. </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ogre.html">Ogre</a>;</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_ogre_1_1_shared_ptr.html">MeshPtr</a> mesh = MeshManager::getSingleton().createManual(<a class="code hl_struct" href="struct_ogre_1_1vector.html">yourMeshName</a>, RGN_DEFAULT);</div>
<div class="line">        mesh-&gt;<a class="code hl_function" href="class_ogre_1_1_mesh.html#a8c40c34ec7c32009904c0cd730f68b5d">_setBounds</a>(<a class="code hl_class" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>({-100,-100,0}, {100,100,0});</div>
<div class="ttc" id="aclass_ogre_1_1_axis_aligned_box_html"><div class="ttname"><a href="class_ogre_1_1_axis_aligned_box.html">Ogre::AxisAlignedBox</a></div><div class="ttdoc">A 3D box aligned with the x/y/z axes.</div><div class="ttdef"><b>Definition</b> OgreAxisAlignedBox.h:56</div></div>
<div class="ttc" id="aclass_ogre_1_1_mesh_html_a8c40c34ec7c32009904c0cd730f68b5d"><div class="ttname"><a href="class_ogre_1_1_mesh.html#a8c40c34ec7c32009904c0cd730f68b5d">Ogre::Mesh::_setBounds</a></div><div class="ttdeci">void _setBounds(const AxisAlignedBox &amp;bounds, bool pad=true)</div><div class="ttdoc">Manually set the bounding box for this Mesh.</div></div>
<div class="ttc" id="aclass_ogre_1_1_shared_ptr_html"><div class="ttname"><a href="class_ogre_1_1_shared_ptr.html">Ogre::SharedPtr&lt; Mesh &gt;</a></div></div>
<div class="ttc" id="anamespace_ogre_html"><div class="ttname"><a href="namespace_ogre.html">Ogre</a></div><div class="ttdef"><b>Definition</b> OgreAlignedAllocator.h:34</div></div>
<div class="ttc" id="astruct_ogre_1_1vector_html"><div class="ttname"><a href="struct_ogre_1_1vector.html">Ogre::vector</a></div><div class="ttdef"><b>Definition</b> OgreDeprecated.h:54</div></div>
</div><!-- fragment --><p>Next we define what should end up in our vertex and index buffer. We will store all data interleaved in one buffer. This typically has some advantages due to cache coherency and also is what ManualObject does automatically for us.</p>
<div class="fragment"><div class="line">        <span class="keywordtype">float</span> <a class="code hl_struct" href="struct_ogre_1_1vector.html">vertices</a>[32] = {</div>
<div class="line">            -100, -100, 0,  <span class="comment">// pos</span></div>
<div class="line">            0,0,1,          <span class="comment">// normal</span></div>
<div class="line">            0,1,            <span class="comment">// texcoord</span></div>
<div class="line">            100, -100, 0,</div>
<div class="line">            0,0,1,</div>
<div class="line">            1,1,</div>
<div class="line">            100,  100, 0,</div>
<div class="line">            0,0,1,</div>
<div class="line">            1,0,</div>
<div class="line">            -100,  100, 0 ,</div>
<div class="line">            0,0,1,</div>
<div class="line">            0,0 </div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_struct" href="struct_ogre_1_1vector.html">uint16</a> <a class="code hl_struct" href="struct_ogre_1_1vector.html">faces</a>[6] = {0,1,2,</div>
<div class="line">                           0,2,3 };</div>
</div><!-- fragment --><p>However we could also split the data into multiple buffers with lower precision to save some bytes on texture coordinates and normals.</p>
<p>To describe the vertex sources, we have to create a <a class="el" href="class_ogre_1_1_vertex_data.html" title="collects together all the vertex-related information used to render geometry.">Ogre::VertexData</a> object. Notably it stores how many vertices we have.</p>
<div class="fragment"><div class="line">        mesh-&gt;<a class="code hl_function" href="class_ogre_1_1_mesh.html#adcbc72da23236ec8c702f9b07defe37b">createVertexData</a>();</div>
<div class="line">        mesh-&gt;<a class="code hl_variable" href="class_ogre_1_1_mesh.html#a1fd9968ccd424f913a7f3f68639f3ecf">sharedVertexData</a>-&gt;<a class="code hl_variable" href="class_ogre_1_1_vertex_data.html#a6afe42c302caf4f47d57b8771f5691fe">vertexCount</a> = 4;</div>
<div class="line">        <a class="code hl_class" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a>* <a class="code hl_struct" href="struct_ogre_1_1vector.html">decl</a> = mesh-&gt;<a class="code hl_variable" href="class_ogre_1_1_mesh.html#a1fd9968ccd424f913a7f3f68639f3ecf">sharedVertexData</a>-&gt;<a class="code hl_variable" href="class_ogre_1_1_vertex_data.html#abac9cde9c001b97cf1fea7fd05b79cf4">vertexDeclaration</a>;</div>
<div class="line">        <a class="code hl_class" href="class_ogre_1_1_vertex_buffer_binding.html">VertexBufferBinding</a>* bind = mesh-&gt;<a class="code hl_variable" href="class_ogre_1_1_mesh.html#a1fd9968ccd424f913a7f3f68639f3ecf">sharedVertexData</a>-&gt;<a class="code hl_variable" href="class_ogre_1_1_vertex_data.html#a1cf7dacb2a133d71620abd59cb3180b0">vertexBufferBinding</a>;</div>
<div class="ttc" id="aclass_ogre_1_1_mesh_html_a1fd9968ccd424f913a7f3f68639f3ecf"><div class="ttname"><a href="class_ogre_1_1_mesh.html#a1fd9968ccd424f913a7f3f68639f3ecf">Ogre::Mesh::sharedVertexData</a></div><div class="ttdeci">VertexData * sharedVertexData</div><div class="ttdoc">Shared vertex data.</div><div class="ttdef"><b>Definition</b> OgreMesh.h:310</div></div>
<div class="ttc" id="aclass_ogre_1_1_mesh_html_adcbc72da23236ec8c702f9b07defe37b"><div class="ttname"><a href="class_ogre_1_1_mesh.html#adcbc72da23236ec8c702f9b07defe37b">Ogre::Mesh::createVertexData</a></div><div class="ttdeci">void createVertexData(HardwareBufferManagerBase *mgr=nullptr)</div><div class="ttdoc">Creates a new shared vertex data object.</div><div class="ttdef"><b>Definition</b> OgreMesh.h:320</div></div>
<div class="ttc" id="aclass_ogre_1_1_vertex_buffer_binding_html"><div class="ttname"><a href="class_ogre_1_1_vertex_buffer_binding.html">Ogre::VertexBufferBinding</a></div><div class="ttdoc">Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...</div><div class="ttdef"><b>Definition</b> OgreHardwareVertexBuffer.h:480</div></div>
<div class="ttc" id="aclass_ogre_1_1_vertex_data_html_a1cf7dacb2a133d71620abd59cb3180b0"><div class="ttname"><a href="class_ogre_1_1_vertex_data.html#a1cf7dacb2a133d71620abd59cb3180b0">Ogre::VertexData::vertexBufferBinding</a></div><div class="ttdeci">VertexBufferBinding * vertexBufferBinding</div><div class="ttdoc">Defines which vertex buffers are bound to which sources.</div><div class="ttdef"><b>Definition</b> OgreVertexIndexData.h:95</div></div>
<div class="ttc" id="aclass_ogre_1_1_vertex_data_html_a6afe42c302caf4f47d57b8771f5691fe"><div class="ttname"><a href="class_ogre_1_1_vertex_data.html#a6afe42c302caf4f47d57b8771f5691fe">Ogre::VertexData::vertexCount</a></div><div class="ttdeci">uint32 vertexCount</div><div class="ttdoc">The number of vertices to process in this particular rendering group.</div><div class="ttdef"><b>Definition</b> OgreVertexIndexData.h:101</div></div>
<div class="ttc" id="aclass_ogre_1_1_vertex_data_html_abac9cde9c001b97cf1fea7fd05b79cf4"><div class="ttname"><a href="class_ogre_1_1_vertex_data.html#abac9cde9c001b97cf1fea7fd05b79cf4">Ogre::VertexData::vertexDeclaration</a></div><div class="ttdeci">VertexDeclaration * vertexDeclaration</div><div class="ttdoc">Declaration of the the format of the vertex input.</div><div class="ttdef"><b>Definition</b> OgreVertexIndexData.h:91</div></div>
<div class="ttc" id="aclass_ogre_1_1_vertex_declaration_html"><div class="ttname"><a href="class_ogre_1_1_vertex_declaration.html">Ogre::VertexDeclaration</a></div><div class="ttdoc">This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...</div><div class="ttdef"><b>Definition</b> OgreHardwareVertexBuffer.h:278</div></div>
</div><!-- fragment --><p>The actual description of our vertex buffer however is stored inside the <a class="el" href="class_ogre_1_1_vertex_declaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">Ogre::VertexDeclaration</a>.</p>
<div class="fragment"><div class="line">        <span class="keywordtype">size_t</span> offset = 0;</div>
<div class="line">        offset += <a class="code hl_struct" href="struct_ogre_1_1vector.html">decl</a>-&gt;addElement(0, offset, VET_FLOAT3, VES_POSITION).getSize();</div>
<div class="line">        offset += <a class="code hl_struct" href="struct_ogre_1_1vector.html">decl</a>-&gt;addElement(0, offset, VET_FLOAT3, VES_NORMAL).getSize();</div>
<div class="line">        offset += <a class="code hl_struct" href="struct_ogre_1_1vector.html">decl</a>-&gt;addElement(0, offset, VET_FLOAT2, VES_TEXTURE_COORDINATES, 0).getSize();</div>
</div><!-- fragment --><p>Now we can continue to create the Hardware Buffers and upload our data.</p>
<div class="fragment"><div class="line">        <a class="code hl_class" href="class_ogre_1_1_shared_ptr.html">HardwareVertexBufferPtr</a> <a class="code hl_struct" href="struct_ogre_1_1vector.html">vbuf</a> =</div>
<div class="line">            HardwareBufferManager::getSingleton().createVertexBuffer(offset, 4, HBU_GPU_ONLY);</div>
<div class="line">        <a class="code hl_struct" href="struct_ogre_1_1vector.html">vbuf</a>-&gt;writeData(0, <a class="code hl_struct" href="struct_ogre_1_1vector.html">vbuf</a>-&gt;getSizeInBytes(), <a class="code hl_struct" href="struct_ogre_1_1vector.html">vertices</a>, <span class="keyword">true</span>);</div>
<div class="line">        bind-&gt;<a class="code hl_function" href="class_ogre_1_1_vertex_buffer_binding.html#ae992dcf47b063f02f47cc302f9839de9">setBinding</a>(0, <a class="code hl_struct" href="struct_ogre_1_1vector.html">vbuf</a>);</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_ogre_1_1_shared_ptr.html">HardwareIndexBufferPtr</a> <a class="code hl_struct" href="struct_ogre_1_1vector.html">ibuf</a> =</div>
<div class="line">            HardwareBufferManager::getSingleton().createIndexBuffer(HardwareIndexBuffer::IT_16BIT, 6, HBU_GPU_ONLY);</div>
<div class="line">        <a class="code hl_struct" href="struct_ogre_1_1vector.html">ibuf</a>-&gt;writeData(0, <a class="code hl_struct" href="struct_ogre_1_1vector.html">ibuf</a>-&gt;getSizeInBytes(), <a class="code hl_struct" href="struct_ogre_1_1vector.html">faces</a>, <span class="keyword">true</span>);</div>
<div class="ttc" id="aclass_ogre_1_1_vertex_buffer_binding_html_ae992dcf47b063f02f47cc302f9839de9"><div class="ttname"><a href="class_ogre_1_1_vertex_buffer_binding.html#ae992dcf47b063f02f47cc302f9839de9">Ogre::VertexBufferBinding::setBinding</a></div><div class="ttdeci">void setBinding(unsigned short index, const HardwareVertexBufferSharedPtr &amp;buffer)</div><div class="ttdoc">Set a binding, associating a vertex buffer with a given index.</div></div>
</div><!-- fragment --><p>Note how we used the symbolical constant <code>0</code> to link the <a class="el" href="class_ogre_1_1_hardware_vertex_buffer.html" title="Specialisation of HardwareBuffer for a vertex buffer.">Ogre::HardwareVertexBuffer</a> to the <a class="el" href="class_ogre_1_1_vertex_declaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">Ogre::VertexDeclaration</a>. This allows the underlying RenderSystem to swap VertexBuffers without changing the VertexDeclaration. i.e. render different Meshes that share the same vertex layout, without changing the state.</p>
<p>Finally we create the <a class="el" href="class_ogre_1_1_sub_mesh.html" title="Defines a part of a complete mesh.">Ogre::SubMesh</a> that will be ultimately rendered.</p>
<div class="fragment"><div class="line">        <a class="code hl_class" href="class_ogre_1_1_sub_mesh.html">SubMesh</a>* sub = mesh-&gt;<a class="code hl_function" href="class_ogre_1_1_mesh.html#af3841a74eb861910b00bb6c7744faf65">createSubMesh</a>();</div>
<div class="line">        sub-&gt;<a class="code hl_variable" href="class_ogre_1_1_sub_mesh.html#a931e3764e3bf1c3ef7431fc852770fb1">useSharedVertices</a> = <span class="keyword">true</span>;</div>
<div class="line">        sub-&gt;<a class="code hl_variable" href="class_ogre_1_1_sub_mesh.html#aad428fa6595c7fb01ef7543e5d8d6454">indexData</a>-&gt;<a class="code hl_variable" href="class_ogre_1_1_index_data.html#a1a9f241fbc57ce4cce5615302da71b76">indexBuffer</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">ibuf</a>;</div>
<div class="line">        sub-&gt;<a class="code hl_variable" href="class_ogre_1_1_sub_mesh.html#aad428fa6595c7fb01ef7543e5d8d6454">indexData</a>-&gt;<a class="code hl_variable" href="class_ogre_1_1_index_data.html#a77a5cd1f32a0ac033a7cee9b50424c4e">indexCount</a> = 6;</div>
<div class="line">        sub-&gt;<a class="code hl_variable" href="class_ogre_1_1_sub_mesh.html#aad428fa6595c7fb01ef7543e5d8d6454">indexData</a>-&gt;<a class="code hl_variable" href="class_ogre_1_1_index_data.html#a5de34ff4f44a224ac2f1f9b855d8671c">indexStart</a> = 0;</div>
<div class="ttc" id="aclass_ogre_1_1_index_data_html_a1a9f241fbc57ce4cce5615302da71b76"><div class="ttname"><a href="class_ogre_1_1_index_data.html#a1a9f241fbc57ce4cce5615302da71b76">Ogre::IndexData::indexBuffer</a></div><div class="ttdeci">HardwareIndexBufferSharedPtr indexBuffer</div><div class="ttdoc">Pointer to the HardwareIndexBuffer to use, must be specified if useIndexes = true.</div><div class="ttdef"><b>Definition</b> OgreVertexIndexData.h:254</div></div>
<div class="ttc" id="aclass_ogre_1_1_index_data_html_a5de34ff4f44a224ac2f1f9b855d8671c"><div class="ttname"><a href="class_ogre_1_1_index_data.html#a5de34ff4f44a224ac2f1f9b855d8671c">Ogre::IndexData::indexStart</a></div><div class="ttdeci">uint32 indexStart</div><div class="ttdoc">Index in the buffer to start from for this operation.</div><div class="ttdef"><b>Definition</b> OgreVertexIndexData.h:257</div></div>
<div class="ttc" id="aclass_ogre_1_1_index_data_html_a77a5cd1f32a0ac033a7cee9b50424c4e"><div class="ttname"><a href="class_ogre_1_1_index_data.html#a77a5cd1f32a0ac033a7cee9b50424c4e">Ogre::IndexData::indexCount</a></div><div class="ttdeci">uint32 indexCount</div><div class="ttdoc">The number of indexes to use from the buffer.</div><div class="ttdef"><b>Definition</b> OgreVertexIndexData.h:260</div></div>
<div class="ttc" id="aclass_ogre_1_1_mesh_html_af3841a74eb861910b00bb6c7744faf65"><div class="ttname"><a href="class_ogre_1_1_mesh.html#af3841a74eb861910b00bb6c7744faf65">Ogre::Mesh::createSubMesh</a></div><div class="ttdeci">SubMesh * createSubMesh(void)</div><div class="ttdoc">Creates a new SubMesh.</div></div>
<div class="ttc" id="aclass_ogre_1_1_sub_mesh_html"><div class="ttname"><a href="class_ogre_1_1_sub_mesh.html">Ogre::SubMesh</a></div><div class="ttdoc">Defines a part of a complete mesh.</div><div class="ttdef"><b>Definition</b> OgreSubMesh.h:61</div></div>
<div class="ttc" id="aclass_ogre_1_1_sub_mesh_html_a931e3764e3bf1c3ef7431fc852770fb1"><div class="ttname"><a href="class_ogre_1_1_sub_mesh.html#a931e3764e3bf1c3ef7431fc852770fb1">Ogre::SubMesh::useSharedVertices</a></div><div class="ttdeci">bool useSharedVertices</div><div class="ttdoc">Indicates if this submesh shares vertex data with other meshes or whether it has it's own vertices.</div><div class="ttdef"><b>Definition</b> OgreSubMesh.h:143</div></div>
<div class="ttc" id="aclass_ogre_1_1_sub_mesh_html_aad428fa6595c7fb01ef7543e5d8d6454"><div class="ttname"><a href="class_ogre_1_1_sub_mesh.html#aad428fa6595c7fb01ef7543e5d8d6454">Ogre::SubMesh::indexData</a></div><div class="ttdeci">IndexData * indexData</div><div class="ttdoc">Face index data.</div><div class="ttdef"><b>Definition</b> OgreSubMesh.h:91</div></div>
</div><!-- fragment --><p>Note that while our VertexBuffer is shared, the IndexBuffer is not. This allows rendering different faces of the same object using different Materials. Here, each SubMesh links the faces (IndexBuffer) to the according material.</p>
<p>Finally, we have to update the loading state of the mesh as </p><div class="fragment"><div class="line">mesh-&gt;<a class="code hl_function" href="class_ogre_1_1_resource.html#a699d1c851f494a8d5d23d23b695ceb47">load</a>();</div>
<div class="ttc" id="aclass_ogre_1_1_resource_html_a699d1c851f494a8d5d23d23b695ceb47"><div class="ttname"><a href="class_ogre_1_1_resource.html#a699d1c851f494a8d5d23d23b695ceb47">Ogre::Resource::load</a></div><div class="ttdeci">virtual void load(bool backgroundThread=false)</div><div class="ttdoc">Loads the resource, if it is not already.</div></div>
</div><!-- fragment --><p> If you have registered a <a class="el" href="class_ogre_1_1_manual_resource_loader.html" title="Interface describing a manual resource loader.">Ogre::ManualResourceLoader</a>, the resource loading would only happen now.</p>
<dl class="section note"><dt>Note</dt><dd>Using the <a class="el" href="class_ogre_1_1_manual_resource_loader.html" title="Interface describing a manual resource loader.">Ogre::ManualResourceLoader</a> is highly recommended. It allows lazy-loading the data on demand as well as unloading and re-loading resources when running out of memory. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
