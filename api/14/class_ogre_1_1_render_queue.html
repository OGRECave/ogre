<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::RenderQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.5</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_render_queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_render_queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::RenderQueue Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___render_system.html">RenderSystem</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Class to manage the scene object rendering queue.  
 <a href="class_ogre_1_1_render_queue.html#details">More...</a></p>

<p><code>#include &lt;OgreRenderQueue.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::RenderQueue:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_render_queue__inherit__graph.svg" width="160" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue_1_1_renderable_listener.html">RenderableListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to listen in on items being added to the render queue.  <a href="class_ogre_1_1_render_queue_1_1_renderable_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a10570a44541d6dfdcc03f0a0f482744c" id="r_a10570a44541d6dfdcc03f0a0f482744c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">typedef</a> std::unique_ptr&lt; <a class="el" href="class_ogre_1_1_render_queue_group.html">RenderQueueGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a10570a44541d6dfdcc03f0a0f482744c">RenderQueueGroupMap</a>[<a class="el" href="group___render_system.html#ggad08013a341ff0ef07c39fa3502bf6c00a43e81e888625a08308a616f5c82c7a97">RENDER_QUEUE_COUNT</a>]</td></tr>
<tr class="separator:a10570a44541d6dfdcc03f0a0f482744c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5454a3907c8ce62ab9454b7e4e6ef818" id="r_a5454a3907c8ce62ab9454b7e4e6ef818"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a5454a3907c8ce62ab9454b7e4e6ef818">RenderQueue</a> ()</td></tr>
<tr class="separator:a5454a3907c8ce62ab9454b7e4e6ef818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15db5053b0d5bbd21cf9e797ea06f0d9" id="r_a15db5053b0d5bbd21cf9e797ea06f0d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a15db5053b0d5bbd21cf9e797ea06f0d9">~RenderQueue</a> ()</td></tr>
<tr class="separator:a15db5053b0d5bbd21cf9e797ea06f0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d590945dee3692564beec95d89c70f" id="r_a02d590945dee3692564beec95d89c70f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_render_queue.html#a10570a44541d6dfdcc03f0a0f482744c">RenderQueueGroupMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a02d590945dee3692564beec95d89c70f">_getQueueGroups</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a02d590945dee3692564beec95d89c70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method, returns the queue groups.  <br /></td></tr>
<tr class="separator:a02d590945dee3692564beec95d89c70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8caa5feac9cee401f34f5aa1918d0d" id="r_acc8caa5feac9cee401f34f5aa1918d0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#acc8caa5feac9cee401f34f5aa1918d0d">addRenderable</a> (<a class="el" href="class_ogre_1_1_renderable.html">Renderable</a> *<a class="el" href="struct_ogre_1_1vector.html">pRend</a>)</td></tr>
<tr class="memdesc:acc8caa5feac9cee401f34f5aa1918d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a renderable object to the queue.  <br /></td></tr>
<tr class="separator:acc8caa5feac9cee401f34f5aa1918d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b67aff41b50d24cef0420871ce6f3af" id="r_a8b67aff41b50d24cef0420871ce6f3af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a8b67aff41b50d24cef0420871ce6f3af">addRenderable</a> (<a class="el" href="class_ogre_1_1_renderable.html">Renderable</a> *<a class="el" href="struct_ogre_1_1vector.html">pRend</a>, <a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a> <a class="el" href="struct_ogre_1_1vector.html">groupId</a>)</td></tr>
<tr class="memdesc:a8b67aff41b50d24cef0420871ce6f3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a renderable object to the queue.  <br /></td></tr>
<tr class="separator:a8b67aff41b50d24cef0420871ce6f3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb30e0dd6cd6db7f74650d311a68013" id="r_aedb30e0dd6cd6db7f74650d311a68013"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#aedb30e0dd6cd6db7f74650d311a68013">addRenderable</a> (<a class="el" href="class_ogre_1_1_renderable.html">Renderable</a> *<a class="el" href="struct_ogre_1_1vector.html">pRend</a>, <a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a> <a class="el" href="struct_ogre_1_1vector.html">groupID</a>, <a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a> <a class="el" href="struct_ogre_1_1vector.html">priority</a>)</td></tr>
<tr class="memdesc:aedb30e0dd6cd6db7f74650d311a68013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a renderable object to the queue.  <br /></td></tr>
<tr class="separator:aedb30e0dd6cd6db7f74650d311a68013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7351e9922649a71a54fb5b0ccfb525c4" id="r_a7351e9922649a71a54fb5b0ccfb525c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a7351e9922649a71a54fb5b0ccfb525c4">clear</a> (<a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">destroyPassMaps</a>=<a class="el" href="struct_ogre_1_1vector.html">false</a>)</td></tr>
<tr class="memdesc:a7351e9922649a71a54fb5b0ccfb525c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the queue - should only be called by SceneManagers.  <br /></td></tr>
<tr class="separator:a7351e9922649a71a54fb5b0ccfb525c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c1a5214c10422de1a473ac56edba37" id="r_aa5c1a5214c10422de1a473ac56edba37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#aa5c1a5214c10422de1a473ac56edba37">getDefaultQueueGroup</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:aa5c1a5214c10422de1a473ac56edba37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on.  <br /></td></tr>
<tr class="separator:aa5c1a5214c10422de1a473ac56edba37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34df6226f67084565eac7bb074ea744" id="r_aa34df6226f67084565eac7bb074ea744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#aa34df6226f67084565eac7bb074ea744">getDefaultRenderablePriority</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:aa34df6226f67084565eac7bb074ea744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use.  <br /></td></tr>
<tr class="separator:aa34df6226f67084565eac7bb074ea744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08219c77ee8917a8af5742b7f9f728d" id="r_ac08219c77ee8917a8af5742b7f9f728d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_render_queue_group.html">RenderQueueGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#ac08219c77ee8917a8af5742b7f9f728d">getQueueGroup</a> (<a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a> <a class="el" href="struct_ogre_1_1vector.html">qid</a>)</td></tr>
<tr class="memdesc:ac08219c77ee8917a8af5742b7f9f728d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a render queue group.  <br /></td></tr>
<tr class="separator:ac08219c77ee8917a8af5742b7f9f728d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49a10e69b06091657d3c3c7a248f711" id="r_ac49a10e69b06091657d3c3c7a248f711"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_render_queue_1_1_renderable_listener.html">RenderableListener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#ac49a10e69b06091657d3c3c7a248f711">getRenderableListener</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="separator:ac49a10e69b06091657d3c3c7a248f711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5abe9b1faef28536da92d2c836b4df8" id="r_ad5abe9b1faef28536da92d2c836b4df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#ad5abe9b1faef28536da92d2c836b4df8">getShadowCastersCannotBeReceivers</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ad5abe9b1faef28536da92d2c836b4df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not objects which cast shadows should be treated as never receiving shadows.  <br /></td></tr>
<tr class="separator:ad5abe9b1faef28536da92d2c836b4df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5898a67b700d740c9b7416a10007ac55" id="r_a5898a67b700d740c9b7416a10007ac55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a5898a67b700d740c9b7416a10007ac55">getSplitNoShadowPasses</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a5898a67b700d740c9b7416a10007ac55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not the queue will split passes which have shadow receive turned off (in their parent material), which is needed when certain shadow techniques are used.  <br /></td></tr>
<tr class="separator:a5898a67b700d740c9b7416a10007ac55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508c8398715d145fb899e43e3d58ce00" id="r_a508c8398715d145fb899e43e3d58ce00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a508c8398715d145fb899e43e3d58ce00">getSplitPassesByLightingType</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a508c8398715d145fb899e43e3d58ce00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal.  <br /></td></tr>
<tr class="separator:a508c8398715d145fb899e43e3d58ce00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55552364f1a8ecb2fb9a166ef92e070a" id="r_a55552364f1a8ecb2fb9a166ef92e070a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a55552364f1a8ecb2fb9a166ef92e070a">merge</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *<a class="el" href="struct_ogre_1_1vector.html">rhs</a>)</td></tr>
<tr class="memdesc:a55552364f1a8ecb2fb9a166ef92e070a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge render queue.  <br /></td></tr>
<tr class="separator:a55552364f1a8ecb2fb9a166ef92e070a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af90d52791616e975fc0da4dc1ec78e" id="r_a5af90d52791616e975fc0da4dc1ec78e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a5af90d52791616e975fc0da4dc1ec78e">processVisibleObject</a> (<a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *<a class="el" href="struct_ogre_1_1vector.html">mo</a>, <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *<a class="el" href="struct_ogre_1_1vector.html">cam</a>, <a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">onlyShadowCasters</a>, <a class="el" href="struct_ogre_1_1_visible_objects_bounds_info.html">VisibleObjectsBoundsInfo</a> *<a class="el" href="struct_ogre_1_1vector.html">visibleBounds</a>)</td></tr>
<tr class="memdesc:a5af90d52791616e975fc0da4dc1ec78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to perform the standard actions associated with getting a visible object to add itself to the queue.  <br /></td></tr>
<tr class="separator:a5af90d52791616e975fc0da4dc1ec78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee86531136c2069ab7ed03ec8802b624" id="r_aee86531136c2069ab7ed03ec8802b624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#aee86531136c2069ab7ed03ec8802b624">setDefaultQueueGroup</a> (<a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a> <a class="el" href="struct_ogre_1_1vector.html">grp</a>)</td></tr>
<tr class="memdesc:aee86531136c2069ab7ed03ec8802b624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on.  <br /></td></tr>
<tr class="separator:aee86531136c2069ab7ed03ec8802b624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5d94b3d357524a08affce11c383374" id="r_aeb5d94b3d357524a08affce11c383374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#aeb5d94b3d357524a08affce11c383374">setDefaultRenderablePriority</a> (<a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a> <a class="el" href="struct_ogre_1_1vector.html">priority</a>)</td></tr>
<tr class="memdesc:aeb5d94b3d357524a08affce11c383374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use.  <br /></td></tr>
<tr class="separator:aeb5d94b3d357524a08affce11c383374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4830aa759ae0619a637dc979f8f0d581" id="r_a4830aa759ae0619a637dc979f8f0d581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a4830aa759ae0619a637dc979f8f0d581">setRenderableListener</a> (<a class="el" href="class_ogre_1_1_render_queue_1_1_renderable_listener.html">RenderableListener</a> *<a class="el" href="struct_ogre_1_1vector.html">listener</a>)</td></tr>
<tr class="memdesc:a4830aa759ae0619a637dc979f8f0d581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a renderable listener on the queue.  <br /></td></tr>
<tr class="separator:a4830aa759ae0619a637dc979f8f0d581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9a571f752196f24799e5aebb6bd715" id="r_aac9a571f752196f24799e5aebb6bd715"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#aac9a571f752196f24799e5aebb6bd715">setShadowCastersCannotBeReceivers</a> (<a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">ind</a>)</td></tr>
<tr class="memdesc:aac9a571f752196f24799e5aebb6bd715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not objects which cast shadows should be treated as never receiving shadows.  <br /></td></tr>
<tr class="separator:aac9a571f752196f24799e5aebb6bd715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edec1309abf170a0dd09612911fc4bc" id="r_a4edec1309abf170a0dd09612911fc4bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a4edec1309abf170a0dd09612911fc4bc">setSplitNoShadowPasses</a> (<a class="el" href="struct_ogre_1_1vector.html">bool</a> split)</td></tr>
<tr class="memdesc:a4edec1309abf170a0dd09612911fc4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the queue will split passes which have shadow receive turned off (in their parent material), which is needed when certain shadow techniques are used.  <br /></td></tr>
<tr class="separator:a4edec1309abf170a0dd09612911fc4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c00d063c95049da895c7bfc8923311" id="r_a12c00d063c95049da895c7bfc8923311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_render_queue.html#a12c00d063c95049da895c7bfc8923311">setSplitPassesByLightingType</a> (<a class="el" href="struct_ogre_1_1vector.html">bool</a> split)</td></tr>
<tr class="memdesc:a12c00d063c95049da895c7bfc8923311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal.  <br /></td></tr>
<tr class="separator:a12c00d063c95049da895c7bfc8923311"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to manage the scene object rendering queue. </p>
<p>Objects are grouped by material to minimise rendering state changes. The map from material to renderable object is wrapped in a class for ease of use. </p><dl class="section user"><dt></dt><dd>This class now includes the concept of 'queue groups' which allows the application adding the renderable to specifically schedule it so that it is included in a discrete group. Good for separating renderables into the main scene, backgrounds and overlays, and also could be used in the future for more complex multipass routines like stenciling. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a10570a44541d6dfdcc03f0a0f482744c" name="a10570a44541d6dfdcc03f0a0f482744c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10570a44541d6dfdcc03f0a0f482744c">&#9670;&#160;</a></span>RenderQueueGroupMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">typedef</a> std::unique_ptr&lt;<a class="el" href="class_ogre_1_1_render_queue_group.html">RenderQueueGroup</a>&gt; Ogre::RenderQueue::RenderQueueGroupMap[<a class="el" href="group___render_system.html#ggad08013a341ff0ef07c39fa3502bf6c00a43e81e888625a08308a616f5c82c7a97">RENDER_QUEUE_COUNT</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5454a3907c8ce62ab9454b7e4e6ef818" name="a5454a3907c8ce62ab9454b7e4e6ef818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5454a3907c8ce62ab9454b7e4e6ef818">&#9670;&#160;</a></span>RenderQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::RenderQueue::RenderQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15db5053b0d5bbd21cf9e797ea06f0d9" name="a15db5053b0d5bbd21cf9e797ea06f0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15db5053b0d5bbd21cf9e797ea06f0d9">&#9670;&#160;</a></span>~RenderQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> Ogre::RenderQueue::~RenderQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7351e9922649a71a54fb5b0ccfb525c4" name="a7351e9922649a71a54fb5b0ccfb525c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7351e9922649a71a54fb5b0ccfb525c4">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::RenderQueue::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>destroyPassMaps</em> = <code><a class="el" href="struct_ogre_1_1vector.html">false</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty the queue - should only be called by SceneManagers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destroyPassMaps</td><td>Set to true to destroy all pass maps so that the queue is completely clean (useful when switching scene managers) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac08219c77ee8917a8af5742b7f9f728d" name="ac08219c77ee8917a8af5742b7f9f728d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08219c77ee8917a8af5742b7f9f728d">&#9670;&#160;</a></span>getQueueGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_render_queue_group.html">RenderQueueGroup</a> * Ogre::RenderQueue::getQueueGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a>&#160;</td>
          <td class="paramname"><em>qid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a render queue group. </p>
<p>OGRE registers new queue groups as they are requested, therefore this method will always return a valid group. </p>

</div>
</div>
<a id="aedb30e0dd6cd6db7f74650d311a68013" name="aedb30e0dd6cd6db7f74650d311a68013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb30e0dd6cd6db7f74650d311a68013">&#9670;&#160;</a></span>addRenderable() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::RenderQueue::addRenderable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_renderable.html">Renderable</a> *&#160;</td>
          <td class="paramname"><em>pRend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a>&#160;</td>
          <td class="paramname"><em>groupID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a renderable object to the queue. </p>
<p>This methods adds a <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to the queue, which will be rendered later by the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a>. This is the advanced version of the call which allows the renderable to be added to any queue. </p><dl class="section note"><dt>Note</dt><dd>Called by implementation of <a class="el" href="class_ogre_1_1_movable_object.html#ac77b03ec95bbe3de7d9b9d7993dc785e" title="Internal method by which the movable object must add Renderable subclass instances to the rendering q...">MovableObject::_updateRenderQueue</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRend</td><td>Pointer to the <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to be added to the queue </td></tr>
    <tr><td class="paramname">groupID</td><td>The group the renderable is to be added to. This can be used to schedule renderable objects in separate groups such that the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a> respects the divisions between the groupings and does not reorder them outside these boundaries. This can be handy for overlays where no matter what you want the overlay to be rendered last. </td></tr>
    <tr><td class="paramname">priority</td><td>Controls the priority of the renderable within the queue group. If this number is raised, the renderable will be rendered later in the group compared to it's peers. Don't use this unless you really need to, manually ordering renderables prevents OGRE from sorting them for best efficiency. However this could be useful for ordering 2D elements manually for example. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b67aff41b50d24cef0420871ce6f3af" name="a8b67aff41b50d24cef0420871ce6f3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b67aff41b50d24cef0420871ce6f3af">&#9670;&#160;</a></span>addRenderable() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::RenderQueue::addRenderable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_renderable.html">Renderable</a> *&#160;</td>
          <td class="paramname"><em>pRend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a>&#160;</td>
          <td class="paramname"><em>groupId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a renderable object to the queue. </p>
<p>This methods adds a <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to the queue, which will be rendered later by the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a>. This is the simplified version of the call which does not require a priority to be specified. The queue priority is take from the current default (see setDefaultRenderablePriority). </p><dl class="section note"><dt>Note</dt><dd>Called by implementation of <a class="el" href="class_ogre_1_1_movable_object.html#ac77b03ec95bbe3de7d9b9d7993dc785e" title="Internal method by which the movable object must add Renderable subclass instances to the rendering q...">MovableObject::_updateRenderQueue</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRend</td><td>Pointer to the <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to be added to the queue </td></tr>
    <tr><td class="paramname">groupId</td><td>The group the renderable is to be added to. This can be used to schedule renderable objects in separate groups such that the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a> respects the divisions between the groupings and does not reorder them outside these boundaries. This can be handy for overlays where no matter what you want the overlay to be rendered last. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc8caa5feac9cee401f34f5aa1918d0d" name="acc8caa5feac9cee401f34f5aa1918d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8caa5feac9cee401f34f5aa1918d0d">&#9670;&#160;</a></span>addRenderable() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::RenderQueue::addRenderable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_renderable.html">Renderable</a> *&#160;</td>
          <td class="paramname"><em>pRend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a renderable object to the queue. </p>
<p>This methods adds a <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to the queue, which will be rendered later by the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a>. This is the simplified version of the call which does not require a queue or priority to be specified. The queue group is taken from the current default (see setDefaultQueueGroup). The queue priority is take from the current default (see setDefaultRenderablePriority). </p><dl class="section note"><dt>Note</dt><dd>Called by implementation of <a class="el" href="class_ogre_1_1_movable_object.html#ac77b03ec95bbe3de7d9b9d7993dc785e" title="Internal method by which the movable object must add Renderable subclass instances to the rendering q...">MovableObject::_updateRenderQueue</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRend</td><td>Pointer to the <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to be added to the queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5c1a5214c10422de1a473ac56edba37" name="aa5c1a5214c10422de1a473ac56edba37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c1a5214c10422de1a473ac56edba37">&#9670;&#160;</a></span>getDefaultQueueGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a> Ogre::RenderQueue::getDefaultQueueGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on. </p>

</div>
</div>
<a id="aeb5d94b3d357524a08affce11c383374" name="aeb5d94b3d357524a08affce11c383374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5d94b3d357524a08affce11c383374">&#9670;&#160;</a></span>setDefaultRenderablePriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::RenderQueue::setDefaultRenderablePriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use. </p>

</div>
</div>
<a id="aa34df6226f67084565eac7bb074ea744" name="aa34df6226f67084565eac7bb074ea744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34df6226f67084565eac7bb074ea744">&#9670;&#160;</a></span>getDefaultRenderablePriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a> Ogre::RenderQueue::getDefaultRenderablePriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use. </p>

</div>
</div>
<a id="aee86531136c2069ab7ed03ec8802b624" name="aee86531136c2069ab7ed03ec8802b624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee86531136c2069ab7ed03ec8802b624">&#9670;&#160;</a></span>setDefaultQueueGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::RenderQueue::setDefaultQueueGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a135bdde033ee93f327917c6ff578d46c">uint8</a>&#160;</td>
          <td class="paramname"><em>grp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on. </p>
<p>See the enum RenderQueueGroupID for what kind of values can be used here. </p>

</div>
</div>
<a id="a02d590945dee3692564beec95d89c70f" name="a02d590945dee3692564beec95d89c70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d590945dee3692564beec95d89c70f">&#9670;&#160;</a></span>_getQueueGroups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_render_queue.html#a10570a44541d6dfdcc03f0a0f482744c">RenderQueueGroupMap</a> &amp; Ogre::RenderQueue::_getQueueGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method, returns the queue groups. </p>

</div>
</div>
<a id="a12c00d063c95049da895c7bfc8923311" name="a12c00d063c95049da895c7bfc8923311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c00d063c95049da895c7bfc8923311">&#9670;&#160;</a></span>setSplitPassesByLightingType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::RenderQueue::setSplitPassesByLightingType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>split</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal. </p>

</div>
</div>
<a id="a508c8398715d145fb899e43e3d58ce00" name="a508c8398715d145fb899e43e3d58ce00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508c8398715d145fb899e43e3d58ce00">&#9670;&#160;</a></span>getSplitPassesByLightingType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">bool</a> Ogre::RenderQueue::getSplitPassesByLightingType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal. </p>

</div>
</div>
<a id="a4edec1309abf170a0dd09612911fc4bc" name="a4edec1309abf170a0dd09612911fc4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edec1309abf170a0dd09612911fc4bc">&#9670;&#160;</a></span>setSplitNoShadowPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::RenderQueue::setSplitNoShadowPasses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>split</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not the queue will split passes which have shadow receive turned off (in their parent material), which is needed when certain shadow techniques are used. </p>

</div>
</div>
<a id="a5898a67b700d740c9b7416a10007ac55" name="a5898a67b700d740c9b7416a10007ac55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5898a67b700d740c9b7416a10007ac55">&#9670;&#160;</a></span>getSplitNoShadowPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">bool</a> Ogre::RenderQueue::getSplitNoShadowPasses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets whether or not the queue will split passes which have shadow receive turned off (in their parent material), which is needed when certain shadow techniques are used. </p>

</div>
</div>
<a id="aac9a571f752196f24799e5aebb6bd715" name="aac9a571f752196f24799e5aebb6bd715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9a571f752196f24799e5aebb6bd715">&#9670;&#160;</a></span>setShadowCastersCannotBeReceivers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::RenderQueue::setShadowCastersCannotBeReceivers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>ind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not objects which cast shadows should be treated as never receiving shadows. </p>

</div>
</div>
<a id="ad5abe9b1faef28536da92d2c836b4df8" name="ad5abe9b1faef28536da92d2c836b4df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5abe9b1faef28536da92d2c836b4df8">&#9670;&#160;</a></span>getShadowCastersCannotBeReceivers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">bool</a> Ogre::RenderQueue::getShadowCastersCannotBeReceivers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets whether or not objects which cast shadows should be treated as never receiving shadows. </p>

</div>
</div>
<a id="a4830aa759ae0619a637dc979f8f0d581" name="a4830aa759ae0619a637dc979f8f0d581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4830aa759ae0619a637dc979f8f0d581">&#9670;&#160;</a></span>setRenderableListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::RenderQueue::setRenderableListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_queue_1_1_renderable_listener.html">RenderableListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a renderable listener on the queue. </p>
<p>There can only be a single renderable listener on the queue, since that listener has complete control over the techniques in use. </p>

</div>
</div>
<a id="ac49a10e69b06091657d3c3c7a248f711" name="ac49a10e69b06091657d3c3c7a248f711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49a10e69b06091657d3c3c7a248f711">&#9670;&#160;</a></span>getRenderableListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_render_queue_1_1_renderable_listener.html">RenderableListener</a> * Ogre::RenderQueue::getRenderableListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55552364f1a8ecb2fb9a166ef92e070a" name="a55552364f1a8ecb2fb9a166ef92e070a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55552364f1a8ecb2fb9a166ef92e070a">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::RenderQueue::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge render queue. </p>

</div>
</div>
<a id="a5af90d52791616e975fc0da4dc1ec78e" name="a5af90d52791616e975fc0da4dc1ec78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af90d52791616e975fc0da4dc1ec78e">&#9670;&#160;</a></span>processVisibleObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::RenderQueue::processVisibleObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>mo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>onlyShadowCasters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_visible_objects_bounds_info.html">VisibleObjectsBoundsInfo</a> *&#160;</td>
          <td class="paramname"><em>visibleBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to perform the standard actions associated with getting a visible object to add itself to the queue. </p>
<p>This is a replacement for <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a> implementations of the associated tasks related to calling <a class="el" href="class_ogre_1_1_movable_object.html#ac77b03ec95bbe3de7d9b9d7993dc785e" title="Internal method by which the movable object must add Renderable subclass instances to the rendering q...">MovableObject::_updateRenderQueue</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_render_queue_8h.html">OgreRenderQueue.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
