<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::Image Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_image.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_image-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::Image Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___image.html">Image</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Class representing an image file.  
 <a href="class_ogre_1_1_image.html#details">More...</a></p>

<p><code>#include &lt;OgreImage.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::Image:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_image__inherit__graph.svg" width="114" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa1d0fe80507583b39161736e4be198d5" id="r_aa1d0fe80507583b39161736e4be198d5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5">Filter</a> { <a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5a7ef2addab7f4ada3d9892979c0b309ca">FILTER_NEAREST</a>
, <a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5a4bd7e862129bad718a43406a38716a46">FILTER_LINEAR</a>
, <a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5a4d66afbe9239683a6fb6b90edb1611b5">FILTER_BILINEAR</a> = FILTER_LINEAR
 }</td></tr>
<tr class="separator:aa1d0fe80507583b39161736e4be198d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4285ffbb1d7edb6cd969d0be0971bfc2" id="r_a4285ffbb1d7edb6cd969d0be0971bfc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a4285ffbb1d7edb6cd969d0be0971bfc2">Image</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">img</a>)</td></tr>
<tr class="memdesc:a4285ffbb1d7edb6cd969d0be0971bfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructor - copies all the data from the target image.  <br /></td></tr>
<tr class="separator:a4285ffbb1d7edb6cd969d0be0971bfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad787d3568f5996e3d6d92e1fb54415ea" id="r_ad787d3568f5996e3d6d92e1fb54415ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#ad787d3568f5996e3d6d92e1fb54415ea">Image</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format=<a class="el" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caa4292ed700edc51d74776f6efaf2a099">PF_UNKNOWN</a>, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> width=0, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> height=0, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> depth=1, <a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> *buffer=<a class="el" href="struct_ogre_1_1vector.html">NULL</a>, <a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">autoDelete</a>=<a class="el" href="struct_ogre_1_1vector.html">true</a>)</td></tr>
<tr class="memdesc:ad787d3568f5996e3d6d92e1fb54415ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard constructor.  <br /></td></tr>
<tr class="separator:ad787d3568f5996e3d6d92e1fb54415ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f50179edd65bdeeb6c440d0a35c1bb1" id="r_a3f50179edd65bdeeb6c440d0a35c1bb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a3f50179edd65bdeeb6c440d0a35c1bb1">~Image</a> ()</td></tr>
<tr class="memdesc:a3f50179edd65bdeeb6c440d0a35c1bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard destructor.  <br /></td></tr>
<tr class="separator:a3f50179edd65bdeeb6c440d0a35c1bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c76c792fda5b2c8c6d064451eb3121" id="r_a59c76c792fda5b2c8c6d064451eb3121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a59c76c792fda5b2c8c6d064451eb3121">combineTwoImagesAsRGBA</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">rgb</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">alpha</a>, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format=<a class="el" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39cae0afb06af1cb73f624e66540c64bb2cb">PF_BYTE_RGBA</a>)</td></tr>
<tr class="memdesc:a59c76c792fda5b2c8c6d064451eb3121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha).  <br /></td></tr>
<tr class="separator:a59c76c792fda5b2c8c6d064451eb3121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03348ae68a6b5467a2e3d131f6571f2" id="r_af03348ae68a6b5467a2e3d131f6571f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#af03348ae68a6b5467a2e3d131f6571f2">create</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> width, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> height, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> depth=1, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> <a class="el" href="struct_ogre_1_1vector.html">numFaces</a>=1, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> <a class="el" href="struct_ogre_1_1vector.html">numMipMaps</a>=0)</td></tr>
<tr class="memdesc:af03348ae68a6b5467a2e3d131f6571f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a buffer of given size if needed  <br /></td></tr>
<tr class="separator:af03348ae68a6b5467a2e3d131f6571f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad933a75945dd8573925bf707d9035a6b" id="r_ad933a75945dd8573925bf707d9035a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#ad933a75945dd8573925bf707d9035a6b">encode</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">formatextension</a>)</td></tr>
<tr class="memdesc:ad933a75945dd8573925bf707d9035a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the image and return a stream to the data.  <br /></td></tr>
<tr class="separator:ad933a75945dd8573925bf707d9035a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d7bd12ad2d4e175cffb437910a7394" id="r_a56d7bd12ad2d4e175cffb437910a7394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a56d7bd12ad2d4e175cffb437910a7394">flipAroundX</a> ()</td></tr>
<tr class="memdesc:a56d7bd12ad2d4e175cffb437910a7394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips (mirrors) the image around the X-axis.  <br /></td></tr>
<tr class="separator:a56d7bd12ad2d4e175cffb437910a7394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e9935472e11e81eedb5dbdb9e0e2ea" id="r_a19e9935472e11e81eedb5dbdb9e0e2ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a19e9935472e11e81eedb5dbdb9e0e2ea">flipAroundY</a> ()</td></tr>
<tr class="memdesc:a19e9935472e11e81eedb5dbdb9e0e2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips (mirrors) the image around the Y-axis.  <br /></td></tr>
<tr class="separator:a19e9935472e11e81eedb5dbdb9e0e2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f90a41e3bbdb3abb2b0ce9954b5a12" id="r_ac9f90a41e3bbdb3abb2b0ce9954b5a12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#ac9f90a41e3bbdb3abb2b0ce9954b5a12">freeMemory</a> ()</td></tr>
<tr class="memdesc:ac9f90a41e3bbdb3abb2b0ce9954b5a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all the memory held by this image, if owned by this image (not dynamic)  <br /></td></tr>
<tr class="separator:ac9f90a41e3bbdb3abb2b0ce9954b5a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2929381e7da36687ee19e4329635cb3d" id="r_a2929381e7da36687ee19e4329635cb3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a2929381e7da36687ee19e4329635cb3d">getBPP</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a2929381e7da36687ee19e4329635cb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits per pixel.  <br /></td></tr>
<tr class="separator:a2929381e7da36687ee19e4329635cb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ac05fa8046d8e6aff2192cf02d48a8" id="r_a29ac05fa8046d8e6aff2192cf02d48a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a29ac05fa8046d8e6aff2192cf02d48a8">getColourAt</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> x, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> y, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> z) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a29ac05fa8046d8e6aff2192cf02d48a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get colour value from a certain location in the image.  <br /></td></tr>
<tr class="separator:a29ac05fa8046d8e6aff2192cf02d48a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f581fb0afb172c128736f3164c0a7b0" id="r_a8f581fb0afb172c128736f3164c0a7b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a8f581fb0afb172c128736f3164c0a7b0">getData</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> x=0, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> y=0, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> z=0)</td></tr>
<tr class="memdesc:a8f581fb0afb172c128736f3164c0a7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal image buffer at the specified pixel location.  <br /></td></tr>
<tr class="separator:a8f581fb0afb172c128736f3164c0a7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b06065c84b0e69bd5bfa94b463d8bf" id="r_a18b06065c84b0e69bd5bfa94b463d8bf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="struct_ogre_1_1vector.html">typename</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </td></tr>
<tr class="memitem:a18b06065c84b0e69bd5bfa94b463d8bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">T</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a18b06065c84b0e69bd5bfa94b463d8bf">getData</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> x=0, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> y=0, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> z=0)</td></tr>
<tr class="memdesc:a18b06065c84b0e69bd5bfa94b463d8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a18b06065c84b0e69bd5bfa94b463d8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa3474921a721041d9c5e2ee7387fc6" id="r_a0aa3474921a721041d9c5e2ee7387fc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a0aa3474921a721041d9c5e2ee7387fc6">getData</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> x=0, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> y=0, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> z=0) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a0aa3474921a721041d9c5e2ee7387fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a0aa3474921a721041d9c5e2ee7387fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0d15337398d95007fe610267421c35" id="r_a5c0d15337398d95007fe610267421c35"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="struct_ogre_1_1vector.html">typename</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </td></tr>
<tr class="memitem:a5c0d15337398d95007fe610267421c35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a5c0d15337398d95007fe610267421c35">getData</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> x=0, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> y=0, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> z=0) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a5c0d15337398d95007fe610267421c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a5c0d15337398d95007fe610267421c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a8872592918bec601a02ceab85a004" id="r_ab0a8872592918bec601a02ceab85a004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#ab0a8872592918bec601a02ceab85a004">getDepth</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ab0a8872592918bec601a02ceab85a004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the depth of the image.  <br /></td></tr>
<tr class="separator:ab0a8872592918bec601a02ceab85a004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a4902d28d19106138c1de923898d1a" id="r_ab2a4902d28d19106138c1de923898d1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#ab2a4902d28d19106138c1de923898d1a">getFormat</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ab2a4902d28d19106138c1de923898d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the image format.  <br /></td></tr>
<tr class="separator:ab2a4902d28d19106138c1de923898d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12402f8d6c9485051bf27970ce815a3" id="r_aa12402f8d6c9485051bf27970ce815a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#aa12402f8d6c9485051bf27970ce815a3">getHasAlpha</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:aa12402f8d6c9485051bf27970ce815a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the image has an alpha component.  <br /></td></tr>
<tr class="separator:aa12402f8d6c9485051bf27970ce815a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064e61e5225c5405d838e2e96a45beed" id="r_a064e61e5225c5405d838e2e96a45beed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a064e61e5225c5405d838e2e96a45beed">getHeight</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a064e61e5225c5405d838e2e96a45beed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the height of the image in pixels.  <br /></td></tr>
<tr class="separator:a064e61e5225c5405d838e2e96a45beed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2db6b18aae0389177f297e9c6bee8a7" id="r_ae2db6b18aae0389177f297e9c6bee8a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#ae2db6b18aae0389177f297e9c6bee8a7">getNumFaces</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ae2db6b18aae0389177f297e9c6bee8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces of the image.  <br /></td></tr>
<tr class="separator:ae2db6b18aae0389177f297e9c6bee8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2445c198e2d5018e2056daac7fa7cdb" id="r_ad2445c198e2d5018e2056daac7fa7cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#ad2445c198e2d5018e2056daac7fa7cdb">getNumMipmaps</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ad2445c198e2d5018e2056daac7fa7cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of mipmaps contained in the image.  <br /></td></tr>
<tr class="separator:ad2445c198e2d5018e2056daac7fa7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65aa7216f9f9ecce4158ffd20b9cea6" id="r_af65aa7216f9f9ecce4158ffd20b9cea6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#af65aa7216f9f9ecce4158ffd20b9cea6">getPixelBox</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> <a class="el" href="struct_ogre_1_1vector.html">face</a>=0, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> <a class="el" href="struct_ogre_1_1vector.html">mipmap</a>=0) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:af65aa7216f9f9ecce4158ffd20b9cea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_ogre_1_1_pixel_box.html" title="A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory.">PixelBox</a> encapsulating the image data of a mipmap.  <br /></td></tr>
<tr class="separator:af65aa7216f9f9ecce4158ffd20b9cea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8c00129e855863b05ee8ea835ba338" id="r_aed8c00129e855863b05ee8ea835ba338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#aed8c00129e855863b05ee8ea835ba338">getRowSpan</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:aed8c00129e855863b05ee8ea835ba338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the physical width in bytes of each row of pixels.  <br /></td></tr>
<tr class="separator:aed8c00129e855863b05ee8ea835ba338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483cf37ca3ff2965d6d7a2e2c54973f5" id="r_a483cf37ca3ff2965d6d7a2e2c54973f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a483cf37ca3ff2965d6d7a2e2c54973f5">getSize</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a483cf37ca3ff2965d6d7a2e2c54973f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the data buffer in bytes.  <br /></td></tr>
<tr class="separator:a483cf37ca3ff2965d6d7a2e2c54973f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649d36eb8288161540d223b7106b7d67" id="r_a649d36eb8288161540d223b7106b7d67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a649d36eb8288161540d223b7106b7d67">getWidth</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a649d36eb8288161540d223b7106b7d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the width of the image in pixels.  <br /></td></tr>
<tr class="separator:a649d36eb8288161540d223b7106b7d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86de801dc4420a536e7de544ba596c1b" id="r_a86de801dc4420a536e7de544ba596c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a86de801dc4420a536e7de544ba596c1b">hasFlag</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="group___image.html#ga975bb6abd3c277b9a91d849367885474">ImageFlags</a> <a class="el" href="struct_ogre_1_1vector.html">imgFlag</a>) <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a86de801dc4420a536e7de544ba596c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the image has the appropriate flag set.  <br /></td></tr>
<tr class="separator:a86de801dc4420a536e7de544ba596c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f15052fc60ab5f098680d7d6ab99ff" id="r_a57f15052fc60ab5f098680d7d6ab99ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a57f15052fc60ab5f098680d7d6ab99ff">load</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;stream, <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> type=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>)</td></tr>
<tr class="memdesc:a57f15052fc60ab5f098680d7d6ab99ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an image file from a stream.  <br /></td></tr>
<tr class="separator:a57f15052fc60ab5f098680d7d6ab99ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5312a67dfaeb1716ae9ab72c1af766cb" id="r_a5312a67dfaeb1716ae9ab72c1af766cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a5312a67dfaeb1716ae9ab72c1af766cb">load</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;filename, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">groupName</a>)</td></tr>
<tr class="memdesc:a5312a67dfaeb1716ae9ab72c1af766cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an image file.  <br /></td></tr>
<tr class="separator:a5312a67dfaeb1716ae9ab72c1af766cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf094d49238538a9f4f80c6ac532d46" id="r_a9cf094d49238538a9f4f80c6ac532d46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a9cf094d49238538a9f4f80c6ac532d46">loadDynamicImage</a> (<a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> *data, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> width, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> height, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:a9cf094d49238538a9f4f80c6ac532d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a9cf094d49238538a9f4f80c6ac532d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81363025683df3af1855cf388e3f2caa" id="r_a81363025683df3af1855cf388e3f2caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a81363025683df3af1855cf388e3f2caa">loadDynamicImage</a> (<a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> *data, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> width, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> height, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> depth, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format, <a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">autoDelete</a>=<a class="el" href="struct_ogre_1_1vector.html">false</a>, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> <a class="el" href="struct_ogre_1_1vector.html">numFaces</a>=1, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> <a class="el" href="struct_ogre_1_1vector.html">numMipMaps</a>=0)</td></tr>
<tr class="memdesc:a81363025683df3af1855cf388e3f2caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a pointer to raw data in memory.  <br /></td></tr>
<tr class="separator:a81363025683df3af1855cf388e3f2caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30aab2634e40b600171794123e98f63b" id="r_a30aab2634e40b600171794123e98f63b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a30aab2634e40b600171794123e98f63b">loadRawData</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;stream, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> width, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> height, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:a30aab2634e40b600171794123e98f63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a30aab2634e40b600171794123e98f63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cbedd586cda280a36de5aaae6874e7" id="r_a19cbedd586cda280a36de5aaae6874e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a19cbedd586cda280a36de5aaae6874e7">loadRawData</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;stream, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> width, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> height, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> depth, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> <a class="el" href="struct_ogre_1_1vector.html">numFaces</a>=1, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> <a class="el" href="struct_ogre_1_1vector.html">numMipMaps</a>=0)</td></tr>
<tr class="memdesc:a19cbedd586cda280a36de5aaae6874e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads raw data from a stream.  <br /></td></tr>
<tr class="separator:a19cbedd586cda280a36de5aaae6874e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bba1b24287b72855b2ddfc67b3f0b6a" id="r_a4bba1b24287b72855b2ddfc67b3f0b6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a4bba1b24287b72855b2ddfc67b3f0b6a">loadTwoImagesAsRGBA</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">rgbStream</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">alphaStream</a>, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format=<a class="el" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39cae0afb06af1cb73f624e66540c64bb2cb">PF_BYTE_RGBA</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">rgbType</a>=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">alphaType</a>=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>)</td></tr>
<tr class="memdesc:a4bba1b24287b72855b2ddfc67b3f0b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha).  <br /></td></tr>
<tr class="separator:a4bba1b24287b72855b2ddfc67b3f0b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9637f7e84d6869469842dd693fa0a23b" id="r_a9637f7e84d6869469842dd693fa0a23b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a9637f7e84d6869469842dd693fa0a23b">loadTwoImagesAsRGBA</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">rgbFilename</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">alphaFilename</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">groupName</a>, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format=<a class="el" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39cae0afb06af1cb73f624e66540c64bb2cb">PF_BYTE_RGBA</a>)</td></tr>
<tr class="memdesc:a9637f7e84d6869469842dd693fa0a23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha).  <br /></td></tr>
<tr class="separator:a9637f7e84d6869469842dd693fa0a23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad3b0c218fbf257faf83f02c3697b2a" id="r_abad3b0c218fbf257faf83f02c3697b2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#abad3b0c218fbf257faf83f02c3697b2a">operator=</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">img</a>)</td></tr>
<tr class="memdesc:abad3b0c218fbf257faf83f02c3697b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator - copies all the data from the target image.  <br /></td></tr>
<tr class="separator:abad3b0c218fbf257faf83f02c3697b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a00ee3969db8f5255d2485e3599f03" id="r_a67a00ee3969db8f5255d2485e3599f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a67a00ee3969db8f5255d2485e3599f03">resize</a> (<a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a> width, <a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a> height, <a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5">Filter</a> <a class="el" href="struct_ogre_1_1vector.html">filter</a>=<a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5a4d66afbe9239683a6fb6b90edb1611b5">FILTER_BILINEAR</a>)</td></tr>
<tr class="memdesc:a67a00ee3969db8f5255d2485e3599f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a 2D image, applying the appropriate filter.  <br /></td></tr>
<tr class="separator:a67a00ee3969db8f5255d2485e3599f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611359a16f40f5c18bd937acd33e27c2" id="r_a611359a16f40f5c18bd937acd33e27c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a611359a16f40f5c18bd937acd33e27c2">save</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;filename)</td></tr>
<tr class="memdesc:a611359a16f40f5c18bd937acd33e27c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the image as a file.  <br /></td></tr>
<tr class="separator:a611359a16f40f5c18bd937acd33e27c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3433519ee4aa9a9141b67657810b110" id="r_af3433519ee4aa9a9141b67657810b110"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#af3433519ee4aa9a9141b67657810b110">setColourAt</a> (<a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> <a class="el" href="struct_ogre_1_1vector.html">const</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">cv</a>, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> x, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> y, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> z)</td></tr>
<tr class="memdesc:af3433519ee4aa9a9141b67657810b110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set colour value at a certain location in the image.  <br /></td></tr>
<tr class="separator:af3433519ee4aa9a9141b67657810b110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b0625728f28925b3c7803f82d342ee" id="r_a60b0625728f28925b3c7803f82d342ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#a60b0625728f28925b3c7803f82d342ee">setTo</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">col</a>)</td></tr>
<tr class="memdesc:a60b0625728f28925b3c7803f82d342ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets all pixels to the specified colour  <br /></td></tr>
<tr class="separator:a60b0625728f28925b3c7803f82d342ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab4681974e712d9701c9396e98c6eb07d" id="r_ab4681974e712d9701c9396e98c6eb07d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#ab4681974e712d9701c9396e98c6eb07d">applyGamma</a> (<a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> *buffer, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="struct_ogre_1_1vector.html">gamma</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> size, <a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> <a class="el" href="struct_ogre_1_1vector.html">bpp</a>)</td></tr>
<tr class="memdesc:ab4681974e712d9701c9396e98c6eb07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does gamma adjustment.  <br /></td></tr>
<tr class="separator:ab4681974e712d9701c9396e98c6eb07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90b11682c53f7fe2c99bfd3bc06c5ac" id="r_ad90b11682c53f7fe2c99bfd3bc06c5ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#ad90b11682c53f7fe2c99bfd3bc06c5ac">calculateSize</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> <a class="el" href="struct_ogre_1_1vector.html">mipmaps</a>, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> <a class="el" href="struct_ogre_1_1vector.html">faces</a>, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> width, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> height, <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> depth, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:ad90b11682c53f7fe2c99bfd3bc06c5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function to calculate size in bytes from the number of mipmaps, faces and the dimensions.  <br /></td></tr>
<tr class="separator:ad90b11682c53f7fe2c99bfd3bc06c5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa974d7e6060aa68bf6105156be7069" id="r_abfa974d7e6060aa68bf6105156be7069"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#abfa974d7e6060aa68bf6105156be7069">getFileExtFromMagic</a> (<a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> stream)</td></tr>
<tr class="memdesc:abfa974d7e6060aa68bf6105156be7069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function to get an image type string from a stream via magic numbers.  <br /></td></tr>
<tr class="separator:abfa974d7e6060aa68bf6105156be7069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefc5ec16de7ea09fca1c5bbe6782a4c" id="r_adefc5ec16de7ea09fca1c5bbe6782a4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image.html#adefc5ec16de7ea09fca1c5bbe6782a4c">scale</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;src, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;dst, <a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5">Filter</a> <a class="el" href="struct_ogre_1_1vector.html">filter</a>=<a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5a4d66afbe9239683a6fb6b90edb1611b5">FILTER_BILINEAR</a>)</td></tr>
<tr class="memdesc:adefc5ec16de7ea09fca1c5bbe6782a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a 1D, 2D or 3D image volume.  <br /></td></tr>
<tr class="separator:adefc5ec16de7ea09fca1c5bbe6782a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing an image file. </p>
<p>The <a class="el" href="class_ogre_1_1_image.html" title="Class representing an image file.">Image</a> class usually holds uncompressed image data and is the only object that can be loaded in a texture. <a class="el" href="class_ogre_1_1_image.html" title="Class representing an image file.">Image</a> objects handle image data decoding themselves by the means of locating the correct <a class="el" href="class_ogre_1_1_codec.html" title="Abstract class that defines a &#39;codec&#39;.">Codec</a> object for each data type. </p><dl class="section user"><dt></dt><dd>Typically, you would want to use an <a class="el" href="class_ogre_1_1_image.html" title="Class representing an image file.">Image</a> object to load a texture when extra processing needs to be done on an image before it is loaded or when you want to blit to an existing texture. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa1d0fe80507583b39161736e4be198d5" name="aa1d0fe80507583b39161736e4be198d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d0fe80507583b39161736e4be198d5">&#9670;&#160;</a></span>Filter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">enum</a> <a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5">Ogre::Image::Filter</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa1d0fe80507583b39161736e4be198d5a7ef2addab7f4ada3d9892979c0b309ca" name="aa1d0fe80507583b39161736e4be198d5a7ef2addab7f4ada3d9892979c0b309ca"></a>FILTER_NEAREST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa1d0fe80507583b39161736e4be198d5a4bd7e862129bad718a43406a38716a46" name="aa1d0fe80507583b39161736e4be198d5a4bd7e862129bad718a43406a38716a46"></a>FILTER_LINEAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa1d0fe80507583b39161736e4be198d5a4d66afbe9239683a6fb6b90edb1611b5" name="aa1d0fe80507583b39161736e4be198d5a4d66afbe9239683a6fb6b90edb1611b5"></a>FILTER_BILINEAR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad787d3568f5996e3d6d92e1fb54415ea" name="ad787d3568f5996e3d6d92e1fb54415ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad787d3568f5996e3d6d92e1fb54415ea">&#9670;&#160;</a></span>Image() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Image::Image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caa4292ed700edc51d74776f6efaf2a099">PF_UNKNOWN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> *&#160;</td>
          <td class="paramname"><em>buffer</em> = <code><a class="el" href="struct_ogre_1_1vector.html">NULL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>autoDelete</em> = <code><a class="el" href="struct_ogre_1_1vector.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard constructor. </p>
<p>allocates a buffer of given size if buffer pointer is NULL. </p>

</div>
</div>
<a id="a4285ffbb1d7edb6cd969d0be0971bfc2" name="a4285ffbb1d7edb6cd969d0be0971bfc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4285ffbb1d7edb6cd969d0be0971bfc2">&#9670;&#160;</a></span>Image() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Image::Image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy-constructor - copies all the data from the target image. </p>

</div>
</div>
<a id="a3f50179edd65bdeeb6c440d0a35c1bb1" name="a3f50179edd65bdeeb6c440d0a35c1bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f50179edd65bdeeb6c440d0a35c1bb1">&#9670;&#160;</a></span>~Image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Image::~Image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af03348ae68a6b5467a2e3d131f6571f2" name="af03348ae68a6b5467a2e3d131f6571f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03348ae68a6b5467a2e3d131f6571f2">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::Image::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>numFaces</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>numMipMaps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates a buffer of given size if needed </p>
<ul>
<li>If the current allocation is equal to the requested size, this does nothing</li>
<li>Otherwise any current allocation is freed, and memory of specified size is allocated</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_image.html#a81363025683df3af1855cf388e3f2caa" title="Stores a pointer to raw data in memory.">loadDynamicImage</a> </dd></dl>

</div>
</div>
<a id="abad3b0c218fbf257faf83f02c3697b2a" name="abad3b0c218fbf257faf83f02c3697b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad3b0c218fbf257faf83f02c3697b2a">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp; Ogre::Image::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator - copies all the data from the target image. </p>

</div>
</div>
<a id="a60b0625728f28925b3c7803f82d342ee" name="a60b0625728f28925b3c7803f82d342ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b0625728f28925b3c7803f82d342ee">&#9670;&#160;</a></span>setTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::Image::setTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets all pixels to the specified colour </p>
<p>format conversion is performed as needed </p>

</div>
</div>
<a id="a19e9935472e11e81eedb5dbdb9e0e2ea" name="a19e9935472e11e81eedb5dbdb9e0e2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e9935472e11e81eedb5dbdb9e0e2ea">&#9670;&#160;</a></span>flipAroundY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp; Ogre::Image::flipAroundY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flips (mirrors) the image around the Y-axis. </p>
<p>An example of an original and flipped image: </p><pre>
originalimg
00000000000
00000000000
00000000000
00000000000
00000000000
------------&gt; flip axis
00000000000
00000000000
00000000000
00000000000
00000000000
originalimg
</pre> 
</div>
</div>
<a id="a56d7bd12ad2d4e175cffb437910a7394" name="a56d7bd12ad2d4e175cffb437910a7394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d7bd12ad2d4e175cffb437910a7394">&#9670;&#160;</a></span>flipAroundX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp; Ogre::Image::flipAroundX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flips (mirrors) the image around the X-axis. </p>
<p>An example of an original and flipped image: </p><pre>
       flip axis
           |
originalimg|gmilanigiro
00000000000|00000000000
00000000000|00000000000
00000000000|00000000000
00000000000|00000000000
00000000000|00000000000
</pre> 
</div>
</div>
<a id="a81363025683df3af1855cf388e3f2caa" name="a81363025683df3af1855cf388e3f2caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81363025683df3af1855cf388e3f2caa">&#9670;&#160;</a></span>loadDynamicImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp; Ogre::Image::loadDynamicImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>autoDelete</em> = <code><a class="el" href="struct_ogre_1_1vector.html">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>numFaces</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>numMipMaps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a pointer to raw data in memory. </p>
<p>The pixel format has to be specified.</p>
<p>This method loads an image into memory held in the object. The pixel format will be either greyscale or RGB with an optional Alpha component. The type can be determined by calling <a class="el" href="class_ogre_1_1_image.html#ab2a4902d28d19106138c1de923898d1a" title="Returns the image format.">getFormat()</a>. </p><dl class="section note"><dt>Note</dt><dd>Whilst typically your image is likely to be a simple 2D image, you can define complex images including cube maps, volume maps, and images including custom mip levels. The layout of the internal memory should be: <ul>
<li>
face 0, mip 0 (top), width x height (x depth) </li>
<li>
face 0, mip 1, width/2 x height/2 (x depth/2) </li>
<li>
face 0, mip 2, width/4 x height/4 (x depth/4) </li>
<li>
.. remaining mips for face 0 ..  </li>
<li>
face 1, mip 0 (top), width x height (x depth)&lt;/li </li>
<li>
.. and so on.  </li>
</ul>
Of course, you will never have multiple faces (cube map) and depth too. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data pointer </td></tr>
    <tr><td class="paramname">width</td><td>Width of image </td></tr>
    <tr><td class="paramname">height</td><td>Height of image </td></tr>
    <tr><td class="paramname">depth</td><td><a class="el" href="class_ogre_1_1_image.html" title="Class representing an image file.">Image</a> Depth (in 3d images, numbers of layers, otherwise 1) </td></tr>
    <tr><td class="paramname">format</td><td>Pixel Format </td></tr>
    <tr><td class="paramname">autoDelete</td><td>If memory associated with this buffer is to be destroyed with the <a class="el" href="class_ogre_1_1_image.html" title="Class representing an image file.">Image</a> object. Note: it's important that if you set this option to true, that you allocated the memory using OGRE_ALLOC_T with a category of MEMCATEGORY_GENERAL to ensure the freeing of memory matches up. </td></tr>
    <tr><td class="paramname">numFaces</td><td>The number of faces the image data has inside (6 for cubemaps, 1 otherwise) </td></tr>
    <tr><td class="paramname">numMipMaps</td><td>The number of mipmaps the image data has inside </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The memory associated with this buffer is NOT destroyed with the <a class="el" href="class_ogre_1_1_image.html" title="Class representing an image file.">Image</a> object, unless autoDelete is set to true.</dd></dl>
<p>The size of the buffer must be numFaces * PixelUtil::getMemorySize(width, height, depth, format) </p>

</div>
</div>
<a id="a9cf094d49238538a9f4f80c6ac532d46" name="a9cf094d49238538a9f4f80c6ac532d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf094d49238538a9f4f80c6ac532d46">&#9670;&#160;</a></span>loadDynamicImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp; Ogre::Image::loadDynamicImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a19cbedd586cda280a36de5aaae6874e7" name="a19cbedd586cda280a36de5aaae6874e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cbedd586cda280a36de5aaae6874e7">&#9670;&#160;</a></span>loadRawData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp; Ogre::Image::loadRawData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>numFaces</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>numMipMaps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads raw data from a stream. </p>
<p>See the function loadDynamicImage for a description of the parameters.</p>
<p>The size of the buffer must be numFaces * PixelUtil::getMemorySize(width, height, depth, format) </p><dl class="section note"><dt>Note</dt><dd>Whilst typically your image is likely to be a simple 2D image, you can define complex images including cube maps and images including custom mip levels. The layout of the internal memory should be: <ul>
<li>
face 0, mip 0 (top), width x height (x depth) </li>
<li>
face 0, mip 1, width/2 x height/2 (x depth/2) </li>
<li>
face 0, mip 2, width/4 x height/4 (x depth/4) </li>
<li>
.. remaining mips for face 0 ..  </li>
<li>
face 1, mip 0 (top), width x height (x depth)&lt;/li </li>
<li>
.. and so on.  </li>
</ul>
Of course, you will never have multiple faces (cube map) and depth too. </dd></dl>

</div>
</div>
<a id="a30aab2634e40b600171794123e98f63b" name="a30aab2634e40b600171794123e98f63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30aab2634e40b600171794123e98f63b">&#9670;&#160;</a></span>loadRawData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp; Ogre::Image::loadRawData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5312a67dfaeb1716ae9ab72c1af766cb" name="a5312a67dfaeb1716ae9ab72c1af766cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5312a67dfaeb1716ae9ab72c1af766cb">&#9670;&#160;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp; Ogre::Image::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads an image file. </p>
<p>This method loads an image into memory. <a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> format for which an associated <a class="el" href="class_ogre_1_1_image_codec.html" title="Codec specialized in images.">ImageCodec</a> is registered can be loaded. This can include complex formats like DDS with embedded custom mipmaps, cube faces and volume textures. The type can be determined by calling <a class="el" href="class_ogre_1_1_image.html#ab2a4902d28d19106138c1de923898d1a" title="Returns the image format.">getFormat()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of an image file to load. </td></tr>
    <tr><td class="paramname">groupName</td><td>Name of the resource group to search for the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The memory associated with this buffer is destroyed with the <a class="el" href="class_ogre_1_1_image.html" title="Class representing an image file.">Image</a> object. </dd></dl>

</div>
</div>
<a id="a57f15052fc60ab5f098680d7d6ab99ff" name="a57f15052fc60ab5f098680d7d6ab99ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f15052fc60ab5f098680d7d6ab99ff">&#9670;&#160;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp; Ogre::Image::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads an image file from a stream. </p>
<p>This method works in the same way as the filename-based load method except it loads the image from a <a class="el" href="class_ogre_1_1_data_stream.html" title="General purpose class used for encapsulating the reading and writing of data.">DataStream</a> object. This <a class="el" href="class_ogre_1_1_data_stream.html" title="General purpose class used for encapsulating the reading and writing of data.">DataStream</a> is expected to contain the encoded data as it would be held in a file. <a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> format for which an associated <a class="el" href="class_ogre_1_1_image_codec.html" title="Codec specialized in images.">ImageCodec</a> is registered can be loaded. This can include complex formats like DDS with embedded custom mipmaps, cube faces and volume textures. The type can be determined by calling <a class="el" href="class_ogre_1_1_image.html#ab2a4902d28d19106138c1de923898d1a" title="Returns the image format.">getFormat()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The source data. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the image. Used to decide what decompression codec to use. Can be left blank if the stream data includes a header to identify the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Image::load( const String&amp; filename ) </dd></dl>

</div>
</div>
<a id="a9637f7e84d6869469842dd693fa0a23b" name="a9637f7e84d6869469842dd693fa0a23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9637f7e84d6869469842dd693fa0a23b">&#9670;&#160;</a></span>loadTwoImagesAsRGBA() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp; Ogre::Image::loadTwoImagesAsRGBA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rgbFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>alphaFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39cae0afb06af1cb73f624e66540c64bb2cb">PF_BYTE_RGBA</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgbFilename</td><td>Filename of image supplying the RGB channels (any alpha is ignored) </td></tr>
    <tr><td class="paramname">alphaFilename</td><td>Filename of image supplying the alpha channel. If a luminance image the single channel is used directly, if an RGB image then the values are converted to greyscale. </td></tr>
    <tr><td class="paramname">groupName</td><td>The resource group from which to load the images </td></tr>
    <tr><td class="paramname">format</td><td>The destination format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bba1b24287b72855b2ddfc67b3f0b6a" name="a4bba1b24287b72855b2ddfc67b3f0b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bba1b24287b72855b2ddfc67b3f0b6a">&#9670;&#160;</a></span>loadTwoImagesAsRGBA() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp; Ogre::Image::loadTwoImagesAsRGBA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>rgbStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>alphaStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39cae0afb06af1cb73f624e66540c64bb2cb">PF_BYTE_RGBA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rgbType</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>alphaType</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgbStream</td><td>Stream of image supplying the RGB channels (any alpha is ignored) </td></tr>
    <tr><td class="paramname">alphaStream</td><td>Stream of image supplying the alpha channel. If a luminance image the single channel is used directly, if an RGB image then the values are converted to greyscale. </td></tr>
    <tr><td class="paramname">format</td><td>The destination format </td></tr>
    <tr><td class="paramname">rgbType</td><td>The type of the RGB image. Used to decide what decompression codec to use. Can be left blank if the stream data includes a header to identify the data. </td></tr>
    <tr><td class="paramname">alphaType</td><td>The type of the alpha image. Used to decide what decompression codec to use. Can be left blank if the stream data includes a header to identify the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59c76c792fda5b2c8c6d064451eb3121" name="a59c76c792fda5b2c8c6d064451eb3121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c76c792fda5b2c8c6d064451eb3121">&#9670;&#160;</a></span>combineTwoImagesAsRGBA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image.html">Image</a> &amp; Ogre::Image::combineTwoImagesAsRGBA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>rgb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39cae0afb06af1cb73f624e66540c64bb2cb">PF_BYTE_RGBA</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgb</td><td><a class="el" href="class_ogre_1_1_image.html" title="Class representing an image file.">Image</a> supplying the RGB channels (any alpha is ignored) </td></tr>
    <tr><td class="paramname">alpha</td><td><a class="el" href="class_ogre_1_1_image.html" title="Class representing an image file.">Image</a> supplying the alpha channel. If a luminance image the single channel is used directly, if an RGB image then the values are converted to greyscale. </td></tr>
    <tr><td class="paramname">format</td><td>The destination format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a611359a16f40f5c18bd937acd33e27c2" name="a611359a16f40f5c18bd937acd33e27c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611359a16f40f5c18bd937acd33e27c2">&#9670;&#160;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::Image::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the image as a file. </p>
<p>Saving and loading are implemented by back end (sometimes third party) codecs. Implemented saving functionality is more limited than loading in some cases. Particularly DDS file format support is currently limited to true colour or single channel float32, square, power of two textures with no mipmaps. Volumetric support is currently limited to DDS files. </p>

</div>
</div>
<a id="ad933a75945dd8573925bf707d9035a6b" name="ad933a75945dd8573925bf707d9035a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad933a75945dd8573925bf707d9035a6b">&#9670;&#160;</a></span>encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> Ogre::Image::encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>formatextension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the image and return a stream to the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formatextension</td><td>An extension to identify the image format to encode into, e.g. "jpg" or "png" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f581fb0afb172c128736f3164c0a7b0" name="a8f581fb0afb172c128736f3164c0a7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f581fb0afb172c128736f3164c0a7b0">&#9670;&#160;</a></span>getData() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> * Ogre::Image::getData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>x</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>y</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>z</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the internal image buffer at the specified pixel location. </p>
<p>Be careful with this method. You will almost certainly prefer to use getPixelBox, especially with complex images which include many faces or custom mipmaps. </p>

</div>
</div>
<a id="a0aa3474921a721041d9c5e2ee7387fc6" name="a0aa3474921a721041d9c5e2ee7387fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa3474921a721041d9c5e2ee7387fc6">&#9670;&#160;</a></span>getData() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> * Ogre::Image::getData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>x</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>y</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>z</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a18b06065c84b0e69bd5bfa94b463d8bf" name="a18b06065c84b0e69bd5bfa94b463d8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b06065c84b0e69bd5bfa94b463d8bf">&#9670;&#160;</a></span>getData() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1vector.html">typename</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">T</a> * Ogre::Image::getData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>x</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>y</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>z</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5c0d15337398d95007fe610267421c35" name="a5c0d15337398d95007fe610267421c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0d15337398d95007fe610267421c35">&#9670;&#160;</a></span>getData() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1vector.html">typename</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> * Ogre::Image::getData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>x</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>y</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>z</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a483cf37ca3ff2965d6d7a2e2c54973f5" name="a483cf37ca3ff2965d6d7a2e2c54973f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483cf37ca3ff2965d6d7a2e2c54973f5">&#9670;&#160;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">size_t</a> Ogre::Image::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the data buffer in bytes. </p>

</div>
</div>
<a id="ad2445c198e2d5018e2056daac7fa7cdb" name="ad2445c198e2d5018e2056daac7fa7cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2445c198e2d5018e2056daac7fa7cdb">&#9670;&#160;</a></span>getNumMipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> Ogre::Image::getNumMipmaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of mipmaps contained in the image. </p>

</div>
</div>
<a id="a86de801dc4420a536e7de544ba596c1b" name="a86de801dc4420a536e7de544ba596c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86de801dc4420a536e7de544ba596c1b">&#9670;&#160;</a></span>hasFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">bool</a> Ogre::Image::hasFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="group___image.html#ga975bb6abd3c277b9a91d849367885474">ImageFlags</a>&#160;</td>
          <td class="paramname"><em>imgFlag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the image has the appropriate flag set. </p>

</div>
</div>
<a id="a649d36eb8288161540d223b7106b7d67" name="a649d36eb8288161540d223b7106b7d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649d36eb8288161540d223b7106b7d67">&#9670;&#160;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> Ogre::Image::getWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the width of the image in pixels. </p>

</div>
</div>
<a id="a064e61e5225c5405d838e2e96a45beed" name="a064e61e5225c5405d838e2e96a45beed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064e61e5225c5405d838e2e96a45beed">&#9670;&#160;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> Ogre::Image::getHeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the height of the image in pixels. </p>

</div>
</div>
<a id="ab0a8872592918bec601a02ceab85a004" name="ab0a8872592918bec601a02ceab85a004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a8872592918bec601a02ceab85a004">&#9670;&#160;</a></span>getDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> Ogre::Image::getDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the depth of the image. </p>

</div>
</div>
<a id="ae2db6b18aae0389177f297e9c6bee8a7" name="ae2db6b18aae0389177f297e9c6bee8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2db6b18aae0389177f297e9c6bee8a7">&#9670;&#160;</a></span>getNumFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> Ogre::Image::getNumFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of faces of the image. </p>
<p>This is usually 6 for a cubemap, and 1 for a normal image. </p>

<p class="reference">References <a class="el" href="group___image.html#gga975bb6abd3c277b9a91d849367885474ae53b467393ae6fd94277782dd276b620">Ogre::IF_CUBEMAP</a>.</p>

</div>
</div>
<a id="aed8c00129e855863b05ee8ea835ba338" name="aed8c00129e855863b05ee8ea835ba338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8c00129e855863b05ee8ea835ba338">&#9670;&#160;</a></span>getRowSpan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">size_t</a> Ogre::Image::getRowSpan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the physical width in bytes of each row of pixels. </p>

</div>
</div>
<a id="ab2a4902d28d19106138c1de923898d1a" name="ab2a4902d28d19106138c1de923898d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a4902d28d19106138c1de923898d1a">&#9670;&#160;</a></span>getFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> Ogre::Image::getFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the image format. </p>

</div>
</div>
<a id="a2929381e7da36687ee19e4329635cb3d" name="a2929381e7da36687ee19e4329635cb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2929381e7da36687ee19e4329635cb3d">&#9670;&#160;</a></span>getBPP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> Ogre::Image::getBPP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bits per pixel. </p>

</div>
</div>
<a id="aa12402f8d6c9485051bf27970ce815a3" name="aa12402f8d6c9485051bf27970ce815a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12402f8d6c9485051bf27970ce815a3">&#9670;&#160;</a></span>getHasAlpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">bool</a> Ogre::Image::getHasAlpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the image has an alpha component. </p>

</div>
</div>
<a id="ab4681974e712d9701c9396e98c6eb07d" name="ab4681974e712d9701c9396e98c6eb07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4681974e712d9701c9396e98c6eb07d">&#9670;&#160;</a></span>applyGamma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::Image::applyGamma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a07f1f7c1d84d58c9beae02e1ebb945e4">uchar</a>&#160;</td>
          <td class="paramname"><em>bpp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does gamma adjustment. </p>
<dl class="section note"><dt>Note</dt><dd>Basic algo taken from Titan Engine, copyright (c) 2000 Ignacio Castano Iguado </dd></dl>

</div>
</div>
<a id="a29ac05fa8046d8e6aff2192cf02d48a8" name="a29ac05fa8046d8e6aff2192cf02d48a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ac05fa8046d8e6aff2192cf02d48a8">&#9670;&#160;</a></span>getColourAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> Ogre::Image::getColourAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get colour value from a certain location in the image. </p>
<p>The z coordinate is only valid for cubemaps and volume textures. This uses the first (largest) mipmap. </p>

</div>
</div>
<a id="af3433519ee4aa9a9141b67657810b110" name="af3433519ee4aa9a9141b67657810b110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3433519ee4aa9a9141b67657810b110">&#9670;&#160;</a></span>setColourAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::Image::setColourAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> <a class="el" href="struct_ogre_1_1vector.html">const</a> &amp;&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set colour value at a certain location in the image. </p>
<p>The z coordinate is only valid for cubemaps and volume textures. This uses the first (largest) mipmap. </p>

</div>
</div>
<a id="af65aa7216f9f9ecce4158ffd20b9cea6" name="af65aa7216f9f9ecce4158ffd20b9cea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65aa7216f9f9ecce4158ffd20b9cea6">&#9670;&#160;</a></span>getPixelBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> Ogre::Image::getPixelBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>face</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>mipmap</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_ogre_1_1_pixel_box.html" title="A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory.">PixelBox</a> encapsulating the image data of a mipmap. </p>

</div>
</div>
<a id="ac9f90a41e3bbdb3abb2b0ce9954b5a12" name="ac9f90a41e3bbdb3abb2b0ce9954b5a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f90a41e3bbdb3abb2b0ce9954b5a12">&#9670;&#160;</a></span>freeMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::Image::freeMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all the memory held by this image, if owned by this image (not dynamic) </p>

</div>
</div>
<a id="adefc5ec16de7ea09fca1c5bbe6782a4c" name="adefc5ec16de7ea09fca1c5bbe6782a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefc5ec16de7ea09fca1c5bbe6782a4c">&#9670;&#160;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::Image::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5a4d66afbe9239683a6fb6b90edb1611b5">FILTER_BILINEAR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale a 1D, 2D or 3D image volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="class_ogre_1_1_pixel_box.html" title="A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory.">PixelBox</a> containing the source pointer, dimensions and format </td></tr>
    <tr><td class="paramname">dst</td><td><a class="el" href="class_ogre_1_1_pixel_box.html" title="A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory.">PixelBox</a> containing the destination pointer, dimensions and format </td></tr>
    <tr><td class="paramname">filter</td><td>Which filter to use This function can do pixel format conversion in the process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>dst and src can point to the same <a class="el" href="class_ogre_1_1_pixel_box.html" title="A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory.">PixelBox</a> object without any problem </dd></dl>

</div>
</div>
<a id="a67a00ee3969db8f5255d2485e3599f03" name="a67a00ee3969db8f5255d2485e3599f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a00ee3969db8f5255d2485e3599f03">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::Image::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="class_ogre_1_1_image.html#aa1d0fe80507583b39161736e4be198d5a4d66afbe9239683a6fb6b90edb1611b5">FILTER_BILINEAR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a 2D image, applying the appropriate filter. </p>

</div>
</div>
<a id="ad90b11682c53f7fe2c99bfd3bc06c5ac" name="ad90b11682c53f7fe2c99bfd3bc06c5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90b11682c53f7fe2c99bfd3bc06c5ac">&#9670;&#160;</a></span>calculateSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="struct_ogre_1_1vector.html">size_t</a> Ogre::Image::calculateSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>mipmaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function to calculate size in bytes from the number of mipmaps, faces and the dimensions. </p>

</div>
</div>
<a id="abfa974d7e6060aa68bf6105156be7069" name="abfa974d7e6060aa68bf6105156be7069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa974d7e6060aa68bf6105156be7069">&#9670;&#160;</a></span>getFileExtFromMagic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> Ogre::Image::getFileExtFromMagic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a>&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function to get an image type string from a stream via magic numbers. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_image_8h.html">OgreImage.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_image.html">Image</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
