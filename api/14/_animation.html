<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Animation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_animation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Animation</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Animation-State">Animation State</a></li>
<li class="level1"><a href="#Skeletal-Animation">Skeletal Animation</a></li>
<li class="level1"><a href="#SceneNode-Animation">SceneNode Animation</a></li>
<li class="level1"><a href="#Vertex-Animation">Vertex Animation</a><ul><li class="level2"><a href="#autotoc_md54">Why two subtypes?</a></li>
<li class="level2"><a href="#autotoc_md55">Subtype applies per track</a></li>
<li class="level2"><a href="#autotoc_md56">Vertex buffer arrangements</a></li>
<li class="level2"><a href="#Morph-Animation">Morph Animation</a></li>
<li class="level2"><a href="#Pose-Animation">Pose Animation</a></li>
<li class="level2"><a href="#Combining-Skeletal-and-Vertex-Animation">Combining Skeletal and Vertex Animation</a><ul><li class="level3"><a href="#Combined-Hardware-Skinning">Combined Hardware Skinning</a></li>
<li class="level3"><a href="#Submesh-Splits">Submesh Splits</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Numeric-Value-Animation">Numeric Value Animation</a><ul><li class="level2"><a href="#autotoc_md57">AnimableObject</a></li>
<li class="level2"><a href="#autotoc_md58">AnimableValue</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>OGRE supports a pretty flexible keyframe based animation system that allows you to script animation for several different purposes:</p>
<dl compact="compact">
<dt><a class="el" href="_animation.html#SceneNode-Animation">SceneNode Animation</a> </dt>
<dd>Animating SceneNodes automatically to create effects like camera sweeps, objects following predefined paths, etc.  </dd>
<dt><a class="el" href="_animation.html#Skeletal-Animation">Skeletal Animation</a> </dt>
<dd>Mesh animation using a skeletal structure to determine how the mesh deforms.  </dd>
<dt><a class="el" href="_animation.html#Vertex-Animation">Vertex Animation</a> </dt>
<dd>Mesh animation using snapshots of vertex data to determine how the shape of the mesh changes.  </dd>
<dt><a class="el" href="_animation.html#Numeric-Value-Animation">Numeric Value Animation</a> </dt>
<dd>Using OGRE’s extensible class structure to animate any value.  </dd>
</dl>
<p>The diagram below shows the relationship between the different animation classes in OGRE:</p>
<div class="image">
<object type="image/svg+xml" data="AnimationSystem.svg" style="pointer-events: none;"></object>
</div>
    <h1><a class="anchor" id="Animation-State"></a>
Animation State</h1>
<p>When an entity with any kind of animation is created, an 'animation state' object is assigned to each animation. This allows you to control both the weight and the time position (where applicable) for applying the animation to that specific entity. You can reuse the same animation definitions across multiple entities, and OGRE handles the internal management of this reuse.</p>
<p>You can retrieve a pointer to the <a class="el" href="class_ogre_1_1_animation_state.html" title="Represents the state of an animation and the weight of its influence.">Ogre::AnimationState</a> object by calling <a class="el" href="class_ogre_1_1_entity.html#a0de9751e9d01243dd7438d916833ea0a" title="For entities based on animated meshes, gets the AnimationState object for a single animation.">Ogre::Entity::getAnimationState</a>. You can then call methods on this returned object to update the animation, probably in the <code>frameStarted</code> event. Each AnimationState needs to be enabled using the <code>setEnabled</code> method before the animation it refers to will take effect. AnimationState also has a very simple method <code>addTime</code> which allows you to alter the animation position incrementally, and it will automatically loop for you. addTime can take positive or negative values (so you can reverse the animation if you want).</p>
<h1><a class="anchor" id="Skeletal-Animation"></a>
Skeletal Animation</h1>
<p>Skeletal animation is a process of animating a mesh by moving a set of hierarchical bones within the mesh, which in turn moves the vertices of the model according to the bone assignments stored in each vertex. An alternative term for this approach is ’skinning’. The usual way of creating these animations is with a modelling tool such as Softimage XSI, Milkshape 3D, Blender, 3D Studio or Maya among others. OGRE provides exporters to allow you to get the data out of these modellers and into the engine See <a class="el" href="_mesh-_tools.html#Exporters">Exporters</a>.</p>
<p>There are many grades of skeletal animation, and not all engines (or modellers for that matter) support all of them. OGRE supports the following features:</p>
<ul>
<li>Each mesh can be linked to a single skeleton</li>
<li>Unlimited bones per skeleton</li>
<li>Hierarchical forward-kinematics on bones</li>
<li>Multiple named animations per skeleton (e.g. ’Walk’, ’Run’, ’Jump’, ’Shoot’ etc)</li>
<li>Unlimited keyframes per animation</li>
<li>Linear or spline-based interpolation between keyframes</li>
<li>A vertex can be assigned to multiple bones and assigned weightings for smoother skinning</li>
<li>Multiple animations can be applied to a mesh at the same time, again with a blend weighting</li>
</ul>
<p>Skeletons and the animations which go with them are held in <code>.skeleton</code> files, which are produced by the OGRE exporters. These files are loaded automatically when you create an Entity based on a Mesh which is linked to the skeleton in question. You then use <a class="el" href="_animation.html#Animation-State">Animation State</a> to set the use of animation on the entity in question.</p>
<p>Skeletal animation can be performed in software, or implemented in shaders (hardware skinning). Clearly the latter is preferable, since it takes some of the work away from the CPU and gives it to the graphics card, and also means that the vertex data does not need to be re-uploaded every frame. This is especially important for large, detailed models. You should try to use hardware skinning wherever possible; this basically means assigning a material which has a vertex program powered technique. See <a class="el" href="_high-level-_programs.html#Skeletal-Animation-in-Vertex-Programs">Skeletal Animation in Vertex Programs</a> for more details. Skeletal animation can be combined with vertex animation, See <a class="el" href="_animation.html#Combining-Skeletal-and-Vertex-Animation">Combining Skeletal and Vertex Animation</a>.</p>
<h1><a class="anchor" id="SceneNode-Animation"></a>
SceneNode Animation</h1>
<p>SceneNode animation is created from the SceneManager in order to animate the movement of SceneNodes, to make any attached objects move around automatically. You can see this performing a camera swoop in the CameraTrack Sample, or controlling how the fish move around in the pond in the Fresnel Sample.</p>
<p>At its heart, scene node animation is mostly the same code which animates the underlying skeleton in skeletal animation. After creating the main Animation using <a class="el" href="class_ogre_1_1_scene_manager.html#aad530a7588b2544eba74370c041dfbe5" title="Creates an animation which can be used to animate scene nodes.">Ogre::SceneManager::createAnimation</a> you can create a NodeAnimationTrack per SceneNode that you want to animate, and create keyframes which control its position, orientation and scale which can be interpolated linearly or via splines. You use <a class="el" href="_animation.html#Animation-State">Animation State</a> in the same way as you do for skeletal/vertex animation, except you obtain the state from SceneManager instead of from an individual Entity.</p>
<dl class="section note"><dt>Note</dt><dd>While AnimationStates are automatically created when an entity is created, you need to manually create them for scene node animations.</dd></dl>
<p>AnimationStates are applied automatically every frame, or the state can be applied manually in advance using the <a class="el" href="class_ogre_1_1_scene_manager.html#ab8ebc8d2fdc6798152ac6a31282de210" title="Internal method for applying animations to scene nodes.">Ogre::SceneManager::_applySceneAnimations()</a> method. See the API reference for full details of the interface for configuring scene animations.</p>
<h1><a class="anchor" id="Vertex-Animation"></a>
Vertex Animation</h1>
<p>Vertex animation is about using information about the movement of vertices directly to animate the mesh. Each track in a vertex animation targets a single VertexData instance. Vertex animation is stored inside the .mesh file since it is tightly linked to the vertex structure of the mesh.</p>
<p>There are actually two subtypes of vertex animation, for reasons which will be discussed in a moment.</p>
<dl compact="compact">
<dt><a class="el" href="_animation.html#Morph-Animation">Morph Animation</a> </dt>
<dd><p class="startdd"></p>
<p class="interdd">Morph animation is a very simple technique which interpolates mesh snapshots along a keyframe timeline. Morph animation has a direct correlation to old-school character animation techniques used before skeletal animation was widely used.<br  />
</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="_animation.html#Pose-Animation">Pose Animation</a> </dt>
<dd><p class="startdd"></p>
<p class="interdd">Pose animation is about blending multiple discrete poses, expressed as offsets to the base vertex data, with different weights to provide a final result. Pose animation’s most obvious use is facial animation.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="Why-two-subtypes_003f"></a></p>
<h2><a class="anchor" id="autotoc_md54"></a>
Why two subtypes?</h2>
<p>So, why two subtypes of vertex animation? Couldn’t both be implemented using the same system? The short answer is yes; in fact you can implement both types using pose animation. But for very good reasons we decided to allow morph animation to be specified separately since the subset of features that it uses is both easier to define and has lower requirements on hardware shaders, if animation is implemented through them. If you don’t care about the reasons why these are implemented differently, you can skip to the next part.</p>
<p>Morph animation is a simple approach where we have a whole series of snapshots of vertex data which must be interpolated, e.g. a running animation implemented as morph targets. Because this is based on simple snapshots, it’s quite fast to use when animating an entire mesh because it’s a simple linear change between keyframes. However, this simplistic approach does not support blending between multiple morph animations. If you need animation blending, you are advised to use skeletal animation for full-mesh animation, and pose animation for animation of subsets of meshes or where skeletal animation doesn’t fit - for example facial animation. For animating in a vertex shader, morph animation is quite simple and just requires the 2 vertex buffers (one the original position buffer) of absolute position data, and an interpolation factor. Each track in a morph animation references a unique set of vertex data.</p>
<p>Pose animation is more complex. Like morph animation each track references a single unique set of vertex data, but unlike morph animation, each keyframe references 1 or more ’poses’, each with an influence level. A pose is a series of offsets to the base vertex data, and may be sparse - i.e. it may not reference every vertex. Because they’re offsets, they can be blended - both within a track and between animations. This set of features is very well suited to facial animation.</p>
<p>For example, let’s say you modelled a face (one set of vertex data), and defined a set of poses which represented the various phonetic positions of the face. You could then define an animation called ’SayHello’, containing a single track which referenced the face vertex data, and which included a series of keyframes, each of which referenced one or more of the facial positions at different influence levels - the combination of which over time made the face form the shapes required to say the word ’hello’. Since the poses are only stored once, but can be referenced may times in many animations, this is a very powerful way to build up a speech system.</p>
<p>The downside of pose animation is that it can be more difficult to set up, requiring poses to be separately defined and then referenced in the keyframes. Also, since it uses more buffers (one for the base data, and one for each active pose), if you’re animating in hardware using vertex shaders you need to keep an eye on how many poses you’re blending at once. You define a maximum supported number in your vertex program definition, via the includes_pose_animation material script entry, See <a class="el" href="_high-level-_programs.html#Pose-Animation-in-Vertex-Programs">Pose Animation in Vertex Programs</a>.</p>
<p>So, by partitioning the vertex animation approaches into 2, we keep the simple morph technique easy to use, whilst still allowing all the powerful techniques to be used. Note that morph animation cannot be blended with other types of vertex animation on the same vertex data (pose animation or other morph animation); pose animation can be blended with other pose animation though, and both types can be combined with skeletal animation. This combination limitation applies per set of vertex data though, not globally across the mesh (see below). Also note that all morph animation can be expressed (in a more complex fashion) as pose animation, but not vice versa.</p>
<p><a class="anchor" id="Subtype-applies-per-track"></a></p>
<h2><a class="anchor" id="autotoc_md55"></a>
Subtype applies per track</h2>
<p>It’s important to note that the subtype in question is held at a track level, not at the animation or mesh level. Since tracks map onto VertexData instances, this means that if your mesh is split into SubMeshes, each with their own dedicated geometry, you can have one SubMesh animated using pose animation, and others animated with morph animation (or not vertex animated at all).</p>
<p>For example, a common set-up for a complex character which needs both skeletal and facial animation might be to split the head into a separate SubMesh with its own geometry, then apply skeletal animation to both submeshes, and pose animation to just the head.</p>
<p>To see how to apply vertex animation, See <a class="el" href="_animation.html#Animation-State">Animation State</a>.</p>
<p><a class="anchor" id="Vertex-buffer-arrangements"></a></p>
<h2><a class="anchor" id="autotoc_md56"></a>
Vertex buffer arrangements</h2>
<p>When using vertex animation in software, vertex buffers need to be arranged such that vertex positions reside in their own hardware buffer. This is to avoid having to upload all the other vertex data when updating, which would quickly saturate the GPU bus. When using the OGRE .mesh format and the tools / exporters that go with it, OGRE organises this for you automatically. But if you create buffers yourself, you need to be aware of the layout arrangements.</p>
<p>To do this, you have a set of helper functions in <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Ogre::Mesh</a>. See API Reference entries for Ogre::VertexData::reorganiseBuffers() and <a class="el" href="class_ogre_1_1_vertex_declaration.html#a20f6d70daf36d78ecfd3f9143e54f748" title="Generates a new VertexDeclaration for optimal usage based on the current vertex declaration,...">Ogre::VertexDeclaration::getAutoOrganisedDeclaration()</a>. The latter will turn a vertex declaration into one which is recommended for the usage you’ve indicated, and the former will reorganise the contents of a set of buffers to conform to that layout.</p>
<h2><a class="anchor" id="Morph-Animation"></a>
Morph Animation</h2>
<p>Morph animation works by storing snapshots of the absolute vertex positions in each keyframe, and interpolating between them. Morph animation is mainly useful for animating objects which could not be adequately handled using skeletal animation; this is mostly objects that have to radically change structure and shape as part of the animation such that a skeletal structure isn’t appropriate.</p>
<p>Because absolute positions are used, it is not possible to blend more than one morph animation on the same vertex data; you should use skeletal animation if you want to include animation blending since it is much more efficient. If you activate more than one animation which includes morph tracks for the same vertex data, only the last one will actually take effect. This also means that the ’weight’ option on the animation state is not used for morph animation.</p>
<p>Morph animation can be combined with skeletal animation if required See <a class="el" href="_animation.html#Combining-Skeletal-and-Vertex-Animation">Combining Skeletal and Vertex Animation</a>. Morph animation can also be implemented in hardware using vertex shaders, See <a class="el" href="_high-level-_programs.html#Morph-Animation-in-Vertex-Programs">Morph Animation in Vertex Programs</a>.</p>
<h2><a class="anchor" id="Pose-Animation"></a>
Pose Animation</h2>
<p>Pose animation allows you to blend together potentially multiple vertex poses at different influence levels into final vertex state. A common use for this is facial animation, where each facial expression is placed in a separate animation, and influences used to either blend from one expression to another, or to combine full expressions if each pose only affects part of the face.</p>
<p>In order to do this, pose animation uses a set of reference poses defined in the mesh, expressed as offsets to the original vertex data. It does not require that every vertex has an offset - those that don’t are left alone. When blending in software these vertices are completely skipped - when blending in hardware (which requires a vertex entry for every vertex), zero offsets for vertices which are not mentioned are automatically created for you.</p>
<p>Once you’ve defined the poses, you can refer to them in animations. Each pose animation track refers to a single set of geometry (either the shared geometry of the mesh, or dedicated geometry on a submesh), and each keyframe in the track can refer to one or more poses, each with its own influence level. The weight applied to the entire animation scales these influence levels too. You can define many keyframes which cause the blend of poses to change over time. The absence of a pose reference in a keyframe when it is present in a neighbouring one causes it to be treated as an influence of 0 for interpolation.</p>
<p>You should be careful how many poses you apply at once. When performing pose animation in hardware (See <a class="el" href="_high-level-_programs.html#Pose-Animation-in-Vertex-Programs">Pose Animation in Vertex Programs</a>), every active pose requires another vertex buffer to be added to the shader, and in when animating in software it will also take longer the more active poses you have. Bear in mind that if you have 2 poses in one keyframe, and a different 2 in the next, that actually means there are 4 active keyframes when interpolating between them.</p>
<p>You can combine pose animation with skeletal animation, See <a class="el" href="_animation.html#Combining-Skeletal-and-Vertex-Animation">Combining Skeletal and Vertex Animation</a>, and you can also hardware accelerate the application of the blend with a vertex shader, See <a class="el" href="_high-level-_programs.html#Pose-Animation-in-Vertex-Programs">Pose Animation in Vertex Programs</a>.</p>
<h2><a class="anchor" id="Combining-Skeletal-and-Vertex-Animation"></a>
Combining Skeletal and Vertex Animation</h2>
<p>Skeletal animation and vertex animation (of either subtype) can both be enabled on the same entity at the same time (See <a class="el" href="_animation.html#Animation-State">Animation State</a>). The effect of this is that vertex animation is applied first to the base mesh, then skeletal animation is applied to the result. This allows you, for example, to facially animate a character using pose vertex animation, whilst performing the main movement animation using skeletal animation.</p>
<p>Combining the two is, from a user perspective, as simple as just enabling both animations at the same time. When it comes to using this feature efficiently though, there are a few points to bear in mind:</p>
<h3><a class="anchor" id="Combined-Hardware-Skinning"></a>
Combined Hardware Skinning</h3>
<p>For complex characters it is a very good idea to implement hardware skinning by including a technique in your materials which has a vertex program which can perform the kinds of animation you are using in hardware.</p>
<p>When combining animation types, your vertex programs must support both types of animation that the combined mesh needs, otherwise hardware skinning will be disabled. You should implement the animation in the same way that OGRE does, i.e. perform vertex animation first, then apply skeletal animation to the result of that. Remember that the implementation of morph animation passes 2 absolute snapshot buffers of the from &amp; to keyframes, along with a single parametric, which you have to linearly interpolate, whilst pose animation passes the base vertex data plus ’n’ pose offset buffers, and ’n’ parametric weight values.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="_high-level-_programs.html#Skeletal-Animation-in-Vertex-Programs">Skeletal Animation in Vertex Programs</a></li>
<li><a class="el" href="_high-level-_programs.html#Morph-Animation-in-Vertex-Programs">Morph Animation in Vertex Programs</a></li>
<li><a class="el" href="_high-level-_programs.html#Pose-Animation-in-Vertex-Programs">Pose Animation in Vertex Programs</a></li>
</ul>
</dd></dl>
<h3><a class="anchor" id="Submesh-Splits"></a>
Submesh Splits</h3>
<p>If you only need to combine vertex and skeletal animation for a small part of your mesh, e.g. the face, you could split your mesh into 2 parts, one which needs the combination and one which does not, to reduce the calculation overhead. Note that it will also reduce vertex buffer usage since vertex keyframe / pose buffers will also be smaller. Note that if you use hardware skinning you should then implement 2 separate vertex programs, one which does only skeletal animation, and the other which does skeletal and vertex animation.</p>
<h1><a class="anchor" id="Numeric-Value-Animation"></a>
Numeric Value Animation</h1>
<p>Apart from the specific animation types which may well comprise the most common uses of the animation framework, you can also use animations to alter any value which is exposed via the <a class="el" href="_animation.html#AnimableObject">AnimableObject</a> interface.</p>
<p><a class="anchor" id="AnimableObject"></a><a class="anchor" id="AnimableObject-1"></a></p>
<h2><a class="anchor" id="autotoc_md57"></a>
AnimableObject</h2>
<p><a class="el" href="class_ogre_1_1_animable_object.html" title="Defines an interface to classes which have one or more AnimableValue instances to expose.">Ogre::AnimableObject</a> is an abstract interface that any class can implement in order to provide advertise that it has animable properties. The interface provides methods to list the animable properties, and to create <a class="el" href="class_ogre_1_1_animable_value.html" title="Defines an object property which is animable, i.e.">Ogre::AnimableValue</a> objects which can be used to animate those properties.</p>
<p>One example of this is the <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene.">Ogre::Light</a> class. It extends AnimableObject and provides AnimableValues for properties such as <code>"diffuseColour"</code> and <code>"attenuation"</code>. Animation tracks can be created for these values and thus properties of the light can be scripted to change. Other objects, including your custom objects, can extend this interface in the same way to provide animation support to their properties.</p>
<p><a class="anchor" id="AnimableValue"></a><a class="anchor" id="AnimableValue-1"></a></p>
<h2><a class="anchor" id="autotoc_md58"></a>
AnimableValue</h2>
<p>When implementing custom animable properties, you have to also implement a number of methods on the <a class="el" href="class_ogre_1_1_animable_value.html" title="Defines an object property which is animable, i.e.">Ogre::AnimableValue</a> interface - basically anything which has been marked as unimplemented. These are not pure virtual methods simply because you only have to implement the methods required for the type of value you’re animating. Again, see the examples in Light to see how this is done. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
