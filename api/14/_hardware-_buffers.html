<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Hardware Buffers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_hardware-_buffers.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Hardware Buffers</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#The-Hardware-Buffer-Manager">The Hardware Buffer Manager</a></li>
<li class="level1"><a href="#Buffer-Usage">Buffer Usage</a></li>
<li class="level1"><a href="#Shadow-Buffers">Shadow Buffers</a></li>
<li class="level1"><a href="#Data-Transfer">Data Transfer</a><ul><li class="level2"><a href="#autotoc_md240">writeData and readData</a></li>
<li class="level2"><a href="#Locking-buffers">Locking buffers</a><ul><li class="level3"><a href="#autotoc_md241">Lock parameters</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Practical-Buffer-Tips">Practical Buffer Tips</a><ul><li class="level2"><a href="#autotoc_md242">Vulkan specific notes</a></li>
</ul>
</li>
<li class="level1"><a href="#Hardware-Vertex-Buffers">Hardware Vertex Buffers</a><ul><li class="level2"><a href="#The-VertexData-class">The VertexData class</a></li>
<li class="level2"><a href="#Vertex-Declarations">Vertex Declarations</a></li>
<li class="level2"><a href="#Vertex-Buffer-Bindings">Vertex Buffer Bindings</a></li>
<li class="level2"><a href="#Creating-the-Vertex-Buffer">Creating the Vertex Buffer</a></li>
<li class="level2"><a href="#Binding-the-Vertex-Buffer">Binding the Vertex Buffer</a></li>
<li class="level2"><a href="#Updating-Vertex-Buffers">Updating Vertex Buffers</a></li>
</ul>
</li>
<li class="level1"><a href="#Hardware-Index-Buffers">Hardware Index Buffers</a><ul><li class="level2"><a href="#The-IndexData-class">The IndexData class</a></li>
<li class="level2"><a href="#autotoc_md243">Creating an Index Buffer</a></li>
<li class="level2"><a href="#Updating-Index-Buffers">Updating Index Buffers</a></li>
</ul>
</li>
<li class="level1"><a href="#Hardware-Pixel-Buffers">Hardware Pixel Buffers</a><ul><li class="level2"><a href="#Pixel-boxes">Pixel boxes</a></li>
<li class="level2"><a href="#Updating-Pixel-Buffers">Updating Pixel Buffers</a><ul><li class="level3"><a href="#blitFromMemory">Blit from memory</a></li>
<li class="level3"><a href="#Direct-memory-locking">Direct memory locking</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Textures">Textures</a><ul><li class="level2"><a href="#Creating-a-texture">Creating a texture</a></li>
<li class="level2"><a href="#Getting-a-PixelBuffer">Getting a PixelBuffer</a></li>
<li class="level2"><a href="#Cube-map-textures">Cube map textures</a></li>
<li class="level2"><a href="#Pixel-Formats">Pixel Formats</a><ul><li class="level3"><a href="#Colour-channels">Colour channels</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The general premise with a hardware buffer is that it is an area of memory with which you can do whatever you like; there is no format (vertex or otherwise) associated with the buffer itself - that is entirely up to interpretation by the methods that use it - in that way, a <a class="el" href="class_ogre_1_1_hardware_buffer.html" title="Abstract class defining common features of hardware buffers.">Ogre::HardwareBuffer</a> is just like an area of memory you might allocate using <code>malloc</code> - the difference being that this memory is accessible by the GPU driver. Vertex buffers, index buffers and pixel buffers inherit most of their features from the HardwareBuffer class.</p>
<p><a class="anchor" id="The-Hardware-Buffer-Manager-1"></a></p>
<h1><a class="anchor" id="The-Hardware-Buffer-Manager"></a>
The Hardware Buffer Manager</h1>
<p>The HardwareBufferManager class is the factory hub of all the objects in the new geometry system. You create and destroy the majority of the objects you use to define geometry through this class. Itâ€™s a Singleton, so you access it by doing HardwareBufferManager::getSingleton() - however be aware that it is only guaranteed to exist after the RenderSystem has been initialised (after you call Root::initialise); this is because the objects created are invariably API-specific, although you will deal with them through one common interface. For example:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ogre_1_1_vertex_declaration.html">Ogre::VertexDeclaration</a>* decl = HardwareBufferManager::getSingleton().createVertexDeclaration();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> vbuf = <a class="code hl_function" href="class_ogre_1_1_hardware_buffer_manager.html#a90c028c2ce1ec1364627cb0faca2320e">Ogre::HardwareBufferManager::getSingleton</a>().createVertexBuffer(</div>
<div class="line">    3 * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),  <span class="comment">// size of one whole vertex</span></div>
<div class="line">    numVertices,        <span class="comment">// number of vertices</span></div>
<div class="line">    <a class="code hl_enumvalue" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532ad4ea5a32caed7bbb643f6536606dba64">Ogre::HBU_GPU_ONLY</a>, <span class="comment">// usage</span></div>
<div class="line">    <span class="keyword">false</span>);             <span class="comment">// no shadow buffer</span></div>
<div class="ttc" id="aclass_ogre_1_1_hardware_buffer_manager_html_a90c028c2ce1ec1364627cb0faca2320e"><div class="ttname"><a href="class_ogre_1_1_hardware_buffer_manager.html#a90c028c2ce1ec1364627cb0faca2320e">Ogre::HardwareBufferManager::getSingleton</a></div><div class="ttdeci">static HardwareBufferManager &amp; getSingleton(void)</div><div class="ttdoc">Get the singleton instance.</div></div>
<div class="ttc" id="aclass_ogre_1_1_vertex_declaration_html"><div class="ttname"><a href="class_ogre_1_1_vertex_declaration.html">Ogre::VertexDeclaration</a></div><div class="ttdoc">This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...</div><div class="ttdef"><b>Definition</b> OgreHardwareVertexBuffer.h:278</div></div>
<div class="ttc" id="agroup___render_system_html_gga3e7bd12438696e8c75150be1fbe90532ad4ea5a32caed7bbb643f6536606dba64"><div class="ttname"><a href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532ad4ea5a32caed7bbb643f6536606dba64">Ogre::HBU_GPU_ONLY</a></div><div class="ttdeci">@ HBU_GPU_ONLY</div><div class="ttdoc">Device-local GPU (video) memory.</div><div class="ttdef"><b>Definition</b> OgreHardwareBuffer.h:71</div></div>
</div><!-- fragment --><p>Donâ€™t worry about the details of the above, weâ€™ll cover that in the later sections. The important thing to remember is to always create objects through the HardwareBufferManager, donâ€™t use â€™newâ€™ (it wonâ€™t work anyway in most cases).</p>
<h1><a class="anchor" id="Buffer-Usage"></a>
Buffer Usage</h1>
<p>Because the memory in a hardware buffer is likely to be under significant contention during the rendering of a scene, the kind of access you need to the buffer over the time it is used is extremely important; whether you need to update the contents of the buffer regularly, whether you need to be able to read information back from it, these are all important factors to how the graphics card manages the buffer. The method and exact parameters used to create a buffer depends on whether you are creating an <a class="el" href="_hardware-_buffers.html#Hardware-Index-Buffers">index buffer</a> or <a class="el" href="_hardware-_buffers.html#Hardware-Vertex-Buffers">vertex buffer</a>, however one creation parameter is common to them both - the <code>usage</code>. The most optimal type of hardware buffer is one which is not updated often, and is never read from. The usage parameter of <code>createVertexBuffer</code> or <code>createIndexBuffer</code> can be one of <a class="el" href="group___render_system.html#ga3e7bd12438696e8c75150be1fbe90532" title="Enums describing buffer usage.">Ogre::HardwareBufferUsage</a>.</p>
<p>Choosing the usage of your buffers carefully is important to getting optimal performance out of your geometry. If you have a situation where you need to update a vertex buffer often, consider whether you actually need to update <b>all</b> the parts of it, or just some. If itâ€™s the latter, consider using more than one buffer, with only the data you need to modify in the HBU_CPU_TO_GPU buffer. Always try to use the HBU_GPU_ONLY form. This just means that you cannot read <em>directly</em> from the hardware buffer, which is good practice because reading from hardware buffers is very slow. If you really need to read data back, use a shadow buffer, described in the next section.</p>
<p>The following table shows how the descriptive usage names map to the legacy terminology used in older versions of Ogre as well as rendering APIs like D3D11 and OpenGL.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Legacy name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">HBU_GPU_ONLY   </td><td class="markdownTableBodyNone">HBU_STATIC_WRITE_ONLY    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">HBU_CPU_TO_GPU   </td><td class="markdownTableBodyNone">HBU_DYNAMIC_WRITE_ONLY    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">HBU_GPU_TO_CPU   </td><td class="markdownTableBodyNone">HBU_STATIC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">HBU_CPU_ONLY   </td><td class="markdownTableBodyNone">HBU_DYNAMIC   </td></tr>
</table>
<h1><a class="anchor" id="Shadow-Buffers"></a>
Shadow Buffers</h1>
<p>Reading data from a buffer in the GPU memory is very expensive. However, if you have a cast-iron need to read the contents of the buffer, you should set the <code>shadowBuffer</code> parameter of <code>createVertexBuffer</code> or <code>createIndexBuffer</code> to <code>true</code>. This causes the hardware buffer to be shadowed with a <em>staging</em> system-memory copy, which will be synchronised with the GPU buffer at locking (<code>HBL_READ_ONLY</code>) or unlocking (<code>HBL_WRITE_ONLY</code>) time. You can read from with no more penalty than reading ordinary memory. The catch is that you now have two copies of the buffer - one in system memory and one on the GPU. Therefore do not use it, unless you need it.</p>
<h1><a class="anchor" id="Data-Transfer"></a>
Data Transfer</h1>
<p>In order to read or update a hardware buffer, you have to notify the card about it as it can have an effect on its rendering queue. Ogre provides two ways of doing this as described below.</p>
<h2><a class="anchor" id="autotoc_md240"></a>
writeData and readData</h2>
<p>If your data is already somewhere in system memory, you can use the simple <code>writeData</code> and <code>readData</code> methods. These can be thought of as locking the buffer (as described below) and doing a <code>memcpy</code>. Some APIs, like OpenGL, implement this more efficiently though.</p>
<div class="fragment"><div class="line">std::vector&lt;float&gt; vec = ...;</div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_shared_ptr.html">Ogre::HardwareBufferPtr</a> pBuffer = ...;</div>
<div class="line"><span class="comment">// the last parameter means we discard all previous content on writing</span></div>
<div class="line">pBuffer-&gt;writeData(0, vec.size() * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), vec.data(), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclass_ogre_1_1_shared_ptr_html"><div class="ttname"><a href="class_ogre_1_1_shared_ptr.html">Ogre::SharedPtr&lt; HardwareBuffer &gt;</a></div></div>
</div><!-- fragment --><p>However, this approach has a noticeable overhead, if you update small portions of the buffer at different locations. Also, it obviously requires system memory to be allocated for the data.</p>
<h2><a class="anchor" id="Locking-buffers"></a>
Locking buffers</h2>
<p>Locking performs 2 functions - it tells the card that you want access to the buffer, and it returns a pointer which you can manipulate. Note that if youâ€™ve asked to read the buffer (and remember, you really shouldnâ€™t unless youâ€™ve set the buffer up with a shadow buffer), the contents of the hardware buffer will have been copied into system memory somewhere in order for you to get access to it. For the same reason, when youâ€™re finished with the buffer you must unlock it; if you locked the buffer for writing this will trigger the process of uploading the modified information to the graphics hardware.</p>
<dl class="section note"><dt>Note</dt><dd>It is strongly recommended to use <a class="el" href="struct_ogre_1_1_hardware_buffer_lock_guard.html" title="Locking helper.">Ogre::HardwareBufferLockGuard</a> instead of manually locking and unlocking buffers. This guarantees unlocking even in case of exception.</dd></dl>
<p><a class="anchor" id="Lock-parameters"></a></p>
<h3><a class="anchor" id="autotoc_md241"></a>
Lock parameters</h3>
<p>When you lock a buffer, you call one of the following methods:</p>
<div class="fragment"><div class="line">HardwareBufferPtr pBuffer = ...;</div>
<div class="line"><span class="comment">// Lock the entire buffer</span></div>
<div class="line">pBuffer-&gt;lock(lockType);</div>
<div class="line"><span class="comment">// Lock only part of the buffer</span></div>
<div class="line">pBuffer-&gt;lock(start, length, lockType);</div>
</div><!-- fragment --><p>The first call locks the entire buffer, the second locks only the section from <code>start</code> (as a byte offset), for <code>length</code> bytes. This could be faster than locking the entire buffer since less is transferred, but not if you later update the rest of the buffer too, because doing it in small chunks like this means you cannot use <a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5a176ad39ac15fc0a6028d820a6fe228ae" title="Discards the entire buffer while locking.">Ogre::HardwareBuffer::HBL_DISCARD</a>. The <code>lockType</code> parameter can have a large effect on the performance of your application, especially if you are not using a shadow buffer. See <a class="el" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5" title="Locking options.">Ogre::HardwareBuffer::LockOptions</a>.</p>
<p>Once you have locked a buffer, you can use the pointer returned however you wish (just donâ€™t bother trying to read the data thatâ€™s there if youâ€™ve used <code>HBL_DISCARD</code>, or write the data if youâ€™ve used <code>HBL_READ_ONLY</code>). Modifying the contents depends on the type of buffer. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="_hardware-_buffers.html#Updating-Vertex-Buffers">Updating Vertex Buffers</a> </dd>
<dd>
<a class="el" href="_hardware-_buffers.html#Updating-Index-Buffers">Updating Index Buffers</a></dd></dl>
<h1><a class="anchor" id="Practical-Buffer-Tips"></a>
Practical Buffer Tips</h1>
<p>The interplay of usage mode on creation, and locking options when reading / updating is important for performance. Hereâ€™s some tips:</p>
<ol type="1">
<li>Aim for the â€™perfectâ€™ buffer by creating with <code>HBU_GPU_ONLY</code>, with no shadow buffer, and locking all of it once only with <code>HBL_DISCARD</code> to populate it. Never touch it again.</li>
<li>If you need to update a buffer regularly, you will have to compromise. Use <code>HBU_CPU_TO_GPU</code> when creating (still no shadow buffer), and use <code>HBL_DISCARD</code> to lock the entire buffer, or if you canâ€™t then use <code>HBL_NO_OVERWRITE</code> to lock parts of it.</li>
<li>If you really need to read data from the buffer, create it with a shadow buffer. Make sure you use <code>HBL_READ_ONLY</code> when locking for reading because it will avoid the upload normally associated with unlocking the buffer. You can also combine this with either of the 2 previous points, obviously try for <code>HBU_GPU_ONLY</code> if you can - remember that the usage refers to the hardware buffer so can be safely used with a shadow buffer you read from.</li>
<li>Split your vertex buffers up if you find that your usage patterns for different elements of the vertex are different. No point having one huge updatable buffer with all the vertex data in it, if all you need to update is the texture coordinates. Split that part out into its own buffer and make the rest <code>HBU_GPU_ONLY</code>.</li>
</ol>
<h2><a class="anchor" id="autotoc_md242"></a>
Vulkan specific notes</h2>
<p>When it comes to Vulkan, the above tips become rules. Ogre does not try to emulate the behaviour of older APIs and gets out of the way when you are about to shoot yourself in the foot.</p><ul>
<li>As the GPU might not yet be done processing the data, you should always use <code>HBL_DISCARD</code> or multiple buffers to avoid rendering glitches</li>
<li><code>HBU_GPU_ONLY</code> buffer updates must be done before rendering of the current frame starts (i.e. <code>RenderSystem::_render</code> has been called)</li>
</ul>
<h1><a class="anchor" id="Hardware-Vertex-Buffers"></a>
Hardware Vertex Buffers</h1>
<p>This section covers specialised hardware buffers which contain vertex data.</p>
<h2><a class="anchor" id="The-VertexData-class"></a>
The VertexData class</h2>
<p>The <a class="el" href="class_ogre_1_1_vertex_data.html" title="collects together all the vertex-related information used to render geometry.">Ogre::VertexData</a> class  collects together all the vertex-related information used to render geometry.  </p>
<p>The RenderOperation requires a pointer to a VertexData object, and it is also used in Mesh and SubMesh to store the vertex positions, normals, texture coordinates etc. VertexData can either be used alone (in order to render unindexed geometry, where the stream of vertices defines the triangles), or in combination with IndexData where the triangles are defined by indexes which refer to the entries in VertexData. Itâ€™s worth noting that you donâ€™t necessarily have to use VertexData to store your applications geometry; all that is required is that you can build a VertexData structure when it comes to rendering. This is pretty easy since all of VertexDataâ€™s members are pointers, so you could maintain your vertex buffers and declarations in alternative structures if you like, so long as you can convert them for rendering.   The VertexData class has a number of important members:</p>
<dl compact="compact">
<dt>vertexStart </dt>
<dd><p class="startdd"></p>
<p class="interdd">The position in the bound buffers to start reading vertex data from. This allows you to use a single buffer for many different renderables.  </p>
<p class="enddd"></p>
</dd>
<dt>vertexCount </dt>
<dd><p class="startdd"></p>
<p class="interdd">The number of vertices to process in this particular rendering group.  </p>
<p class="enddd"></p>
</dd>
<dt>vertexDeclaration </dt>
<dd><p class="startdd"></p>
<p class="interdd">Declaration of the the format of the vertex input.  </p>
<p class="interdd">Note that this is created for you on construction.   See <a class="el" href="_hardware-_buffers.html#Vertex-Declarations">Vertex Declarations</a></p>
<p class="enddd"></p>
</dd>
<dt>vertexBufferBinding </dt>
<dd><p class="startdd"></p>
<p class="interdd">Defines which vertex buffers are bound to which sources.  </p>
<p class="interdd">Note that this is created for you on construction.   See <a class="el" href="_hardware-_buffers.html#Vertex-Buffer-Bindings">Vertex Buffer Bindings</a></p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="Vertex-Declarations"></a>
Vertex Declarations</h2>
<p>Vertex declarations define the vertex inputs used to render the geometry you want to appear on the screen. Basically this means that for each vertex, you want to feed a certain set of data into the graphics pipeline, which (you hope) will affect how it all looks when the triangles are drawn. Vertex declarations let you pull items of data (which we call vertex elements, represented by the VertexElement class) from any number of buffers, both shared and dedicated to that particular element. Itâ€™s your job to ensure that the contents of the buffers make sense when interpreted in the way that your VertexDeclaration indicates that they should. To add an element to a VertexDeclaration, you call <a class="el" href="class_ogre_1_1_vertex_declaration.html#a129bd245e36201e693d5d3605c402353" title="Adds a new VertexElement to this declaration.">Ogre::VertexDeclaration::addElement</a> method. The parameters to this method are:</p>
<dl compact="compact">
<dt>source </dt>
<dd><p class="startdd"></p>
<p class="interdd">This tells the declaration which buffer the element is to be pulled from. Note that this is just an index, which may range from 0 to one less than the number of buffers which are being bound as sources of vertex data. See <a class="el" href="_hardware-_buffers.html#Vertex-Buffer-Bindings">Vertex Buffer Bindings</a> for information on how a real buffer is bound to a source index. Storing the source of the vertex element this way (rather than using a buffer pointer) allows you to rebind the source of a vertex very easily, without changing the declaration of the vertex format itself.</p>
<p class="enddd"></p>
</dd>
<dt>offset </dt>
<dd><p class="startdd"></p>
<p class="interdd">Tells the declaration how far in bytes the element is offset from the start of each whole vertex in this buffer. This will be 0 if this is the only element being sourced from this buffer, but if other elements are there then it may be higher. A good way of thinking of this is the size of all vertex elements which precede this element in the buffer.</p>
<p class="enddd"></p>
</dd>
<dt>type </dt>
<dd><p class="startdd"></p>
<p class="interdd">This defines the data type of the vertex input, including its size. This is an important element because as GPUs become more advanced, we can no longer assume that position input will always require 3 floating point numbers, because programmable vertex pipelines allow full control over the inputs and outputs. This part of the element definition covers the basic type and size, e.g. VET_FLOAT3 is 3 floating point numbers - the meaning of the data is dealt with in the next parameter.</p>
<p class="enddd"></p>
</dd>
<dt>semantic </dt>
<dd><p class="startdd"></p>
<p class="interdd">This defines the meaning of the element - the GPU will use this to determine what to use this input for, and programmable vertex pipelines will use this to identify which semantic to map the input to. This can identify the element as positional data, normal data, texture coordinate data, etc. See the API reference for full details of all the options.</p>
<p class="enddd"></p>
</dd>
<dt>index </dt>
<dd><p class="startdd"></p>
<p class="interdd">This parameter is only required when you supply more than one element of the same semantic in one vertex declaration. For example, if you supply more than one set of texture coordinates, you would set first sets index to 0, and the second set to 1.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>You can repeat the call to addElement for as many elements as you have in your vertex input structures. There are also useful methods on VertexDeclaration for locating elements within a declaration - see the API reference for full details.</p>
<h2><a class="anchor" id="Vertex-Buffer-Bindings"></a>
Vertex Buffer Bindings</h2>
<p>Vertex buffer bindings are about associating a vertex buffer with a source index used in <a class="el" href="_hardware-_buffers.html#Vertex-Declarations">Vertex Declarations</a>.</p>
<h2><a class="anchor" id="Creating-the-Vertex-Buffer"></a>
Creating the Vertex Buffer</h2>
<p>Firstly, lets look at how you create a vertex buffer:</p>
<div class="fragment"><div class="line">HardwareVertexBufferPtr vbuf =</div>
<div class="line">    <a class="code hl_function" href="class_ogre_1_1_hardware_buffer_manager.html#a90c028c2ce1ec1364627cb0faca2320e">Ogre::HardwareBufferManager::getSingleton</a>().createVertexBuffer(</div>
<div class="line">    3 * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),  <span class="comment">// size of one whole vertex</span></div>
<div class="line">    numVertices,        <span class="comment">// number of vertices</span></div>
<div class="line">    <a class="code hl_enumvalue" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532ad4ea5a32caed7bbb643f6536606dba64">Ogre::HBU_GPU_ONLY</a>, <span class="comment">// usage</span></div>
<div class="line">    <span class="keyword">false</span>);             <span class="comment">// no shadow buffer</span></div>
</div><!-- fragment --><p>Notice that we use <a class="el" href="_hardware-_buffers.html#The-Hardware-Buffer-Manager">The Hardware Buffer Manager</a> to create our vertex buffer, and that a class called <a class="el" href="namespace_ogre.html#a23079674b2abb8481c373860bca2c22a">Ogre::HardwareVertexBufferPtr</a> is returned from the method, rather than a raw pointer. This is because vertex buffers are reference counted - you are able to use a single vertex buffer as a source for multiple pieces of geometry therefore a standard pointer would not be good enough, because you would not know when all the different users of it had finished with it. The <code>HardwareVertexBufferPtr</code> class manages its own destruction by keeping a reference count of the number of times it is being used - when the last <code>HardwareVertexBufferPtr</code> is destroyed, the buffer itself automatically destroys itself.</p>
<p>The parameters to the creation of a vertex buffer are as follows:</p>
<dl compact="compact">
<dt>vertexSize </dt>
<dd><p class="startdd"></p>
<p class="interdd">The size in bytes of a whole vertex in this buffer. A vertex may include multiple elements, and in fact the contents of the vertex data may be reinterpreted by different vertex declarations if you wish. Therefore you must tell the buffer manager how large a whole vertex is, but not the internal format of the vertex, since that is down to the declaration to interpret. In the above example, the size is set to the size of 3 floating point values - this would be enough to hold a standard 3D position or normal, or a 3D texture coordinate, per vertex.</p>
<p class="enddd"></p>
</dd>
<dt>numVertices </dt>
<dd><p class="startdd"></p>
<p class="interdd">The number of vertices in this buffer. Remember, not all the vertices have to be used at once - it can be beneficial to create large buffers which are shared between many chunks of geometry because changing vertex buffer bindings is a render state switch, and those are best minimised.</p>
<p class="enddd"></p>
</dd>
<dt>usage </dt>
<dd><p class="startdd"></p>
<p class="interdd">This tells the system how you intend to use the buffer. See <a class="el" href="_hardware-_buffers.html#Buffer-Usage">Buffer Usage</a></p>
<p class="enddd"></p>
</dd>
<dt>useShadowBuffer </dt>
<dd><p class="startdd"></p>
<p class="interdd">Tells the system whether you want this buffer backed by a system-memory copy. See <a class="el" href="_hardware-_buffers.html#Shadow-Buffers">Shadow Buffers</a></p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="Binding-the-Vertex-Buffer"></a>
Binding the Vertex Buffer</h2>
<p>The second part of the process is to bind this buffer which you have created to a source index. To do this, you call:</p>
<div class="fragment"><div class="line">vertexBufferBinding-&gt;setBinding(0, vbuf);</div>
</div><!-- fragment --><p>This results in the vertex buffer you created earlier being bound to source index 0, so any vertex element which is pulling its data from source index 0 will retrieve data from this buffer. There are also methods for retrieving buffers from the binding data - see the API reference for full details.</p>
<h2><a class="anchor" id="Updating-Vertex-Buffers"></a>
Updating Vertex Buffers</h2>
<p>The complexity of updating a vertex buffer entirely depends on how its contents are laid out. You can <a class="el" href="_hardware-_buffers.html#Locking-buffers">lock a buffer</a>, but how you write data into it vert much depends on what it contains. Let's start with a vert simple example. Let's say you have a buffer which only contains vertex positions, so it only contains sets of 3 floating point numbers per vertex. In this case, all you need to do to write data into it is:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> pFloat = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span>*<span class="keyword">&gt;</span>(vbuf-&gt;lock(HardwareBuffer::HBL_DISCARD));</div>
</div><!-- fragment --><p>... then you just write positions in chunks of 3 reals. If you have other floating point data in there, itâ€™s a little more complex but the principle is largely the same, you just need to write alternate elements. But what if you have elements of different types, or you need to derive how to write the vertex data from the elements themselves? Well, there are some useful methods on the VertexElement class to help you out. Firstly, you lock the buffer but assign the result to a unsigned char* rather than a specific type. Then, for each element which is sourcing from this buffer (which you can find out by calling VertexDeclaration::findElementsBySource) you call VertexElement::baseVertexPointerToElement. This offsets a pointer which points at the base of a vertex in a buffer to the beginning of the element in question, and allows you to use a pointer of the right type to boot. Hereâ€™s a full example:</p>
<div class="fragment"><div class="line"><span class="comment">// will automatically release the lock</span></div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1_hardware_buffer_lock_guard.html">Ogre::HardwareBufferLockGuard</a> vbufLock(vbuf, HardwareBuffer::HBL_READ_ONLY);</div>
<div class="line"><span class="comment">// Get base pointer</span></div>
<div class="line"><span class="keyword">auto</span> pVert = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(vbufLock.pData);</div>
<div class="line"><span class="keywordtype">float</span>* pFloat;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0; v &lt; vertexCount; ++v)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Get elements</span></div>
<div class="line">    <span class="keywordflow">for</span> (VertexElement&amp; elem : decl-&gt;findElementsBySource(bufferIdx))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (elem.getSemantic() == VES_POSITION)</div>
<div class="line">        {</div>
<div class="line">            elem.baseVertexPointerToElement(pVert, &amp;pFloat);</div>
<div class="line">            <span class="comment">// write position using pFloat</span></div>
<div class="line"> </div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        ...</div>
<div class="line">        </div>
<div class="line">        </div>
<div class="line">    }</div>
<div class="line">    pVert += vbuf-&gt;getVertexSize();</div>
<div class="line">}</div>
<div class="ttc" id="astruct_ogre_1_1_hardware_buffer_lock_guard_html"><div class="ttname"><a href="struct_ogre_1_1_hardware_buffer_lock_guard.html">Ogre::HardwareBufferLockGuard</a></div><div class="ttdoc">Locking helper.</div><div class="ttdef"><b>Definition</b> OgreHardwareBuffer.h:395</div></div>
</div><!-- fragment --><p>See the API docs for full details of all the helper methods on VertexDeclaration and VertexElement to assist you in manipulating vertex buffer data pointers.</p>
<h1><a class="anchor" id="Hardware-Index-Buffers"></a>
Hardware Index Buffers</h1>
<p>Index buffers are used to render geometry by building triangles out of vertices indirectly by reference to their position in the buffer, rather than just building triangles by sequentially reading vertices. Index buffers are simpler than vertex buffers, since they are just a list of indexes at the end of the day, however they can be held on the hardware and shared between multiple pieces of geometry in the same way vertex buffers can, so the rules on creation and locking are the same.</p>
<h2><a class="anchor" id="The-IndexData-class"></a>
The IndexData class</h2>
<p>This class summarises the information required to use a set of indexes to render geometry. Its members are as follows:</p>
<dl compact="compact">
<dt>indexStart </dt>
<dd><p class="startdd"></p>
<p class="interdd">The first index used by this piece of geometry; this can be useful for sharing a single index buffer among several geometry pieces.</p>
<p class="enddd"></p>
</dd>
<dt>indexCount </dt>
<dd><p class="startdd"></p>
<p class="interdd">The number of indexes used by this particular renderable.</p>
<p class="enddd"></p>
</dd>
<dt>indexBuffer </dt>
<dd><p class="startdd"></p>
<p class="interdd">The index buffer which is used to source the indexes.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="Creating-an-Index-Buffer"></a></p>
<h2><a class="anchor" id="autotoc_md243"></a>
Creating an Index Buffer</h2>
<p>Index buffers are created using See <a class="el" href="_hardware-_buffers.html#The-Hardware-Buffer-Manager">The Hardware Buffer Manager</a> just like vertex buffers, hereâ€™s how:</p>
<div class="fragment"><div class="line">HardwareIndexBufferPtr ibuf = <a class="code hl_function" href="class_ogre_1_1_hardware_buffer_manager.html#a90c028c2ce1ec1364627cb0faca2320e">Ogre::HardwareBufferManager::getSingleton</a>().</div>
<div class="line">    createIndexBuffer(</div>
<div class="line">        HardwareIndexBuffer::IT_16BIT, <span class="comment">// type of index</span></div>
<div class="line">        numIndexes, <span class="comment">// number of indexes</span></div>
<div class="line">        <a class="code hl_enumvalue" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532ad4ea5a32caed7bbb643f6536606dba64">Ogre::HBU_GPU_ONLY</a>, <span class="comment">// usage</span></div>
<div class="line">        <span class="keyword">false</span>); <span class="comment">// no shadow buffer </span></div>
</div><!-- fragment --><p>Once again, notice that the return type is a class rather than a pointer; this is reference counted so that the buffer is automatically destroyed when no more references are made to it. The parameters to the index buffer creation are:</p>
<dl compact="compact">
<dt>indexType </dt>
<dd><p class="startdd"></p>
<p class="interdd">There are 2 types of index; 16-bit and 32-bit. They both perform the same way, except that the latter can address larger vertex buffers. If your buffer includes more than 65526 vertices, then you will need to use 32-bit indexes. Note that you should only use 32-bit indexes when you need to, since they incur more overhead than 16-bit vertices, and are not supported on some older hardware.</p>
<p class="enddd"></p>
</dd>
<dt>numIndexes </dt>
<dd><p class="startdd"></p>
<p class="interdd">The number of indexes in the buffer. As with vertex buffers, you should consider whether you can use a shared index buffer which is used by multiple pieces of geometry, since there can be performance advantages to switching index buffers less often.</p>
<p class="enddd"></p>
</dd>
<dt>usage </dt>
<dd><p class="startdd"></p>
<p class="interdd">This tells the system how you intend to use the buffer. See <a class="el" href="_hardware-_buffers.html#Buffer-Usage">Buffer Usage</a></p>
<p class="enddd"></p>
</dd>
<dt>useShadowBuffer </dt>
<dd><p class="startdd"></p>
<p class="interdd">Tells the system whether you want this buffer backed by a system-memory copy. See <a class="el" href="_hardware-_buffers.html#Shadow-Buffers">Shadow Buffers</a></p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="Updating-Index-Buffers"></a>
Updating Index Buffers</h2>
<p>Updating index buffers can only be done when you <a class="el" href="_hardware-_buffers.html#Locking-buffers">lock the buffer</a> for writing; Locking returns a void pointer, which must be cast to the appropriate type; with index buffers this is either an <code>uint16</code> (for 16-bit indexes) or an <code>uint32</code> (for 32-bit indexes). For example:</p>
<div class="fragment"><div class="line">uint16* pIdx = <span class="keyword">static_cast&lt;</span>uint16*<span class="keyword">&gt;</span>(ibuf-&gt;lock(<a class="code hl_enumvalue" href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5a176ad39ac15fc0a6028d820a6fe228ae">Ogre::HardwareBuffer::HBL_DISCARD</a>));</div>
<div class="ttc" id="aclass_ogre_1_1_hardware_buffer_html_afa30cb566683a34a7c0e8aaf772553d5a176ad39ac15fc0a6028d820a6fe228ae"><div class="ttname"><a href="class_ogre_1_1_hardware_buffer.html#afa30cb566683a34a7c0e8aaf772553d5a176ad39ac15fc0a6028d820a6fe228ae">Ogre::HardwareBuffer::HBL_DISCARD</a></div><div class="ttdeci">@ HBL_DISCARD</div><div class="ttdoc">Discards the entire buffer while locking.</div><div class="ttdef"><b>Definition</b> OgreHardwareBuffer.h:154</div></div>
</div><!-- fragment --><p>You can then write to the buffer using the usual pointer semantics, just remember to unlock the buffer when youâ€™re finished!</p>
<h1><a class="anchor" id="Hardware-Pixel-Buffers"></a>
Hardware Pixel Buffers</h1>
<p>Hardware Pixel Buffers are a special kind of buffer that stores graphical data in graphics card memory, generally for use as textures. Pixel buffers can represent a one dimensional, two dimensional or three dimensional image. A texture can consist of a multiple of these buffers.</p>
<p>In contrary to vertex and index buffers, pixel buffers are not constructed directly. When creating <a class="el" href="_hardware-_buffers.html#Textures">Textures</a>, the necessary pixel buffers to hold the data are constructed automatically.</p>
<h2><a class="anchor" id="Pixel-boxes"></a>
Pixel boxes</h2>
<p>All methods in <a class="el" href="namespace_ogre.html">Ogre</a> that take or return raw image data return a <a class="el" href="class_ogre_1_1_pixel_box.html" title="A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory.">Ogre::PixelBox</a> object.</p>
<p>A PixelBox is a primitive describing a volume (3D), image (2D) or line (1D) of pixels in CPU memory. It describes the location and data format of a region of memory used for image data, but does not do any memory management in itself.</p>
<p>Inside the memory pointed to by the <em>data</em> member of a pixel box, pixels are stored as a succession of "depth" slices (in Z), each containing "height" rows (Y) of "width" pixels (X).</p>
<p>Dimensions that are not used must be 1. For example, a one dimensional image will have extents (width,1,1). A two dimensional image has extents (width,height,1).</p>
<h2><a class="anchor" id="Updating-Pixel-Buffers"></a>
Updating Pixel Buffers</h2>
<p>Pixel Buffers can be updated in two different ways; a simple, convenient way and a more difficult (but in some cases faster) method. Both methods make use of <a class="el" href="class_ogre_1_1_pixel_box.html" title="A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory.">Ogre::PixelBox</a> objects to represent image data in memory.</p>
<h3><a class="anchor" id="blitFromMemory"></a>
Blit from memory</h3>
<p>The easy method to get an image into a PixelBuffer is by using <a class="el" href="class_ogre_1_1_hardware_pixel_buffer.html#ae12e40bc3a6461d93b7bfae20e58c866" title="Copies a region from normal memory to a region of this pixelbuffer.">Ogre::HardwarePixelBuffer::blitFromMemory</a>. This takes a PixelBox object and does all necessary pixel format conversion and scaling for you. For example, to create a manual texture and load an image into it, all you have to do is</p>
<div class="fragment"><div class="line"><span class="comment">// Manually loads an image and puts the contents in a manually created texture</span></div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_image.html">Ogre::Image</a> img;</div>
<div class="line">img.<a class="code hl_function" href="class_ogre_1_1_image.html#a5312a67dfaeb1716ae9ab72c1af766cb">load</a>(<span class="stringliteral">&quot;elephant.png&quot;</span>, <span class="stringliteral">&quot;General&quot;</span>);</div>
<div class="line"><span class="comment">// Create RGB texture with 5 mipmaps</span></div>
<div class="line">TexturePtr tex = <a class="code hl_function" href="class_ogre_1_1_texture_manager.html#a8faa10c9150687d1bf229ccff16a8960">Ogre::TextureManager::getSingleton</a>().createManual(</div>
<div class="line">    <span class="stringliteral">&quot;elephant&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;General&quot;</span>,</div>
<div class="line">    <a class="code hl_enumvalue" href="group___resources.html#ggaac3431531c3258e3c1c86ef8a4c06228af1f732018f5a2a7d35233e2ceeb4ee0e">Ogre::TEX_TYPE_2D</a>,</div>
<div class="line">    img.<a class="code hl_function" href="class_ogre_1_1_image.html#a649d36eb8288161540d223b7106b7d67">getWidth</a>(), img.<a class="code hl_function" href="class_ogre_1_1_image.html#a064e61e5225c5405d838e2e96a45beed">getHeight</a>(),</div>
<div class="line">    5, <a class="code hl_enumvalue" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2542d39f6712cb6f69907330a31a9342">Ogre::PF_X8R8G8B8</a>);</div>
<div class="line"><span class="comment">// Copy face 0 mipmap 0 of the image to face 0 mipmap 0 of the texture.</span></div>
<div class="line">tex-&gt;getBuffer(0,0)-&gt;blitFromMemory(img.<a class="code hl_function" href="class_ogre_1_1_image.html#af65aa7216f9f9ecce4158ffd20b9cea6">getPixelBox</a>(0,0));</div>
<div class="ttc" id="aclass_ogre_1_1_image_html"><div class="ttname"><a href="class_ogre_1_1_image.html">Ogre::Image</a></div><div class="ttdoc">Class representing an image file.</div><div class="ttdef"><b>Definition</b> OgreImage.h:61</div></div>
<div class="ttc" id="aclass_ogre_1_1_image_html_a064e61e5225c5405d838e2e96a45beed"><div class="ttname"><a href="class_ogre_1_1_image.html#a064e61e5225c5405d838e2e96a45beed">Ogre::Image::getHeight</a></div><div class="ttdeci">uint32 getHeight(void) const</div><div class="ttdoc">Gets the height of the image in pixels.</div><div class="ttdef"><b>Definition</b> OgreImage.h:369</div></div>
<div class="ttc" id="aclass_ogre_1_1_image_html_a5312a67dfaeb1716ae9ab72c1af766cb"><div class="ttname"><a href="class_ogre_1_1_image.html#a5312a67dfaeb1716ae9ab72c1af766cb">Ogre::Image::load</a></div><div class="ttdeci">Image &amp; load(const String &amp;filename, const String &amp;groupName)</div><div class="ttdoc">Loads an image file.</div></div>
<div class="ttc" id="aclass_ogre_1_1_image_html_a649d36eb8288161540d223b7106b7d67"><div class="ttname"><a href="class_ogre_1_1_image.html#a649d36eb8288161540d223b7106b7d67">Ogre::Image::getWidth</a></div><div class="ttdeci">uint32 getWidth(void) const</div><div class="ttdoc">Gets the width of the image in pixels.</div><div class="ttdef"><b>Definition</b> OgreImage.h:365</div></div>
<div class="ttc" id="aclass_ogre_1_1_image_html_af65aa7216f9f9ecce4158ffd20b9cea6"><div class="ttname"><a href="class_ogre_1_1_image.html#af65aa7216f9f9ecce4158ffd20b9cea6">Ogre::Image::getPixelBox</a></div><div class="ttdeci">PixelBox getPixelBox(uint32 face=0, uint32 mipmap=0) const</div><div class="ttdoc">Get a PixelBox encapsulating the image data of a mipmap.</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_manager_html_a8faa10c9150687d1bf229ccff16a8960"><div class="ttname"><a href="class_ogre_1_1_texture_manager.html#a8faa10c9150687d1bf229ccff16a8960">Ogre::TextureManager::getSingleton</a></div><div class="ttdeci">static TextureManager &amp; getSingleton(void)</div><div class="ttdoc">Get the singleton instance.</div></div>
<div class="ttc" id="agroup___image_html_gga7e0353e7d36d4c2e8468641b7303d39ca2542d39f6712cb6f69907330a31a9342"><div class="ttname"><a href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2542d39f6712cb6f69907330a31a9342">Ogre::PF_X8R8G8B8</a></div><div class="ttdeci">@ PF_X8R8G8B8</div><div class="ttdoc">32-bit pixel format, 8 bits for red, 8 bits for green, 8 bits for blue like Ogre::PF_A8R8G8B8,...</div><div class="ttdef"><b>Definition</b> OgrePixelFormat.h:111</div></div>
<div class="ttc" id="agroup___resources_html_ggaac3431531c3258e3c1c86ef8a4c06228af1f732018f5a2a7d35233e2ceeb4ee0e"><div class="ttname"><a href="group___resources.html#ggaac3431531c3258e3c1c86ef8a4c06228af1f732018f5a2a7d35233e2ceeb4ee0e">Ogre::TEX_TYPE_2D</a></div><div class="ttdeci">@ TEX_TYPE_2D</div><div class="ttdoc">2D texture, used in combination with 2D texture coordinates (default)</div><div class="ttdef"><b>Definition</b> OgreTexture.h:105</div></div>
</div><!-- fragment --><h3><a class="anchor" id="Direct-memory-locking"></a>
Direct memory locking</h3>
<p>A more advanced method to transfer image data from and to a PixelBuffer is to use locking. By locking a PixelBuffer you can directly access its contents in whatever the internal format of the buffer inside the GPU is.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">buffer-&gt;lock(HardwareBuffer::HBL_DISCARD);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="class_ogre_1_1_pixel_box.html">Ogre::PixelBox</a> &amp;pb = buffer-&gt;getCurrentLock();</div>
<div class="line"> </div>
<div class="line">uint32 *data = <span class="keyword">static_cast&lt;</span>uint32*<span class="keyword">&gt;</span>(pb.<a class="code hl_variable" href="class_ogre_1_1_pixel_box.html#a59624c7c33ade5365428473a1f3dc85a">data</a>);</div>
<div class="line"><span class="keywordtype">size_t</span> height = pb.<a class="code hl_function" href="struct_ogre_1_1_box.html#a352d26dea0069f2e7f1414e8caa2328c">getHeight</a>();</div>
<div class="line"><span class="keywordtype">size_t</span> width = pb.<a class="code hl_function" href="struct_ogre_1_1_box.html#a5499449ff454ff98aaa697f8854376fc">getWidth</a>();</div>
<div class="line"><span class="keywordtype">size_t</span> pitch = pb.<a class="code hl_variable" href="class_ogre_1_1_pixel_box.html#aacf8f1ebed40c557389d9d1e9dda3b68">rowPitch</a>; <span class="comment">// Skip between rows of image</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> y=0; y&lt;height; ++y)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> x=0; x&lt;width; ++x)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// 0xRRGGBB -&gt; fill the buffer with yellow pixels</span></div>
<div class="line">        data[pitch*y + x] = 0x00FFFF00;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">buffer-&gt;unlock();</div>
<div class="ttc" id="aclass_ogre_1_1_pixel_box_html"><div class="ttname"><a href="class_ogre_1_1_pixel_box.html">Ogre::PixelBox</a></div><div class="ttdoc">A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory.</div><div class="ttdef"><b>Definition</b> OgrePixelFormat.h:349</div></div>
<div class="ttc" id="aclass_ogre_1_1_pixel_box_html_a59624c7c33ade5365428473a1f3dc85a"><div class="ttname"><a href="class_ogre_1_1_pixel_box.html#a59624c7c33ade5365428473a1f3dc85a">Ogre::PixelBox::data</a></div><div class="ttdeci">uchar * data</div><div class="ttdoc">The data pointer.</div><div class="ttdef"><b>Definition</b> OgrePixelFormat.h:383</div></div>
<div class="ttc" id="aclass_ogre_1_1_pixel_box_html_aacf8f1ebed40c557389d9d1e9dda3b68"><div class="ttname"><a href="class_ogre_1_1_pixel_box.html#aacf8f1ebed40c557389d9d1e9dda3b68">Ogre::PixelBox::rowPitch</a></div><div class="ttdeci">size_t rowPitch</div><div class="ttdoc">Number of elements between the leftmost pixel of one row and the left pixel of the next.</div><div class="ttdef"><b>Definition</b> OgrePixelFormat.h:388</div></div>
<div class="ttc" id="astruct_ogre_1_1_box_html_a352d26dea0069f2e7f1414e8caa2328c"><div class="ttname"><a href="struct_ogre_1_1_box.html#a352d26dea0069f2e7f1414e8caa2328c">Ogre::Box::getHeight</a></div><div class="ttdeci">uint32 getHeight() const</div><div class="ttdoc">Get the height of this box.</div><div class="ttdef"><b>Definition</b> OgreCommon.h:567</div></div>
<div class="ttc" id="astruct_ogre_1_1_box_html_a5499449ff454ff98aaa697f8854376fc"><div class="ttname"><a href="struct_ogre_1_1_box.html#a5499449ff454ff98aaa697f8854376fc">Ogre::Box::getWidth</a></div><div class="ttdeci">uint32 getWidth() const</div><div class="ttdoc">Get the width of this box.</div><div class="ttdef"><b>Definition</b> OgreCommon.h:565</div></div>
</div><!-- fragment --><h1><a class="anchor" id="Textures"></a>
Textures</h1>
<p>A texture is an image that can be applied onto the surface of a three dimensional model. In Ogre, textures are represented by the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Ogre::Texture</a> resource class.</p>
<h2><a class="anchor" id="Creating-a-texture"></a>
Creating a texture</h2>
<p>Textures are created through the TextureManager. In most cases they are created from image files directly by the <a class="el" href="namespace_ogre.html">Ogre</a> resource system. If you are reading this, you most probably want to create a texture manually so that you can provide it with image data yourself. This is done through <a class="el" href="class_ogre_1_1_texture_manager.html#aafa494d2704fdff05708db9db4bac3a0" title="Create a manual texture with specified width, height and depth (not loaded from a file).">Ogre::TextureManager::createManual</a>:</p>
<div class="fragment"><div class="line">tex = <a class="code hl_function" href="class_ogre_1_1_texture_manager.html#a8faa10c9150687d1bf229ccff16a8960">Ogre::TextureManager::getSingleton</a>().createManual(</div>
<div class="line">    <span class="stringliteral">&quot;MyManualTexture&quot;</span>, <span class="comment">// Name of texture</span></div>
<div class="line">    <span class="stringliteral">&quot;General&quot;</span>, <span class="comment">// Name of resource group in which the texture should be created</span></div>
<div class="line">    TEX_TYPE_2D, <span class="comment">// Texture type</span></div>
<div class="line">    256, <span class="comment">// Width</span></div>
<div class="line">    256, <span class="comment">// Height</span></div>
<div class="line">    1, <span class="comment">// Depth (Must be 1 for two dimensional textures)</span></div>
<div class="line">    0, <span class="comment">// No mipmaps</span></div>
<div class="line">    PF_A8R8G8B8, <span class="comment">// internal Pixel format hint</span></div>
<div class="line">    HBU_GPU_ONLY | TU_AUTOMIPMAP <span class="comment">// usage</span></div>
<div class="line">);</div>
</div><!-- fragment --><p>This example creates a texture named <em>MyManualTexture</em> in resource group <em>General</em>. It is a square <em>two dimensional</em> texture, with width 256 and height 256.</p>
<p>The available texture types are specified in <a class="el" href="group___resources.html#gaac3431531c3258e3c1c86ef8a4c06228" title="Enum identifying the texture type.">Ogre::TextureType</a>. Pixel formats are summarised in <a class="el" href="_hardware-_buffers.html#Pixel-Formats">Pixel Formats</a>. </p><dl class="section note"><dt>Note</dt><dd>The format specified here is only a hint. If the hardware does not support the requested format, you will get the closest supported alternative format as returned by <a class="el" href="class_ogre_1_1_texture_manager.html#abdb6dabaecc1bcf27ce9906f85b64235" title="Gets the format which will be natively used for a requested format given the constraints of the curre...">Ogre::TextureManager::getNativeFormat</a>.</dd></dl>
<p>In addition to the hardware buffer usages as described in <a class="el" href="group___render_system.html#ga3e7bd12438696e8c75150be1fbe90532" title="Enums describing buffer usage.">Ogre::HardwareBufferUsage</a> there are some usage flags specific to textures defined in <a class="el" href="group___resources.html#gaf140ec886884a864abc74a7556f8bf67" title="Enum identifying the texture usage.">Ogre::TextureUsage</a>.</p>
<h2><a class="anchor" id="Getting-a-PixelBuffer"></a>
Getting a PixelBuffer</h2>
<p>A Texture can consist of multiple <a class="el" href="_hardware-_buffers.html#Hardware-Pixel-Buffers">Hardware Pixel Buffers</a>, one for each combo if mipmap level and face number. To get a PixelBuffer from a Texture object the method <a class="el" href="class_ogre_1_1_texture.html#a0e27aa7d2f734ff39d706e7ff6577cf9" title="Return hardware pixel buffer for a surface.">Ogre::Texture::getBuffer</a> is used:</p>
<p><code>face</code> should be zero for non-cubemap textures. For <a class="el" href="_hardware-_buffers.html#Cube-map-textures">Cube map textures</a> it identifies which one of the cube faces to use.</p>
<p><code>mipmap</code> is zero for the zeroth mipmap level, one for the first mipmap level, and so on. On textures that have automatic mipmap generation (<code>TU_AUTOMIPMAP</code>) only level 0 should be accessed, the rest will be taken care of by the rendering API.</p>
<p>A simple example of using getBuffer is</p>
<div class="fragment"><div class="line"><span class="comment">// Get the PixelBuffer for face 0, mipmap 0.</span></div>
<div class="line">HardwarePixelBufferSharedPtr ptr = tex-&gt;getBuffer(0,0);</div>
</div><!-- fragment --><h2><a class="anchor" id="Cube-map-textures"></a>
Cube map textures</h2>
<p>The cube map texture type (<a class="el" href="group___resources.html#ggaac3431531c3258e3c1c86ef8a4c06228ae295fe0fa26623b66cc023f462962344" title="cube map (six two dimensional textures, one for each cube face), used in combination with 3D texture ...">Ogre::TEX_TYPE_CUBE_MAP</a>) is a different beast from the others; a cube map texture represents a series of six two dimensional images addressed by 3D texture coordinates.</p>
<dl class="section user"><dt>+X (face 0)</dt><dd>Represents the positive x plane (right).</dd></dl>
<dl class="section user"><dt>-X (face 1)</dt><dd>Represents the negative x plane (left).</dd></dl>
<dl class="section user"><dt>+Y (face 2)</dt><dd>Represents the positive y plane (top).</dd></dl>
<dl class="section user"><dt>-Y (face 3)</dt><dd>Represents the negative y plane (bottom).</dd></dl>
<dl class="section user"><dt>+Z (face 4)</dt><dd>Represents the positive z plane (front).</dd></dl>
<dl class="section user"><dt>-Z (face 5)</dt><dd>Represents the negative z plane (back).</dd></dl>
<h2><a class="anchor" id="Pixel-Formats"></a>
Pixel Formats</h2>
<p>A pixel format described the storage format of pixel data. It defines the way pixels are encoded in memory. The components are specified in "packed" native byte order for native endian (16, 24 and 32 bit) integers. This means that a pixel with format <a class="el" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca0d5c9bdb0633c1849758fea566a2b754" title="32-bit pixel format, 8 bits for alpha, red, green and blue.">Ogre::PF_A8R8G8B8</a> can be seen as a 32 bit integer, written as <code>0xAARRGGBB</code> in hexadecimal on a little-endian (x86) machine or as <code>0xBBGGRRAA</code> on a big-endian machine. The example above would be expressed with an array of bytes as <code>{0xBB, 0xGG, 0xRR, 0xAA}</code> on both machines. Therefore, one would use the <a class="el" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca8048c85373860a1893d237ac89d3712f" title="32-bit pixel format, 8 bits for blue, green, red and alpha.">Ogre::PF_BYTE_BGRA</a> format when reading pixel data expressed in bytes. This format aliases to either <a class="el" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39cabedff220dc4f3ed679bf246c14ce3df6" title="32-bit pixel format, 8 bits for blue, green, red and alpha.">Ogre::PF_A8B8G8R8</a> or <a class="el" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca74ea3b1c0c5f4ae06b1a7136c5523eca" title="32-bit pixel format, 8 bits for red, green, blue and alpha.">Ogre::PF_R8G8B8A8</a> depending on the machine endianness.  </p>
<p>A pixel format described the storage format of pixel data. It defines the way pixels are encoded in memory. The following classes of pixel formats (PF_*) are defined:</p>
<dl class="section user"><dt>Native endian formats (PF_A8R8G8B8 and other formats with bit counts)</dt><dd>These are native endian (16, 24 and 32 bit) integers in memory. The meaning of the letters is described below.</dd></dl>
<dl class="section user"><dt>Byte formats (PF_BYTE_*)</dt><dd>These formats have one byte per channel, and their channels in memory are organized in the order they are specified in the format name. For example, PF_BYTE_RGBA consists of blocks of four bytes, one for red, one for green, one for blue, one for alpha.</dd></dl>
<dl class="section user"><dt>Short formats (PF_SHORT_*)</dt><dd>These formats have one unsigned short (16 bit integer) per channel, and their channels in memory are organized in the order they are specified in the format name. For example, PF_SHORT_RGBA consists of blocks of four 16 bit integers, one for red, one for green, one for blue, one for alpha.</dd></dl>
<dl class="section user"><dt>Float16 formats (PF_FLOAT16_*)</dt><dd>These formats have one 16 bit floating point number per channel, and their channels in memory are organized in the order they are specified in the format name. For example, PF_FLOAT16_RGBA consists of blocks of four 16 bit floats, one for red, one for green, one for blue, one for alpha. The 16 bit floats, also called half float) are very similar to the IEEE single-precision floating-point standard of the 32 bits floats, except that they have only 5 exponent bits and 10 mantissa. Note that there is no standard C++ data type or CPU support to work with these efficiently, but GPUs can calculate with these much more efficiently than with 32 bit floats.</dd></dl>
<dl class="section user"><dt>Float32 formats (PF_FLOAT32_*)</dt><dd>These formats have one 32 bit floating point number per channel, and their channels in memory are organized in the order they are specified in the format name. For example, PF_FLOAT32_RGBA consists of blocks of four 32 bit floats, one for red, one for green, one for blue, one for alpha. The C++ data type for these 32 bits floats is just "float".</dd></dl>
<dl class="section user"><dt>Compressed formats (PF_DXT[1-5])</dt><dd>S3TC compressed texture formats, <a href="http://en.wikipedia.org/wiki/S3TC">a good description can be found at Wikipedia</a></dd></dl>
<p>For a complete list see <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c" title="The pixel format used for images, textures, and render surfaces.">Ogre::PixelFormat</a>.</p>
<h3><a class="anchor" id="Colour-channels"></a>
Colour channels</h3>
<p>The meaning of the channels R,G,B,A,L and X is defined as</p>
<dl class="section user"><dt>R</dt><dd>Red colour component, usually ranging from 0.0 (no red) to 1.0 (full red).</dd></dl>
<dl class="section user"><dt>G</dt><dd>Green colour component, usually ranging from 0.0 (no green) to 1.0 (full green).</dd></dl>
<dl class="section user"><dt>B</dt><dd>Blue colour component, usually ranging from 0.0 (no blue) to 1.0 (full blue).</dd></dl>
<dl class="section user"><dt>A</dt><dd>Alpha component, usually ranging from 0.0 (entire transparent) to 1.0 (opaque).</dd></dl>
<dl class="section user"><dt>L</dt><dd>Luminance component, usually ranging from 0.0 (black) to 1.0 (white). The luminance component is duplicated in the R, G, and B channels to achieve a greyscale image.</dd></dl>
<dl class="section user"><dt>X</dt><dd>This component is completely ignored.</dd></dl>
<p>If none of red, green and blue components, or luminance is defined in a format, these default to 0. For the alpha channel this is different; if no alpha is defined, it defaults to 1. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
