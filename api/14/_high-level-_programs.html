<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: GPU Program Scripts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_high-level-_programs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">GPU Program Scripts</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Default-Program-Parameters">Default Program Parameters</a></li>
<li class="level1"><a href="#autotoc_md188">High Level Programs</a><ul><li class="level2"><a href="#Preprocessor-definitions">Preprocessor definitions</a></li>
<li class="level2"><a href="#autotoc_md189">Entry Point</a></li>
</ul>
</li>
<li class="level1"><a href="#GLSL">GLSL programs</a><ul><li class="level2"><a href="#Binding-vertex-attributes">Binding vertex attributes</a></li>
<li class="level2"><a href="#GLSL-Mesh-Shaders">Buffers in Mesh Shaders</a></li>
<li class="level2"><a href="#GLSL-Texture-Samplers">Binding Texture Samplers</a></li>
<li class="level2"><a href="#Matrix-parameters">Matrix parameters</a></li>
<li class="level2"><a href="#Uniform-Buffers">Uniform Buffers</a></li>
<li class="level2"><a href="#Transform-Feedback-Varyings">Transform Feedback Varyings</a></li>
<li class="level2"><a href="#Legacy-GLSL-features">Compatibility profile GLSL features</a><ul><li class="level3"><a href="#autotoc_md190">OpenGL state</a></li>
<li class="level3"><a href="#autotoc_md191">Built-in attributes</a></li>
<li class="level3"><a href="#autotoc_md192">Geometry shader in/ out</a></li>
<li class="level3"><a href="#autotoc_md193">Multi module shaders</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Cg">Cg programs</a></li>
<li class="level1"><a href="#HLSL">DirectX HLSL</a></li>
<li class="level1"><a href="#Assembler-Shaders">Assembler Shaders</a><ul><li class="level2"><a href="#Specifying-Named-Constants-for-Assembler-Shaders">Specifying Named Constants</a></li>
</ul>
</li>
<li class="level1"><a href="#multi-language-programs">Multi-language Programs</a></li>
<li class="level1"><a href="#Unified-High_002dlevel-Programs">Unified High-level Programs</a></li>
<li class="level1"><a href="#Program-Parameter-Specification">Parameter specification</a><ul><li class="level2"><a href="#autotoc_md194">param_indexed</a></li>
<li class="level2"><a href="#autotoc_md195">param_indexed_auto</a></li>
<li class="level2"><a href="#autotoc_md196">param_named</a></li>
<li class="level2"><a href="#autotoc_md197">param_named_auto</a></li>
<li class="level2"><a href="#autotoc_md198">shared_params_ref</a></li>
</ul>
</li>
<li class="level1"><a href="#Declaring-Shared-Parameters">Declaring Shared Parameters</a><ul><li class="level2"><a href="#autotoc_md199">Hardware Support</a></li>
</ul>
</li>
<li class="level1"><a href="#Shadows-and-Vertex-Programs">Shadows and Vertex Programs</a></li>
<li class="level1"><a href="#Instancing-in-Vertex-Programs">Instancing in Vertex Programs</a></li>
<li class="level1"><a href="#Skeletal-Animation-in-Vertex-Programs">Skeletal Animation in Vertex Programs</a></li>
<li class="level1"><a href="#Morph-Animation-in-Vertex-Programs">Morph Animation in Vertex Programs</a></li>
<li class="level1"><a href="#Pose-Animation-in-Vertex-Programs">Pose Animation in Vertex Programs</a></li>
<li class="level1"><a href="#Vertex-Texture-Fetch">Vertex Texture Fetch</a><ul><li class="level2"><a href="#autotoc_md200">Declaring the use of vertex texture fetching</a></li>
<li class="level2"><a href="#autotoc_md201">DirectX9 binding limitations</a></li>
<li class="level2"><a href="#autotoc_md202">Texture format limitations</a></li>
<li class="level2"><a href="#autotoc_md203">Hardware limitations</a></li>
</ul>
</li>
<li class="level1"><a href="#GpuProgram-API">Programmatic creation</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="Declaring-Vertex_002fGeometry_002fFragment-Programs"></a></p>
<p>In order <a class="el" href="_material-_scripts.html#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass">to use a vertex, geometry or fragment program in your materials</a>, you first have to define them. A single program definition can be used by any number of materials, the only prerequisite is that a program must be defined before being referenced in the pass section of a material.</p>
<p>The definition of a program can either be embedded in the .material script itself (in which case it must precede any references to it in the script), or if you wish to use the same program across multiple .material files, you can define it in an external .program script. You define the program in exactly the same way whether you use a .program script or a .material script, the only difference is that all .program scripts are guaranteed to have been parsed before <b>all</b> .material scripts, so you can guarantee that your program has been defined before any .material script that might use it. Just like .material scripts, .program scripts will be read from any location which is on your resource path, and you can define many programs in a single script.</p>
<p>Vertex, geometry and fragment programs can be low-level (i.e. assembler code written to the specification of a given low level syntax such as vs_1_1 or arbfp1) or high-level such as DirectX HLSL and OpenGL GLSL. High level languages give you a number of advantages, such as being able to write more intuitive code, and possibly being able to target multiple architectures in a single program (for example, the same Cg program might be able to be used in both D3D and GL, whilst the equivalent low-level programs would require separate techniques, each targeting a different API). High-level programs also allow you to use named parameters instead of simply indexed ones, although parameters are not defined here, they are used in the Pass.</p>
<p>Here is an example of a definition of a low-level vertex program:</p>
<div class="fragment"><div class="line">vertex_program myVertexProgram spirv</div>
<div class="line">{</div>
<div class="line">    source myVertexProgram.spv</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you can see, thatâ€™s very simple, and defining a fragment or geometry program is exactly the same, just with <code>vertex_program</code> replaced with <code>fragment_program</code> or <code>geometry_program</code>, respectively. Likewise, for tessellation and compute programs, use <code>tessellation_hull_program</code>, <code>tessellation_domain_program</code>, and <code>compute_program</code>.</p>
<p>You give the program a name in the header, followed by the word <code>spirv</code> to indicate the syntax being used. Inside the braces, you specify where the source is going to come from (and this is loaded from any of the resource locations as with other media). The syntax specification is necessary for the engine to know what syntax the program is in before reading it. During the compilation of the material, it is important to quickly skip programs that use unsupported syntax to avoid loading the program first.</p>
<h1><a class="anchor" id="Default-Program-Parameters"></a>
Default Program Parameters</h1>
<p>While defining a vertex, geometry or fragment program, you can also specify the default parameters to be used for materials which use it, unless they specifically override them. You do this by including a nested â€™default_paramsâ€™ section, like so:</p>
<div class="fragment"><div class="line">vertex_program <a class="code hl_namespace" href="namespace_ogre.html">Ogre</a>/CelShadingVPGLSL glsl</div>
<div class="line">{</div>
<div class="line">    source Example_CelShadingVp.glsl</div>
<div class="line">    syntax glsl150</div>
<div class="line"> </div>
<div class="line">    default_params</div>
<div class="line">    {</div>
<div class="line">        param_named_auto lightPosition light_position_object_space 0</div>
<div class="line">        param_named_auto eyePosition camera_position_object_space</div>
<div class="line">        param_named_auto worldViewProj worldviewproj_matrix</div>
<div class="line">        param_named shininess <span class="keywordtype">float</span> 10 </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_ogre_html"><div class="ttname"><a href="namespace_ogre.html">Ogre</a></div><div class="ttdef"><b>Definition</b> OgreAlignedAllocator.h:34</div></div>
</div><!-- fragment --><p>The syntax of the parameter definition is exactly the same as when you define parameters when using programs, See <a class="el" href="_high-level-_programs.html#Program-Parameter-Specification">Parameter specification</a>. Defining default parameters allows you to avoid rebinding common parameters repeatedly (clearly in the above example, all but â€™shininessâ€™ are unlikely to change between uses of the program) which makes your material declarations shorter.</p>
<h1><a class="anchor" id="autotoc_md188"></a>
High Level Programs</h1>
<p>Support for high level vertex and fragment programs is provided through plugins; this is to make sure that an application using OGRE can use as little or as much of the high-level program functionality as they like. OGRE supports multiple high-level program types. Notably DirectX <a class="el" href="_high-level-_programs.html#HLSL">HLSL</a>, and OpenGL <a class="el" href="_high-level-_programs.html#GLSL">GLSL</a>. HLSL can only be used with the DirectX rendersystem, and GLSL can only be used with the GL and Vulkan rendersystems.</p>
<p>One way to support both HLSL and GLSL is to include separate techniques in the material script, each one referencing separate programs. However, if the programs are basically the same, with the same parameters, and the techniques are complex this can bloat your material scripts with duplication fairly quickly. Instead, if the only difference is the language of the vertex &amp; fragment program you can use OGREâ€™s <a class="el" href="_high-level-_programs.html#Unified-High_002dlevel-Programs">Unified High-level Programs</a> to automatically pick a program suitable for your rendersystem whilst using a single technique.</p>
<p>There is also <a class="el" href="_high-level-_programs.html#Cg">Cg</a> which is deprecated, but allows to use the same Shader code across different APIs - although experience has shown that more advanced programs, particularly fragment programs which perform a lot of texture fetches, can produce better code in the rendersystem-specific shader language. The better alternative to Cg is to use <a class="el" href="_high-level-_programs.html#multi-language-programs">Multi-language Programs</a> with <code>OgreUnifiedShader.h</code>. This achieves the same goal as Cg, but uses only a few straightforward preprocessor macros.</p>
<h2><a class="anchor" id="Preprocessor-definitions"></a>
Preprocessor definitions</h2>
<p>Both GLSL and HLSL support using preprocessor definitions in your code - some are defined by the implementation, but you can also define your own, say in order to use the same source code for a few different variants of the same technique. In order to use this feature, include preprocessor conditions in your code, of the kind <code>#ifdef SYMBOL</code>, <code>#if SYMBOL==2</code> etc. Then in your program definition, use the <code>preprocessor_defines</code> option, following it with a string of definitions. Definitions are separated by <code>;</code> or <code>,</code> and may optionally have a <code>=</code> operator within them to specify a definition value. Those without an <code>=</code> will implicitly have a definition of 1.</p>
<dl class="section user"><dt></dt><dd>Format: preprocessor_defines &lt;defines&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: preprocessor_defines CLEVERTECHNIQUE,NUMTHINGS=2</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// in your shader</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef CLEVERTECHNIQUE</span></div>
<div class="line">    <span class="comment">// some clever stuff here</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    <span class="comment">// normal technique</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if NUM_THINGS==2</span></div>
<div class="line">    <span class="comment">// Some specific code</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    <span class="comment">// something else</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>This way you can use the same source code but still include small variations, each one defined as a different Ogre program name but based on the same source code.</p>
<dl class="section note"><dt>Note</dt><dd>on GLSL Ogre pre-processes the source itself instead on relying on the driver implementation which is often buggy. This relaxes using <code>#ifdef</code> directives compared to the standard - e.g. you can <code>#ifdef #version</code>. However this means that defines specified in GLSL extensions are not present.</dd></dl>
<h2><a class="anchor" id="autotoc_md189"></a>
Entry Point</h2>
<p>The parameter <code>entry_point</code>, specifies the name of a function which will be the first one called as part of the program. Unlike assembler programs, which just run top-to-bottom, high-level programs can include multiple functions and as such you must specify the one which start the ball rolling. If you omit this line, Ogre will default to looking for a function called <code>main</code>.</p>
<dl class="section user"><dt></dt><dd>Format: entry_point &lt;name&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: entry_point main_vp</dd></dl>
<dl class="section note"><dt>Note</dt><dd>on GLSL the <code>entry_point</code> is required to be <code>main</code></dd></dl>
<h1><a class="anchor" id="GLSL"></a>
GLSL programs</h1>
<p>GLSL is the native shading language of the OpenGL API and requires no plugins there. Additionally, you can use it with Vulkan by loading the <code>Plugin_GLSLangProgramManager</code>. Declaring a OpenGL GLSL program is similar to Cg but simpler. Hereâ€™s an example:</p>
<div class="fragment"><div class="line">vertex_program myGLSLVertexProgram glsl</div>
<div class="line">{</div>
<div class="line">    source myGLSLVertexProgram.vert</div>
<div class="line">}</div>
</div><!-- fragment --><p>The type <code>glsl</code> works with the GL and GL3+ RenderSystems, while with the GLES2 RenderSystem you must specify <code>glsles</code> instead. For Vulkan, you must specify <code>glslang</code> so the GLSLang Plugin is used. This also works with GL3+, in case you prefer not to use the GLSL compiler of your driver. If your shader is designed for this, you can also specify all of those at once. See <a class="el" href="_high-level-_programs.html#multi-language-programs">Multi-language Programs</a>.</p>
<p>In GLSL, no entry point needs to be defined since it is always <code>main()</code> and there is no target definition since GLSL source is compiled into native GPU code and not intermediate assembly.</p>
<p>For modularity Ogre supports the non-standard <code>#include &lt;something.glsl&gt;</code> directive in GLSL. It also works with OpenGL ES and resembles what is available with HLSL and Cg.</p>
<h2><a class="anchor" id="Binding-vertex-attributes"></a>
Binding vertex attributes</h2>
<p>Vertex attributes must be declared in the shader, for the vertex data bound to it by <a class="el" href="namespace_ogre.html">Ogre</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// GL2 compatible syntax; attribute data is bound by attribute name</span></div>
<div class="line">attribute vec4 vertex;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Attribute data bound by explicit location (requires GL3+)</span></div>
<div class="line">layout(location = 0) in vec4 vertex;</div>
</div><!-- fragment --><p>refer to the following table for the location indices and names to use:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantic   </th><th class="markdownTableHeadNone">Custom name   </th><th class="markdownTableHeadNone">Binding location   </th><th class="markdownTableHeadNone">Legacy OpenGL built-in    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655ad04d50e91c2ec5377e610b3f5b9b07f2" title="Position, typically VET_FLOAT3.">Ogre::VES_POSITION</a>   </td><td class="markdownTableBodyNone">vertex   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">gl_Vertex    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655a63d3494547f373f5c4397a41b39cf6a0" title="Blending weights.">Ogre::VES_BLEND_WEIGHTS</a>   </td><td class="markdownTableBodyNone">blendWeights   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">n/a    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655a1dec7d36a64625348e23af26c9231227" title="Normal, typically VET_FLOAT3.">Ogre::VES_NORMAL</a>   </td><td class="markdownTableBodyNone">normal   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">gl_Normal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655a370307b10c00d1459acc51f9a3ed1150" title="Colour, typically VET_UBYTE4.">Ogre::VES_COLOUR</a>   </td><td class="markdownTableBodyNone">colour   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">gl_Color    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655aa4e4ff3ea17d3098cfea6e97732dae55" title="Secondary colour. Generally free for custom data. Means specular with OpenGL FFP.">Ogre::VES_COLOUR2</a>   </td><td class="markdownTableBodyNone">secondary_colour   </td><td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">gl_SecondaryColor    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655ae54f94c9c9cf553d227c2aab2c499bbf" title="Blending indices.">Ogre::VES_BLEND_INDICES</a>   </td><td class="markdownTableBodyNone">blendIndices   </td><td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone">n/a    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655a17abb855311f3a67bc31414cad8d6212" title="Texture coordinates, typically VET_FLOAT2.">Ogre::VES_TEXTURE_COORDINATES</a>   </td><td class="markdownTableBodyNone">uv0 - uv7   </td><td class="markdownTableBodyNone">8-15   </td><td class="markdownTableBodyNone">gl_MultiTexCoord0 - gl_MultiTexCoord7    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655a57d43012049b3ec7b4240b207dd029f2" title="Tangent (X axis if normal is Z)">Ogre::VES_TANGENT</a>   </td><td class="markdownTableBodyNone">tangent   </td><td class="markdownTableBodyNone">14   </td><td class="markdownTableBodyNone">n/a    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655a2b06bd6ce4e2b9115ab122e35d86502f" title="Binormal (Y axis if normal is Z)">Ogre::VES_BINORMAL</a>   </td><td class="markdownTableBodyNone">binormal   </td><td class="markdownTableBodyNone">15   </td><td class="markdownTableBodyNone">n/a   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>uv6 and uv7 share attributes with tangent and binormal respectively so cannot both be present.</dd></dl>
<h2><a class="anchor" id="GLSL-Mesh-Shaders"></a>
Buffers in Mesh Shaders</h2>
<p>With mesh shaders the input assembly stage is skipped and hence the vertex attributes are not available. Instead, Ogre will bind the vertex buffers as SSBOs to a binding point defined by the <a class="el" href="class_ogre_1_1_vertex_buffer_binding.html" title="Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...">Ogre::VertexBufferBinding</a> index, offset by 3.</p>
<p>In the shader you can access the buffer as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// buffer at index 0, which is expected to contain float data</span></div>
<div class="line">layout(binding = 3) readonly buffer VertexDataIn</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> data[];</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="GLSL-Texture-Samplers"></a>
Binding Texture Samplers</h2>
<p>To bind samplers to texture unit indices from the material scripts, you can either use the explicit binding with GL4.2+ or set the sampler via a <code>int</code> type named parameter.</p>
<div class="fragment"><div class="line"><span class="comment">// Explicit binding location (requires OpenGL 4.2+)</span></div>
<div class="line">layout(binding = 0) uniform sampler2D diffuseMap;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compatible syntax; binding is managed via the material script</span></div>
<div class="line">uniform sampler2D diffuseMap;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>as we cannot detect the presence of explicit binding, you must add the <code>has_sampler_binding true</code> option to the program definition, so your locations are not overriden</dd></dl>
<p>Binding the sampler in material script is done as:</p>
<div class="fragment"><div class="line">material exampleGLSLTexturing</div>
<div class="line">{</div>
<div class="line">  technique</div>
<div class="line">  {</div>
<div class="line">    pass</div>
<div class="line">    {</div>
<div class="line">      fragment_program_ref myFragmentShader</div>
<div class="line">      {</div>
<div class="line">        param_named diffuseMap <span class="keywordtype">int</span> 0</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      texture_unit </div>
<div class="line">      {</div>
<div class="line">        texture myTexture.jpg 2d</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>An index value of 0 refers to the first texture unit in the pass, an index value of 1 refers to the second unit in the pass and so on.</p>
<h2><a class="anchor" id="Matrix-parameters"></a>
Matrix parameters</h2>
<p>Here are some examples of passing matrices to GLSL mat2, mat3, mat4 uniforms:</p>
<div class="fragment"><div class="line"><span class="comment">// mat4 uniform</span></div>
<div class="line">param_named OcclusionMatrix matrix4x4 1 0 0 0  0 1 0 0  0 0 1 0  0 0 0 0</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line">param_named ViewMatrix float16 0 1 0 0  0 0 1 0  0 0 0 1  0 0 0 0</div>
<div class="line"> </div>
<div class="line"><span class="comment">// mat3</span></div>
<div class="line">param_named TextRotMatrix float9 1 0 0  0 1 0  0 0 1</div>
<div class="line"> </div>
<div class="line"><span class="comment">// mat2 uniform</span></div>
<div class="line">param_named skewMatrix float4 0.5 0 -0.5 1.0</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>GLSL uses column-major storage by default, while Ogre is using row-major storage. Furthermore, GLSL is using column-major addressing, while Ogre and HLSL use row-major addressing. This means that <code>mat[0]</code> is the first column in GLSL, but the first row in HLSL and Ogre. Ogre takes care of transposing square matrices before uploading them with GLSL, so matrix-vector multiplication <code>M*v</code> just works and <code>mat[0]</code> will return the same data. However, with non-square matrices transposing would change their GLSL type from e.g. <code>mat2x4</code> (two columns, four rows) to <code>mat4x2</code> (two rows, four columns) and consequently what <code>mat[0]</code> would return. Therefore Ogre just passes such matrices unchanged and you have to handle this case (notably in skinning) yourself by either transposing the matrix in the shader or column-wise access.</dd></dl>
<h2><a class="anchor" id="Uniform-Buffers"></a>
Uniform Buffers</h2>
<p>If supported by the RenderSystem, you can opt-in to use uniform buffers for parameter storage. This is done by declaring the parameters in a uniform block named <code>OgreUniforms</code> </p>
<div class="fragment"><div class="line">layout(std140, row_major) uniform OgreUniforms</div>
<div class="line">{</div>
<div class="line">    mat4 worldTransform;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Transform-Feedback-Varyings"></a>
Transform Feedback Varyings</h2>
<p>Similarly to vertex attributes, the transform feedback varyings are bound by name. Only interleaved output to a single buffer is supported. The offsets are given by the <a class="el" href="class_ogre_1_1_vertex_declaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">Ogre::VertexDeclaration</a>. The available varyings are:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantic   </th><th class="markdownTableHeadNone">Varying name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655ad04d50e91c2ec5377e610b3f5b9b07f2" title="Position, typically VET_FLOAT3.">Ogre::VES_POSITION</a>   </td><td class="markdownTableBodyNone">xfb_position    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655a1dec7d36a64625348e23af26c9231227" title="Normal, typically VET_FLOAT3.">Ogre::VES_NORMAL</a>   </td><td class="markdownTableBodyNone">xfb_normal    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655a370307b10c00d1459acc51f9a3ed1150" title="Colour, typically VET_UBYTE4.">Ogre::VES_COLOUR</a>   </td><td class="markdownTableBodyNone">xfb_colour    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655aa4e4ff3ea17d3098cfea6e97732dae55" title="Secondary colour. Generally free for custom data. Means specular with OpenGL FFP.">Ogre::VES_COLOUR2</a>   </td><td class="markdownTableBodyNone">xfb_colour2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group___render_system.html#ggac7ecb5ad110f918f709b3c5d5cbae655a17abb855311f3a67bc31414cad8d6212" title="Texture coordinates, typically VET_FLOAT2.">Ogre::VES_TEXTURE_COORDINATES</a>   </td><td class="markdownTableBodyNone">xfb_uv0 - xfb_uv7   </td></tr>
</table>
<h2><a class="anchor" id="Legacy-GLSL-features"></a>
Compatibility profile GLSL features</h2>
<p>The following features are only available when using the legacy OpenGL profile. Notably they are not available with GL3+ or GLES2.</p>
<h3><a class="anchor" id="autotoc_md190"></a>
OpenGL state</h3>
<p>GLSL can access most of the GL states directly so you do not need to pass these states through <a class="el" href="_high-level-_programs.html#param_005fnamed_005fauto">param_named_auto</a> in the material script. This includes lights, material state, and all the matrices used in the openGL state i.e. model view matrix, worldview projection matrix etc.</p>
<h3><a class="anchor" id="autotoc_md191"></a>
Built-in attributes</h3>
<p>GLSL natively supports automatic binding of the most common incoming per-vertex attributes (e.g. <code>gl_Vertex</code>, <code>gl_Normal</code>, <code>gl_MultiTexCoord0</code> etc) as described in section 7.3 of the GLSL manual. There are some drivers that do not behave correctly when mixing built-in vertex attributes like <code>gl_Normal</code> and custom vertex attributes, so for maximum compatibility you should use all custom attributes</p>
<h3><a class="anchor" id="autotoc_md192"></a>
Geometry shader in/ out</h3>
<p>GLSL allows the same shader to run on different types of geometry primitives. In order to properly link the shaders together, you have to specify which primitives it will receive as input, which primitives it will emit and how many vertices a single run of the shader can generate. The GLSL geometry_program definition requires three additional parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_operation_type</td><td>The operation type of the geometry that the shader will receive. Can be â€™point_listâ€™, â€™line_listâ€™, â€™line_stripâ€™, â€™triangle_listâ€™, â€™triangle_stripâ€™ or â€™triangle_fanâ€™.</td></tr>
    <tr><td class="paramname">output_operation_type</td><td>The operation type of the geometry that the shader will emit. Can be â€™point_listâ€™, â€™line_stripâ€™ or â€™triangle_stripâ€™.</td></tr>
    <tr><td class="paramname">max_output_vertices</td><td>The maximum number of vertices that the shader can emit. There is an upper limit for this value, it is exposed in the render system capabilities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">geometry_program <a class="code hl_namespace" href="namespace_ogre.html">Ogre</a>/GPTest/Swizzle_GP_GLSL glsl</div>
<div class="line">{</div>
<div class="line">    source SwizzleGP.glsl</div>
<div class="line">    input_operation_type triangle_list</div>
<div class="line">    output_operation_type line_strip</div>
<div class="line">    max_output_vertices 6</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<p>With GL3+ these values are specified using the <code>layout</code> modifier.</p>
<h3><a class="anchor" id="autotoc_md193"></a>
Multi module shaders</h3>
<p>The <code>attach</code> keyword allows creating GLSL shaders from multiple shader modules of the same type. The referencing shader has to forward-declare the functions it intends to use</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000294">Deprecated:</a></b></dt><dd>The <code>attach</code> keyword for multi-module shaders is not supported on OpenGL ES and therefore deprecated in favor of the <code>#include</code> directive</dd></dl>
<div class="fragment"><div class="line">vertex_program myExternalGLSLFunction glsl</div>
<div class="line">{</div>
<div class="line">    source myExternalGLSLfunction.vert</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">vertex_program myGLSLVertexProgram glsl</div>
<div class="line">{</div>
<div class="line">    source myGLSLfunction.vert</div>
<div class="line">    attach myExternalGLSLFunction</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="Cg"></a>
Cg programs</h1>
<p>In order to define Cg programs, you have to have to load <code>Plugin_CgProgramManager</code> at startup, either through plugins.cfg or through your own plugin loading code. They are very easy to define:</p>
<div class="fragment"><div class="line">fragment_program myCgFragmentProgram cg</div>
<div class="line">{</div>
<div class="line">    source myCgFragmentProgram.cg</div>
<div class="line">    entry_point main_fp</div>
<div class="line">    profiles ps_2_0 arbfp1</div>
<div class="line">}</div>
</div><!-- fragment --><p>There are a few differences between this and the assembler program - to begin with, we declare that the fragment program is of type <code>cg</code> rather than <code>spirv</code>, which indicates that itâ€™s a high-level program using Cg. The <code>source</code> parameter is the same, except this time itâ€™s referencing a Cg source file instead of a file of assembler.</p>
<p>Here is where things start to change. Instead of a fixed <code>syntax</code> parameter, you specify one or more <code>profiles</code>; profiles are how Cg compiles a program down to the low-level assembler. The profiles have the same names as the assembler syntax codes mentioned above; the main difference is that you can list more than one, thus allowing the program to be compiled down to more low-level syntaxes so you can write a single high-level program which runs on both D3D and GL. You are advised to just enter the simplest profiles under which your programs can be compiled in order to give it the maximum compatibility. The ordering also matters; if a card supports more than one syntax then the one listed first will be used.</p>
<dl class="section note"><dt>Note</dt><dd>Instead of <code>preprocessor_defines</code> Cg uses the <code>compile_arguments</code> option where you can specify arguments exactly as you would to the <a href="http://developer.download.nvidia.com/cg/cgc.html">cgc command-line compiler</a>. While this gives you more flexibility, it means that you must specify the defines as <code>-DSYMBOL</code> separated by spaces. Keep this in mind when copying program definitions across the supported languages.</dd></dl>
<h1><a class="anchor" id="HLSL"></a>
DirectX HLSL</h1>
<p>DirectX HLSL has an almost identical language syntax to Cg but is tied to the DirectX API. The benefit over Cg is that it only requires the DirectX render system plugin, not any additional plugins. Declaring a DirectX HLSL program is very similar to Cg. Hereâ€™s an example:</p>
<div class="fragment"><div class="line">vertex_program myHLSLVertexProgram hlsl</div>
<div class="line">{</div>
<div class="line">    source myHLSLVertexProgram.hlsl</div>
<div class="line">    entry_point main_vp</div>
<div class="line">    target vs_2_0</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you can see, the main syntax is almost identical, except that instead of <code>profiles</code> with a list of assembler formats, you have a <code>target</code> parameter which allows a single assembler target to be specified - obviously this has to be a DirectX assembler format syntax code.</p>
<dl class="section note"><dt>Note</dt><dd>One thing to bear in mind is that HLSL allows you to use 2 different ways to multiply a vector by a matrix - mul(v,m) or mul(m,v). The only difference between them is that the matrix is effectively transposed. You should use mul(m,v) with the matrices passed in from <a class="el" href="namespace_ogre.html">Ogre</a> - this agrees with the shaders produced from tools like RenderMonkey, and is consistent with Cg too, but disagrees with the Dx9 SDK and FX Composer which use mul(v,m) - you will have to switch the parameters to mul() in those shaders. </dd>
<dd>
If you use the <code>float3x4</code> / <code>matrix3x4</code> type in your shader, bound to an OGRE auto-definition (such as bone matrices) you should use the <code>column_major_matrices = false</code> option (discussed below) in your program definition. This is because OGRE passes <code>float3x4</code> as row-major to save constant space (3 float4â€™s rather than 4 float4â€™s with only the top 3 values used) and this tells OGRE to pass all matrices like this, so that you can use mul(m,v) consistently for all calculations. OGRE will also to tell the shader to compile in row-major form (you donâ€™t have to set the <code>/Zpr</code> compile option or #pragma pack(row-major) option, OGRE does this for you). Note that passing bones in float4x3 form is not supported by OGRE, but you donâ€™t need it given the above.</dd></dl>
<p><b>Advanced options</b><br  />
</p>
<dl compact="compact">
<dt>column_major_matrices &lt;true|false&gt; </dt>
<dd><p class="startdd"></p>
<p class="interdd">The default for this option is â€™trueâ€™ so that OGRE passes matrices auto-bound matrices in a form where mul(m,v) works. Setting this option to false does 2 things - it transpose auto-bound 4x4 matrices and also sets the /Zpr (row-major) option on the shader compilation. This means you can still use mul(m,v), but the matrix layout is row-major instead. This is only useful if you need to use bone matrices (float3x4) in a shader since it saves a float4 constant for every bone involved.</p>
<p class="enddd"></p>
</dd>
<dt>optimisation_level &lt;opt&gt; </dt>
<dd><p class="startdd"></p>
<p class="interdd">Set the optimisation level, which can be one of â€™defaultâ€™, â€™noneâ€™, â€™0â€™, â€™1â€™, â€™2â€™, or â€™3â€™. This corresponds to the /O parameter of fxc.exe, except that in â€™defaultâ€™ mode, optimisation is disabled in debug mode and set to 1 in release mode (fxc.exe uses 1 all the time). Unsurprisingly the default value is â€™defaultâ€™. You may want to change this if you want to tweak the optimisation, for example if your shader gets so complex that it will not longer compile without some minimum level of optimisation.</p>
<p class="enddd"></p>
</dd>
</dl>
<h1><a class="anchor" id="Assembler-Shaders"></a>
Assembler Shaders</h1>
<p>You can specify assembly shaders directly as the syntax code of the program, if you compiled them ahead of time. Alternatively, you can use the syntax code to specify the <code>target</code> of a high-level shader, which will be compiled on-the-fly to the specified syntax.</p>
<p>The current supported syntaxes are:</p>
<dl compact="compact">
<dt>spirv </dt>
<dd><p class="startdd"></p>
<p class="interdd">The assembly language used by Vulkan</p>
<p class="enddd"></p>
</dd>
<dt>gl_spirv </dt>
<dd><p class="startdd"></p>
<p class="interdd">SPIRV variant exposed by ARB_gl_spirv</p>
<p class="enddd"></p>
</dd>
<dt>vs_* </dt>
<dd><p class="startdd"></p>
<p class="interdd">These is are the DirectX vertex shader assembler syntaxes.</p>
<dl class="section note"><dt>Note</dt><dd>on D3D11 the following targets will alias to <code>vs_4_0</code> levels so you can use them for both D3D9 and D3D11.<ul>
<li><code>vs_2_0</code> to <code>vs_4_0_level_9_1</code> </li>
<li><code>vs_2_a</code> to <code>vs_4_0_level_9_3</code> </li>
<li><code>vs_3_0</code> to <code>vs_4_0</code> </li>
</ul>
</dd></dl>
</dd>
<dt>arbvp1 </dt>
<dd><p class="startdd"></p>
<p class="interdd">This is the OpenGL standard assembler format for vertex programs. Itâ€™s roughly equivalent to DirectX vs_1_1.</p>
<p class="enddd"></p>
</dd>
<dt>vp* </dt>
<dd><p class="startdd"></p>
<p class="interdd">These are nVidia-specific OpenGL vertex shader syntax which is a superset of vs_1_1, that have otherwise no equivalent in OpenGL.</p>
<p class="enddd"></p>
</dd>
<dt>ps_* </dt>
<dd><p class="startdd"></p>
<p class="enddd">DirectX pixel shader (i.e. fragment program) assembler syntax. </p><dl class="section note"><dt>Note</dt><dd>for ATI 8500, 9000, 9100, 9200 hardware, these profiles can also be used in OpenGL. The ATI 8500 to 9200 do not support arbfp1 but do support atifs extension in OpenGL which is very similar in function to ps_1_4 in DirectX. Ogre has a built in ps_1_x to atifs compiler that is automatically invoked when ps_1_x is used in OpenGL on ATI hardware.</dd></dl>
</dd>
<dt>arbfp1 </dt>
<dd><p class="startdd"></p>
<p class="interdd">This is the OpenGL standard assembler format for fragment programs. Itâ€™s roughly equivalent to ps_2_0, which means that not all cards that support basic pixel shaders under DirectX support arbfp1 (for example neither the GeForce3 or GeForce4 support arbfp1, but they do support ps_1_1).</p>
<p class="enddd"></p>
</dd>
<dt>fp20 </dt>
<dd><p class="startdd"></p>
<p class="interdd">This is an nVidia-specific OpenGL fragment syntax which is a superset of ps 1.3. It allows you to use the <a href="https://www.nvidia.com/attach/6400">nvparse format</a> for basic fragment programs. It actually uses NV_texture_shader and NV_register_combiners to provide functionality equivalent to DirectXâ€™s ps_1_1 under GL, but only for nVidia cards. However, since ATI cards adopted arbfp1 a little earlier than nVidia, it is mainly nVidia cards like the GeForce3 and GeForce4 that this will be useful for.</p>
<p class="enddd"></p>
</dd>
<dt>fp* </dt>
<dd><p class="startdd"></p>
<p class="interdd">Another nVidia-specific OpenGL fragment shader syntax.</p>
<p class="enddd"></p>
</dd>
<dt>gpu_gp, gp4_gp </dt>
<dd><p class="startdd"></p>
<p class="interdd">An nVidia-specific OpenGL geometry shader syntax. <br  />
 Supported cards: nVidia GeForce FX8 series<br  />
</p>
<p class="enddd"></p>
</dd>
</dl>
<p>You can get a definitive list of the syntaxes supported by the current card by calling <code><a class="el" href="class_ogre_1_1_gpu_program_manager.html#a8102fdaa0a40ec7019c94e5911f650db" title="Returns the syntaxes that the RenderSystem supports.">Ogre::GpuProgramManager::getSupportedSyntax()</a></code>.</p>
<h2><a class="anchor" id="Specifying-Named-Constants-for-Assembler-Shaders"></a>
Specifying Named Constants</h2>
<p>Assembler shaders donâ€™t have named constants (also called uniform parameters) because the language does not support them - however if you for example decided to precompile your shaders from a high-level language down to assembler for performance or obscurity, you might still want to use the named parameters. Well, you actually can - <a class="el" href="struct_ogre_1_1_gpu_named_constants.html" title="Struct collecting together the information for named constants.">Ogre::GpuNamedConstants</a> which contains the named parameter mappings has a â€™saveâ€™ method which you can use to write this data to disk, where you can reference it later using the <code>manual_named_constants</code> directive inside your assembler program declaration, e.g.</p>
<div class="fragment"><div class="line">vertex_program myVertexProgram spirv</div>
<div class="line">{</div>
<div class="line">    source myVertexProgram.spv</div>
<div class="line">    manual_named_constants myVertexProgram.constants</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this case myVertexProgram.constants has been created by calling <code><a class="el" href="struct_ogre_1_1_gpu_named_constants.html#a4ce0c92c117f2c7dd91acf697821ef67" title="Saves constant definitions to a file compatible with GpuProgram::setManualNamedConstantsFile.">Ogre::GpuNamedConstants::save</a>("myVertexProgram.constants");</code> sometime earlier as preparation, from the original high-level program. Once youâ€™ve used this directive, you can use named parameters here even though the assembler program itself has no knowledge of them.</p>
<h1><a class="anchor" id="multi-language-programs"></a>
Multi-language Programs</h1>
<p>Basic programs, like the <code>example.frag</code> stated above, are compatible with GLSL and GLSLES. To avoid duplicating the whole program declaration, you can simply specify all the language types the program is compatible with as:</p>
<div class="fragment"><div class="line">fragment_program myFragmentShader glsl glsles</div>
<div class="line">{</div>
<div class="line">    source example.frag</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can even write programs compatible with both HLSL and GLSL by using <code>#include &lt;OgreUnifiedShader.h&gt;</code> in the shader which provides cross-language macros to help with this. See <a class="el" href="_cross-platform-_shaders.html">Cross-platform Shaders</a> for more information.</p>
<h1><a class="anchor" id="Unified-High_002dlevel-Programs"></a>
Unified High-level Programs</h1>
<p>As mentioned above, it can often be useful to write both HLSL and GLSL programs to specifically target each platform, but if you do this via multiple material techniques this can cause a bloated material definition when the only difference is the program language. Well, there is another option. You can â€™wrapâ€™ multiple programs in a â€™unifiedâ€™ program definition, which will automatically choose one of a series of â€™delegateâ€™ programs depending on the rendersystem and hardware support.</p>
<div class="fragment"><div class="line">vertex_program myVertexProgram unified</div>
<div class="line">{</div>
<div class="line">    delegate realProgram1</div>
<div class="line">    delegate realProgram2</div>
<div class="line">    ... etc</div>
<div class="line">}</div>
</div><!-- fragment --><p>This works for both vertex and fragment programs, and you can list as many delegates as you like - the first one to be supported by the current rendersystem &amp; hardware will be used as the real program. This is almost like a mini-technique system, but for a single program and with a much tighter purpose. You can only use this where the programs take all the same inputs, particularly textures and other pass / sampler state. Where the only difference between the programs is the language (or possibly the target in HLSL - you can include multiple HLSL programs with different targets in a single unified program too if you want, or indeed any number of other high-level programs), this can become a very powerful feature. For example, without this feature hereâ€™s how youâ€™d have to define a programmable material which supported HLSL and GLSL:</p>
<div class="fragment"><div class="line">vertex_program myVertexProgramHLSL hlsl</div>
<div class="line">{</div>
<div class="line">    source prog.hlsl</div>
<div class="line">    entry_point main_vp</div>
<div class="line">    target vs_2_0</div>
<div class="line">}</div>
<div class="line">fragment_program myFragmentProgramHLSL hlsl</div>
<div class="line">{</div>
<div class="line">    source prog.hlsl</div>
<div class="line">    entry_point main_fp</div>
<div class="line">    target ps_2_0</div>
<div class="line">}</div>
<div class="line">vertex_program myVertexProgramGLSL glsl</div>
<div class="line">{</div>
<div class="line">    source prog.vert</div>
<div class="line">}</div>
<div class="line">fragment_program myFragmentProgramGLSL glsl</div>
<div class="line">{</div>
<div class="line">    source prog.frag</div>
<div class="line">    default_params</div>
<div class="line">    {</div>
<div class="line">        param_named tex <span class="keywordtype">int</span> 0</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line">material SupportHLSLandGLSLwithoutUnified</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// HLSL technique</span></div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            vertex_program_ref myVertexProgramHLSL</div>
<div class="line">            {</div>
<div class="line">                param_named_auto worldViewProj worldviewproj_matrix</div>
<div class="line">                param_named_auto lightColour light_diffuse_colour 0</div>
<div class="line">                param_named_auto lightSpecular light_specular_colour 0</div>
<div class="line">                param_named_auto lightAtten light_attenuation 0</div>
<div class="line">            }</div>
<div class="line">            fragment_program_ref myFragmentProgramHLSL</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// GLSL technique</span></div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            vertex_program_ref myVertexProgramGLSL</div>
<div class="line">            {</div>
<div class="line">                param_named_auto worldViewProj worldviewproj_matrix</div>
<div class="line">                param_named_auto lightColour light_diffuse_colour 0</div>
<div class="line">                param_named_auto lightSpecular light_specular_colour 0</div>
<div class="line">                param_named_auto lightAtten light_attenuation 0</div>
<div class="line">            }</div>
<div class="line">            fragment_program_ref myFragmentProgramGLSL</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And thatâ€™s a really small example. Everything you added to the HLSL technique, youâ€™d have to duplicate in the GLSL technique too. So instead, hereâ€™s how youâ€™d do it with unified program definitions:</p>
<div class="fragment"><div class="line">vertex_program myVertexProgramHLSL hlsl</div>
<div class="line">{</div>
<div class="line">    source prog.hlsl</div>
<div class="line">    entry_point main_vp</div>
<div class="line">    target vs_2_0</div>
<div class="line">}</div>
<div class="line">fragment_program myFragmentProgramHLSL hlsl</div>
<div class="line">{</div>
<div class="line">    source prog.hlsl</div>
<div class="line">    entry_point main_fp</div>
<div class="line">    target ps_2_0</div>
<div class="line">}</div>
<div class="line">vertex_program myVertexProgramGLSL glsl</div>
<div class="line">{</div>
<div class="line">    source prog.vert</div>
<div class="line">}</div>
<div class="line">fragment_program myFragmentProgramGLSL glsl</div>
<div class="line">{</div>
<div class="line">    source prog.frag</div>
<div class="line">    default_params</div>
<div class="line">    {</div>
<div class="line">        param_named tex <span class="keywordtype">int</span> 0</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Unified definition</span></div>
<div class="line">vertex_program myVertexProgram unified</div>
<div class="line">{</div>
<div class="line">    delegate myVertexProgramGLSL</div>
<div class="line">    delegate myVertexProgramHLSL</div>
<div class="line">}</div>
<div class="line">fragment_program myFragmentProgram unified</div>
<div class="line">{</div>
<div class="line">    delegate myFragmentProgramGLSL</div>
<div class="line">    delegate myFragmentProgramHLSL</div>
<div class="line">}</div>
<div class="line">material SupportHLSLandGLSLwithUnified</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// HLSL technique</span></div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            vertex_program_ref myVertexProgram</div>
<div class="line">            {</div>
<div class="line">                param_named_auto worldViewProj worldviewproj_matrix</div>
<div class="line">                param_named_auto lightColour light_diffuse_colour 0</div>
<div class="line">                param_named_auto lightSpecular light_specular_colour 0</div>
<div class="line">                param_named_auto lightAtten light_attenuation 0</div>
<div class="line">            }</div>
<div class="line">            fragment_program_ref myFragmentProgram</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>At runtime, when myVertexProgram or myFragmentProgram are used, OGRE automatically picks a real program to delegate to based on whatâ€™s supported on the current hardware / rendersystem. If none of the delegates are supported, the entire technique referencing the unified program is marked as unsupported and the next technique in the material is checked for fallback, just like normal. As your materials get larger, and you find you need to support HLSL and GLSL specifically (or need to write multiple interface-compatible versions of a program for whatever other reason), unified programs can really help reduce duplication.</p>
<h1><a class="anchor" id="Program-Parameter-Specification"></a>
Parameter specification</h1>
<p>Parameters can be specified using one of 4 commands as shown below. The same syntax is used whether you are defining a parameter just for this particular use of the program, or when specifying the <a class="el" href="_high-level-_programs.html#Default-Program-Parameters">Default Program Parameters</a>. Parameters set in the specific use of the program override the defaults.</p>
<ul>
<li><a class="el" href="_high-level-_programs.html#param_005findexed">param_indexed</a></li>
<li><a class="el" href="_high-level-_programs.html#param_005findexed_005fauto">param_indexed_auto</a></li>
<li><a class="el" href="_high-level-_programs.html#param_005fnamed">param_named</a></li>
<li><a class="el" href="_high-level-_programs.html#param_005fnamed_005fauto">param_named_auto</a></li>
<li><a class="el" href="_high-level-_programs.html#shared_005fparams_005fref">shared_params_ref</a></li>
</ul>
<p><a class="anchor" id="param_005findexed"></a><a class="anchor" id="param_005findexed-1"></a></p>
<h2><a class="anchor" id="autotoc_md194"></a>
param_indexed</h2>
<p>This command sets the value of an indexed parameter.</p>
<dl class="section user"><dt></dt><dd>Format: param_indexed &lt;index&gt; &lt;type&gt; &lt;value&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: param_indexed 0 float4 10.0 0 0 0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>simply a number representing the position in the parameter list which the value should be written, and you should derive this from your program definition. The index is relative to the way constants are stored on the card, which is in 4-element blocks. For example if you defined a float4 parameter at index 0, the next index would be 1. If you defined a matrix4x4 at index 0, the next usable index would be 4, since a 4x4 matrix takes up 4 indexes.</td></tr>
    <tr><td class="paramname">type</td><td>can be float4, matrix4x4, float&lt;n&gt;, int4, int&lt;n&gt;. Note that â€™intâ€™ parameters are only available on some more advanced program syntaxes, check the D3D or GL vertex / fragment program documentation for full details. Typically the most useful ones will be float4 and matrix4x4. Note that if you use a type which is not a multiple of 4, then the remaining values up to the multiple of 4 will be filled with zeroes for you (since GPUs always use banks of 4 floats per constant even if only one is used).</td></tr>
    <tr><td class="paramname">value</td><td>a space or tab-delimited list of values which can be converted into the type you have specified.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="param_005findexed_005fauto"></a><a class="anchor" id="param_005findexed_005fauto-1"></a></p>
<h2><a class="anchor" id="autotoc_md195"></a>
param_indexed_auto</h2>
<p>This command tells <a class="el" href="namespace_ogre.html">Ogre</a> to automatically update a given parameter with a derived value. This frees you from writing code to update program parameters every frame when they are always changing.</p>
<dl class="section user"><dt></dt><dd>Format: param_indexed_auto &lt;index&gt; &lt;autoConstType&gt; &lt;extraInfo&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: param_indexed_auto 0 worldviewproj_matrix</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>has the same meaning as <a class="el" href="_high-level-_programs.html#param_005findexed">param_indexed</a>; note this time you do not have to specify the size of the parameter because the engine knows this already. In the example, the world/view/projection matrix is being used so this is implicitly a matrix4x4.</td></tr>
    <tr><td class="paramname">autoConstType,extraInfo</td><td>is one of <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters,...">Ogre::GpuProgramParameters::AutoConstantType</a> without the <code>ACT_</code> prefix. E.g. <code>ACT_WORLD_MATRIX</code> becomes <code>world_matrix</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="param_005fnamed"></a><a class="anchor" id="param_005fnamed-1"></a></p>
<h2><a class="anchor" id="autotoc_md196"></a>
param_named</h2>
<p>This is the same as param_indexed, but uses a named parameter instead of an index. This can only be used with high-level programs which include parameter names; if youâ€™re using an assembler program then you have no choice but to use indexes. Note that you can use indexed parameters for high-level programs too, but it is less portable since if you reorder your parameters in the high-level program the indexes will change. </p><dl class="section user"><dt></dt><dd>Format: param_named &lt;name&gt; &lt;type&gt; &lt;value&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: param_named shininess float4 10.0 0 0 0</dd></dl>
<p>The type is required because the program is not compiled and loaded when the material script is parsed, so at this stage we have no idea what types the parameters are. Programs are only loaded and compiled when they are used, to save memory.</p>
<p><a class="anchor" id="param_005fnamed_005fauto"></a><a class="anchor" id="param_005fnamed_005fauto-1"></a></p>
<h2><a class="anchor" id="autotoc_md197"></a>
param_named_auto</h2>
<p>This is the named equivalent of param_indexed_auto, for use with high-level programs.</p>
<dl class="section user"><dt></dt><dd>Format: param_named_auto &lt;name&gt; &lt;autoConstType&gt; &lt;extraInfo&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: param_named_auto worldViewProj worldviewproj_matrix</dd></dl>
<p>The allowed <code>autoConstType</code> and the meaning of <code>extraInfo</code> are detailed in <a class="el" href="_high-level-_programs.html#param_005findexed_005fauto">param_indexed_auto</a>.</p>
<p><a class="anchor" id="shared_005fparams_005fref"></a><a class="anchor" id="shared_005fparams_005fref-1"></a></p>
<h2><a class="anchor" id="autotoc_md198"></a>
shared_params_ref</h2>
<p>This option allows you to reference shared parameter sets as defined in <a class="el" href="_high-level-_programs.html#Declaring-Shared-Parameters">Declaring Shared Parameters</a>. </p><dl class="section user"><dt></dt><dd>Format: shared_params_ref &lt;shared_set_name&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: shared_params_ref mySharedParams</dd></dl>
<p>The only required parameter is a name, which must be the name of an already defined shared parameter set. All named parameters which are present in both the program and the shared parameter set will be linked, and the shared parameters values will be used.</p>
<h1><a class="anchor" id="Declaring-Shared-Parameters"></a>
Declaring Shared Parameters</h1>
<p>Often, not every parameter you want to pass to a shader is unique to that program, and perhaps you want to give the same value to a number of different programs, and a number of different materials using that program. Shared parameter sets allow you to define a â€™holding areaâ€™ for shared parameters that can then be referenced when you need them in particular shaders, while keeping the definition of that value in one place. To define a set of shared parameters, you do this:</p>
<div class="fragment"><div class="line">shared_params YourSharedParamsName</div>
<div class="line">{</div>
<div class="line">    shared_param_named mySharedParam1 float4 0.1 0.2 0.3 0.4</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you can see, you need to use the keyword â€™shared_paramsâ€™ and follow it with the name that you will use to identify these shared parameters. Inside the curly braces, you can define one parameter per line, in a way which is very similar to the <a class="el" href="_high-level-_programs.html#param_005fnamed">param_named</a> syntax. The definition of these lines is: </p><dl class="section user"><dt></dt><dd>Format: shared_param_named &lt;param_name&gt; &lt;param_type&gt; [&lt;[array_size]&gt;] [&lt;initial_values&gt;]</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param_name</td><td>must be unique within the set </td></tr>
    <tr><td class="paramname">param_type</td><td>can be any one of float, float2, float3, float4, int, int2, int3, int4, matrix2x2, matrix2x3, matrix2x4, matrix3x2, matrix3x3, matrix3x4, matrix4x2, matrix4x3 and matrix4x4. </td></tr>
    <tr><td class="paramname">array_size</td><td>allows you to define arrays of param_type should you wish, and if present must be a number enclosed in square brackets (and note, must be separated from the param_type with whitespace). </td></tr>
    <tr><td class="paramname">initial_values</td><td>If you wish, you can also initialise the parameters by providing a list of values.</td></tr>
  </table>
  </dd>
</dl>
<p>Once you have defined the shared parameters, you can reference them inside default_params and params blocks using <a class="el" href="_high-level-_programs.html#shared_005fparams_005fref">shared_params_ref</a>. You can also obtain a reference to them in your code via <a class="el" href="class_ogre_1_1_gpu_program_manager.html#a2aebd515c488f378e859db9bded95412" title="Retrieve a set of shared parameters, which can be used across many GpuProgramParameters objects of di...">Ogre::GpuProgramManager::getSharedParameters</a>, and update the values for all instances using them.</p>
<h2><a class="anchor" id="autotoc_md199"></a>
Hardware Support</h2>
<p>Furthermore, shared_params can be mapped to hardware buffers, if supported by the RenderSystem. To enable this, you have to provide a matching declaration in your shader.</p>
<p>For HLSL, that would be a constant buffer defined as </p><div class="fragment"><div class="line">cbuffer YourSharedParamsName</div>
<div class="line">{</div>
<div class="line">    float4 mySharedParam1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>and for GLSL a uniform block defined as </p><div class="fragment"><div class="line">layout(std140, row_major) uniform YourSharedParamsName</div>
<div class="line">{</div>
<div class="line">    vec4 mySharedParam1;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="Shadows-and-Vertex-Programs"></a>
Shadows and Vertex Programs</h1>
<p>When using <a class="el" href="_shadows.html">Shadows</a>, the use of vertex programs can add some additional complexities, because Ogre can only automatically deal with everything when using the fixed-function pipeline. If you use vertex programs, and you are also using shadows, you may need to make some adjustments.</p>
<ul>
<li>If you use <b>stencil shadows</b>, then any vertex programs which do vertex deformation can be a problem, because stencil shadows are calculated on the CPU, which does not have access to the modified vertices. If the vertex program is doing standard skeletal animation, this is ok (see section above) because Ogre knows how to replicate the effect in software, but any other vertex deformation cannot be replicated, and you will either have to accept that the shadow will not reflect this deformation, or you should turn off shadows for that object.</li>
<li>If you use <b>texture shadows</b>, then vertex deformation is acceptable; however, when rendering the object into the shadow texture (the shadow caster pass), the shadow has to be rendered in a solid colour (linked to the ambient colour). You must therefore provide an alternative vertex program, so Ogre provides you with a way of specifying one to use when rendering the caster.</li>
</ul>
<p>Basically you specify an alternate material to use when rendering the object into the shadow texture:</p>
<div class="fragment"><div class="line">technique myShaderBasedTechnique</div>
<div class="line">{</div>
<div class="line">    shadow_caster_material myShadowCasterMaterial</div>
<div class="line">    pass</div>
<div class="line">    {</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>When rendering a shadow caster, <a class="el" href="namespace_ogre.html">Ogre</a> will automatically use the alternate material. You can bind the same or different parameters to the program - the most important thing is that you bind <code>*ambient_light_colour*</code>, since this determines the colour of the shadow in modulative texture shadows. If you donâ€™t supply an alternate material, <a class="el" href="namespace_ogre.html">Ogre</a> will fall back on a fixed-function material which will not reflect any vertex deformation you do in your vertex or geometry programs.</p>
<p>In addition, when rendering the shadow receivers with shadow textures, <a class="el" href="namespace_ogre.html">Ogre</a> needs to project the shadow texture. It does this automatically in fixed function mode, but if the receivers use vertex programs, they need to have a shadow receiver material which does the usual vertex deformation, but also generates projective texture coordinates.</p>
<dl class="section note"><dt>Note</dt><dd>At this point you can as well just extend your original program for <a class="el" href="_shadows.html#Integrated-Texture-Shadows">Integrated Texture Shadows</a>. The only advantage of the technique below is that you can use the same material with and without shadow mapping.</dd></dl>
<p>The alternative material is linked into the technique - similarly to the caster material - like:</p>
<div class="fragment"><div class="line">technique myShaderBasedTechnique</div>
<div class="line">{</div>
<div class="line">    shadow_receiver_material myShadowReceiverMaterial</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">material myShadowReceiverMaterial</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    vertex_program_ref myShadowReceiverVertexProgram</div>
<div class="line">    {</div>
<div class="line">        param_indexed_auto 0 worldviewproj_matrix</div>
<div class="line">        param_indexed_auto 4 texture_worldviewproj_matrix</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>For the purposes of writing the alternate program, there is an automatic parameter binding of <code>texture_worldviewproj_matrix</code> which provides the program with texture projection parameters. The vertex program should do its normal vertex processing, and generate texture coordinates using this matrix and place them in texture coord sets 0 and 1, since some shadow techniques use 2 texture units. The colour of the vertices output by this vertex program must always be white, so as not to affect the final colour of the rendered shadow.</p>
<p>When using additive texture shadows, the <code>shadow_receiver_material</code> replaces the lighting render, so if you perform any fragment program lighting you also need to pull in a custom fragment program:</p>
<div class="fragment"><div class="line">pass</div>
<div class="line">{</div>
<div class="line">    fragment_program_ref myShadowReceiverFragmentProgram</div>
<div class="line">    {</div>
<div class="line">        param_named_auto lightDiffuse light_diffuse_colour 0</div>
<div class="line">    }</div>
<div class="line">    texture_unit</div>
<div class="line">    {</div>
<div class="line">        content_type shadow</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>You should pass the projected shadow coordinates from the custom vertex program. As for textures, define a <code>texture_unit</code> with <code>content_type</code> <code>shadow</code> to pull the shadow texture. Your shadow receiver fragment program is likely to be the same as the bare lighting pass of your normal material, except that you insert an extra texture sampler for the shadow texture, which you will use to adjust the result by (modulating diffuse and specular components).</p>
<h1><a class="anchor" id="Instancing-in-Vertex-Programs"></a>
Instancing in Vertex Programs</h1>
<p>You can implement hardware instancing by writing a vertex program which reads the world matrix of each instance from a <code>float3x4</code> vertex attribute. However, you need to communicate this support to Ogre so it batches the instances instead of rendering them individually. You do this by adding the following attribute to your <code>vertex_program</code> definition:</p>
<div class="fragment"><div class="line">includes_instancing <span class="keyword">true</span></div>
</div><!-- fragment --><p>When you do this, all SubEntities with the same material will be batched together. Ogre will create and populate an instance buffer with the world matrices of the instances. This buffer is provided in the <code>TEXCOORD1</code> attribute (also consuming <code>TEXCOORD2</code> and <code>TEXCOORD3</code>) to the vertex shader.</p>
<p>When batching, all instances are rendered in a single draw-call. All per-renderable operations are only performed with the first SubMesh of the batch.</p>
<p>Therefore the following features are not supported:</p><ul>
<li><code>start_light</code> and <code>iteration</code> (all instances share the same lights)</li>
<li>flip culling on negative scale (all instances use the same face order)</li>
<li>custom renderable parameters (not implemented)</li>
<li>light scissoring &amp; clipping (not implemented)</li>
<li>manualLightList (not implemented)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Instancing cannot be used together with skeletal animation (neither Hardware nor Software).</dd></dl>
<h1><a class="anchor" id="Skeletal-Animation-in-Vertex-Programs"></a>
Skeletal Animation in Vertex Programs</h1>
<p>You can implement skeletal animation in hardware by writing a vertex program which uses the per-vertex blending indices and blending weights, together with an array of world matrices (which will be provided for you by <a class="el" href="namespace_ogre.html">Ogre</a> if you bind the automatic parameter â€™world_matrix_array_3x4â€™). However, you need to communicate this support to <a class="el" href="namespace_ogre.html">Ogre</a> so it does not perform skeletal animation in software for you. You do this by adding the following attribute to your <code>vertex_program</code> definition:</p>
<div class="fragment"><div class="line">includes_skeletal_animation <span class="keyword">true</span></div>
</div><!-- fragment --><p>When you do this, any skeletally animated entity which uses this material will forgo the usual animation blend and will expect the vertex program to do it, for both vertex positions and normals. Note that ALL submeshes must be assigned a material which implements this, and that if you combine skeletal animation with vertex animation (See <a class="el" href="_animation.html">Animation</a>) then all techniques must be hardware accelerated for any to be.</p>
<h1><a class="anchor" id="Morph-Animation-in-Vertex-Programs"></a>
Morph Animation in Vertex Programs</h1>
<p>You can implement morph animation in hardware by writing a vertex program which linearly blends between the first and second position keyframes passed as positions and the first free texture coordinate set, and by binding the animation_parametric value to a parameter (which tells you how far to interpolate between the two). However, you need to communicate this support to <a class="el" href="namespace_ogre.html">Ogre</a> so it does not perform morph animation in software for you. You do this by adding the following attribute to your <code>vertex_program</code> definition:</p>
<div class="fragment"><div class="line">includes_morph_animation <span class="keyword">true</span></div>
</div><!-- fragment --><p>When you do this, any skeletally animated entity which uses this material will forgo the usual software morph and will expect the vertex program to do it. Note that if your model includes both skeletal animation and morph animation, they must both be implemented in the vertex program if either is to be hardware acceleration. Note that ALL submeshes must be assigned a material which implements this, and that if you combine skeletal animation with vertex animation (See <a class="el" href="_animation.html">Animation</a>) then all techniques must be hardware accelerated for any to be.</p>
<h1><a class="anchor" id="Pose-Animation-in-Vertex-Programs"></a>
Pose Animation in Vertex Programs</h1>
<p>You can implement pose animation (blending between multiple poses based on weight) in a vertex program by pulling in the original vertex data (bound to position), and as many pose offset buffers as youâ€™ve defined in your â€™includes_pose_animationâ€™ declaration, which will be in the first free texture unit upwards. You must also use the animation_parametric parameter to define the starting point of the constants which will contain the pose weights; they will start at the parameter you define and fill â€™nâ€™ constants, where â€™nâ€™ is the max number of poses this shader can blend, i.e. the parameter to includes_pose_animation.</p>
<div class="fragment"><div class="line">includes_pose_animation 4</div>
</div><!-- fragment --><p>Note that ALL submeshes must be assigned a material which implements this, and that if you combine skeletal animation with vertex animation (See <a class="el" href="_animation.html">Animation</a>) then all techniques must be hardware accelerated for any to be.</p>
<h1><a class="anchor" id="Vertex-Texture-Fetch"></a>
Vertex Texture Fetch</h1>
<p>More recent generations of video card allow you to perform a read from a texture in the vertex program rather than just the fragment program, as is traditional. This allows you to, for example, read the contents of a texture and displace vertices based on the intensity of the colour contained within.</p>
<p><a class="anchor" id="Declaring-the-use-of-vertex-texture-fetching"></a></p>
<h2><a class="anchor" id="autotoc_md200"></a>
Declaring the use of vertex texture fetching</h2>
<p>If your vertex program makes use of Vertex Texture Fetch, you should declare that as</p>
<div class="fragment"><div class="line">uses_vertex_texture_fetch <span class="keyword">true</span></div>
</div><!-- fragment --><p>Since hardware support for vertex texture fetching is not ubiquitous, you should use the directive when declaring your vertex programs which use vertex textures, so that if it is not supported, technique fallback can be enabled. This is not strictly necessary for DirectX-targeted shaders, since vertex texture fetching is only supported in vs_3_0, which can be stated as a required syntax in your shader definition, but for OpenGL (GLSL), there are cards which support GLSL but not vertex textures, so you should be explicit about your need for them.</p>
<p><a class="anchor" id="Render-system-texture-binding-differences"></a></p>
<h2><a class="anchor" id="autotoc_md201"></a>
DirectX9 binding limitations</h2>
<p>Shader Model 3.0 (SM3.0) hardware under DirectX9 includes 4 sampler bindings for the purposes of vertex textures. <a class="el" href="namespace_ogre.html">Ogre</a> assigns the first 4 texture units to these bindings - therefore you should put fragment-only textures last.</p>
<p><a class="anchor" id="Texture-format-limitations"></a></p>
<h2><a class="anchor" id="autotoc_md202"></a>
Texture format limitations</h2>
<p>Again as at the time of writing, the types of texture you can use in a vertex program are limited to 1- or 4-component, full precision floating point formats. In code that equates to PF_FLOAT32_R or PF_FLOAT32_RGBA. No other formats are supported. In addition, the textures must be regular 2D textures (no cube or volume maps) and mipmapping and filtering is not supported, although you can perform filtering in your vertex program if you wish by sampling multiple times.</p>
<p><a class="anchor" id="Hardware-limitations"></a></p>
<h2><a class="anchor" id="autotoc_md203"></a>
Hardware limitations</h2>
<p>As at the time of writing (early Q3 2006), ATI do not support texture fetch in their current crop of cards (Radeon X1n00). nVidia do support it in both their 6n00 and 7n00 range. ATI support an alternative called â€™Render to Vertex Bufferâ€™, but this is not standardised at this time and is very much different in its implementation, so cannot be considered to be a drop-in replacement. This is the case even though the Radeon X1n00 cards claim to support vs_3_0 (which requires vertex texture fetch).</p>
<h1><a class="anchor" id="GpuProgram-API"></a>
Programmatic creation</h1>
<p>In case you need to create GPU Programs programmatically, see the following example for how the script is mapped to the API.</p>
<div class="fragment"><div class="line">vertex_program glTF2/PBR_vs glsl</div>
<div class="line">{</div>
<div class="line">    source pbr-vert.glsl</div>
<div class="line">    preprocessor_defines HAS_NORMALS,HAS_TANGENTS</div>
<div class="line">    default_params</div>
<div class="line">    {</div>
<div class="line">        param_named_auto u_MVPMatrix worldviewproj_matrix</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> becomes </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ogre.html">Ogre</a>;</div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_gpu_program_manager.html">GpuProgramManager</a>&amp; <a class="code hl_struct" href="struct_ogre_1_1vector.html">mgr</a> = GpuProgramManager::getSingleton();</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_shared_ptr.html">GpuProgramPtr</a> <a class="code hl_struct" href="struct_ogre_1_1vector.html">vertex_program</a> = <a class="code hl_struct" href="struct_ogre_1_1vector.html">mgr</a>.createProgram(<span class="stringliteral">&quot;glTF2/PBR_vs&quot;</span>, RGN_DEFAULT, <span class="stringliteral">&quot;glsl&quot;</span>, GPT_VERTEX_PROGRAM);</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">vertex_program</a>-&gt;setSource(<span class="stringliteral">&quot;pbr-vert.glsl&quot;</span>);</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1vector.html">vertex_program</a>-&gt;setParameter(<span class="stringliteral">&quot;preprocessor_defines&quot;</span>, <span class="stringliteral">&quot;HAS_NORMALS,HAS_TANGENTS&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_shared_ptr.html">GpuProgramParametersPtr</a> params = <a class="code hl_struct" href="struct_ogre_1_1vector.html">vertex_program</a>-&gt;getDefaultParameters();</div>
<div class="line">params-&gt;<a class="code hl_function" href="class_ogre_1_1_gpu_program_parameters.html#a347164bfe559f2e466701a68a54a3da3">setNamedAutoConstant</a>(<span class="stringliteral">&quot;u_MVPMatrix&quot;</span>, GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX);</div>
<div class="ttc" id="aclass_ogre_1_1_gpu_program_manager_html"><div class="ttname"><a href="class_ogre_1_1_gpu_program_manager.html">Ogre::GpuProgramManager</a></div><div class="ttdoc">This ResourceManager manages GPU shader programs.</div><div class="ttdef"><b>Definition</b> OgreGpuProgramManager.h:69</div></div>
<div class="ttc" id="aclass_ogre_1_1_gpu_program_parameters_html_a347164bfe559f2e466701a68a54a3da3"><div class="ttname"><a href="class_ogre_1_1_gpu_program_parameters.html#a347164bfe559f2e466701a68a54a3da3">Ogre::GpuProgramParameters::setNamedAutoConstant</a></div><div class="ttdeci">void setNamedAutoConstant(const String &amp;name, AutoConstantType acType, uint32 extraInfo=0)</div><div class="ttdoc">Sets up a constant which will automatically be updated by the system.</div></div>
<div class="ttc" id="aclass_ogre_1_1_shared_ptr_html"><div class="ttname"><a href="class_ogre_1_1_shared_ptr.html">Ogre::SharedPtr&lt; GpuProgram &gt;</a></div></div>
<div class="ttc" id="astruct_ogre_1_1vector_html"><div class="ttname"><a href="struct_ogre_1_1vector.html">Ogre::vector</a></div><div class="ttdef"><b>Definition</b> OgreDeprecated.h:54</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li><li class="navelem"><a class="el" href="_scripts.html">Scripts</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
