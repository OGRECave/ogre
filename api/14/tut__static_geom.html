<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Static Geometry</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('tut__static_geom.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Static Geometry</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md311">Blades of grass</a></li>
<li class="level1"><a href="#autotoc_md312">A field of grass</a></li>
<li class="level1"><a href="#autotoc_md313">Animating StaticGeometry</a></li>
<li class="level1"><a href="#autotoc_md314">Advanced Object Batching</a></li>
</ul>
</div>
<div class="textblock"><p>If we have a collection of entities in our scene that will not be moved, then Ogre can perform an optimization by rendering them in "batches". Modern GPUs are designed to render an enormous amount of triangles at once. We are able to take advantage of this through the batching techniques used by a <a class="el" href="class_ogre_1_1_static_geometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene.">Ogre::StaticGeometry</a> object. Static geometry is a bit of a misnomer in this case, because we can use some tricks to accomplish things like grass waving in the wind, but the general idea is that this is an object that will not be manipulated a great deal. Good examples include rocks, trees, and buildings.</p>
<p>The full source for this tutorial can be found in samples directory <b>Samples/Simple/include/Grass.h</b>.</p>
<h1><a class="anchor" id="autotoc_md311"></a>
Blades of grass</h1>
<p>The first thing we will do is create the grass mesh we will be rendering. We will use a pattern you've probably seen to create the illusion of grass. We will render three square quads that have a grass texture applied to them. We will create one, then place another rotated 60 degrees, and then place a third rotated 120 degrees. This will create a simple illusion of 3D grass.</p>
<p>The first step will be to define some variables. We will define the width and height of our quad, then we will initialize a vector that will be used to define the four corners of our quad. We will again be using quaternions to handle rotations. Our plan is to use the vector to represent the orientation of the base of our quad.</p>
<div class="fragment"><div class="line">         <span class="comment">// planes intersect along the Y axis with 60 degrees between them</span></div>
<div class="line">         Vector3 vec = Quaternion(Degree(i * 60), Vector3::UNIT_Y) * Vector3(width / 2, 0, 0);</div>
</div><!-- fragment --><p>This should look somewhat familiar. We have created a quaternion that rotates by multiples of 60 degree around the y-axis.</p>
<p>The vector we are using starts out pointing down the x-axis with a length that is half the width of our quad. This may be a little hard to visualize. Here is a picture to help:</p>
<div class="image">
<img src="quad_visual.png" alt=""/>
</div>
    <p>Remember that x and z are in the plane of the floor. So our vector keeps track of where the foundation of our quad is, we build everything from that.</p>
<p>We will now begin defining our manual object. We set the render operation to be OT_TRIANGLE_LIST. This means that after we define our vertices with the <code>position</code> method, we then have to let <a class="el" href="namespace_ogre.html">Ogre</a> know how to set up the index buffer by giving it a list of triangles made from the vertices.</p>
<div class="fragment"><div class="line">     ManualObject obj(<span class="stringliteral">&quot;GrassObject&quot;</span>);</div>
<div class="line">     obj.begin(<span class="stringliteral">&quot;Examples/GrassBlades&quot;</span>);</div>
</div><!-- fragment --><p>For each quad we are going to define four vertices representing the corners. We will also specify a texture coordinates. These are normalized coordinates that tell <a class="el" href="namespace_ogre.html">Ogre</a> how to map the texture on to our mesh. In our case, these coordinates are very simple since we are creating a solid square.</p>
<div class="fragment"><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 4; j++) <span class="comment">// each plane has 4 vertices</span></div>
<div class="line">         {</div>
<div class="line">             vec.y = j % 2 ? 0 : height;</div>
<div class="line">             obj.position(j &lt; 2 ? Vector3(-1, 1, -1) * vec : vec);</div>
<div class="line">             obj.textureCoord(j &lt; 2 ? 0 : 1, j % 2);</div>
<div class="line"> </div>
<div class="line">             <span class="comment">// all normals point straight up</span></div>
<div class="line">             obj.normal(0, 1, 0);</div>
<div class="line">         }</div>
</div><!-- fragment --><p>We've also labeled the four corners with the order they were created to help with creating the triangles. The count starts with the 0th corner.</p>
<p>To ensure that both triangles face the same direction, we need to provide the points in counter-clockwise order. The <code>triangle</code> method does not directly take positions, instead it takes three numbers that represent the order in which the points were created. This is why we labeled the four corners in our image.</p>
<div class="fragment"><div class="line">         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> off = i * 4;</div>
<div class="line">         <span class="comment">// each plane consists of 2 triangles</span></div>
<div class="line">         obj.triangle(off + 0, off + 3, off + 1);</div>
<div class="line">         obj.triangle(off + 0, off + 2, off + 3);</div>
</div><!-- fragment --><p>First, ignore the offset value and look at the numbers we are adding. They match the numbers we assigned in the image. The first triangle connects the 0th, 3rd, and 1st corners. The second triangle connects the 0th, 2nd, and 3rd corners. You can look at the image to see these are in counter-clockwise order. The purpose of the offset is because we are creating three different quads, but they are all going to be a part of one manual object. So the second quad's corners will be numbered 4, 5, 6, 7. Adding the offset accounts for this.</p>
<p>After we've created all three quads, the loop finishes and we call <code>end</code> to finalize the object.</p>
<div class="fragment"><div class="line">     obj.end();</div>
<div class="line">     obj.convertToMesh(<span class="stringliteral">&quot;grass&quot;</span>);</div>
</div><!-- fragment --><p>The last line converts our manual object into an actual mesh. Meshes require less storage compared to directly using the manual object for rendering.</p>
<p>We are now finished creating the grass mesh. If you create a complex mesh, then you may save it to a file instead of rebuilding the mesh each time. To do this, you would save the mesh pointer that is returned by <code>convertToMesh</code>. Then you would use a mesh serializer to export the mesh to a file.</p>
<p>Here is an example. Do <b>not</b> add this code to our current project. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> mesh = obj.convertToMesh(<span class="stringliteral">&quot;GrassBladesMesh&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_mesh_serializer.html">Ogre::MeshSerializer</a> ser;</div>
<div class="line">ser.<a class="code hl_function" href="class_ogre_1_1_mesh_serializer.html#a55ce1998a5ef0fa8354e6e9c63026d0a">exportMesh</a>(mesh, <span class="stringliteral">&quot;my_grass.mesh&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_static_geometry.html">Ogre::StaticGeometry</a>* mField;</div>
<div class="ttc" id="aclass_ogre_1_1_mesh_serializer_html"><div class="ttname"><a href="class_ogre_1_1_mesh_serializer.html">Ogre::MeshSerializer</a></div><div class="ttdoc">Class for serialising mesh data to/from an OGRE .mesh file.</div><div class="ttdef"><b>Definition</b> OgreMeshSerializer.h:92</div></div>
<div class="ttc" id="aclass_ogre_1_1_mesh_serializer_html_a55ce1998a5ef0fa8354e6e9c63026d0a"><div class="ttname"><a href="class_ogre_1_1_mesh_serializer.html#a55ce1998a5ef0fa8354e6e9c63026d0a">Ogre::MeshSerializer::exportMesh</a></div><div class="ttdeci">void exportMesh(const Mesh *pMesh, const String &amp;filename, MeshVersion version, Endian endianMode=ENDIAN_NATIVE)</div><div class="ttdoc">Exports a mesh to the file specified, in a specific version format.</div></div>
<div class="ttc" id="aclass_ogre_1_1_static_geometry_html"><div class="ttname"><a href="class_ogre_1_1_static_geometry.html">Ogre::StaticGeometry</a></div><div class="ttdoc">Pre-transforms and batches up meshes for efficient use as static geometry in a scene.</div><div class="ttdef"><b>Definition</b> OgreStaticGeometry.h:121</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md312"></a>
A field of grass</h1>
<p>Now we get to the creation of our static geometry. The first thing we do is create an entity from the grass mesh we constructed, then we ask the scene manager to give us a pointer to a new StaticGeometry object.</p>
<div class="fragment"><div class="line">     <span class="comment">// create our grass mesh, and create a grass entity from it</span></div>
<div class="line">     createGrassMesh();</div>
<div class="line">     Entity* grass = mSceneMgr-&gt;createEntity(<span class="stringliteral">&quot;Grass&quot;</span>, <span class="stringliteral">&quot;grass&quot;</span>);</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// create a static geometry field, which we will populate with grass</span></div>
<div class="line">     mField = mSceneMgr-&gt;createStaticGeometry(<span class="stringliteral">&quot;Field&quot;</span>);</div>
<div class="line">     mField-&gt;setRegionDimensions(Vector3(140, 140, 140));</div>
<div class="line">     mField-&gt;setOrigin(Vector3(70, 70, 70));</div>
</div><!-- fragment --><p>Here, RegionDimensions refer to the physical size of one batch. All grass patches located within the region will be treated as one. Patches outside the region will be in a separate batch. This allows you to trade culling for batching effectiveness.</p>
<p>Now we will prepare the actual build. We are going to loop through points on the floor of our region and place a grass patch with a random offset at each point.</p>
<div class="fragment"><div class="line">     <span class="comment">// add grass uniformly throughout the field, with some random variations</span></div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = -280; x &lt; 280; x += 20)</div>
<div class="line">     {</div>
<div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> z = -280; z &lt; 280; z += 20)</div>
<div class="line">         {</div>
<div class="line">             Vector3 pos(x + Math::RangeRandom(-7, 7), 0, z + Math::RangeRandom(-7, 7));</div>
<div class="line">             Quaternion ori(Degree(Math::RangeRandom(0, 359)), Vector3::UNIT_Y);</div>
<div class="line">             Vector3 scale(1, Math::RangeRandom(0.85, 1.15), 1);</div>
<div class="line"> </div>
<div class="line">             mField-&gt;addEntity(grass, pos, ori, scale);</div>
<div class="line">         }</div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">     mField-&gt;build();  <span class="comment">// build our static geometry (bake the grass into it)</span></div>
</div><!-- fragment --><p>We've partitioned the floor of our region into enough sections to fit all of our grass patches. The first thing we do is calculate an offset that will be used to randomly nudge each grass patch. This will help it look a little more natural. We use this offset to define a position vector for our object. To do this, we use the <a class="el" href="class_ogre_1_1_math.html#afedce6fa2a819ea7a2420e10fb00a189" title="Generate a random number within the range provided.">Ogre::Math::RangeRandom</a>. We then use the same method to create a randomized scale vector to add some more variety to our grass. Our three quads were already rotated 60 degrees from each other, but now we are randomly rotating the entire grass patch as a whole. Always remember to play around with numbers like these to create surprising effects in your scene. Some great game mechanics have been discovered by doing exactly this.</p>
<p>The last thing we do is add a new grass entity to our scene using all of the information we've just set up. We then call the <code>build</code> method to construct our StaticGeometry object.</p>
<dl class="section note"><dt>Note</dt><dd>When defining static geometry, you will either use <a class="el" href="class_ogre_1_1_static_geometry.html#a98c44ba2920c9e07d29548d5ee927b5e" title="Adds an Entity to the static geometry.">Ogre::StaticGeometry::addEntity</a> or <a class="el" href="class_ogre_1_1_static_geometry.html#aa077e3cb67caa3109a5664795644156a" title="Adds all the Entity objects attached to a SceneNode and all it&#39;s children to the static geometry.">Ogre::StaticGeometry::addSceneNode</a>. The latter method adds all of the entities attached to that scene node to the static geometry. It uses the positions, orientations, and scales of the child nodes instead of requiring you to specify them manually. When using <code>addSceneNode</code>, be sure to remove the scene node from its previous parent. If you do not, <a class="el" href="namespace_ogre.html">Ogre</a> will render them both.</dd></dl>
<h1><a class="anchor" id="autotoc_md313"></a>
Animating StaticGeometry</h1>
<p>Once you have created a StaticGeometry object, you are not supposed to do much more with it. After all, that's the entire point behind static geometry - it's supposed to be static. As mentioned before, you can use certain tricks to do things like grass waving in the wind. If you are interested in how to do this, then take a look at the <code>Examples/GrassBladesWaver</code> material, which adds wave-like behavior to our grass meshes through a vertex-shader.</p>
<h1><a class="anchor" id="autotoc_md314"></a>
Advanced Object Batching</h1>
<p>This is just the beginning of the batching technique. StaticGeometry objects are useful for grouping together many things that will not move. But if you're trying to create something more massive, like a forest or a large terrain covered in grass, then you should look into more advanced batching techniques. A good place to start is the <a href="https://ogrecave.github.io/ogre-pagedgeometry/">PagedGeometry Engine</a>. It works similar to StaticGeometry, but extends it with paging and automatic Impostor generation for LOD.</p>
<p>If you actually need your Entities to move in space or if each entity consists of many vertices, rather take a look at <a class="el" href="class_ogre_1_1_scene_manager.html#a5579128d01a04448a96d6a2acc663a45" title="Creates an InstanceManager interface to create &amp; manipulate instanced entities You need to call this ...">Ogre::SceneManager::createInstanceManager</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
