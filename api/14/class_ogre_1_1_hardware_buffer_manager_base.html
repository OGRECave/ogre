<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::HardwareBufferManagerBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.5</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_hardware_buffer_manager_base.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_hardware_buffer_manager_base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::HardwareBufferManagerBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___render_system.html">RenderSystem</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Base definition of a hardware buffer manager.  
 <a href="class_ogre_1_1_hardware_buffer_manager_base.html#details">More...</a></p>

<p><code>#include &lt;OgreHardwareBufferManager.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::HardwareBufferManagerBase:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_hardware_buffer_manager_base__inherit__graph.svg" width="470" height="286"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa1f5ef725fdeacc6018e1dee3b7eded5" id="r_aa1f5ef725fdeacc6018e1dee3b7eded5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#aa1f5ef725fdeacc6018e1dee3b7eded5">HardwareBufferManagerBase</a> ()</td></tr>
<tr class="separator:aa1f5ef725fdeacc6018e1dee3b7eded5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc50f8bac0fad6710aa205d0c4e295c4" id="r_abc50f8bac0fad6710aa205d0c4e295c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#abc50f8bac0fad6710aa205d0c4e295c4">~HardwareBufferManagerBase</a> ()</td></tr>
<tr class="separator:abc50f8bac0fad6710aa205d0c4e295c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876ce18832783cd168f4e55d989c3f1c" id="r_a876ce18832783cd168f4e55d989c3f1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#a876ce18832783cd168f4e55d989c3f1c">_forceReleaseBufferCopies</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">sourceBuffer</a>)</td></tr>
<tr class="memdesc:a876ce18832783cd168f4e55d989c3f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method that forces the release of copies of a given buffer.  <br /></td></tr>
<tr class="separator:a876ce18832783cd168f4e55d989c3f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c05c63b98f45df312660e724d95320" id="r_a01c05c63b98f45df312660e724d95320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#a01c05c63b98f45df312660e724d95320">_freeUnusedBufferCopies</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>)</td></tr>
<tr class="memdesc:a01c05c63b98f45df312660e724d95320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all unused vertex buffer copies.  <br /></td></tr>
<tr class="separator:a01c05c63b98f45df312660e724d95320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b2e243bab8522ae27ec23268ea154a" id="r_a29b2e243bab8522ae27ec23268ea154a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#a29b2e243bab8522ae27ec23268ea154a">_notifyVertexBufferDestroyed</a> (<a class="el" href="class_ogre_1_1_hardware_vertex_buffer.html">HardwareVertexBuffer</a> *buf)</td></tr>
<tr class="memdesc:a29b2e243bab8522ae27ec23268ea154a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that a hardware vertex buffer has been destroyed.  <br /></td></tr>
<tr class="separator:a29b2e243bab8522ae27ec23268ea154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5551674a13abf8d3458d2798e58d7cd9" id="r_a5551674a13abf8d3458d2798e58d7cd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#a5551674a13abf8d3458d2798e58d7cd9">_releaseBufferCopies</a> (<a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">forceFreeUnused</a>=<a class="el" href="struct_ogre_1_1vector.html">false</a>)</td></tr>
<tr class="memdesc:a5551674a13abf8d3458d2798e58d7cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for releasing all temporary buffers; is called by OGRE.  <br /></td></tr>
<tr class="separator:a5551674a13abf8d3458d2798e58d7cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38acebabcc266b2afef7c8dff234a98" id="r_aa38acebabcc266b2afef7c8dff234a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#aa38acebabcc266b2afef7c8dff234a98">allocateVertexBufferCopy</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">sourceBuffer</a>, <a class="el" href="class_ogre_1_1_hardware_buffer_licensee.html">HardwareBufferLicensee</a> *licensee, <a class="el" href="struct_ogre_1_1vector.html">bool</a> copyData=<a class="el" href="struct_ogre_1_1vector.html">false</a>)</td></tr>
<tr class="memdesc:aa38acebabcc266b2afef7c8dff234a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a copy of a given vertex buffer.  <br /></td></tr>
<tr class="separator:aa38acebabcc266b2afef7c8dff234a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46262b1cc1e8bfe136e9bb203894c41" id="r_ae46262b1cc1e8bfe136e9bb203894c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="namespace_ogre.html#a54481042551b3b7ca50133fb287ef89f">HardwareIndexBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#ae46262b1cc1e8bfe136e9bb203894c41">createIndexBuffer</a> (<a class="el" href="class_ogre_1_1_hardware_index_buffer.html#afc6252abb2231698e8a8f936105cc9f1">HardwareIndexBuffer::IndexType</a> <a class="el" href="struct_ogre_1_1vector.html">itype</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">numIndexes</a>, <a class="el" href="class_ogre_1_1_hardware_buffer.html#a81c7a563d8a33c8ef21fb70913412a17">HardwareBuffer::Usage</a> <a class="el" href="struct_ogre_1_1vector.html">usage</a>, <a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">useShadowBuffer</a>=<a class="el" href="struct_ogre_1_1vector.html">false</a>)=0</td></tr>
<tr class="memdesc:ae46262b1cc1e8bfe136e9bb203894c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hardware index buffer.  <br /></td></tr>
<tr class="separator:ae46262b1cc1e8bfe136e9bb203894c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db6eed911de330dd6a83a7b77447a72" id="r_a4db6eed911de330dd6a83a7b77447a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="namespace_ogre.html#a7e0bc377ed62eee5daa8987e28b2ce93">RenderToVertexBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#a4db6eed911de330dd6a83a7b77447a72">createRenderToVertexBuffer</a> ()</td></tr>
<tr class="memdesc:a4db6eed911de330dd6a83a7b77447a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render to vertex buffer.  <br /></td></tr>
<tr class="separator:a4db6eed911de330dd6a83a7b77447a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4fe7d19ac6072774e795b7d0dd0f16" id="r_a1f4fe7d19ac6072774e795b7d0dd0f16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="namespace_ogre.html#a9140aec81d4c373ea427d72ca046d845">HardwareBufferPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#a1f4fe7d19ac6072774e795b7d0dd0f16">createUniformBuffer</a> (<a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">sizeBytes</a>, <a class="el" href="group___render_system.html#ga3e7bd12438696e8c75150be1fbe90532">HardwareBufferUsage</a> <a class="el" href="struct_ogre_1_1vector.html">usage</a>=<a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532acbb4350fbecafb42887765883469fe6f">HBU_CPU_TO_GPU</a>, <a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">useShadowBuffer</a>=<a class="el" href="struct_ogre_1_1vector.html">false</a>)</td></tr>
<tr class="memdesc:a1f4fe7d19ac6072774e795b7d0dd0f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create uniform buffer.  <br /></td></tr>
<tr class="separator:a1f4fe7d19ac6072774e795b7d0dd0f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6009815139b407d20347dd3e2262e5ad" id="r_a6009815139b407d20347dd3e2262e5ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#a6009815139b407d20347dd3e2262e5ad">createVertexBuffer</a> (<a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">vertexSize</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">numVerts</a>, <a class="el" href="class_ogre_1_1_hardware_buffer.html#a81c7a563d8a33c8ef21fb70913412a17">HardwareBuffer::Usage</a> <a class="el" href="struct_ogre_1_1vector.html">usage</a>, <a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">useShadowBuffer</a>=<a class="el" href="struct_ogre_1_1vector.html">false</a>)=0</td></tr>
<tr class="memdesc:a6009815139b407d20347dd3e2262e5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hardware vertex buffer.  <br /></td></tr>
<tr class="separator:a6009815139b407d20347dd3e2262e5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5679f5b94e46d1f23c0983e7b4a629" id="r_a6b5679f5b94e46d1f23c0983e7b4a629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vertex_buffer_binding.html">VertexBufferBinding</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#a6b5679f5b94e46d1f23c0983e7b4a629">createVertexBufferBinding</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>)</td></tr>
<tr class="memdesc:a6b5679f5b94e46d1f23c0983e7b4a629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_ogre_1_1_vertex_buffer_binding.html" title="Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...">VertexBufferBinding</a>.  <br /></td></tr>
<tr class="separator:a6b5679f5b94e46d1f23c0983e7b4a629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fe7e6ead375c922356554f598528a5" id="r_af4fe7e6ead375c922356554f598528a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#af4fe7e6ead375c922356554f598528a5">createVertexDeclaration</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a>)</td></tr>
<tr class="memdesc:af4fe7e6ead375c922356554f598528a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vertex declaration.  <br /></td></tr>
<tr class="separator:af4fe7e6ead375c922356554f598528a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2868897d9a417b523f2fe9420f1e22" id="r_a7c2868897d9a417b523f2fe9420f1e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#a7c2868897d9a417b523f2fe9420f1e22">destroyVertexBufferBinding</a> (<a class="el" href="class_ogre_1_1_vertex_buffer_binding.html">VertexBufferBinding</a> *<a class="el" href="struct_ogre_1_1vector.html">binding</a>)</td></tr>
<tr class="memdesc:a7c2868897d9a417b523f2fe9420f1e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a <a class="el" href="class_ogre_1_1_vertex_buffer_binding.html" title="Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...">VertexBufferBinding</a>.  <br /></td></tr>
<tr class="separator:a7c2868897d9a417b523f2fe9420f1e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b729879133ff816e15f73e921c3b18" id="r_ae3b729879133ff816e15f73e921c3b18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#ae3b729879133ff816e15f73e921c3b18">destroyVertexDeclaration</a> (<a class="el" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a> *<a class="el" href="struct_ogre_1_1vector.html">decl</a>)</td></tr>
<tr class="memdesc:ae3b729879133ff816e15f73e921c3b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a vertex declaration.  <br /></td></tr>
<tr class="separator:ae3b729879133ff816e15f73e921c3b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca9ea14315ef17d74f6ab972d9a1ec8" id="r_acca9ea14315ef17d74f6ab972d9a1ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#acca9ea14315ef17d74f6ab972d9a1ec8">releaseVertexBufferCopy</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">bufferCopy</a>)</td></tr>
<tr class="memdesc:acca9ea14315ef17d74f6ab972d9a1ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually release a vertex buffer copy for others to subsequently use.  <br /></td></tr>
<tr class="separator:acca9ea14315ef17d74f6ab972d9a1ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab717df387ec6c1e119ed2ac0e2c9a54b" id="r_ab717df387ec6c1e119ed2ac0e2c9a54b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html#ab717df387ec6c1e119ed2ac0e2c9a54b">touchVertexBufferCopy</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">bufferCopy</a>)</td></tr>
<tr class="memdesc:ab717df387ec6c1e119ed2ac0e2c9a54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell engine that the vertex buffer copy intent to reuse.  <br /></td></tr>
<tr class="separator:ab717df387ec6c1e119ed2ac0e2c9a54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base definition of a hardware buffer manager. </p>
<p>This class is deliberately not a <a class="el" href="class_ogre_1_1_singleton.html" title="Template class for creating single-instance global classes.">Singleton</a>, so that multiple types can exist at once (notably <a class="el" href="class_ogre_1_1_default_hardware_buffer_manager_base.html" title="Specialisation of HardwareBufferManagerBase to emulate hardware buffers.">DefaultHardwareBufferManagerBase</a>). The <a class="el" href="class_ogre_1_1_singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> is add via the inheritance in <a class="el" href="class_ogre_1_1_hardware_buffer_manager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> below. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa1f5ef725fdeacc6018e1dee3b7eded5" name="aa1f5ef725fdeacc6018e1dee3b7eded5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f5ef725fdeacc6018e1dee3b7eded5">&#9670;&#160;</a></span>HardwareBufferManagerBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::HardwareBufferManagerBase::HardwareBufferManagerBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc50f8bac0fad6710aa205d0c4e295c4" name="abc50f8bac0fad6710aa205d0c4e295c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc50f8bac0fad6710aa205d0c4e295c4">&#9670;&#160;</a></span>~HardwareBufferManagerBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> Ogre::HardwareBufferManagerBase::~HardwareBufferManagerBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6009815139b407d20347dd3e2262e5ad" name="a6009815139b407d20347dd3e2262e5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6009815139b407d20347dd3e2262e5ad">&#9670;&#160;</a></span>createVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a> Ogre::HardwareBufferManagerBase::createVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>vertexSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>numVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a81c7a563d8a33c8ef21fb70913412a17">HardwareBuffer::Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em> = <code><a class="el" href="struct_ogre_1_1vector.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a hardware vertex buffer. </p>
<p>This method creates a new vertex buffer; this will act as a source of geometry data for rendering objects. Note that because the meaning of the contents of the vertex buffer depends on the usage, this method does not specify a vertex format; the user of this buffer can actually insert whatever data they wish, in any format. However, in order to use this with a <a class="el" href="class_ogre_1_1_render_operation.html" title="&#39;New&#39; rendering operation using vertex buffers.">RenderOperation</a>, the data in this vertex buffer will have to be associated with a semantic element of the rendering pipeline, e.g. a position, or texture coordinates. This is done using the <a class="el" href="class_ogre_1_1_vertex_declaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">VertexDeclaration</a> class, which itself contains <a class="el" href="class_ogre_1_1_vertex_element.html" title="This class declares the usage of a single vertex buffer as a component of a complete VertexDeclaratio...">VertexElement</a> structures referring to the source data. Note that because vertex buffers can be shared, they are reference counted so you do not need to worry about destroying them this will be done automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexSize</td><td>The size in bytes of each vertex in this buffer; you must calculate this based on the kind of data you expect to populate this buffer with. </td></tr>
    <tr><td class="paramname">numVerts</td><td>The number of vertices in this buffer. </td></tr>
    <tr><td class="paramname">usage</td><td>One or more members of the <a class="el" href="group___render_system.html#ga3e7bd12438696e8c75150be1fbe90532" title="Enums describing buffer usage.">HardwareBufferUsage</a> enumeration; you are strongly advised to use <a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532ad4ea5a32caed7bbb643f6536606dba64" title="Device-local GPU (video) memory.">HBU_GPU_ONLY</a> wherever possible, if you need to update regularly, consider <a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532acbb4350fbecafb42887765883469fe6f" title="Mappable on host and preferably fast to access by GPU.">HBU_CPU_TO_GPU</a> or useShadowBuffer=true. </td></tr>
    <tr><td class="paramname">useShadowBuffer</td><td>If set to <code>true</code>, this buffer will be 'shadowed' by one stored in system memory rather than GPU memory. See <a class="el" href="_hardware-_buffers.html#Shadow-Buffers">Shadow Buffers</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_ogre_1_1_default_hardware_buffer_manager_base.html#a5da8447cf5e6eb75756e392fcc8bf7fa">Ogre::DefaultHardwareBufferManagerBase</a>, and <a class="el" href="class_ogre_1_1_default_hardware_buffer_manager.html#a4705dd8822b0d33c17e1941572bd820d">Ogre::DefaultHardwareBufferManager</a>.</p>

</div>
</div>
<a id="ae46262b1cc1e8bfe136e9bb203894c41" name="ae46262b1cc1e8bfe136e9bb203894c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46262b1cc1e8bfe136e9bb203894c41">&#9670;&#160;</a></span>createIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="namespace_ogre.html#a54481042551b3b7ca50133fb287ef89f">HardwareIndexBufferSharedPtr</a> Ogre::HardwareBufferManagerBase::createIndexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_index_buffer.html#afc6252abb2231698e8a8f936105cc9f1">HardwareIndexBuffer::IndexType</a>&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>numIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer.html#a81c7a563d8a33c8ef21fb70913412a17">HardwareBuffer::Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em> = <code><a class="el" href="struct_ogre_1_1vector.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a hardware index buffer. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that because buffers can be shared, they are reference counted so you do not need to worry about destroying them this will be done automatically. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itype</td><td>The type in index, either 16- or 32-bit, depending on how many vertices you need to be able to address </td></tr>
    <tr><td class="paramname">numIndexes</td><td>The number of indexes in the buffer </td></tr>
    <tr><td class="paramname">usage</td><td>One or more members of the <a class="el" href="group___render_system.html#ga3e7bd12438696e8c75150be1fbe90532" title="Enums describing buffer usage.">HardwareBufferUsage</a> enumeration. </td></tr>
    <tr><td class="paramname">useShadowBuffer</td><td>If set to <code>true</code>, this buffer will be 'shadowed' by one stored in system memory rather than GPU memory. See <a class="el" href="_hardware-_buffers.html#Shadow-Buffers">Shadow Buffers</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_ogre_1_1_default_hardware_buffer_manager_base.html#a04cdef3c288888285d710c832f6d0084">Ogre::DefaultHardwareBufferManagerBase</a>, and <a class="el" href="class_ogre_1_1_default_hardware_buffer_manager.html#afcf18a21b65c0375d28c5686307a3eee">Ogre::DefaultHardwareBufferManager</a>.</p>

</div>
</div>
<a id="a4db6eed911de330dd6a83a7b77447a72" name="a4db6eed911de330dd6a83a7b77447a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db6eed911de330dd6a83a7b77447a72">&#9670;&#160;</a></span>createRenderToVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="namespace_ogre.html#a7e0bc377ed62eee5daa8987e28b2ce93">RenderToVertexBufferSharedPtr</a> Ogre::HardwareBufferManagerBase::createRenderToVertexBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a render to vertex buffer. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The parameters (such as vertex size etc) are determined later and are allocated when needed. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_default_hardware_buffer_manager.html#ad52b27601f52d5028d5f56e074e27d06">Ogre::DefaultHardwareBufferManager</a>.</p>

</div>
</div>
<a id="a1f4fe7d19ac6072774e795b7d0dd0f16" name="a1f4fe7d19ac6072774e795b7d0dd0f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4fe7d19ac6072774e795b7d0dd0f16">&#9670;&#160;</a></span>createUniformBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="namespace_ogre.html#a9140aec81d4c373ea427d72ca046d845">HardwareBufferPtr</a> Ogre::HardwareBufferManagerBase::createUniformBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___render_system.html#ga3e7bd12438696e8c75150be1fbe90532">HardwareBufferUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em> = <code><a class="el" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532acbb4350fbecafb42887765883469fe6f">HBU_CPU_TO_GPU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em> = <code><a class="el" href="struct_ogre_1_1vector.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create uniform buffer. </p>
<p>This type of buffer allows the upload of shader constants once, and sharing between shader stages or even shaders from another materials. The update shall be triggered by <a class="el" href="class_ogre_1_1_gpu_program_parameters.html" title="Collects together the program parameters used for a GpuProgram.">GpuProgramParameters</a>, if is dirty </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_default_hardware_buffer_manager.html#af224a816c521f8d7da2aa5c1e312f25b">Ogre::DefaultHardwareBufferManager</a>, and <a class="el" href="class_ogre_1_1_default_hardware_buffer_manager_base.html#add6e9073c2ef26aa9e739ed0c081c0f5">Ogre::DefaultHardwareBufferManagerBase</a>.</p>

</div>
</div>
<a id="af4fe7e6ead375c922356554f598528a5" name="af4fe7e6ead375c922356554f598528a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fe7e6ead375c922356554f598528a5">&#9670;&#160;</a></span>createVertexDeclaration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a> * Ogre::HardwareBufferManagerBase::createVertexDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new vertex declaration. </p>

</div>
</div>
<a id="ae3b729879133ff816e15f73e921c3b18" name="ae3b729879133ff816e15f73e921c3b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b729879133ff816e15f73e921c3b18">&#9670;&#160;</a></span>destroyVertexDeclaration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBufferManagerBase::destroyVertexDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a> *&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a vertex declaration. </p>

</div>
</div>
<a id="a6b5679f5b94e46d1f23c0983e7b4a629" name="a6b5679f5b94e46d1f23c0983e7b4a629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5679f5b94e46d1f23c0983e7b4a629">&#9670;&#160;</a></span>createVertexBufferBinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vertex_buffer_binding.html">VertexBufferBinding</a> * Ogre::HardwareBufferManagerBase::createVertexBufferBinding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_ogre_1_1_vertex_buffer_binding.html" title="Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...">VertexBufferBinding</a>. </p>

</div>
</div>
<a id="a7c2868897d9a417b523f2fe9420f1e22" name="a7c2868897d9a417b523f2fe9420f1e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2868897d9a417b523f2fe9420f1e22">&#9670;&#160;</a></span>destroyVertexBufferBinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBufferManagerBase::destroyVertexBufferBinding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vertex_buffer_binding.html">VertexBufferBinding</a> *&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a <a class="el" href="class_ogre_1_1_vertex_buffer_binding.html" title="Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...">VertexBufferBinding</a>. </p>

</div>
</div>
<a id="aa38acebabcc266b2afef7c8dff234a98" name="aa38acebabcc266b2afef7c8dff234a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38acebabcc266b2afef7c8dff234a98">&#9670;&#160;</a></span>allocateVertexBufferCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a> Ogre::HardwareBufferManagerBase::allocateVertexBufferCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer_licensee.html">HardwareBufferLicensee</a> *&#160;</td>
          <td class="paramname"><em>licensee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>copyData</em> = <code><a class="el" href="struct_ogre_1_1vector.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a copy of a given vertex buffer. </p>
<p>This method allocates a temporary copy of an existing vertex buffer. This buffer is subsequently stored and can be made available for other purposes later without incurring the cost of construction / destruction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceBuffer</td><td>The source buffer to use as a copy. </td></tr>
    <tr><td class="paramname">licensee</td><td>Pointer back to the class requesting the copy, which must implement HardwareBufferLicense in order to be notified when the license expires. </td></tr>
    <tr><td class="paramname">copyData</td><td>If <code>true</code>, the current data is copied as well as the structure of the buffer/ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acca9ea14315ef17d74f6ab972d9a1ec8" name="acca9ea14315ef17d74f6ab972d9a1ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca9ea14315ef17d74f6ab972d9a1ec8">&#9670;&#160;</a></span>releaseVertexBufferCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBufferManagerBase::releaseVertexBufferCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferCopy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually release a vertex buffer copy for others to subsequently use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferCopy</td><td>The buffer copy. The caller is expected to delete or at least no longer use this reference, since another user may well begin to modify the contents of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab717df387ec6c1e119ed2ac0e2c9a54b" name="ab717df387ec6c1e119ed2ac0e2c9a54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab717df387ec6c1e119ed2ac0e2c9a54b">&#9670;&#160;</a></span>touchVertexBufferCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBufferManagerBase::touchVertexBufferCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferCopy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell engine that the vertex buffer copy intent to reuse. </p>
<p><a class="el" href="namespace_ogre.html">Ogre</a> internal keep an expired delay counter. When the counter count down to zero, it'll release for other purposes later. But you can use this function to reset the counter to the internal configured value, keep the buffer not get released for some frames. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferCopy</td><td>The buffer copy. The caller is expected to keep this buffer copy for use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01c05c63b98f45df312660e724d95320" name="a01c05c63b98f45df312660e724d95320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c05c63b98f45df312660e724d95320">&#9670;&#160;</a></span>_freeUnusedBufferCopies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBufferManagerBase::_freeUnusedBufferCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all unused vertex buffer copies. </p>
<p>This method free all temporary vertex buffers that not in used. In normally, temporary vertex buffers are subsequently stored and can be made available for other purposes later without incurring the cost of construction / destruction. But in some cases you want to free them to save hardware memory (e.g. application was runs in a long time, you might free temporary buffers periodically to avoid memory overload). </p>

</div>
</div>
<a id="a5551674a13abf8d3458d2798e58d7cd9" name="a5551674a13abf8d3458d2798e58d7cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5551674a13abf8d3458d2798e58d7cd9">&#9670;&#160;</a></span>_releaseBufferCopies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBufferManagerBase::_releaseBufferCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>forceFreeUnused</em> = <code><a class="el" href="struct_ogre_1_1vector.html">false</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for releasing all temporary buffers; is called by OGRE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forceFreeUnused</td><td>If <code>true</code>, free all unused temporary buffers. If <code>false</code>, auto detect and free all unused temporary buffers based on temporary buffers utilization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a876ce18832783cd168f4e55d989c3f1c" name="a876ce18832783cd168f4e55d989c3f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876ce18832783cd168f4e55d989c3f1c">&#9670;&#160;</a></span>_forceReleaseBufferCopies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBufferManagerBase::_forceReleaseBufferCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method that forces the release of copies of a given buffer. </p>
<p>This usually means that the buffer which the copies are based on has been changed in some fundamental way, and the owner of the original wishes to make that known so that new copies will reflect the changes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceBuffer</td><td>The source buffer as a shared pointer. <a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> buffer copies created from the source buffer are deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29b2e243bab8522ae27ec23268ea154a" name="a29b2e243bab8522ae27ec23268ea154a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b2e243bab8522ae27ec23268ea154a">&#9670;&#160;</a></span>_notifyVertexBufferDestroyed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::HardwareBufferManagerBase::_notifyVertexBufferDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_vertex_buffer.html">HardwareVertexBuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notification that a hardware vertex buffer has been destroyed. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_hardware_buffer_manager_8h.html">OgreHardwareBufferManager.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
