<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::StreamSerialiser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;14.4</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_stream_serialiser.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_stream_serialiser-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::StreamSerialiser Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___resources.html">Resources</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Utility class providing helper methods for reading / writing structured data held in a <a class="el" href="class_ogre_1_1_data_stream.html" title="General purpose class used for encapsulating the reading and writing of data.">DataStream</a>.  
 <a href="class_ogre_1_1_stream_serialiser.html#details">More...</a></p>

<p><code>#include &lt;OgreStreamSerialiser.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::StreamSerialiser:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_stream_serialiser__inherit__graph.svg" width="180" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html">Chunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a chunk of data in a file.  <a href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a072077ff56678e964608a7451db7c3f0" id="r_a072077ff56678e964608a7451db7c3f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a072077ff56678e964608a7451db7c3f0">Endian</a> { <a class="el" href="class_ogre_1_1_stream_serialiser.html#a072077ff56678e964608a7451db7c3f0a921fa6c4bf1316b54e0877ad1e983c9c">ENDIAN_AUTO</a>
, <a class="el" href="class_ogre_1_1_stream_serialiser.html#a072077ff56678e964608a7451db7c3f0afa17cf3b68b6464762f03423afc83d6e">ENDIAN_BIG</a>
, <a class="el" href="class_ogre_1_1_stream_serialiser.html#a072077ff56678e964608a7451db7c3f0a344ebede556d120f89fbfd35b544a0fb">ENDIAN_LITTLE</a>
 }</td></tr>
<tr class="memdesc:a072077ff56678e964608a7451db7c3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endianness of files.  <a href="class_ogre_1_1_stream_serialiser.html#a072077ff56678e964608a7451db7c3f0">More...</a><br /></td></tr>
<tr class="separator:a072077ff56678e964608a7451db7c3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf4285399b89b088f2f297dda10fc91" id="r_a6cf4285399b89b088f2f297dda10fc91"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a6cf4285399b89b088f2f297dda10fc91">RealStorageFormat</a> { <a class="el" href="class_ogre_1_1_stream_serialiser.html#a6cf4285399b89b088f2f297dda10fc91ae3bcbc915c3187091bf95f1e7426a837">REAL_FLOAT</a>
, <a class="el" href="class_ogre_1_1_stream_serialiser.html#a6cf4285399b89b088f2f297dda10fc91a2b594a33ac97bd7a0cc2d9047e2b1912">REAL_DOUBLE</a>
 }</td></tr>
<tr class="memdesc:a6cf4285399b89b088f2f297dda10fc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">The storage format of Real values.  <a href="class_ogre_1_1_stream_serialiser.html#a6cf4285399b89b088f2f297dda10fc91">More...</a><br /></td></tr>
<tr class="separator:a6cf4285399b89b088f2f297dda10fc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f33fe43504c631349b4a4c6244525b1" id="r_a6f33fe43504c631349b4a4c6244525b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a6f33fe43504c631349b4a4c6244525b1">StreamSerialiser</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;stream, <a class="el" href="class_ogre_1_1_stream_serialiser.html#a072077ff56678e964608a7451db7c3f0">Endian</a> <a class="el" href="struct_ogre_1_1vector.html">endianMode</a>=<a class="el" href="class_ogre_1_1_stream_serialiser.html#a072077ff56678e964608a7451db7c3f0a921fa6c4bf1316b54e0877ad1e983c9c">ENDIAN_AUTO</a>, <a class="el" href="struct_ogre_1_1vector.html">bool</a> <a class="el" href="struct_ogre_1_1vector.html">autoHeader</a>=<a class="el" href="struct_ogre_1_1vector.html">true</a>, <a class="el" href="class_ogre_1_1_stream_serialiser.html#a6cf4285399b89b088f2f297dda10fc91">RealStorageFormat</a> <a class="el" href="struct_ogre_1_1vector.html">realFormat</a>=<a class="el" href="class_ogre_1_1_stream_serialiser.html#a6cf4285399b89b088f2f297dda10fc91ae3bcbc915c3187091bf95f1e7426a837">REAL_FLOAT</a>)</td></tr>
<tr class="memdesc:a6f33fe43504c631349b4a4c6244525b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a6f33fe43504c631349b4a4c6244525b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6469d16380285e935ad31ab9c1807f43" id="r_a6469d16380285e935ad31ab9c1807f43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a6469d16380285e935ad31ab9c1807f43">~StreamSerialiser</a> ()</td></tr>
<tr class="separator:a6469d16380285e935ad31ab9c1807f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fa5f5b426eecb48246039f397befab" id="r_aa0fa5f5b426eecb48246039f397befab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#aa0fa5f5b426eecb48246039f397befab">eof</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:aa0fa5f5b426eecb48246039f397befab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the stream is at the end of file.  <br /></td></tr>
<tr class="separator:aa0fa5f5b426eecb48246039f397befab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880c33bffd02ac88cf7378a06ff4785b" id="r_a880c33bffd02ac88cf7378a06ff4785b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html">Chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a880c33bffd02ac88cf7378a06ff4785b">getCurrentChunk</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a880c33bffd02ac88cf7378a06ff4785b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the definition of the current chunk being read (if any).  <br /></td></tr>
<tr class="separator:a880c33bffd02ac88cf7378a06ff4785b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae287158dbf1c109012cb165bfc0cf1e8" id="r_ae287158dbf1c109012cb165bfc0cf1e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#ae287158dbf1c109012cb165bfc0cf1e8">getCurrentChunkDepth</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:ae287158dbf1c109012cb165bfc0cf1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the current depth of the chunk nesting, whether reading or writing.  <br /></td></tr>
<tr class="separator:ae287158dbf1c109012cb165bfc0cf1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517e99ed59380c90a1d29caf5d34df67" id="r_a517e99ed59380c90a1d29caf5d34df67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a517e99ed59380c90a1d29caf5d34df67">getCurrentChunkID</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a517e99ed59380c90a1d29caf5d34df67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of the chunk that's currently being read/written, if any.  <br /></td></tr>
<tr class="separator:a517e99ed59380c90a1d29caf5d34df67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771fae398bd7b30a02ce9343d3de0792" id="r_a771fae398bd7b30a02ce9343d3de0792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="class_ogre_1_1_stream_serialiser.html#a072077ff56678e964608a7451db7c3f0">Endian</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a771fae398bd7b30a02ce9343d3de0792">getEndian</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:a771fae398bd7b30a02ce9343d3de0792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the endian mode.  <br /></td></tr>
<tr class="separator:a771fae398bd7b30a02ce9343d3de0792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63f3833de85040c420f1d9355b2bb52" id="r_aa63f3833de85040c420f1d9355b2bb52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#aa63f3833de85040c420f1d9355b2bb52">getOffsetFromChunkStart</a> () <a class="el" href="struct_ogre_1_1vector.html">const</a></td></tr>
<tr class="memdesc:aa63f3833de85040c420f1d9355b2bb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current byte position relative to the start of the data section of the last chunk that was read or written.  <br /></td></tr>
<tr class="separator:aa63f3833de85040c420f1d9355b2bb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81be1455eacc97d5fcd1df06cbe1b93" id="r_ad81be1455eacc97d5fcd1df06cbe1b93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#ad81be1455eacc97d5fcd1df06cbe1b93">isEndOfChunk</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> id)</td></tr>
<tr class="memdesc:ad81be1455eacc97d5fcd1df06cbe1b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the current data pointer is at the end of the current chunk.  <br /></td></tr>
<tr class="separator:ad81be1455eacc97d5fcd1df06cbe1b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e27e1fff17725bb9970d9ad81cfb39" id="r_aa5e27e1fff17725bb9970d9ad81cfb39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#aa5e27e1fff17725bb9970d9ad81cfb39">peekNextChunkID</a> ()</td></tr>
<tr class="memdesc:aa5e27e1fff17725bb9970d9ad81cfb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this to 'peek' at the next chunk ID without permanently moving the stream pointer.  <br /></td></tr>
<tr class="separator:aa5e27e1fff17725bb9970d9ad81cfb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32788255718a172dd040cf6766e8e32a" id="r_a32788255718a172dd040cf6766e8e32a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a32788255718a172dd040cf6766e8e32a">read</a> (<a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> *aabb, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a32788255718a172dd040cf6766e8e32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fe1551fa5a1dc26317c9b57b8ef1f6" id="r_af8fe1551fa5a1dc26317c9b57b8ef1f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#af8fe1551fa5a1dc26317c9b57b8ef1f6">read</a> (<a class="el" href="struct_ogre_1_1vector.html">bool</a> *val, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:af8fe1551fa5a1dc26317c9b57b8ef1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3af44ad9ac9d841ec5e15d4c6856f3" id="r_a9a3af44ad9ac9d841ec5e15d4c6856f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a9a3af44ad9ac9d841ec5e15d4c6856f3">read</a> (<a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> *m, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a9a3af44ad9ac9d841ec5e15d4c6856f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28eec6a458dd2f02a8849a51dc107dcf" id="r_a28eec6a458dd2f02a8849a51dc107dcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a28eec6a458dd2f02a8849a51dc107dcf">read</a> (<a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> *m, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a28eec6a458dd2f02a8849a51dc107dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e45523a0409077bbcab706ef0a58f64" id="r_a5e45523a0409077bbcab706ef0a58f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a5e45523a0409077bbcab706ef0a58f64">read</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *<a class="el" href="struct_ogre_1_1vector.html">node</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a5e45523a0409077bbcab706ef0a58f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a44458396fa2170fa8858a0328fa97" id="r_a85a44458396fa2170fa8858a0328fa97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a85a44458396fa2170fa8858a0328fa97">read</a> (<a class="el" href="class_ogre_1_1_plane.html">Plane</a> *plane, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a85a44458396fa2170fa8858a0328fa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3173c30a36415d10b4daf6e130953e0e" id="r_a3173c30a36415d10b4daf6e130953e0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a3173c30a36415d10b4daf6e130953e0e">read</a> (<a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> *<a class="el" href="struct_ogre_1_1vector.html">q</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a3173c30a36415d10b4daf6e130953e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da61d9cfea11fa94aef4b3ea1a81eae" id="r_a8da61d9cfea11fa94aef4b3ea1a81eae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a8da61d9cfea11fa94aef4b3ea1a81eae">read</a> (<a class="el" href="class_ogre_1_1_radian.html">Radian</a> *<a class="el" href="struct_ogre_1_1vector.html">angle</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a8da61d9cfea11fa94aef4b3ea1a81eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838c7aea842143bcf54d82d3fe085efe" id="r_a838c7aea842143bcf54d82d3fe085efe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a838c7aea842143bcf54d82d3fe085efe">read</a> (<a class="el" href="class_ogre_1_1_ray.html">Ray</a> *<a class="el" href="struct_ogre_1_1vector.html">ray</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a838c7aea842143bcf54d82d3fe085efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bcb952e488697f41786e1156c00979" id="r_a46bcb952e488697f41786e1156c00979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a46bcb952e488697f41786e1156c00979">read</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> *val, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a46bcb952e488697f41786e1156c00979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242f3491c47852b53b0b689edfc25e4c" id="r_a242f3491c47852b53b0b689edfc25e4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a242f3491c47852b53b0b689edfc25e4c">read</a> (<a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> *<a class="el" href="struct_ogre_1_1vector.html">sphere</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a242f3491c47852b53b0b689edfc25e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa930c1889b253433b459176426795627" id="r_aa930c1889b253433b459176426795627"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#aa930c1889b253433b459176426795627">read</a> (<a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> *<a class="el" href="struct_ogre_1_1vector.html">string</a>)</td></tr>
<tr class="separator:aa930c1889b253433b459176426795627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a8e8540b453b8428992c0c6c599995" id="r_a72a8e8540b453b8428992c0c6c599995"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="struct_ogre_1_1vector.html">typename</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </td></tr>
<tr class="memitem:a72a8e8540b453b8428992c0c6c599995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a72a8e8540b453b8428992c0c6c599995">read</a> (<a class="el" href="struct_ogre_1_1vector.html">T</a> *<a class="el" href="struct_ogre_1_1vector.html">pT</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="memdesc:a72a8e8540b453b8428992c0c6c599995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Catch-all method to read primitive types.  <br /></td></tr>
<tr class="separator:a72a8e8540b453b8428992c0c6c599995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273eb21bd429c3a1dc4ac6981bea7c6b" id="r_a273eb21bd429c3a1dc4ac6981bea7c6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a273eb21bd429c3a1dc4ac6981bea7c6b">read</a> (<a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> *<a class="el" href="struct_ogre_1_1vector.html">vec</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="memdesc:a273eb21bd429c3a1dc4ac6981bea7c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a Vector3  <br /></td></tr>
<tr class="separator:a273eb21bd429c3a1dc4ac6981bea7c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f557c549a65a20e76e605f9bf9fe4c9" id="r_a5f557c549a65a20e76e605f9bf9fe4c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a5f557c549a65a20e76e605f9bf9fe4c9">read</a> (<a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> *<a class="el" href="struct_ogre_1_1vector.html">vec</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a5f557c549a65a20e76e605f9bf9fe4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0e00b95f550cc324cbb5fef1a3766b" id="r_aee0e00b95f550cc324cbb5fef1a3766b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#aee0e00b95f550cc324cbb5fef1a3766b">read</a> (<a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> *<a class="el" href="struct_ogre_1_1vector.html">vec</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:aee0e00b95f550cc324cbb5fef1a3766b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea616ff03daa17c34ac1e38682a501c2" id="r_aea616ff03daa17c34ac1e38682a501c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html">Chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#aea616ff03daa17c34ac1e38682a501c2">readChunkBegin</a> ()</td></tr>
<tr class="memdesc:aea616ff03daa17c34ac1e38682a501c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of the next chunk in the file.  <br /></td></tr>
<tr class="separator:aea616ff03daa17c34ac1e38682a501c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae955dfcf39b9a0d7407289e2073d45e0" id="r_ae955dfcf39b9a0d7407289e2073d45e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html">Chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#ae955dfcf39b9a0d7407289e2073d45e0">readChunkBegin</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> id, <a class="el" href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">uint16</a> <a class="el" href="struct_ogre_1_1vector.html">maxVersion</a>, <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;<a class="el" href="struct_ogre_1_1vector.html">msg</a>=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>)</td></tr>
<tr class="memdesc:ae955dfcf39b9a0d7407289e2073d45e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of the next chunk so long as it's of a given ID and version.  <br /></td></tr>
<tr class="separator:ae955dfcf39b9a0d7407289e2073d45e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b3a9ad5caea2da65b36a07816f968e" id="r_a97b3a9ad5caea2da65b36a07816f968e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a97b3a9ad5caea2da65b36a07816f968e">readChunkEnd</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> id)</td></tr>
<tr class="memdesc:a97b3a9ad5caea2da65b36a07816f968e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish the reading of a chunk.  <br /></td></tr>
<tr class="separator:a97b3a9ad5caea2da65b36a07816f968e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9cd8abb22fbd17c795aa62765b4a59" id="r_a2d9cd8abb22fbd17c795aa62765b4a59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a2d9cd8abb22fbd17c795aa62765b4a59">readData</a> (<a class="el" href="struct_ogre_1_1vector.html">void</a> *buf, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> size, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>)</td></tr>
<tr class="memdesc:a2d9cd8abb22fbd17c795aa62765b4a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read arbitrary data from a stream.  <br /></td></tr>
<tr class="separator:a2d9cd8abb22fbd17c795aa62765b4a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c4b6be63560e6f2ab0b647fe797175" id="r_aa9c4b6be63560e6f2ab0b647fe797175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#aa9c4b6be63560e6f2ab0b647fe797175">startDeflate</a> (<a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">avail_in</a>=0)</td></tr>
<tr class="memdesc:aa9c4b6be63560e6f2ab0b647fe797175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start (un)compressing data.  <br /></td></tr>
<tr class="separator:aa9c4b6be63560e6f2ab0b647fe797175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16f0772431b3939250062d61957189d" id="r_ac16f0772431b3939250062d61957189d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#ac16f0772431b3939250062d61957189d">stopDeflate</a> ()</td></tr>
<tr class="memdesc:ac16f0772431b3939250062d61957189d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop (un)compressing data.  <br /></td></tr>
<tr class="separator:ac16f0772431b3939250062d61957189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac94278ebfddb581f5e73838f573c9cd" id="r_aac94278ebfddb581f5e73838f573c9cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#aac94278ebfddb581f5e73838f573c9cd">undoReadChunk</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> id)</td></tr>
<tr class="memdesc:aac94278ebfddb581f5e73838f573c9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this to 'rewind' the stream to just before the start of the current chunk.  <br /></td></tr>
<tr class="separator:aac94278ebfddb581f5e73838f573c9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6731deffcb48fa5b78422e4f955f5f93" id="r_a6731deffcb48fa5b78422e4f955f5f93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a6731deffcb48fa5b78422e4f955f5f93">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> *aabb, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a6731deffcb48fa5b78422e4f955f5f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4397c12bc7f970bd559d0d24a0116b36" id="r_a4397c12bc7f970bd559d0d24a0116b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a4397c12bc7f970bd559d0d24a0116b36">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">bool</a> *<a class="el" href="struct_ogre_1_1vector.html">boolean</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a4397c12bc7f970bd559d0d24a0116b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6430b8559a0b559d3eefaebef786759e" id="r_a6430b8559a0b559d3eefaebef786759e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a6430b8559a0b559d3eefaebef786759e">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> *m, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a6430b8559a0b559d3eefaebef786759e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffe90cc7b051f0f56faccc739988cea" id="r_a0ffe90cc7b051f0f56faccc739988cea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a0ffe90cc7b051f0f56faccc739988cea">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> *m, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a0ffe90cc7b051f0f56faccc739988cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456b335842b528abb03c953049cac7ad" id="r_a456b335842b528abb03c953049cac7ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a456b335842b528abb03c953049cac7ad">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_node.html">Node</a> *<a class="el" href="struct_ogre_1_1vector.html">node</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a456b335842b528abb03c953049cac7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d289d76cc669fd1ade3ef05fa48bd21" id="r_a0d289d76cc669fd1ade3ef05fa48bd21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a0d289d76cc669fd1ade3ef05fa48bd21">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_plane.html">Plane</a> *plane, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a0d289d76cc669fd1ade3ef05fa48bd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53163836004961bea4bb7ab73819b322" id="r_a53163836004961bea4bb7ab73819b322"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a53163836004961bea4bb7ab73819b322">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> *<a class="el" href="struct_ogre_1_1vector.html">q</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a53163836004961bea4bb7ab73819b322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d03ff4a8aedc9e28412dc25fa48027" id="r_a79d03ff4a8aedc9e28412dc25fa48027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a79d03ff4a8aedc9e28412dc25fa48027">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_radian.html">Radian</a> *<a class="el" href="struct_ogre_1_1vector.html">angle</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a79d03ff4a8aedc9e28412dc25fa48027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad453d94c2cc1ebd6a13d2571ee8d5456" id="r_ad453d94c2cc1ebd6a13d2571ee8d5456"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#ad453d94c2cc1ebd6a13d2571ee8d5456">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_ray.html">Ray</a> *<a class="el" href="struct_ogre_1_1vector.html">ray</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:ad453d94c2cc1ebd6a13d2571ee8d5456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596a55c0496333afcfa6af3e51e36e64" id="r_a596a55c0496333afcfa6af3e51e36e64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a596a55c0496333afcfa6af3e51e36e64">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> *val, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a596a55c0496333afcfa6af3e51e36e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5435ad86ff5851f9012191d3b5179a55" id="r_a5435ad86ff5851f9012191d3b5179a55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a5435ad86ff5851f9012191d3b5179a55">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> *<a class="el" href="struct_ogre_1_1vector.html">sphere</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a5435ad86ff5851f9012191d3b5179a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82759066f35c8cb08e24ce4357c747c7" id="r_a82759066f35c8cb08e24ce4357c747c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a82759066f35c8cb08e24ce4357c747c7">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> *<a class="el" href="struct_ogre_1_1vector.html">string</a>)</td></tr>
<tr class="separator:a82759066f35c8cb08e24ce4357c747c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aae82219abe1e37ea5f1c1adf8bdd1c" id="r_a2aae82219abe1e37ea5f1c1adf8bdd1c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="struct_ogre_1_1vector.html">typename</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </td></tr>
<tr class="memitem:a2aae82219abe1e37ea5f1c1adf8bdd1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a2aae82219abe1e37ea5f1c1adf8bdd1c">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> *<a class="el" href="struct_ogre_1_1vector.html">pT</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="memdesc:a2aae82219abe1e37ea5f1c1adf8bdd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Catch-all method to write primitive types.  <br /></td></tr>
<tr class="separator:a2aae82219abe1e37ea5f1c1adf8bdd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ac46edf43d39927816e34b1a0d983c" id="r_a60ac46edf43d39927816e34b1a0d983c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a60ac46edf43d39927816e34b1a0d983c">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> *<a class="el" href="struct_ogre_1_1vector.html">vec</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a60ac46edf43d39927816e34b1a0d983c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada08984a52a07febc6ddd531c60adbd6" id="r_ada08984a52a07febc6ddd531c60adbd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#ada08984a52a07febc6ddd531c60adbd6">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> *<a class="el" href="struct_ogre_1_1vector.html">vec</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:ada08984a52a07febc6ddd531c60adbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994f2de1f0d13f674b6946b2490c225a" id="r_a994f2de1f0d13f674b6946b2490c225a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a994f2de1f0d13f674b6946b2490c225a">write</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> *<a class="el" href="struct_ogre_1_1vector.html">vec</a>, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>=1)</td></tr>
<tr class="separator:a994f2de1f0d13f674b6946b2490c225a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f031773228cdd832db5c52e7e0ea72" id="r_a49f031773228cdd832db5c52e7e0ea72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a49f031773228cdd832db5c52e7e0ea72">writeChunkBegin</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> id, <a class="el" href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">uint16</a> version=1)</td></tr>
<tr class="memdesc:a49f031773228cdd832db5c52e7e0ea72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin writing a new chunk.  <br /></td></tr>
<tr class="separator:a49f031773228cdd832db5c52e7e0ea72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dbda6a8b282814f3eabcaed6f86abc" id="r_ad7dbda6a8b282814f3eabcaed6f86abc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#ad7dbda6a8b282814f3eabcaed6f86abc">writeChunkEnd</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> id)</td></tr>
<tr class="memdesc:ad7dbda6a8b282814f3eabcaed6f86abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">End writing a chunk.  <br /></td></tr>
<tr class="separator:ad7dbda6a8b282814f3eabcaed6f86abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192b4339d7d5ba458824751e01575d92" id="r_a192b4339d7d5ba458824751e01575d92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a192b4339d7d5ba458824751e01575d92">writeData</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> *buf, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> size, <a class="el" href="struct_ogre_1_1vector.html">size_t</a> <a class="el" href="struct_ogre_1_1vector.html">count</a>)</td></tr>
<tr class="memdesc:a192b4339d7d5ba458824751e01575d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write arbitrary data to a stream.  <br /></td></tr>
<tr class="separator:a192b4339d7d5ba458824751e01575d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad1ba4ab9614504d8028c4d2754ca3315" id="r_ad1ba4ab9614504d8028c4d2754ca3315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_stream_serialiser.html#ad1ba4ab9614504d8028c4d2754ca3315">makeIdentifier</a> (<a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">char</a>(&amp;code)[5])</td></tr>
<tr class="memdesc:ad1ba4ab9614504d8028c4d2754ca3315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a 4-character code into a 32-bit identifier.  <br /></td></tr>
<tr class="separator:ad1ba4ab9614504d8028c4d2754ca3315"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility class providing helper methods for reading / writing structured data held in a <a class="el" href="class_ogre_1_1_data_stream.html" title="General purpose class used for encapsulating the reading and writing of data.">DataStream</a>. </p>
<p>The structure of a file read / written by this class is a series of 'chunks'. A chunk-based format has the advantage of being extensible later, and it's robust, in that a reader can skip chunks that they are not able (or willing) to process. </p><dl class="section user"><dt></dt><dd>Chunks are contained serially in the file, but they can also be nested in order both to provide context, and to group chunks together for potential skipping. </dd></dl>
<dl class="section user"><dt></dt><dd>The data format of a chunk is as follows:<ol type="1">
<li><a class="el" href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html" title="Definition of a chunk of data in a file.">Chunk</a> ID (32-bit uint). This can be any number unique in a context, except the numbers 0x0000, 0x0001 and 0x1000, which are reserved for <a class="el" href="namespace_ogre.html">Ogre</a>'s use</li>
<li><a class="el" href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html" title="Definition of a chunk of data in a file.">Chunk</a> version (16-bit uint). Chunks can change over time so this version number reflects that</li>
<li>Length (32-bit uint). The length of the chunk data section, including nested chunks. Note that this length excludes this header, but includes the header of any nested chunks.</li>
<li>Checksum (32-bit uint). Checksum value generated from the above - basically lets us check this is a valid chunk.</li>
<li><a class="el" href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html" title="Definition of a chunk of data in a file.">Chunk</a> data The '<a class="el" href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html" title="Definition of a chunk of data in a file.">Chunk</a> data' section will contain chunk-specific data, which may include other nested chunks. </li>
</ol>
</dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a072077ff56678e964608a7451db7c3f0" name="a072077ff56678e964608a7451db7c3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072077ff56678e964608a7451db7c3f0">&#9670;&#160;</a></span>Endian</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">enum</a> <a class="el" href="class_ogre_1_1_stream_serialiser.html#a072077ff56678e964608a7451db7c3f0">Ogre::StreamSerialiser::Endian</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The endianness of files. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a072077ff56678e964608a7451db7c3f0a921fa6c4bf1316b54e0877ad1e983c9c" name="a072077ff56678e964608a7451db7c3f0a921fa6c4bf1316b54e0877ad1e983c9c"></a>ENDIAN_AUTO&#160;</td><td class="fielddoc"><p>Automatically determine endianness. </p>
</td></tr>
<tr><td class="fieldname"><a id="a072077ff56678e964608a7451db7c3f0afa17cf3b68b6464762f03423afc83d6e" name="a072077ff56678e964608a7451db7c3f0afa17cf3b68b6464762f03423afc83d6e"></a>ENDIAN_BIG&#160;</td><td class="fielddoc"><p>Use big endian (0x1000 is serialised as 0x10 0x00) </p>
</td></tr>
<tr><td class="fieldname"><a id="a072077ff56678e964608a7451db7c3f0a344ebede556d120f89fbfd35b544a0fb" name="a072077ff56678e964608a7451db7c3f0a344ebede556d120f89fbfd35b544a0fb"></a>ENDIAN_LITTLE&#160;</td><td class="fielddoc"><p>Use little endian (0x1000 is serialised as 0x00 0x10) </p>
</td></tr>
</table>

</div>
</div>
<a id="a6cf4285399b89b088f2f297dda10fc91" name="a6cf4285399b89b088f2f297dda10fc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf4285399b89b088f2f297dda10fc91">&#9670;&#160;</a></span>RealStorageFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">enum</a> <a class="el" href="class_ogre_1_1_stream_serialiser.html#a6cf4285399b89b088f2f297dda10fc91">Ogre::StreamSerialiser::RealStorageFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The storage format of Real values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6cf4285399b89b088f2f297dda10fc91ae3bcbc915c3187091bf95f1e7426a837" name="a6cf4285399b89b088f2f297dda10fc91ae3bcbc915c3187091bf95f1e7426a837"></a>REAL_FLOAT&#160;</td><td class="fielddoc"><p>Real is stored as float, reducing precision if you're using OGRE_DOUBLE_PRECISION. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6cf4285399b89b088f2f297dda10fc91a2b594a33ac97bd7a0cc2d9047e2b1912" name="a6cf4285399b89b088f2f297dda10fc91a2b594a33ac97bd7a0cc2d9047e2b1912"></a>REAL_DOUBLE&#160;</td><td class="fielddoc"><p>Real as stored as double, not useful unless you're using OGRE_DOUBLE_PRECISION. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6f33fe43504c631349b4a4c6244525b1" name="a6f33fe43504c631349b4a4c6244525b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f33fe43504c631349b4a4c6244525b1">&#9670;&#160;</a></span>StreamSerialiser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::StreamSerialiser::StreamSerialiser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a072077ff56678e964608a7451db7c3f0">Endian</a>&#160;</td>
          <td class="paramname"><em>endianMode</em> = <code><a class="el" href="class_ogre_1_1_stream_serialiser.html#a072077ff56678e964608a7451db7c3f0a921fa6c4bf1316b54e0877ad1e983c9c">ENDIAN_AUTO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a>&#160;</td>
          <td class="paramname"><em>autoHeader</em> = <code><a class="el" href="struct_ogre_1_1vector.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_stream_serialiser.html#a6cf4285399b89b088f2f297dda10fc91">RealStorageFormat</a>&#160;</td>
          <td class="paramname"><em>realFormat</em> = <code><a class="el" href="class_ogre_1_1_stream_serialiser.html#a6cf4285399b89b088f2f297dda10fc91ae3bcbc915c3187091bf95f1e7426a837">REAL_FLOAT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream on which you will read / write data. </td></tr>
    <tr><td class="paramname">endianMode</td><td>The endian mode in which to read / writedata. If left at the default, when writing the endian mode will be the native platform mode, and when reading it's expected that the first chunk encountered will be the header chunk, which will determine the endian mode. </td></tr>
    <tr><td class="paramname">autoHeader</td><td>If true, the first write or read to this stream will automatically read / write the header too. This is required if you set endianMode to ENDIAN_AUTO, but if you manually set the endian mode, then you can skip writing / reading the header if you wish, if for example this stream is midway through a file which has already included header information. </td></tr>
    <tr><td class="paramname">realFormat</td><td>Set the format you want to write reals in. Only useful for files that you're writing (since when reading this is picked up from the file), and can only be changed if autoHeader is true, since real format is stored in the header. Defaults to float unless you're using OGRE_DOUBLE_PRECISION. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6469d16380285e935ad31ab9c1807f43" name="a6469d16380285e935ad31ab9c1807f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6469d16380285e935ad31ab9c1807f43">&#9670;&#160;</a></span>~StreamSerialiser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> Ogre::StreamSerialiser::~StreamSerialiser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a771fae398bd7b30a02ce9343d3de0792" name="a771fae398bd7b30a02ce9343d3de0792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771fae398bd7b30a02ce9343d3de0792">&#9670;&#160;</a></span>getEndian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="class_ogre_1_1_stream_serialiser.html#a072077ff56678e964608a7451db7c3f0">Endian</a> Ogre::StreamSerialiser::getEndian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the endian mode. </p>
<p>If the result is ENDIAN_AUTO, this mode will change when the first piece of data is read / written. </p>

</div>
</div>
<a id="ad1ba4ab9614504d8028c4d2754ca3315" name="ad1ba4ab9614504d8028c4d2754ca3315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ba4ab9614504d8028c4d2754ca3315">&#9670;&#160;</a></span>makeIdentifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">static</a> <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> Ogre::StreamSerialiser::makeIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">char</a>(&amp;)&#160;</td>
          <td class="paramname"><em>code</em>[5]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a 4-character code into a 32-bit identifier. </p>
<p>You can use this to generate id's for your chunks based on friendlier 4-character codes rather than assigning numerical IDs, if you like. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>String to pack - must be 4 characters and '\0' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae287158dbf1c109012cb165bfc0cf1e8" name="ae287158dbf1c109012cb165bfc0cf1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae287158dbf1c109012cb165bfc0cf1e8">&#9670;&#160;</a></span>getCurrentChunkDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">size_t</a> Ogre::StreamSerialiser::getCurrentChunkDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report the current depth of the chunk nesting, whether reading or writing. </p>
<p>Returns how many levels of nested chunks are currently being processed, either writing or reading. In order to tidily finish, you must call read/writeChunkEnd this many times. </p>

</div>
</div>
<a id="a517e99ed59380c90a1d29caf5d34df67" name="a517e99ed59380c90a1d29caf5d34df67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517e99ed59380c90a1d29caf5d34df67">&#9670;&#160;</a></span>getCurrentChunkID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> Ogre::StreamSerialiser::getCurrentChunkID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ID of the chunk that's currently being read/written, if any. </p>
<dl class="section return"><dt>Returns</dt><dd>The id of the current chunk being read / written (at the tightest level of nesting), or zero if no chunk is being processed. </dd></dl>

</div>
</div>
<a id="aa63f3833de85040c420f1d9355b2bb52" name="aa63f3833de85040c420f1d9355b2bb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63f3833de85040c420f1d9355b2bb52">&#9670;&#160;</a></span>getOffsetFromChunkStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">size_t</a> Ogre::StreamSerialiser::getOffsetFromChunkStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current byte position relative to the start of the data section of the last chunk that was read or written. </p>
<dl class="section return"><dt>Returns</dt><dd>the offset. Note that a return value of 0 means that either the position is at the start of the chunk data section (ie right after the header), or that no chunk is currently active. Use getCurrentChunkID or getCurrentChunkDepth to determine if a chunk is active. </dd></dl>

</div>
</div>
<a id="aea616ff03daa17c34ac1e38682a501c2" name="aea616ff03daa17c34ac1e38682a501c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea616ff03daa17c34ac1e38682a501c2">&#9670;&#160;</a></span>readChunkBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html">Chunk</a> * Ogre::StreamSerialiser::readChunkBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the start of the next chunk in the file. </p>
<p>Files are serialised in a chunk-based manner, meaning that each section of data is prepended by a chunk header. After reading this chunk header, the next set of data is available directly afterwards. </p><dl class="section note"><dt>Note</dt><dd>When you have finished with this chunk, you should call readChunkEnd. This will perform a bit of validation and clear the chunk from the stack. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html" title="Definition of a chunk of data in a file.">Chunk</a> that comes next </dd></dl>

</div>
</div>
<a id="ae955dfcf39b9a0d7407289e2073d45e0" name="ae955dfcf39b9a0d7407289e2073d45e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae955dfcf39b9a0d7407289e2073d45e0">&#9670;&#160;</a></span>readChunkBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html">Chunk</a> * Ogre::StreamSerialiser::readChunkBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">uint16</a>&#160;</td>
          <td class="paramname"><em>maxVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the start of the next chunk so long as it's of a given ID and version. </p>
<p>This method operates like readChunkBegin, except it checks the ID and version. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID you're expecting. If the next chunk isn't of this ID, then the chunk read is undone and the method returns null. </td></tr>
    <tr><td class="paramname">maxVersion</td><td>The maximum version you're able to process. If the ID is correct but the version exceeds what is passed in here, the chunk is skipped over, the problem logged and null is returned. </td></tr>
    <tr><td class="paramname">msg</td><td>Descriptive text added to the log if versions are not compatible </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The chunk if it passes the validation. </dd></dl>

</div>
</div>
<a id="aac94278ebfddb581f5e73838f573c9cd" name="aac94278ebfddb581f5e73838f573c9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac94278ebfddb581f5e73838f573c9cd">&#9670;&#160;</a></span>undoReadChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::undoReadChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this to 'rewind' the stream to just before the start of the current chunk. </p>
<p>The most common case of wanting to use this is if you'd calledReadChunkBegin(), but the chunk you read wasn't one you wanted to process, and rather than skipping over it (which <a class="el" href="class_ogre_1_1_stream_serialiser.html#a97b3a9ad5caea2da65b36a07816f968e" title="Finish the reading of a chunk.">readChunkEnd()</a> would do), you want to backtrack and give something else an opportunity to read it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the chunk that you were reading (for validation purposes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5e27e1fff17725bb9970d9ad81cfb39" name="aa5e27e1fff17725bb9970d9ad81cfb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e27e1fff17725bb9970d9ad81cfb39">&#9670;&#160;</a></span>peekNextChunkID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> Ogre::StreamSerialiser::peekNextChunkID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this to 'peek' at the next chunk ID without permanently moving the stream pointer. </p>

</div>
</div>
<a id="a97b3a9ad5caea2da65b36a07816f968e" name="a97b3a9ad5caea2da65b36a07816f968e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b3a9ad5caea2da65b36a07816f968e">&#9670;&#160;</a></span>readChunkEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::readChunkEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish the reading of a chunk. </p>
<p>You can call this method at any point after calling readChunkBegin, even if you didn't read all the rest of the data in the chunk. If you did not read to the end of a chunk, this method will automatically skip over the remainder of the chunk and position the stream just after it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the chunk that you were reading (for validation purposes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad81be1455eacc97d5fcd1df06cbe1b93" name="ad81be1455eacc97d5fcd1df06cbe1b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81be1455eacc97d5fcd1df06cbe1b93">&#9670;&#160;</a></span>isEndOfChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">bool</a> Ogre::StreamSerialiser::isEndOfChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether the current data pointer is at the end of the current chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the chunk that you were reading (for validation purposes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0fa5f5b426eecb48246039f397befab" name="aa0fa5f5b426eecb48246039f397befab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0fa5f5b426eecb48246039f397befab">&#9670;&#160;</a></span>eof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">bool</a> Ogre::StreamSerialiser::eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports whether the stream is at the end of file. </p>

</div>
</div>
<a id="a880c33bffd02ac88cf7378a06ff4785b" name="a880c33bffd02ac88cf7378a06ff4785b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880c33bffd02ac88cf7378a06ff4785b">&#9670;&#160;</a></span>getCurrentChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1_stream_serialiser_1_1_chunk.html">Chunk</a> * Ogre::StreamSerialiser::getCurrentChunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the definition of the current chunk being read (if any). </p>

</div>
</div>
<a id="a49f031773228cdd832db5c52e7e0ea72" name="a49f031773228cdd832db5c52e7e0ea72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f031773228cdd832db5c52e7e0ea72">&#9670;&#160;</a></span>writeChunkBegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::writeChunkBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">uint16</a>&#160;</td>
          <td class="paramname"><em>version</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin writing a new chunk. </p>
<p>This starts the process of writing a new chunk to the stream. This will write the chunk header for you, and store a pointer so that the class can automatically go back and fill in the size for you later should you need it to. If you have already begun a chunk without ending it, then this method will start a nested chunk within it. Once written, you can then start writing chunk-specific data into your stream. </p><dl class="section note"><dt>Note</dt><dd>If this is the first chunk in the file </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identifier of the new chunk. <a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> value that's unique in the file context is valid, except for the numbers 0x0001 and 0x1000 which are reserved for internal header identification use. </td></tr>
    <tr><td class="paramname">version</td><td>The version of the chunk you're writing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7dbda6a8b282814f3eabcaed6f86abc" name="ad7dbda6a8b282814f3eabcaed6f86abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7dbda6a8b282814f3eabcaed6f86abc">&#9670;&#160;</a></span>writeChunkEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::writeChunkEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End writing a chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identifier of the chunk - this is really just a safety check, since you can only end the chunk you most recently started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a192b4339d7d5ba458824751e01575d92" name="a192b4339d7d5ba458824751e01575d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192b4339d7d5ba458824751e01575d92">&#9670;&#160;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::writeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write arbitrary data to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to bytes </td></tr>
    <tr><td class="paramname">size</td><td>The size of each element to write; each will be endian-flipped if necessary </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2aae82219abe1e37ea5f1c1adf8bdd1c" name="a2aae82219abe1e37ea5f1c1adf8bdd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aae82219abe1e37ea5f1c1adf8bdd1c">&#9670;&#160;</a></span>write() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1vector.html">typename</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> *&#160;</td>
          <td class="paramname"><em>pT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Catch-all method to write primitive types. </p>

</div>
</div>
<a id="a596a55c0496333afcfa6af3e51e36e64" name="a596a55c0496333afcfa6af3e51e36e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596a55c0496333afcfa6af3e51e36e64">&#9670;&#160;</a></span>write() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60ac46edf43d39927816e34b1a0d983c" name="a60ac46edf43d39927816e34b1a0d983c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ac46edf43d39927816e34b1a0d983c">&#9670;&#160;</a></span>write() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada08984a52a07febc6ddd531c60adbd6" name="ada08984a52a07febc6ddd531c60adbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada08984a52a07febc6ddd531c60adbd6">&#9670;&#160;</a></span>write() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a994f2de1f0d13f674b6946b2490c225a" name="a994f2de1f0d13f674b6946b2490c225a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994f2de1f0d13f674b6946b2490c225a">&#9670;&#160;</a></span>write() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53163836004961bea4bb7ab73819b322" name="a53163836004961bea4bb7ab73819b322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53163836004961bea4bb7ab73819b322">&#9670;&#160;</a></span>write() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6430b8559a0b559d3eefaebef786759e" name="a6430b8559a0b559d3eefaebef786759e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6430b8559a0b559d3eefaebef786759e">&#9670;&#160;</a></span>write() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ffe90cc7b051f0f56faccc739988cea" name="a0ffe90cc7b051f0f56faccc739988cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffe90cc7b051f0f56faccc739988cea">&#9670;&#160;</a></span>write() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82759066f35c8cb08e24ce4357c747c7" name="a82759066f35c8cb08e24ce4357c747c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82759066f35c8cb08e24ce4357c747c7">&#9670;&#160;</a></span>write() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6731deffcb48fa5b78422e4f955f5f93" name="a6731deffcb48fa5b78422e4f955f5f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6731deffcb48fa5b78422e4f955f5f93">&#9670;&#160;</a></span>write() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> *&#160;</td>
          <td class="paramname"><em>aabb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5435ad86ff5851f9012191d3b5179a55" name="a5435ad86ff5851f9012191d3b5179a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5435ad86ff5851f9012191d3b5179a55">&#9670;&#160;</a></span>write() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> *&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d289d76cc669fd1ade3ef05fa48bd21" name="a0d289d76cc669fd1ade3ef05fa48bd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d289d76cc669fd1ade3ef05fa48bd21">&#9670;&#160;</a></span>write() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_plane.html">Plane</a> *&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad453d94c2cc1ebd6a13d2571ee8d5456" name="ad453d94c2cc1ebd6a13d2571ee8d5456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad453d94c2cc1ebd6a13d2571ee8d5456">&#9670;&#160;</a></span>write() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_ray.html">Ray</a> *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79d03ff4a8aedc9e28412dc25fa48027" name="a79d03ff4a8aedc9e28412dc25fa48027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d03ff4a8aedc9e28412dc25fa48027">&#9670;&#160;</a></span>write() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_radian.html">Radian</a> *&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a456b335842b528abb03c953049cac7ad" name="a456b335842b528abb03c953049cac7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456b335842b528abb03c953049cac7ad">&#9670;&#160;</a></span>write() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4397c12bc7f970bd559d0d24a0116b36" name="a4397c12bc7f970bd559d0d24a0116b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4397c12bc7f970bd559d0d24a0116b36">&#9670;&#160;</a></span>write() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">const</a> <a class="el" href="struct_ogre_1_1vector.html">bool</a> *&#160;</td>
          <td class="paramname"><em>boolean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d9cd8abb22fbd17c795aa62765b4a59" name="a2d9cd8abb22fbd17c795aa62765b4a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9cd8abb22fbd17c795aa62765b4a59">&#9670;&#160;</a></span>readData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::readData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">void</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read arbitrary data from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to bytes </td></tr>
    <tr><td class="paramname">size</td><td>The size of each element to read; each will be endian-flipped if necessary </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72a8e8540b453b8428992c0c6c599995" name="a72a8e8540b453b8428992c0c6c599995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a8e8540b453b8428992c0c6c599995">&#9670;&#160;</a></span>read() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1vector.html">typename</a> <a class="el" href="struct_ogre_1_1vector.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">T</a> *&#160;</td>
          <td class="paramname"><em>pT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Catch-all method to read primitive types. </p>

</div>
</div>
<a id="a46bcb952e488697f41786e1156c00979" name="a46bcb952e488697f41786e1156c00979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bcb952e488697f41786e1156c00979">&#9670;&#160;</a></span>read() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a273eb21bd429c3a1dc4ac6981bea7c6b" name="a273eb21bd429c3a1dc4ac6981bea7c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273eb21bd429c3a1dc4ac6981bea7c6b">&#9670;&#160;</a></span>read() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read a Vector3 </p>

</div>
</div>
<a id="a5f557c549a65a20e76e605f9bf9fe4c9" name="a5f557c549a65a20e76e605f9bf9fe4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f557c549a65a20e76e605f9bf9fe4c9">&#9670;&#160;</a></span>read() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee0e00b95f550cc324cbb5fef1a3766b" name="aee0e00b95f550cc324cbb5fef1a3766b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0e00b95f550cc324cbb5fef1a3766b">&#9670;&#160;</a></span>read() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3173c30a36415d10b4daf6e130953e0e" name="a3173c30a36415d10b4daf6e130953e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3173c30a36415d10b4daf6e130953e0e">&#9670;&#160;</a></span>read() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a3af44ad9ac9d841ec5e15d4c6856f3" name="a9a3af44ad9ac9d841ec5e15d4c6856f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3af44ad9ac9d841ec5e15d4c6856f3">&#9670;&#160;</a></span>read() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28eec6a458dd2f02a8849a51dc107dcf" name="a28eec6a458dd2f02a8849a51dc107dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28eec6a458dd2f02a8849a51dc107dcf">&#9670;&#160;</a></span>read() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa930c1889b253433b459176426795627" name="aa930c1889b253433b459176426795627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa930c1889b253433b459176426795627">&#9670;&#160;</a></span>read() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32788255718a172dd040cf6766e8e32a" name="a32788255718a172dd040cf6766e8e32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32788255718a172dd040cf6766e8e32a">&#9670;&#160;</a></span>read() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> *&#160;</td>
          <td class="paramname"><em>aabb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a242f3491c47852b53b0b689edfc25e4c" name="a242f3491c47852b53b0b689edfc25e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242f3491c47852b53b0b689edfc25e4c">&#9670;&#160;</a></span>read() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> *&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85a44458396fa2170fa8858a0328fa97" name="a85a44458396fa2170fa8858a0328fa97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a44458396fa2170fa8858a0328fa97">&#9670;&#160;</a></span>read() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_plane.html">Plane</a> *&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a838c7aea842143bcf54d82d3fe085efe" name="a838c7aea842143bcf54d82d3fe085efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838c7aea842143bcf54d82d3fe085efe">&#9670;&#160;</a></span>read() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_ray.html">Ray</a> *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8da61d9cfea11fa94aef4b3ea1a81eae" name="a8da61d9cfea11fa94aef4b3ea1a81eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da61d9cfea11fa94aef4b3ea1a81eae">&#9670;&#160;</a></span>read() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> *&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e45523a0409077bbcab706ef0a58f64" name="a5e45523a0409077bbcab706ef0a58f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e45523a0409077bbcab706ef0a58f64">&#9670;&#160;</a></span>read() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8fe1551fa5a1dc26317c9b57b8ef1f6" name="af8fe1551fa5a1dc26317c9b57b8ef1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fe1551fa5a1dc26317c9b57b8ef1f6">&#9670;&#160;</a></span>read() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">bool</a> *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9c4b6be63560e6f2ab0b647fe797175" name="aa9c4b6be63560e6f2ab0b647fe797175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c4b6be63560e6f2ab0b647fe797175">&#9670;&#160;</a></span>startDeflate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::startDeflate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1vector.html">size_t</a>&#160;</td>
          <td class="paramname"><em>avail_in</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start (un)compressing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avail_in</td><td>Available bytes for uncompressing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac16f0772431b3939250062d61957189d" name="ac16f0772431b3939250062d61957189d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16f0772431b3939250062d61957189d">&#9670;&#160;</a></span>stopDeflate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1vector.html">virtual</a> <a class="el" href="struct_ogre_1_1vector.html">void</a> Ogre::StreamSerialiser::stopDeflate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop (un)compressing data. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_stream_serialiser_8h.html">OgreStreamSerialiser.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_stream_serialiser.html">StreamSerialiser</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
