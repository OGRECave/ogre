<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">13.6</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::Node Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___scene.html">Scene</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class representing a general-purpose node an articulated scene graph.  
 <a href="class_ogre_1_1_node.html#details">More...</a></p>

<p><code>#include &lt;OgreNode.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::Node:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_node__inherit__graph.svg" width="658" height="262"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_node_1_1_listener.html" title="Listener which gets called back on Node events.">Listener</a> which gets called back on <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> events.  <a href="class_ogre_1_1_node_1_1_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0b69022b50c829ec21e9589bbc591597"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_node.html#a657cdad033f6846883bfaabdd4707435">ChildNodeMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a0b69022b50c829ec21e9589bbc591597">ChildNodeIterator</a></td></tr>
<tr class="separator:a0b69022b50c829ec21e9589bbc591597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657cdad033f6846883bfaabdd4707435"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="class_ogre_1_1_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a657cdad033f6846883bfaabdd4707435">ChildNodeMap</a></td></tr>
<tr class="separator:a657cdad033f6846883bfaabdd4707435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984f44c9104d5c195f67a2b9d88ebae1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_node.html#a657cdad033f6846883bfaabdd4707435">ChildNodeMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a984f44c9104d5c195f67a2b9d88ebae1">ConstChildNodeIterator</a></td></tr>
<tr class="separator:a984f44c9104d5c195f67a2b9d88ebae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42e2063379286eb673eaffff6ca5e99"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> { <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>
, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>
, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99ae28ff4f09161c3f5d19c08c5ef210e04">TS_WORLD</a>
 }</td></tr>
<tr class="memdesc:ac42e2063379286eb673eaffff6ca5e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration denoting the spaces which a transform can be relative to.  <a href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">More...</a><br /></td></tr>
<tr class="separator:ac42e2063379286eb673eaffff6ca5e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9708974fb90fd32035f8d36a47abb0af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a9708974fb90fd32035f8d36a47abb0af">Node</a> ()</td></tr>
<tr class="memdesc:a9708974fb90fd32035f8d36a47abb0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, should only be called by parent, not directly.  <a href="class_ogre_1_1_node.html#a9708974fb90fd32035f8d36a47abb0af">More...</a><br /></td></tr>
<tr class="separator:a9708974fb90fd32035f8d36a47abb0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6c986afc06749ab29f853ae1df58e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a3c6c986afc06749ab29f853ae1df58e3">Node</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name)</td></tr>
<tr class="memdesc:a3c6c986afc06749ab29f853ae1df58e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, should only be called by parent, not directly.  <a href="class_ogre_1_1_node.html#a3c6c986afc06749ab29f853ae1df58e3">More...</a><br /></td></tr>
<tr class="separator:a3c6c986afc06749ab29f853ae1df58e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f92f708c954f8bf6581eb2377656443"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a4f92f708c954f8bf6581eb2377656443">~Node</a> ()</td></tr>
<tr class="separator:a4f92f708c954f8bf6581eb2377656443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6afb3ab2d6bece0391c6592b946c11"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aae6afb3ab2d6bece0391c6592b946c11">_getDerivedOrientation</a> (void) const</td></tr>
<tr class="memdesc:aae6afb3ab2d6bece0391c6592b946c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the orientation of the node as derived from all parents.  <a href="class_ogre_1_1_node.html#aae6afb3ab2d6bece0391c6592b946c11">More...</a><br /></td></tr>
<tr class="separator:aae6afb3ab2d6bece0391c6592b946c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d8ef3c62635ce44260efd749a4bbfc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa6d8ef3c62635ce44260efd749a4bbfc">_getDerivedPosition</a> (void) const</td></tr>
<tr class="memdesc:aa6d8ef3c62635ce44260efd749a4bbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of the node as derived from all parents.  <a href="class_ogre_1_1_node.html#aa6d8ef3c62635ce44260efd749a4bbfc">More...</a><br /></td></tr>
<tr class="separator:aa6d8ef3c62635ce44260efd749a4bbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac948570c146461805c4ff0d79a7de2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aac948570c146461805c4ff0d79a7de2f">_getDerivedScale</a> (void) const</td></tr>
<tr class="memdesc:aac948570c146461805c4ff0d79a7de2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scaling factor of the node as derived from all parents.  <a href="class_ogre_1_1_node.html#aac948570c146461805c4ff0d79a7de2f">More...</a><br /></td></tr>
<tr class="separator:aac948570c146461805c4ff0d79a7de2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea9ad81e4378141a887b572bfec75dd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a1ea9ad81e4378141a887b572bfec75dd">_getFullTransform</a> (void) const</td></tr>
<tr class="memdesc:a1ea9ad81e4378141a887b572bfec75dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the full transformation matrix for this node.  <a href="class_ogre_1_1_node.html#a1ea9ad81e4378141a887b572bfec75dd">More...</a><br /></td></tr>
<tr class="separator:a1ea9ad81e4378141a887b572bfec75dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd410326335dd2b974e832ad102458b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#acfd410326335dd2b974e832ad102458b">_setDerivedOrientation</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr class="memdesc:acfd410326335dd2b974e832ad102458b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the final world orientation of the node directly.  <a href="class_ogre_1_1_node.html#acfd410326335dd2b974e832ad102458b">More...</a><br /></td></tr>
<tr class="separator:acfd410326335dd2b974e832ad102458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31de962a55b0455d7bb3851706073e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a31de962a55b0455d7bb3851706073e95">_setDerivedPosition</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;pos)</td></tr>
<tr class="memdesc:a31de962a55b0455d7bb3851706073e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the final world position of the node directly.  <a href="class_ogre_1_1_node.html#a31de962a55b0455d7bb3851706073e95">More...</a><br /></td></tr>
<tr class="separator:a31de962a55b0455d7bb3851706073e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e829eb9715fa8fa1fdc99739d734eac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a5e829eb9715fa8fa1fdc99739d734eac">_update</a> (bool updateChildren, bool parentHasChanged)</td></tr>
<tr class="memdesc:a5e829eb9715fa8fa1fdc99739d734eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method to update the <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="class_ogre_1_1_node.html#a5e829eb9715fa8fa1fdc99739d734eac">More...</a><br /></td></tr>
<tr class="separator:a5e829eb9715fa8fa1fdc99739d734eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01698919040092766a3a4bfab8e7ceb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af01698919040092766a3a4bfab8e7ceb">addChild</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *child)</td></tr>
<tr class="memdesc:af01698919040092766a3a4bfab8e7ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a (precreated) child scene node to this node.  <a href="class_ogre_1_1_node.html#af01698919040092766a3a4bfab8e7ceb">More...</a><br /></td></tr>
<tr class="separator:af01698919040092766a3a4bfab8e7ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bca65a1d911499aba99843fa41b3e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad4bca65a1d911499aba99843fa41b3e9">cancelUpdate</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *child)</td></tr>
<tr class="memdesc:ad4bca65a1d911499aba99843fa41b3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by children to notify their parent that they no longer need an update.  <a href="class_ogre_1_1_node.html#ad4bca65a1d911499aba99843fa41b3e9">More...</a><br /></td></tr>
<tr class="separator:ad4bca65a1d911499aba99843fa41b3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3969475af6a52109883d7c7d44f35fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a3969475af6a52109883d7c7d44f35fec">convertLocalToWorldDirection</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;localDir, bool useScale)</td></tr>
<tr class="memdesc:a3969475af6a52109883d7c7d44f35fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the world direction of a point in the node local space useful for simple transforms that don't require a child node.  <a href="class_ogre_1_1_node.html#a3969475af6a52109883d7c7d44f35fec">More...</a><br /></td></tr>
<tr class="separator:a3969475af6a52109883d7c7d44f35fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87d582898b40ea668fe67ab428cfdcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa87d582898b40ea668fe67ab428cfdcf">convertLocalToWorldOrientation</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;localOrientation)</td></tr>
<tr class="memdesc:aa87d582898b40ea668fe67ab428cfdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the world orientation of an orientation in the node local space useful for simple transforms that don't require a child node.  <a href="class_ogre_1_1_node.html#aa87d582898b40ea668fe67ab428cfdcf">More...</a><br /></td></tr>
<tr class="separator:aa87d582898b40ea668fe67ab428cfdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bba0ab306650f26ab9f59df8666f3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad0bba0ab306650f26ab9f59df8666f3c">convertLocalToWorldPosition</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;localPos)</td></tr>
<tr class="memdesc:ad0bba0ab306650f26ab9f59df8666f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the world position of a point in the node local space useful for simple transforms that don't require a child node.  <a href="class_ogre_1_1_node.html#ad0bba0ab306650f26ab9f59df8666f3c">More...</a><br /></td></tr>
<tr class="separator:ad0bba0ab306650f26ab9f59df8666f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e1a5a9da67b7bc7292b74ee2cfaba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a25e1a5a9da67b7bc7292b74ee2cfaba6">convertWorldToLocalDirection</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;worldDir, bool useScale)</td></tr>
<tr class="memdesc:a25e1a5a9da67b7bc7292b74ee2cfaba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local direction, relative to this node, of the given world-space direction.  <a href="class_ogre_1_1_node.html#a25e1a5a9da67b7bc7292b74ee2cfaba6">More...</a><br /></td></tr>
<tr class="separator:a25e1a5a9da67b7bc7292b74ee2cfaba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553f4e76d2416bd2c514f82c2f6117b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a553f4e76d2416bd2c514f82c2f6117b7">convertWorldToLocalOrientation</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;worldOrientation)</td></tr>
<tr class="memdesc:a553f4e76d2416bd2c514f82c2f6117b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local orientation, relative to this node, of the given world-space orientation.  <a href="class_ogre_1_1_node.html#a553f4e76d2416bd2c514f82c2f6117b7">More...</a><br /></td></tr>
<tr class="separator:a553f4e76d2416bd2c514f82c2f6117b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8302c220e1e1f9ae9d83142bcb2e30ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a8302c220e1e1f9ae9d83142bcb2e30ca">convertWorldToLocalPosition</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;worldPos)</td></tr>
<tr class="memdesc:a8302c220e1e1f9ae9d83142bcb2e30ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local position, relative to this node, of the given world-space position.  <a href="class_ogre_1_1_node.html#a8302c220e1e1f9ae9d83142bcb2e30ca">More...</a><br /></td></tr>
<tr class="separator:a8302c220e1e1f9ae9d83142bcb2e30ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5595d0f506945c66795322b1878e16aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a5595d0f506945c66795322b1878e16aa">createChild</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="class_ogre_1_1_node.html#a45bb282556bc68d072b62097f3006221">translate</a>=Vector3::ZERO, const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;<a class="el" href="class_ogre_1_1_node.html#ae1991a38daed956ca9edc635e418d6d8">rotate</a>=<a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>)</td></tr>
<tr class="memdesc:a5595d0f506945c66795322b1878e16aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new named <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> as a child of this node.  <a href="class_ogre_1_1_node.html#a5595d0f506945c66795322b1878e16aa">More...</a><br /></td></tr>
<tr class="separator:a5595d0f506945c66795322b1878e16aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baeb7e192fc802f6bf846d3a69dfc19"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a8baeb7e192fc802f6bf846d3a69dfc19">createChild</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="class_ogre_1_1_node.html#a45bb282556bc68d072b62097f3006221">translate</a>=Vector3::ZERO, const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;<a class="el" href="class_ogre_1_1_node.html#ae1991a38daed956ca9edc635e418d6d8">rotate</a>=<a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>)</td></tr>
<tr class="memdesc:a8baeb7e192fc802f6bf846d3a69dfc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an unnamed new <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> as a child of this node.  <a href="class_ogre_1_1_node.html#a8baeb7e192fc802f6bf846d3a69dfc19">More...</a><br /></td></tr>
<tr class="separator:a8baeb7e192fc802f6bf846d3a69dfc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23885bdc27be588857d6d67b2dedf3f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a23885bdc27be588857d6d67b2dedf3f5">getChild</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name) const</td></tr>
<tr class="memdesc:a23885bdc27be588857d6d67b2dedf3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to a named child node.  <a href="class_ogre_1_1_node.html#a23885bdc27be588857d6d67b2dedf3f5">More...</a><br /></td></tr>
<tr class="separator:a23885bdc27be588857d6d67b2dedf3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c9109a64d2f1b3f5bbec7ca324aa6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ae6c9109a64d2f1b3f5bbec7ca324aa6c">getChild</a> (unsigned short index) const</td></tr>
<tr class="memdesc:ae6c9109a64d2f1b3f5bbec7ca324aa6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to a child node.  <a href="class_ogre_1_1_node.html#ae6c9109a64d2f1b3f5bbec7ca324aa6c">More...</a><br /></td></tr>
<tr class="separator:ae6c9109a64d2f1b3f5bbec7ca324aa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac345064ed97045297dd394c0ac38686e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html#a0b69022b50c829ec21e9589bbc591597">ChildNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac345064ed97045297dd394c0ac38686e">getChildIterator</a> (void)</td></tr>
<tr class="separator:ac345064ed97045297dd394c0ac38686e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e673500fba746b62c188771a78ff8d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html#a984f44c9104d5c195f67a2b9d88ebae1">ConstChildNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a2e673500fba746b62c188771a78ff8d6">getChildIterator</a> (void) const</td></tr>
<tr class="separator:a2e673500fba746b62c188771a78ff8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eed1961961324d7eaaa6af5cc88dbc5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_node.html#a657cdad033f6846883bfaabdd4707435">ChildNodeMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a7eed1961961324d7eaaa6af5cc88dbc5">getChildren</a> () const</td></tr>
<tr class="memdesc:a7eed1961961324d7eaaa6af5cc88dbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of sub-nodes of this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="class_ogre_1_1_node.html#a7eed1961961324d7eaaa6af5cc88dbc5">More...</a><br /></td></tr>
<tr class="separator:a7eed1961961324d7eaaa6af5cc88dbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9319dda7b15d46d2e1cb64fd22894811"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a9319dda7b15d46d2e1cb64fd22894811">getInheritOrientation</a> (void) const</td></tr>
<tr class="memdesc:a9319dda7b15d46d2e1cb64fd22894811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is affected by orientation applied to the parent node.  <a href="class_ogre_1_1_node.html#a9319dda7b15d46d2e1cb64fd22894811">More...</a><br /></td></tr>
<tr class="separator:a9319dda7b15d46d2e1cb64fd22894811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cdc6392ec73953b327323cac09307b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad4cdc6392ec73953b327323cac09307b">getInheritScale</a> (void) const</td></tr>
<tr class="memdesc:ad4cdc6392ec73953b327323cac09307b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is affected by scaling factors applied to the parent node.  <a href="class_ogre_1_1_node.html#ad4cdc6392ec73953b327323cac09307b">More...</a><br /></td></tr>
<tr class="separator:ad4cdc6392ec73953b327323cac09307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10da4e58434d3e61c6d76f97a0fd1a80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a10da4e58434d3e61c6d76f97a0fd1a80">getInitialOrientation</a> (void) const</td></tr>
<tr class="memdesc:a10da4e58434d3e61c6d76f97a0fd1a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initial orientation of this node, see setInitialState for more info.  <a href="class_ogre_1_1_node.html#a10da4e58434d3e61c6d76f97a0fd1a80">More...</a><br /></td></tr>
<tr class="separator:a10da4e58434d3e61c6d76f97a0fd1a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515361d8231fc86d9b602ba55f714fa9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a515361d8231fc86d9b602ba55f714fa9">getInitialPosition</a> (void) const</td></tr>
<tr class="memdesc:a515361d8231fc86d9b602ba55f714fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initial position of this node, see setInitialState for more info.  <a href="class_ogre_1_1_node.html#a515361d8231fc86d9b602ba55f714fa9">More...</a><br /></td></tr>
<tr class="separator:a515361d8231fc86d9b602ba55f714fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9b0b08edc2984d41ad38520354a407"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a5b9b0b08edc2984d41ad38520354a407">getInitialScale</a> (void) const</td></tr>
<tr class="memdesc:a5b9b0b08edc2984d41ad38520354a407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initial position of this node, see setInitialState for more info.  <a href="class_ogre_1_1_node.html#a5b9b0b08edc2984d41ad38520354a407">More...</a><br /></td></tr>
<tr class="separator:a5b9b0b08edc2984d41ad38520354a407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad75165137ce70fd865b3c5aa302a3bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aad75165137ce70fd865b3c5aa302a3bc">getListener</a> (void) const</td></tr>
<tr class="memdesc:aad75165137ce70fd865b3c5aa302a3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current listener for this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="class_ogre_1_1_node.html#aad75165137ce70fd865b3c5aa302a3bc">More...</a><br /></td></tr>
<tr class="separator:aad75165137ce70fd865b3c5aa302a3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89628765eff6cbe3ed708337764edf7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a89628765eff6cbe3ed708337764edf7f">getLocalAxes</a> (void) const</td></tr>
<tr class="memdesc:a89628765eff6cbe3ed708337764edf7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a matrix whose columns are the local axes based on the nodes orientation relative to it's parent.  <a href="class_ogre_1_1_node.html#a89628765eff6cbe3ed708337764edf7f">More...</a><br /></td></tr>
<tr class="separator:a89628765eff6cbe3ed708337764edf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264df23a0763ef9f8879c97bcbba0f47"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a264df23a0763ef9f8879c97bcbba0f47">getName</a> (void) const</td></tr>
<tr class="memdesc:a264df23a0763ef9f8879c97bcbba0f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the node.  <a href="class_ogre_1_1_node.html#a264df23a0763ef9f8879c97bcbba0f47">More...</a><br /></td></tr>
<tr class="separator:a264df23a0763ef9f8879c97bcbba0f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf89f99cfb8241341c931c887d6bc40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a5cf89f99cfb8241341c931c887d6bc40">getOrientation</a> () const</td></tr>
<tr class="memdesc:a5cf89f99cfb8241341c931c887d6bc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a quaternion representing the nodes orientation.  <a href="class_ogre_1_1_node.html#a5cf89f99cfb8241341c931c887d6bc40">More...</a><br /></td></tr>
<tr class="separator:a5cf89f99cfb8241341c931c887d6bc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aae34f3fa479e9c532360f93518160a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a8aae34f3fa479e9c532360f93518160a">getParent</a> (void) const</td></tr>
<tr class="memdesc:a8aae34f3fa479e9c532360f93518160a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets this node's parent (NULL if this is the root).  <a href="class_ogre_1_1_node.html#a8aae34f3fa479e9c532360f93518160a">More...</a><br /></td></tr>
<tr class="separator:a8aae34f3fa479e9c532360f93518160a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220642657bd0e307c4ecccb46991267e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a220642657bd0e307c4ecccb46991267e">getPosition</a> (void) const</td></tr>
<tr class="memdesc:a220642657bd0e307c4ecccb46991267e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of the node relative to it's parent.  <a href="class_ogre_1_1_node.html#a220642657bd0e307c4ecccb46991267e">More...</a><br /></td></tr>
<tr class="separator:a220642657bd0e307c4ecccb46991267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1133d2ef5623b7ede0fa15aacbe47311"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a1133d2ef5623b7ede0fa15aacbe47311">getScale</a> (void) const</td></tr>
<tr class="memdesc:a1133d2ef5623b7ede0fa15aacbe47311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scaling factor of this node.  <a href="class_ogre_1_1_node.html#a1133d2ef5623b7ede0fa15aacbe47311">More...</a><br /></td></tr>
<tr class="separator:a1133d2ef5623b7ede0fa15aacbe47311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6249bf582ea32554236af812a2e8a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a1d6249bf582ea32554236af812a2e8a2">getSquaredViewDepth</a> (const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *cam) const</td></tr>
<tr class="memdesc:a1d6249bf582ea32554236af812a2e8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, get the squared view depth.  <a href="class_ogre_1_1_node.html#a1d6249bf582ea32554236af812a2e8a2">More...</a><br /></td></tr>
<tr class="separator:a1d6249bf582ea32554236af812a2e8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa158a89aa8c4d8113ea52435eda1da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_any.html">Any</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a9fa158a89aa8c4d8113ea52435eda1da">getUserAny</a> (void) const</td></tr>
<tr class="separator:a9fa158a89aa8c4d8113ea52435eda1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fcf16e43b07e046816125cbb8dc8f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af3fcf16e43b07e046816125cbb8dc8f3">getUserObjectBindings</a> ()</td></tr>
<tr class="memdesc:af3fcf16e43b07e046816125cbb8dc8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides convenient interface to establish a linkage between custom user application objects and Ogre core classes.  <a href="class_ogre_1_1_node.html#af3fcf16e43b07e046816125cbb8dc8f3">More...</a><br /></td></tr>
<tr class="separator:af3fcf16e43b07e046816125cbb8dc8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa154e07b616313f4c345ec6c0da635cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa154e07b616313f4c345ec6c0da635cd">getUserObjectBindings</a> () const</td></tr>
<tr class="memdesc:aa154e07b616313f4c345ec6c0da635cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_node.html#aa154e07b616313f4c345ec6c0da635cd">More...</a><br /></td></tr>
<tr class="separator:aa154e07b616313f4c345ec6c0da635cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8671415cc4cf15e45bf716a823678736"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a8671415cc4cf15e45bf716a823678736">needUpdate</a> (bool forceParentUpdate=false)</td></tr>
<tr class="memdesc:a8671415cc4cf15e45bf716a823678736"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be called in the event of transform changes to this node that require it's recalculation.  <a href="class_ogre_1_1_node.html#a8671415cc4cf15e45bf716a823678736">More...</a><br /></td></tr>
<tr class="separator:a8671415cc4cf15e45bf716a823678736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622555b1fd2f2d1982e7ab9f2313ef1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a622555b1fd2f2d1982e7ab9f2313ef1f">numChildren</a> (void) const</td></tr>
<tr class="memdesc:a622555b1fd2f2d1982e7ab9f2313ef1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of child nodes under this one.  <a href="class_ogre_1_1_node.html#a622555b1fd2f2d1982e7ab9f2313ef1f">More...</a><br /></td></tr>
<tr class="separator:a622555b1fd2f2d1982e7ab9f2313ef1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d3de1c197a805dd692f775fbbeb022"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac7d3de1c197a805dd692f775fbbeb022">pitch</a> (const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:ac7d3de1c197a805dd692f775fbbeb022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around the X-axis.  <a href="class_ogre_1_1_node.html#ac7d3de1c197a805dd692f775fbbeb022">More...</a><br /></td></tr>
<tr class="separator:ac7d3de1c197a805dd692f775fbbeb022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b3e979879906d5500b961a98d04bc0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a79b3e979879906d5500b961a98d04bc0">removeAllChildren</a> (void)</td></tr>
<tr class="memdesc:a79b3e979879906d5500b961a98d04bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all child Nodes attached to this node.  <a href="class_ogre_1_1_node.html#a79b3e979879906d5500b961a98d04bc0">More...</a><br /></td></tr>
<tr class="separator:a79b3e979879906d5500b961a98d04bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1a96d0ca30f5ca56a5dacf27d68f6c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a7b1a96d0ca30f5ca56a5dacf27d68f6c">removeChild</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name)</td></tr>
<tr class="memdesc:a7b1a96d0ca30f5ca56a5dacf27d68f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the named child from this node.  <a href="class_ogre_1_1_node.html#a7b1a96d0ca30f5ca56a5dacf27d68f6c">More...</a><br /></td></tr>
<tr class="separator:a7b1a96d0ca30f5ca56a5dacf27d68f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dae5b62b42bcb4590aea678c3056f26"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a1dae5b62b42bcb4590aea678c3056f26">removeChild</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *child)</td></tr>
<tr class="memdesc:a1dae5b62b42bcb4590aea678c3056f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_node.html#a1dae5b62b42bcb4590aea678c3056f26">More...</a><br /></td></tr>
<tr class="separator:a1dae5b62b42bcb4590aea678c3056f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912d9d3a804edf9faf8a9e32482502b1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a912d9d3a804edf9faf8a9e32482502b1">removeChild</a> (unsigned short index)</td></tr>
<tr class="memdesc:a912d9d3a804edf9faf8a9e32482502b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the specified child from this node.  <a href="class_ogre_1_1_node.html#a912d9d3a804edf9faf8a9e32482502b1">More...</a><br /></td></tr>
<tr class="separator:a912d9d3a804edf9faf8a9e32482502b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97676492945c888304b71ad4edc85e5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a97676492945c888304b71ad4edc85e5a">requestUpdate</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *child, bool forceParentUpdate=false)</td></tr>
<tr class="memdesc:a97676492945c888304b71ad4edc85e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by children to notify their parent that they need an update.  <a href="class_ogre_1_1_node.html#a97676492945c888304b71ad4edc85e5a">More...</a><br /></td></tr>
<tr class="separator:a97676492945c888304b71ad4edc85e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40baf1928d11cd3cd678445f5d3d7e45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a40baf1928d11cd3cd678445f5d3d7e45">resetOrientation</a> (void)</td></tr>
<tr class="memdesc:a40baf1928d11cd3cd678445f5d3d7e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the nodes orientation (local axes as world axes, no rotation).  <a href="class_ogre_1_1_node.html#a40baf1928d11cd3cd678445f5d3d7e45">More...</a><br /></td></tr>
<tr class="separator:a40baf1928d11cd3cd678445f5d3d7e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398e7142b2fbadea2a63097d37d4112b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a398e7142b2fbadea2a63097d37d4112b">resetToInitialState</a> (void)</td></tr>
<tr class="memdesc:a398e7142b2fbadea2a63097d37d4112b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the position / orientation / scale of this node to it's initial state, see setInitialState for more info.  <a href="class_ogre_1_1_node.html#a398e7142b2fbadea2a63097d37d4112b">More...</a><br /></td></tr>
<tr class="separator:a398e7142b2fbadea2a63097d37d4112b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb62b05fce457b8509cb95517154425f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aeb62b05fce457b8509cb95517154425f">roll</a> (const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:aeb62b05fce457b8509cb95517154425f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around the Z-axis.  <a href="class_ogre_1_1_node.html#aeb62b05fce457b8509cb95517154425f">More...</a><br /></td></tr>
<tr class="separator:aeb62b05fce457b8509cb95517154425f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711e0d29d57360d7a17d99823a409c50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a711e0d29d57360d7a17d99823a409c50">rotate</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;q, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:a711e0d29d57360d7a17d99823a409c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around an arbitrary axis using a Quarternion.  <a href="class_ogre_1_1_node.html#a711e0d29d57360d7a17d99823a409c50">More...</a><br /></td></tr>
<tr class="separator:a711e0d29d57360d7a17d99823a409c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1991a38daed956ca9edc635e418d6d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ae1991a38daed956ca9edc635e418d6d8">rotate</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;axis, const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:ae1991a38daed956ca9edc635e418d6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around an arbitrary axis.  <a href="class_ogre_1_1_node.html#ae1991a38daed956ca9edc635e418d6d8">More...</a><br /></td></tr>
<tr class="separator:ae1991a38daed956ca9edc635e418d6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01627f9f9f1a19afe5965c4ba873a573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a01627f9f9f1a19afe5965c4ba873a573">scale</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;scale)</td></tr>
<tr class="memdesc:a01627f9f9f1a19afe5965c4ba873a573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the node, combining it's current scale with the passed in scaling factor.  <a href="class_ogre_1_1_node.html#a01627f9f9f1a19afe5965c4ba873a573">More...</a><br /></td></tr>
<tr class="separator:a01627f9f9f1a19afe5965c4ba873a573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa670d25ccc7206afb3d7cd6dd709cd34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa670d25ccc7206afb3d7cd6dd709cd34">scale</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="memdesc:aa670d25ccc7206afb3d7cd6dd709cd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_node.html#aa670d25ccc7206afb3d7cd6dd709cd34">More...</a><br /></td></tr>
<tr class="separator:aa670d25ccc7206afb3d7cd6dd709cd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bf413c5680b8ff4ea913bcb83d25f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a66bf413c5680b8ff4ea913bcb83d25f1">setInheritOrientation</a> (bool inherit)</td></tr>
<tr class="memdesc:a66bf413c5680b8ff4ea913bcb83d25f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the node whether it should inherit orientation from it's parent node.  <a href="class_ogre_1_1_node.html#a66bf413c5680b8ff4ea913bcb83d25f1">More...</a><br /></td></tr>
<tr class="separator:a66bf413c5680b8ff4ea913bcb83d25f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6319b597c3c75a30c521d532466c4d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ae6319b597c3c75a30c521d532466c4d9">setInheritScale</a> (bool inherit)</td></tr>
<tr class="memdesc:ae6319b597c3c75a30c521d532466c4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the node whether it should inherit scaling factors from it's parent node.  <a href="class_ogre_1_1_node.html#ae6319b597c3c75a30c521d532466c4d9">More...</a><br /></td></tr>
<tr class="separator:ae6319b597c3c75a30c521d532466c4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7832ae769b627172de3cf594b9769084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a7832ae769b627172de3cf594b9769084">setInitialState</a> (void)</td></tr>
<tr class="memdesc:a7832ae769b627172de3cf594b9769084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current transform of this node to be the 'initial state' ie that position / orientation / scale to be used as a basis for delta values used in keyframe animation.  <a href="class_ogre_1_1_node.html#a7832ae769b627172de3cf594b9769084">More...</a><br /></td></tr>
<tr class="separator:a7832ae769b627172de3cf594b9769084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aadf525c7f437c32cd17b0ccd606f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a9aadf525c7f437c32cd17b0ccd606f71">setListener</a> (<a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a> *listener)</td></tr>
<tr class="memdesc:a9aadf525c7f437c32cd17b0ccd606f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a listener for this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="class_ogre_1_1_node.html#a9aadf525c7f437c32cd17b0ccd606f71">More...</a><br /></td></tr>
<tr class="separator:a9aadf525c7f437c32cd17b0ccd606f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307fe0438fb098be6748e044f66155b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a307fe0438fb098be6748e044f66155b6">setOrientation</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr class="memdesc:a307fe0438fb098be6748e044f66155b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the orientation of this node via a quaternion.  <a href="class_ogre_1_1_node.html#a307fe0438fb098be6748e044f66155b6">More...</a><br /></td></tr>
<tr class="separator:a307fe0438fb098be6748e044f66155b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76bc19286a78c598eec88f80f3b16fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad76bc19286a78c598eec88f80f3b16fb">setOrientation</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> w, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="memdesc:ad76bc19286a78c598eec88f80f3b16fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_node.html#ad76bc19286a78c598eec88f80f3b16fb">More...</a><br /></td></tr>
<tr class="separator:ad76bc19286a78c598eec88f80f3b16fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e58d4789cfe29e4538399b4250ce5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;pos)</td></tr>
<tr class="memdesc:a72e58d4789cfe29e4538399b4250ce5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position of the node relative to it's parent.  <a href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">More...</a><br /></td></tr>
<tr class="separator:a72e58d4789cfe29e4538399b4250ce5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af054933a193ed930790fcd2fb80ba684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af054933a193ed930790fcd2fb80ba684">setPosition</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="memdesc:af054933a193ed930790fcd2fb80ba684"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_node.html#af054933a193ed930790fcd2fb80ba684">More...</a><br /></td></tr>
<tr class="separator:af054933a193ed930790fcd2fb80ba684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad031614d90a8fb18750b350c4221cca2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad031614d90a8fb18750b350c4221cca2">setScale</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;<a class="el" href="class_ogre_1_1_node.html#a01627f9f9f1a19afe5965c4ba873a573">scale</a>)</td></tr>
<tr class="memdesc:ad031614d90a8fb18750b350c4221cca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scaling factor applied to this node.  <a href="class_ogre_1_1_node.html#ad031614d90a8fb18750b350c4221cca2">More...</a><br /></td></tr>
<tr class="separator:ad031614d90a8fb18750b350c4221cca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a075aeadb2ad76cc74ed68e02c9ef26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a9a075aeadb2ad76cc74ed68e02c9ef26">setScale</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="memdesc:a9a075aeadb2ad76cc74ed68e02c9ef26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_node.html#a9a075aeadb2ad76cc74ed68e02c9ef26">More...</a><br /></td></tr>
<tr class="separator:a9a075aeadb2ad76cc74ed68e02c9ef26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdf947d54d8b67b5fef19d68da899ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a2fdf947d54d8b67b5fef19d68da899ae">setUserAny</a> (const <a class="el" href="class_ogre_1_1_any.html">Any</a> &amp;anything)</td></tr>
<tr class="separator:a2fdf947d54d8b67b5fef19d68da899ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198cc48d48e52176bbab96e71cc40696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a198cc48d48e52176bbab96e71cc40696">translate</a> (const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;axes, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;move, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>)</td></tr>
<tr class="memdesc:a198cc48d48e52176bbab96e71cc40696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the node along arbitrary axes.  <a href="class_ogre_1_1_node.html#a198cc48d48e52176bbab96e71cc40696">More...</a><br /></td></tr>
<tr class="separator:a198cc48d48e52176bbab96e71cc40696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c8ec60f7539ac029c9c47b788b2629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a37c8ec60f7539ac029c9c47b788b2629">translate</a> (const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;axes, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>)</td></tr>
<tr class="memdesc:a37c8ec60f7539ac029c9c47b788b2629"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_node.html#a37c8ec60f7539ac029c9c47b788b2629">More...</a><br /></td></tr>
<tr class="separator:a37c8ec60f7539ac029c9c47b788b2629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bb282556bc68d072b62097f3006221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a45bb282556bc68d072b62097f3006221">translate</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;d, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>)</td></tr>
<tr class="memdesc:a45bb282556bc68d072b62097f3006221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the node along the Cartesian axes.  <a href="class_ogre_1_1_node.html#a45bb282556bc68d072b62097f3006221">More...</a><br /></td></tr>
<tr class="separator:a45bb282556bc68d072b62097f3006221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef45be557e0d74354214418a61d1412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aaef45be557e0d74354214418a61d1412">translate</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>)</td></tr>
<tr class="memdesc:aaef45be557e0d74354214418a61d1412"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_node.html#aaef45be557e0d74354214418a61d1412">More...</a><br /></td></tr>
<tr class="separator:aaef45be557e0d74354214418a61d1412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d40ab6711058fa41ec905888587b32"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af0d40ab6711058fa41ec905888587b32">yaw</a> (const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:af0d40ab6711058fa41ec905888587b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around the Y-axis.  <a href="class_ogre_1_1_node.html#af0d40ab6711058fa41ec905888587b32">More...</a><br /></td></tr>
<tr class="separator:af0d40ab6711058fa41ec905888587b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af990db414b5c4b26b055375401d3b5d1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af990db414b5c4b26b055375401d3b5d1">processQueuedUpdates</a> (void)</td></tr>
<tr class="memdesc:af990db414b5c4b26b055375401d3b5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process queued 'needUpdate' calls.  <a href="class_ogre_1_1_node.html#af990db414b5c4b26b055375401d3b5d1">More...</a><br /></td></tr>
<tr class="separator:af990db414b5c4b26b055375401d3b5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4609e37d3a70cf4318c99e9e1fb8dfd9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a4609e37d3a70cf4318c99e9e1fb8dfd9">queueNeedUpdate</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *n)</td></tr>
<tr class="memdesc:a4609e37d3a70cf4318c99e9e1fb8dfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue a 'needUpdate' call to a node safely.  <a href="class_ogre_1_1_node.html#a4609e37d3a70cf4318c99e9e1fb8dfd9">More...</a><br /></td></tr>
<tr class="separator:a4609e37d3a70cf4318c99e9e1fb8dfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing a general-purpose node an articulated scene graph. </p>
<dl class="section remark"><dt>Remarks</dt><dd>A node in the scene graph is a node in a structured tree. A node contains information about the transformation which will apply to it and all of it's children. Child nodes can have transforms of their own, which are combined with their parent's transformations. </dd></dl>
<dl class="section user"><dt></dt><dd>This is an abstract class - concrete classes are based on this for specific purposes, e.g. <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph.">SceneNode</a>, <a class="el" href="class_ogre_1_1_bone.html" title="A bone in a skeleton.">Bone</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a657cdad033f6846883bfaabdd4707435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657cdad033f6846883bfaabdd4707435">&#9670;&nbsp;</a></span>ChildNodeMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_ogre_1_1_node.html">Node</a>*&gt; <a class="el" href="class_ogre_1_1_node.html#a657cdad033f6846883bfaabdd4707435">Ogre::Node::ChildNodeMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b69022b50c829ec21e9589bbc591597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b69022b50c829ec21e9589bbc591597">&#9670;&nbsp;</a></span>ChildNodeIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_node.html#a657cdad033f6846883bfaabdd4707435">ChildNodeMap</a>&gt; <a class="el" href="class_ogre_1_1_node.html#a0b69022b50c829ec21e9589bbc591597">Ogre::Node::ChildNodeIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a984f44c9104d5c195f67a2b9d88ebae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984f44c9104d5c195f67a2b9d88ebae1">&#9670;&nbsp;</a></span>ConstChildNodeIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_node.html#a657cdad033f6846883bfaabdd4707435">ChildNodeMap</a>&gt; <a class="el" href="class_ogre_1_1_node.html#a984f44c9104d5c195f67a2b9d88ebae1">Ogre::Node::ConstChildNodeIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac42e2063379286eb673eaffff6ca5e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42e2063379286eb673eaffff6ca5e99">&#9670;&nbsp;</a></span>TransformSpace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">Ogre::Node::TransformSpace</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration denoting the spaces which a transform can be relative to. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2"></a>TS_LOCAL&#160;</td><td class="fielddoc"><p>Transform is relative to the local space. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce"></a>TS_PARENT&#160;</td><td class="fielddoc"><p>Transform is relative to the space of the parent node. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac42e2063379286eb673eaffff6ca5e99ae28ff4f09161c3f5d19c08c5ef210e04"></a>TS_WORLD&#160;</td><td class="fielddoc"><p>Transform is relative to world space. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9708974fb90fd32035f8d36a47abb0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9708974fb90fd32035f8d36a47abb0af">&#9670;&nbsp;</a></span>Node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Node::Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, should only be called by parent, not directly. </p>

</div>
</div>
<a id="a3c6c986afc06749ab29f853ae1df58e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6c986afc06749ab29f853ae1df58e3">&#9670;&nbsp;</a></span>Node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, should only be called by parent, not directly. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Assigned a name. </dd></dl>

</div>
</div>
<a id="a4f92f708c954f8bf6581eb2377656443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f92f708c954f8bf6581eb2377656443">&#9670;&nbsp;</a></span>~Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a264df23a0763ef9f8879c97bcbba0f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264df23a0763ef9f8879c97bcbba0f47">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Node::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the node. </p>

</div>
</div>
<a id="a8aae34f3fa479e9c532360f93518160a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aae34f3fa479e9c532360f93518160a">&#9670;&nbsp;</a></span>getParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::getParent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets this node's parent (NULL if this is the root). </p>

</div>
</div>
<a id="a5cf89f99cfb8241341c931c887d6bc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf89f99cfb8241341c931c887d6bc40">&#9670;&nbsp;</a></span>getOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&amp; Ogre::Node::getOrientation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a quaternion representing the nodes orientation. </p>

</div>
</div>
<a id="a307fe0438fb098be6748e044f66155b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307fe0438fb098be6748e044f66155b6">&#9670;&nbsp;</a></span>setOrientation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the orientation of this node via a quaternion. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="ad76bc19286a78c598eec88f80f3b16fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76bc19286a78c598eec88f80f3b16fb">&#9670;&nbsp;</a></span>setOrientation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a40baf1928d11cd3cd678445f5d3d7e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40baf1928d11cd3cd678445f5d3d7e45">&#9670;&nbsp;</a></span>resetOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::resetOrientation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the nodes orientation (local axes as world axes, no rotation). </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="a72e58d4789cfe29e4538399b4250ce5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e58d4789cfe29e4538399b4250ce5a">&#9670;&nbsp;</a></span>setPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the position of the node relative to it's parent. </p>

</div>
</div>
<a id="af054933a193ed930790fcd2fb80ba684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af054933a193ed930790fcd2fb80ba684">&#9670;&nbsp;</a></span>setPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_node.html#af054933a193ed930790fcd2fb80ba684">setPosition()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_node.html#af054933a193ed930790fcd2fb80ba684">setPosition()</a>.</p>

</div>
</div>
<a id="a220642657bd0e307c4ecccb46991267e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220642657bd0e307c4ecccb46991267e">&#9670;&nbsp;</a></span>getPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&amp; Ogre::Node::getPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the position of the node relative to it's parent. </p>

</div>
</div>
<a id="ad031614d90a8fb18750b350c4221cca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad031614d90a8fb18750b350c4221cca2">&#9670;&nbsp;</a></span>setScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the scaling factor applied to this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="a9a075aeadb2ad76cc74ed68e02c9ef26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a075aeadb2ad76cc74ed68e02c9ef26">&#9670;&nbsp;</a></span>setScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_node.html#a9a075aeadb2ad76cc74ed68e02c9ef26">setScale()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_node.html#a9a075aeadb2ad76cc74ed68e02c9ef26">setScale()</a>.</p>

</div>
</div>
<a id="a1133d2ef5623b7ede0fa15aacbe47311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1133d2ef5623b7ede0fa15aacbe47311">&#9670;&nbsp;</a></span>getScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&amp; Ogre::Node::getScale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the scaling factor of this node. </p>

</div>
</div>
<a id="a66bf413c5680b8ff4ea913bcb83d25f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bf413c5680b8ff4ea913bcb83d25f1">&#9670;&nbsp;</a></span>setInheritOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setInheritOrientation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inherit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the node whether it should inherit orientation from it's parent node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inherit</td><td>If true, this node's orientation will be affected by its parent's orientation. If false, it will not be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9319dda7b15d46d2e1cb64fd22894811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9319dda7b15d46d2e1cb64fd22894811">&#9670;&nbsp;</a></span>getInheritOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Node::getInheritOrientation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this node is affected by orientation applied to the parent node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd>
<dd>
See setInheritOrientation for more info. </dd></dl>

</div>
</div>
<a id="ae6319b597c3c75a30c521d532466c4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6319b597c3c75a30c521d532466c4d9">&#9670;&nbsp;</a></span>setInheritScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setInheritScale </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inherit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the node whether it should inherit scaling factors from it's parent node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inherit</td><td>If true, this node's scale will be affected by its parent's scale. If false, it will not be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4cdc6392ec73953b327323cac09307b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cdc6392ec73953b327323cac09307b">&#9670;&nbsp;</a></span>getInheritScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Node::getInheritScale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this node is affected by scaling factors applied to the parent node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>See setInheritScale for more info. </dd></dl>

</div>
</div>
<a id="a01627f9f9f1a19afe5965c4ba873a573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01627f9f9f1a19afe5965c4ba873a573">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the node, combining it's current scale with the passed in scaling factor. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method applies an extra scaling factor to the node's existing scale, (unlike setScale which overwrites it) combining it's current scale with the new one. E.g. calling this method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if the existing scale was 1. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="aa670d25ccc7206afb3d7cd6dd709cd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa670d25ccc7206afb3d7cd6dd709cd34">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a45bb282556bc68d072b62097f3006221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bb282556bc68d072b62097f3006221">&#9670;&nbsp;</a></span>translate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the node along the Cartesian axes. </p>
<dl class="section user"><dt></dt><dd>This method moves the node by the supplied vector along the world Cartesian axes, i.e. along world x,y,z </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="class_ogre_1_1_vector.html" title="Standard N-dimensional vector.">Vector</a> with x,y,z values representing the translation. </td></tr>
    <tr><td class="paramname">relativeTo</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaef45be557e0d74354214418a61d1412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef45be557e0d74354214418a61d1412">&#9670;&nbsp;</a></span>translate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a198cc48d48e52176bbab96e71cc40696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198cc48d48e52176bbab96e71cc40696">&#9670;&nbsp;</a></span>translate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the node along arbitrary axes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method translates the node by a vector which is relative to a custom set of axes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>A 3x3 Matrix containing 3 column vectors each representing the axes X, Y and Z respectively. In this format the standard cartesian axes would be expressed as: <pre>
    1 0 0
    0 1 0
    0 0 1
    </pre> i.e. the identity matrix. </td></tr>
    <tr><td class="paramname">move</td><td><a class="el" href="class_ogre_1_1_vector.html" title="Standard N-dimensional vector.">Vector</a> relative to the axes above. </td></tr>
    <tr><td class="paramname">relativeTo</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37c8ec60f7539ac029c9c47b788b2629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c8ec60f7539ac029c9c47b788b2629">&#9670;&nbsp;</a></span>translate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aeb62b05fce457b8509cb95517154425f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb62b05fce457b8509cb95517154425f">&#9670;&nbsp;</a></span>roll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::roll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate the node around the Z-axis. </p>

</div>
</div>
<a id="ac7d3de1c197a805dd692f775fbbeb022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d3de1c197a805dd692f775fbbeb022">&#9670;&nbsp;</a></span>pitch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::pitch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate the node around the X-axis. </p>

</div>
</div>
<a id="af0d40ab6711058fa41ec905888587b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d40ab6711058fa41ec905888587b32">&#9670;&nbsp;</a></span>yaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::yaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate the node around the Y-axis. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_scene_node.html#a4cc0682e9f4af3d1b4640592fab46e2c">Ogre::SceneNode</a>.</p>

</div>
</div>
<a id="ae1991a38daed956ca9edc635e418d6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1991a38daed956ca9edc635e418d6d8">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate the node around an arbitrary axis. </p>

</div>
</div>
<a id="a711e0d29d57360d7a17d99823a409c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711e0d29d57360d7a17d99823a409c50">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate the node around an arbitrary axis using a Quarternion. </p>

</div>
</div>
<a id="a89628765eff6cbe3ed708337764edf7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89628765eff6cbe3ed708337764edf7f">&#9670;&nbsp;</a></span>getLocalAxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> Ogre::Node::getLocalAxes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a matrix whose columns are the local axes based on the nodes orientation relative to it's parent. </p>

</div>
</div>
<a id="a8baeb7e192fc802f6bf846d3a69dfc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8baeb7e192fc802f6bf846d3a69dfc19">&#9670;&nbsp;</a></span>createChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::createChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>translate</em> = <code>Vector3::ZERO</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotate</em> = <code><a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an unnamed new <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> as a child of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translate</td><td>Initial translation offset of child relative to parent </td></tr>
    <tr><td class="paramname">rotate</td><td>Initial rotation relative to parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5595d0f506945c66795322b1878e16aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5595d0f506945c66795322b1878e16aa">&#9670;&nbsp;</a></span>createChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::createChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>translate</em> = <code>Vector3::ZERO</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotate</em> = <code><a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new named <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> as a child of this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This creates a child node with a given name, which allows you to look the node up from the parent which holds this collection of nodes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> to create </td></tr>
    <tr><td class="paramname">translate</td><td>Initial translation offset of child relative to parent </td></tr>
    <tr><td class="paramname">rotate</td><td>Initial rotation relative to parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af01698919040092766a3a4bfab8e7ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01698919040092766a3a4bfab8e7ceb">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a (precreated) child scene node to this node. </p>
<p>If it is attached to another node, it must be detached first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> which is to become a child node of this one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a622555b1fd2f2d1982e7ab9f2313ef1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622555b1fd2f2d1982e7ab9f2313ef1f">&#9670;&nbsp;</a></span>numChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">uint16</a> Ogre::Node::numChildren </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the number of child nodes under this one. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000112">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_node.html#a7eed1961961324d7eaaa6af5cc88dbc5" title="List of sub-nodes of this Node.">getChildren()</a> </dd></dl>

</div>
</div>
<a id="ae6c9109a64d2f1b3f5bbec7ca324aa6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c9109a64d2f1b3f5bbec7ca324aa6c">&#9670;&nbsp;</a></span>getChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to a child node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>There is an alternate getChild method which returns a named child. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000113">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_node.html#a7eed1961961324d7eaaa6af5cc88dbc5" title="List of sub-nodes of this Node.">getChildren()</a> </dd></dl>

</div>
</div>
<a id="a23885bdc27be588857d6d67b2dedf3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23885bdc27be588857d6d67b2dedf3f5">&#9670;&nbsp;</a></span>getChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::getChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to a named child node. </p>

</div>
</div>
<a id="ac345064ed97045297dd394c0ac38686e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac345064ed97045297dd394c0ac38686e">&#9670;&nbsp;</a></span>getChildIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html#a0b69022b50c829ec21e9589bbc591597">ChildNodeIterator</a> Ogre::Node::getChildIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000114">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_node.html#a7eed1961961324d7eaaa6af5cc88dbc5" title="List of sub-nodes of this Node.">getChildren()</a> </dd></dl>

</div>
</div>
<a id="a2e673500fba746b62c188771a78ff8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e673500fba746b62c188771a78ff8d6">&#9670;&nbsp;</a></span>getChildIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html#a984f44c9104d5c195f67a2b9d88ebae1">ConstChildNodeIterator</a> Ogre::Node::getChildIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000115">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_node.html#a7eed1961961324d7eaaa6af5cc88dbc5" title="List of sub-nodes of this Node.">getChildren()</a> </dd></dl>

</div>
</div>
<a id="a7eed1961961324d7eaaa6af5cc88dbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eed1961961324d7eaaa6af5cc88dbc5">&#9670;&nbsp;</a></span>getChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_node.html#a657cdad033f6846883bfaabdd4707435">ChildNodeMap</a>&amp; Ogre::Node::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of sub-nodes of this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>

</div>
</div>
<a id="a912d9d3a804edf9faf8a9e32482502b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912d9d3a804edf9faf8a9e32482502b1">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::removeChild </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the specified child from this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. There is also an alternate version which drops a named child from this node. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_octree_node.html#a7ed537781698934e5820237ce3b0f01f">Ogre::OctreeNode</a>.</p>

</div>
</div>
<a id="a1dae5b62b42bcb4590aea678c3056f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dae5b62b42bcb4590aea678c3056f26">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_octree_node.html#a7bf1a7200c2b028e8eb16315ddac25d6">Ogre::OctreeNode</a>.</p>

</div>
</div>
<a id="a7b1a96d0ca30f5ca56a5dacf27d68f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1a96d0ca30f5ca56a5dacf27d68f6c">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::removeChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the named child from this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_octree_node.html#a6129d7adb150b94ff316c2a83383e927">Ogre::OctreeNode</a>.</p>

</div>
</div>
<a id="a79b3e979879906d5500b961a98d04bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b3e979879906d5500b961a98d04bc0">&#9670;&nbsp;</a></span>removeAllChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::removeAllChildren </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all child Nodes attached to this node. </p>
<p>Does not delete the nodes, just detaches them from this parent, potentially to be reattached elsewhere. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_octree_node.html#a8cbf1e83f92581f1c89eaf391f55d5d5">Ogre::OctreeNode</a>.</p>

</div>
</div>
<a id="a31de962a55b0455d7bb3851706073e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31de962a55b0455d7bb3851706073e95">&#9670;&nbsp;</a></span>_setDerivedPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::_setDerivedPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the final world position of the node directly. </p>
<dl class="section remark"><dt>Remarks</dt><dd>It's advisable to use the local setPosition if possible </dd></dl>

</div>
</div>
<a id="acfd410326335dd2b974e832ad102458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd410326335dd2b974e832ad102458b">&#9670;&nbsp;</a></span>_setDerivedOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::_setDerivedOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the final world orientation of the node directly. </p>
<dl class="section remark"><dt>Remarks</dt><dd>It's advisable to use the local setOrientation if possible, this simply does the conversion for you. </dd></dl>

</div>
</div>
<a id="aae6afb3ab2d6bece0391c6592b946c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6afb3ab2d6bece0391c6592b946c11">&#9670;&nbsp;</a></span>_getDerivedOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&amp; Ogre::Node::_getDerivedOrientation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the orientation of the node as derived from all parents. </p>

</div>
</div>
<a id="aa6d8ef3c62635ce44260efd749a4bbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d8ef3c62635ce44260efd749a4bbfc">&#9670;&nbsp;</a></span>_getDerivedPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&amp; Ogre::Node::_getDerivedPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the position of the node as derived from all parents. </p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_scene_manager.html#ac6e42c947472bf09620ef974c3ac26a5">Ogre::SceneManager::_populateLightList()</a>.</p>

</div>
</div>
<a id="aac948570c146461805c4ff0d79a7de2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac948570c146461805c4ff0d79a7de2f">&#9670;&nbsp;</a></span>_getDerivedScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&amp; Ogre::Node::_getDerivedScale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the scaling factor of the node as derived from all parents. </p>

</div>
</div>
<a id="a1ea9ad81e4378141a887b572bfec75dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea9ad81e4378141a887b572bfec75dd">&#9670;&nbsp;</a></span>_getFullTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a>&amp; Ogre::Node::_getFullTransform </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the full transformation matrix for this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method returns the full transformation matrix for this node, including the effect of any parent node transformations, provided they have been updated using the <a class="el" href="class_ogre_1_1_node.html#a5e829eb9715fa8fa1fdc99739d734eac" title="Internal method to update the Node.">Node::_update</a> method. This should only be called by a <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a> which knows the derived transforms have been updated before calling this method. Applications using <a class="el" href="namespace_ogre.html">Ogre</a> should just use the relative transforms. </dd></dl>

</div>
</div>
<a id="a5e829eb9715fa8fa1fdc99739d734eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e829eb9715fa8fa1fdc99739d734eac">&#9670;&nbsp;</a></span>_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::_update </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateChildren</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parentHasChanged</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method to update the <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Updates this node and any relevant children to incorporate transforms etc. Don't call this yourself unless you are writing a <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a> implementation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updateChildren</td><td>If <code>true</code>, the update cascades down to all children. Specify false if you wish to update children separately, e.g. because of a more selective <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a> implementation. </td></tr>
    <tr><td class="paramname">parentHasChanged</td><td>This flag indicates that the parent transform has changed, so the child should retrieve the parent's transform and combine it with its own even if it hasn't changed itself. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_p_c_z_scene_node.html#afdf56660f1aee5a3e0104ad40b059e34">Ogre::PCZSceneNode</a>, <a class="el" href="class_ogre_1_1_bsp_scene_node.html#a645083e5abba280774870d26518e48ba">Ogre::BspSceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_node.html#af49088ab5736d8de16e24f2d1b07be23">Ogre::SceneNode</a>.</p>

</div>
</div>
<a id="a9aadf525c7f437c32cd17b0ccd606f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aadf525c7f437c32cd17b0ccd606f71">&#9670;&nbsp;</a></span>setListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a listener for this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note for size and performance reasons only one listener per node is allowed. </dd></dl>

</div>
</div>
<a id="aad75165137ce70fd865b3c5aa302a3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad75165137ce70fd865b3c5aa302a3bc">&#9670;&nbsp;</a></span>getListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a>* Ogre::Node::getListener </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current listener for this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>

</div>
</div>
<a id="a7832ae769b627172de3cf594b9769084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7832ae769b627172de3cf594b9769084">&#9670;&nbsp;</a></span>setInitialState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setInitialState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current transform of this node to be the 'initial state' ie that position / orientation / scale to be used as a basis for delta values used in keyframe animation. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You never need to call this method unless you plan to animate this node. If you do plan to animate it, call this method once you've loaded the node with it's base state, ie the state on which all keyframes are based. </dd></dl>
<dl class="section user"><dt></dt><dd>If you never call this method, the initial state is the identity transform, ie do nothing. </dd></dl>

</div>
</div>
<a id="a398e7142b2fbadea2a63097d37d4112b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398e7142b2fbadea2a63097d37d4112b">&#9670;&nbsp;</a></span>resetToInitialState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::resetToInitialState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the position / orientation / scale of this node to it's initial state, see setInitialState for more info. </p>

</div>
</div>
<a id="a515361d8231fc86d9b602ba55f714fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515361d8231fc86d9b602ba55f714fa9">&#9670;&nbsp;</a></span>getInitialPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&amp; Ogre::Node::getInitialPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the initial position of this node, see setInitialState for more info. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Also resets the cumulative animation weight used for blending. </dd></dl>

</div>
</div>
<a id="a8302c220e1e1f9ae9d83142bcb2e30ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8302c220e1e1f9ae9d83142bcb2e30ca">&#9670;&nbsp;</a></span>convertWorldToLocalPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> Ogre::Node::convertWorldToLocalPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>worldPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the local position, relative to this node, of the given world-space position. </p>

</div>
</div>
<a id="ad0bba0ab306650f26ab9f59df8666f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bba0ab306650f26ab9f59df8666f3c">&#9670;&nbsp;</a></span>convertLocalToWorldPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> Ogre::Node::convertLocalToWorldPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the world position of a point in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a id="a25e1a5a9da67b7bc7292b74ee2cfaba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e1a5a9da67b7bc7292b74ee2cfaba6">&#9670;&nbsp;</a></span>convertWorldToLocalDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> Ogre::Node::convertWorldToLocalDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>worldDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the local direction, relative to this node, of the given world-space direction. </p>

</div>
</div>
<a id="a3969475af6a52109883d7c7d44f35fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3969475af6a52109883d7c7d44f35fec">&#9670;&nbsp;</a></span>convertLocalToWorldDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> Ogre::Node::convertLocalToWorldDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the world direction of a point in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a id="a553f4e76d2416bd2c514f82c2f6117b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553f4e76d2416bd2c514f82c2f6117b7">&#9670;&nbsp;</a></span>convertWorldToLocalOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> Ogre::Node::convertWorldToLocalOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>worldOrientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the local orientation, relative to this node, of the given world-space orientation. </p>

</div>
</div>
<a id="aa87d582898b40ea668fe67ab428cfdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87d582898b40ea668fe67ab428cfdcf">&#9670;&nbsp;</a></span>convertLocalToWorldOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> Ogre::Node::convertLocalToWorldOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>localOrientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the world orientation of an orientation in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a id="a10da4e58434d3e61c6d76f97a0fd1a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10da4e58434d3e61c6d76f97a0fd1a80">&#9670;&nbsp;</a></span>getInitialOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&amp; Ogre::Node::getInitialOrientation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the initial orientation of this node, see setInitialState for more info. </p>

</div>
</div>
<a id="a5b9b0b08edc2984d41ad38520354a407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9b0b08edc2984d41ad38520354a407">&#9670;&nbsp;</a></span>getInitialScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&amp; Ogre::Node::getInitialScale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the initial position of this node, see setInitialState for more info. </p>

</div>
</div>
<a id="a1d6249bf582ea32554236af812a2e8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6249bf582ea32554236af812a2e8a2">&#9670;&nbsp;</a></span>getSquaredViewDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Node::getSquaredViewDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>cam</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function, get the squared view depth. </p>
<p><br  />
 </p>

</div>
</div>
<a id="a8671415cc4cf15e45bf716a823678736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8671415cc4cf15e45bf716a823678736">&#9670;&nbsp;</a></span>needUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::needUpdate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceParentUpdate</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To be called in the event of transform changes to this node that require it's recalculation. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This not only tags the node state as being 'dirty', it also requests it's parent to know about it's dirtiness so it will get an update next time. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forceParentUpdate</td><td>Even if the node thinks it has already told it's parent, tell it anyway </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_tag_point.html#a8a2025d7f4eb22046f2a36cad270335f">Ogre::TagPoint</a>, and <a class="el" href="class_ogre_1_1_bone.html#a99ebcfdf0a1516782b949dc0feb4c53c">Ogre::Bone</a>.</p>

</div>
</div>
<a id="a97676492945c888304b71ad4edc85e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97676492945c888304b71ad4edc85e5a">&#9670;&nbsp;</a></span>requestUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::requestUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceParentUpdate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by children to notify their parent that they need an update. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> to be updated </td></tr>
    <tr><td class="paramname">forceParentUpdate</td><td>Even if the node thinks it has already told it's parent, tell it anyway </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4bca65a1d911499aba99843fa41b3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bca65a1d911499aba99843fa41b3e9">&#9670;&nbsp;</a></span>cancelUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::cancelUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by children to notify their parent that they no longer need an update. </p>

</div>
</div>
<a id="a4609e37d3a70cf4318c99e9e1fb8dfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4609e37d3a70cf4318c99e9e1fb8dfd9">&#9670;&nbsp;</a></span>queueNeedUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Node::queueNeedUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue a 'needUpdate' call to a node safely. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You can't call <a class="el" href="class_ogre_1_1_node.html#a8671415cc4cf15e45bf716a823678736" title="To be called in the event of transform changes to this node that require it&#39;s recalculation.">needUpdate()</a> during the scene graph update, e.g. in response to a <a class="el" href="class_ogre_1_1_node_1_1_listener.html" title="Listener which gets called back on Node events.">Node::Listener</a> hook, because the graph is already being updated, and update flag changes cannot be made reliably in that context. Call this method if you need to queue a needUpdate call in this case. </dd></dl>

</div>
</div>
<a id="af990db414b5c4b26b055375401d3b5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af990db414b5c4b26b055375401d3b5d1">&#9670;&nbsp;</a></span>processQueuedUpdates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Node::processQueuedUpdates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process queued 'needUpdate' calls. </p>

</div>
</div>
<a id="a2fdf947d54d8b67b5fef19d68da899ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdf947d54d8b67b5fef19d68da899ae">&#9670;&nbsp;</a></span>setUserAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setUserAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_any.html">Any</a> &amp;&#160;</td>
          <td class="paramname"><em>anything</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000116">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance.">UserObjectBindings::setUserAny</a> via <a class="el" href="class_ogre_1_1_node.html#af3fcf16e43b07e046816125cbb8dc8f3" title="Class that provides convenient interface to establish a linkage between custom user application objec...">getUserObjectBindings()</a> instead.</dd></dl>

</div>
</div>
<a id="a9fa158a89aa8c4d8113ea52435eda1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa158a89aa8c4d8113ea52435eda1da">&#9670;&nbsp;</a></span>getUserAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_any.html">Any</a>&amp; Ogre::Node::getUserAny </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000117">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_user_object_bindings.html#a7b0c9bd7cf25e2d95aea3ee5138ef5b5" title="Retrieves the custom key less user object associated with this class.">UserObjectBindings::getUserAny</a> via <a class="el" href="class_ogre_1_1_node.html#af3fcf16e43b07e046816125cbb8dc8f3" title="Class that provides convenient interface to establish a linkage between custom user application objec...">getUserObjectBindings()</a> instead.</dd></dl>

</div>
</div>
<a id="af3fcf16e43b07e046816125cbb8dc8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fcf16e43b07e046816125cbb8dc8f3">&#9670;&nbsp;</a></span>getUserObjectBindings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::Node::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class that provides convenient interface to establish a linkage between custom user application objects and Ogre core classes. </p>

</div>
</div>
<a id="aa154e07b616313f4c345ec6c0da635cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa154e07b616313f4c345ec6c0da635cd">&#9670;&nbsp;</a></span>getUserObjectBindings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::Node::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_node_8h.html">OgreNode.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_node.html">Node</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
