<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::Pass Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">13.6</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_pass.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_pass-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::Pass Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___materials.html">Materials</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class defining a single pass of a <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> (of a <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Material</a>): a single rendering call.  
 <a href="class_ogre_1_1_pass.html#details">More...</a></p>

<p><code>#include &lt;OgrePass.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::Pass:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_pass__inherit__graph.svg" width="102" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_pass_1_1_hash_func.html">HashFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a functor for calculating the hashcode of a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>.  <a href="struct_ogre_1_1_pass_1_1_hash_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1d30a3c04994e1bd0e1de8cb343341a4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a1d30a3c04994e1bd0e1de8cb343341a4">BuiltinHashFunction</a> { <a class="el" href="class_ogre_1_1_pass.html#a1d30a3c04994e1bd0e1de8cb343341a4aab72a14d25f118c99dd6e9d40953ca46">MIN_TEXTURE_CHANGE</a>
, <a class="el" href="class_ogre_1_1_pass.html#a1d30a3c04994e1bd0e1de8cb343341a4a281f843d23df9554e590a19d1a3987e3">MIN_GPU_PROGRAM_CHANGE</a>
 }</td></tr>
<tr class="memdesc:a1d30a3c04994e1bd0e1de8cb343341a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">There are some default hash functions used to order passes so that render state changes are minimised, this enumerates them.  <a href="class_ogre_1_1_pass.html#a1d30a3c04994e1bd0e1de8cb343341a4">More...</a><br /></td></tr>
<tr class="separator:a1d30a3c04994e1bd0e1de8cb343341a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b42a4f4304f3f2d08fb9394cbefe83"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_pass.html#a1054ecda87f96dad530ec49099379755">TextureUnitStates</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a98b42a4f4304f3f2d08fb9394cbefe83">ConstTextureUnitStateIterator</a></td></tr>
<tr class="separator:a98b42a4f4304f3f2d08fb9394cbefe83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedba8526ffd478f5d731507c4779caf"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="class_ogre_1_1_pass.html">Pass</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aaedba8526ffd478f5d731507c4779caf">PassSet</a></td></tr>
<tr class="separator:aaedba8526ffd478f5d731507c4779caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bc2b00e42ad2699a1e2a1de340d3b4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_pass.html#a1054ecda87f96dad530ec49099379755">TextureUnitStates</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac7bc2b00e42ad2699a1e2a1de340d3b4">TextureUnitStateIterator</a></td></tr>
<tr class="separator:ac7bc2b00e42ad2699a1e2a1de340d3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1054ecda87f96dad530ec49099379755"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a1054ecda87f96dad530ec49099379755">TextureUnitStates</a></td></tr>
<tr class="separator:a1054ecda87f96dad530ec49099379755"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f36f2c48b62fd29b2abdee4425d6a2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a7f36f2c48b62fd29b2abdee4425d6a2c">Pass</a> (<a class="el" href="class_ogre_1_1_technique.html">Technique</a> *parent, unsigned short index)</td></tr>
<tr class="memdesc:a7f36f2c48b62fd29b2abdee4425d6a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_ogre_1_1_pass.html#a7f36f2c48b62fd29b2abdee4425d6a2c">More...</a><br /></td></tr>
<tr class="separator:a7f36f2c48b62fd29b2abdee4425d6a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af67ca21bb1a91d6c228db8207384fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a2af67ca21bb1a91d6c228db8207384fc">Pass</a> (<a class="el" href="class_ogre_1_1_technique.html">Technique</a> *parent, unsigned short index, const <a class="el" href="class_ogre_1_1_pass.html">Pass</a> &amp;oth)</td></tr>
<tr class="memdesc:a2af67ca21bb1a91d6c228db8207384fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="class_ogre_1_1_pass.html#a2af67ca21bb1a91d6c228db8207384fc">More...</a><br /></td></tr>
<tr class="separator:a2af67ca21bb1a91d6c228db8207384fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939fc6e2a02a7d753c84ec11219e97da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a939fc6e2a02a7d753c84ec11219e97da">~Pass</a> ()</td></tr>
<tr class="separator:a939fc6e2a02a7d753c84ec11219e97da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c84896039e6a9f3a44da8468591fb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a44c84896039e6a9f3a44da8468591fb3">_dirtyHash</a> (void)</td></tr>
<tr class="memdesc:a44c84896039e6a9f3a44da8468591fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the hash as dirty.  <a href="class_ogre_1_1_pass.html#a44c84896039e6a9f3a44da8468591fb3">More...</a><br /></td></tr>
<tr class="separator:a44c84896039e6a9f3a44da8468591fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e07d3bccdb7f6c437c107c92e4ae46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46">_load</a> (void)</td></tr>
<tr class="memdesc:ac1e07d3bccdb7f6c437c107c92e4ae46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for loading this pass.  <a href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46">More...</a><br /></td></tr>
<tr class="separator:ac1e07d3bccdb7f6c437c107c92e4ae46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa52a3826a08569b8263834f043a83f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#afaa52a3826a08569b8263834f043a83f">_notifyIndex</a> (unsigned short index)</td></tr>
<tr class="memdesc:afaa52a3826a08569b8263834f043a83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method to adjust pass index.  <a href="class_ogre_1_1_pass.html#afaa52a3826a08569b8263834f043a83f">More...</a><br /></td></tr>
<tr class="separator:afaa52a3826a08569b8263834f043a83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9af04b4a643df1d81cc0443ca34ab2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a6d9af04b4a643df1d81cc0443ca34ab2">_notifyNeedsRecompile</a> (void)</td></tr>
<tr class="memdesc:a6d9af04b4a643df1d81cc0443ca34ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the pass that it needs recompilation.  <a href="class_ogre_1_1_pass.html#a6d9af04b4a643df1d81cc0443ca34ab2">More...</a><br /></td></tr>
<tr class="separator:a6d9af04b4a643df1d81cc0443ca34ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85cf60f49c52c53671d5bb5105231e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab85cf60f49c52c53671d5bb5105231e8">_prepare</a> (void)</td></tr>
<tr class="memdesc:ab85cf60f49c52c53671d5bb5105231e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for preparing to load this pass.  <a href="class_ogre_1_1_pass.html#ab85cf60f49c52c53671d5bb5105231e8">More...</a><br /></td></tr>
<tr class="separator:ab85cf60f49c52c53671d5bb5105231e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367a1affcb2e26d61a5b5e3594b0ce6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a367a1affcb2e26d61a5b5e3594b0ce6a">_recalculateHash</a> (void)</td></tr>
<tr class="memdesc:a367a1affcb2e26d61a5b5e3594b0ce6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for recalculating the hash.  <a href="class_ogre_1_1_pass.html#a367a1affcb2e26d61a5b5e3594b0ce6a">More...</a><br /></td></tr>
<tr class="separator:a367a1affcb2e26d61a5b5e3594b0ce6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4934405e476e98dd05912a1ff42b7b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_pass.html">Pass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4934405e476e98dd05912a1ff42b7b2c">_split</a> (unsigned short numUnits)</td></tr>
<tr class="memdesc:a4934405e476e98dd05912a1ff42b7b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> to one which can be handled in the number of texture units specified.  <a href="class_ogre_1_1_pass.html#a4934405e476e98dd05912a1ff42b7b2c">More...</a><br /></td></tr>
<tr class="separator:a4934405e476e98dd05912a1ff42b7b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5766787845b1be6dfbf45cac068fc825"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a5766787845b1be6dfbf45cac068fc825">_unload</a> (void)</td></tr>
<tr class="memdesc:a5766787845b1be6dfbf45cac068fc825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for unloading this pass.  <a href="class_ogre_1_1_pass.html#a5766787845b1be6dfbf45cac068fc825">More...</a><br /></td></tr>
<tr class="separator:a5766787845b1be6dfbf45cac068fc825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928061c8f56d923808add7e8ba9cdee8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a928061c8f56d923808add7e8ba9cdee8">_unprepare</a> (void)</td></tr>
<tr class="memdesc:a928061c8f56d923808add7e8ba9cdee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for undoing the load preparartion for this pass.  <a href="class_ogre_1_1_pass.html#a928061c8f56d923808add7e8ba9cdee8">More...</a><br /></td></tr>
<tr class="separator:a928061c8f56d923808add7e8ba9cdee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17196c5383815e1af157fc9617c474b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad17196c5383815e1af157fc9617c474b">_updateAutoParams</a> (const <a class="el" href="class_ogre_1_1_auto_param_data_source.html">AutoParamDataSource</a> *source, <a class="el" href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">uint16</a> variabilityMask) const</td></tr>
<tr class="memdesc:ad17196c5383815e1af157fc9617c474b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update automatic parameters.  <a href="class_ogre_1_1_pass.html#ad17196c5383815e1af157fc9617c474b">More...</a><br /></td></tr>
<tr class="separator:ad17196c5383815e1af157fc9617c474b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e0c135dbcacf5d12cc78a15452c7dc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a76e0c135dbcacf5d12cc78a15452c7dc">calculateSize</a> (void) const</td></tr>
<tr class="separator:a76e0c135dbcacf5d12cc78a15452c7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb647950fbc40f52ae139eb166d602d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga4766f4c65e0a47f0a71c5908944a7a3c">CullingMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aedb647950fbc40f52ae139eb166d602d">getCullingMode</a> (void) const</td></tr>
<tr class="memdesc:aedb647950fbc40f52ae139eb166d602d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the culling mode for geometry rendered with this pass.  <a href="class_ogre_1_1_pass.html#aedb647950fbc40f52ae139eb166d602d">More...</a><br /></td></tr>
<tr class="separator:aedb647950fbc40f52ae139eb166d602d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6096fdb876d7929f8d78d4fabae44a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a6096fdb876d7929f8d78d4fabae44a25">getHash</a> (void) const</td></tr>
<tr class="memdesc:a6096fdb876d7929f8d78d4fabae44a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 'hash' of this pass, ie a precomputed number to use for sorting.  <a href="class_ogre_1_1_pass.html#a6096fdb876d7929f8d78d4fabae44a25">More...</a><br /></td></tr>
<tr class="separator:a6096fdb876d7929f8d78d4fabae44a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77551778f0d1989cdf7541cd0a71faf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___materials.html#gaa6fda2d6bac5df9dc239f566ceed77b6">IlluminationStage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a77551778f0d1989cdf7541cd0a71faf8">getIlluminationStage</a> () const</td></tr>
<tr class="memdesc:a77551778f0d1989cdf7541cd0a71faf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the manually assigned illumination stage, if any.  <a href="class_ogre_1_1_pass.html#a77551778f0d1989cdf7541cd0a71faf8">More...</a><br /></td></tr>
<tr class="separator:a77551778f0d1989cdf7541cd0a71faf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3b4e8c3d0058a43cd2b855fc22199c"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#afb3b4e8c3d0058a43cd2b855fc22199c">getIndex</a> (void) const</td></tr>
<tr class="memdesc:afb3b4e8c3d0058a43cd2b855fc22199c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in the parent <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_pass.html#afb3b4e8c3d0058a43cd2b855fc22199c">More...</a><br /></td></tr>
<tr class="separator:afb3b4e8c3d0058a43cd2b855fc22199c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c32f4167d3ac2bfedb5ff536ab87594"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a0c32f4167d3ac2bfedb5ff536ab87594">getLightClipPlanesEnabled</a> () const</td></tr>
<tr class="memdesc:a0c32f4167d3ac2bfedb5ff536ab87594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not this pass will be clipped by user clips planes bounding the area covered by the light.  <a href="class_ogre_1_1_pass.html#a0c32f4167d3ac2bfedb5ff536ab87594">More...</a><br /></td></tr>
<tr class="separator:a0c32f4167d3ac2bfedb5ff536ab87594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27766dcc987d75b836519d8be88fc6f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a27766dcc987d75b836519d8be88fc6f6">getLightScissoringEnabled</a> () const</td></tr>
<tr class="memdesc:a27766dcc987d75b836519d8be88fc6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not this pass will be clipped by a scissor rectangle encompassing the lights that are being used in it.  <a href="class_ogre_1_1_pass.html#a27766dcc987d75b836519d8be88fc6f6">More...</a><br /></td></tr>
<tr class="separator:a27766dcc987d75b836519d8be88fc6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788b633913442314683050c34b2c3c9b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a788b633913442314683050c34b2c3c9b">getLineWidth</a> () const</td></tr>
<tr class="separator:a788b633913442314683050c34b2c3c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd99aaea7eec3026699bfccdd09310b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga67144aea217e56725c43541fb064af20">ManualCullingMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#acd99aaea7eec3026699bfccdd09310b0">getManualCullingMode</a> (void) const</td></tr>
<tr class="memdesc:acd99aaea7eec3026699bfccdd09310b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the manual culling mode for this pass.  <a href="class_ogre_1_1_pass.html#acd99aaea7eec3026699bfccdd09310b0">More...</a><br /></td></tr>
<tr class="separator:acd99aaea7eec3026699bfccdd09310b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242acbbf397d9db273dcb42d9e4a653c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a242acbbf397d9db273dcb42d9e4a653c">getName</a> (void) const</td></tr>
<tr class="memdesc:a242acbbf397d9db273dcb42d9e4a653c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the pass.  <a href="class_ogre_1_1_pass.html#a242acbbf397d9db273dcb42d9e4a653c">More...</a><br /></td></tr>
<tr class="separator:a242acbbf397d9db273dcb42d9e4a653c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858b9c564570fd84e19c77a9b84da557"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a858b9c564570fd84e19c77a9b84da557">getNormaliseNormals</a> (void) const</td></tr>
<tr class="memdesc:a858b9c564570fd84e19c77a9b84da557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass has auto-normalisation of normals set.  <a href="class_ogre_1_1_pass.html#a858b9c564570fd84e19c77a9b84da557">More...</a><br /></td></tr>
<tr class="separator:a858b9c564570fd84e19c77a9b84da557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224fe87a1d87d16212184331ef8a4906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_technique.html">Technique</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a224fe87a1d87d16212184331ef8a4906">getParent</a> (void) const</td></tr>
<tr class="memdesc:a224fe87a1d87d16212184331ef8a4906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_pass.html#a224fe87a1d87d16212184331ef8a4906">More...</a><br /></td></tr>
<tr class="separator:a224fe87a1d87d16212184331ef8a4906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51f3602ae69b8d0f219582aa6b16d48"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad51f3602ae69b8d0f219582aa6b16d48">getPassIterationCount</a> (void) const</td></tr>
<tr class="memdesc:ad51f3602ae69b8d0f219582aa6b16d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pass iteration count value.  <a href="class_ogre_1_1_pass.html#ad51f3602ae69b8d0f219582aa6b16d48">More...</a><br /></td></tr>
<tr class="separator:ad51f3602ae69b8d0f219582aa6b16d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4791eea37712b82994052b3e4a360fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga2df30008578f1d062a70ec268d1ae016">PolygonMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4791eea37712b82994052b3e4a360fa0">getPolygonMode</a> (void) const</td></tr>
<tr class="memdesc:a4791eea37712b82994052b3e4a360fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of light shading to be used.  <a href="class_ogre_1_1_pass.html#a4791eea37712b82994052b3e4a360fa0">More...</a><br /></td></tr>
<tr class="separator:a4791eea37712b82994052b3e4a360fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5a5d646e84a1d6c0be32f1132419f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#acb5a5d646e84a1d6c0be32f1132419f8">getPolygonModeOverrideable</a> (void) const</td></tr>
<tr class="memdesc:acb5a5d646e84a1d6c0be32f1132419f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether this renderable's chosen detail level can be overridden (downgraded) by the camera setting.  <a href="class_ogre_1_1_pass.html#acb5a5d646e84a1d6c0be32f1132419f8">More...</a><br /></td></tr>
<tr class="separator:acb5a5d646e84a1d6c0be32f1132419f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd99345b312bfb24c297b147b7665c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a0bd99345b312bfb24c297b147b7665c5">getResourceGroup</a> (void) const</td></tr>
<tr class="memdesc:a0bd99345b312bfb24c297b147b7665c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the resource group of the ultimate parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Material</a>.  <a href="class_ogre_1_1_pass.html#a0bd99345b312bfb24c297b147b7665c5">More...</a><br /></td></tr>
<tr class="separator:a0bd99345b312bfb24c297b147b7665c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5485f8b014bfa01d765a442999ad9ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga12cb29cae690b696c0f1c4863d8c25a7">ShadeOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a5485f8b014bfa01d765a442999ad9ed3">getShadingMode</a> (void) const</td></tr>
<tr class="memdesc:a5485f8b014bfa01d765a442999ad9ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of light shading to be used.  <a href="class_ogre_1_1_pass.html#a5485f8b014bfa01d765a442999ad9ed3">More...</a><br /></td></tr>
<tr class="separator:a5485f8b014bfa01d765a442999ad9ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6ab6d3bce34b620675e9ccd2dfb89f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4a6ab6d3bce34b620675e9ccd2dfb89f">getTransparentSortingEnabled</a> (void) const</td></tr>
<tr class="memdesc:a4a6ab6d3bce34b620675e9ccd2dfb89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not transparent sorting is enabled.  <a href="class_ogre_1_1_pass.html#a4a6ab6d3bce34b620675e9ccd2dfb89f">More...</a><br /></td></tr>
<tr class="separator:a4a6ab6d3bce34b620675e9ccd2dfb89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9729c4faa36b1a38ce0a8c14a3627dbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a9729c4faa36b1a38ce0a8c14a3627dbe">getTransparentSortingForced</a> (void) const</td></tr>
<tr class="memdesc:a9729c4faa36b1a38ce0a8c14a3627dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not transparent sorting is forced.  <a href="class_ogre_1_1_pass.html#a9729c4faa36b1a38ce0a8c14a3627dbe">More...</a><br /></td></tr>
<tr class="separator:a9729c4faa36b1a38ce0a8c14a3627dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc70de42e8b22b4d8ccedf6868bbbfc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#adc70de42e8b22b4d8ccedf6868bbbfc0">getUserObjectBindings</a> ()</td></tr>
<tr class="memdesc:adc70de42e8b22b4d8ccedf6868bbbfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides convenient interface to establish a linkage between custom user application objects and Ogre core classes.  <a href="class_ogre_1_1_pass.html#adc70de42e8b22b4d8ccedf6868bbbfc0">More...</a><br /></td></tr>
<tr class="separator:adc70de42e8b22b4d8ccedf6868bbbfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a272de4bac1f7ab74ad965217f163ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a1a272de4bac1f7ab74ad965217f163ec">getUserObjectBindings</a> () const</td></tr>
<tr class="memdesc:a1a272de4bac1f7ab74ad965217f163ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a1a272de4bac1f7ab74ad965217f163ec">More...</a><br /></td></tr>
<tr class="separator:a1a272de4bac1f7ab74ad965217f163ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff736f5d1d0eb3e3caa23b1d7c79997"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8ff736f5d1d0eb3e3caa23b1d7c79997">isAmbientOnly</a> (void) const</td></tr>
<tr class="memdesc:a8ff736f5d1d0eb3e3caa23b1d7c79997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this pass is ambient only.  <a href="class_ogre_1_1_pass.html#a8ff736f5d1d0eb3e3caa23b1d7c79997">More...</a><br /></td></tr>
<tr class="separator:a8ff736f5d1d0eb3e3caa23b1d7c79997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36390b119257048ddb35ab0439eed63d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a36390b119257048ddb35ab0439eed63d">isLoaded</a> (void) const</td></tr>
<tr class="memdesc:a36390b119257048ddb35ab0439eed63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this loaded?  <a href="class_ogre_1_1_pass.html#a36390b119257048ddb35ab0439eed63d">More...</a><br /></td></tr>
<tr class="separator:a36390b119257048ddb35ab0439eed63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a67b777d757d158c6cbc2b4f7ec76e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a85a67b777d757d158c6cbc2b4f7ec76e">isTransparent</a> (void) const</td></tr>
<tr class="memdesc:a85a67b777d757d158c6cbc2b4f7ec76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass has some element of transparency.  <a href="class_ogre_1_1_pass.html#a85a67b777d757d158c6cbc2b4f7ec76e">More...</a><br /></td></tr>
<tr class="separator:a85a67b777d757d158c6cbc2b4f7ec76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3af180b9759ea13e557003abc84e594"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab3af180b9759ea13e557003abc84e594">OGRE_MUTEX</a> (mGpuProgramChangeMutex)</td></tr>
<tr class="separator:ab3af180b9759ea13e557003abc84e594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23f6b1ae56f9acdcb05f8cbcf0e9153"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af23f6b1ae56f9acdcb05f8cbcf0e9153">OGRE_MUTEX</a> (mTexUnitChangeMutex)</td></tr>
<tr class="separator:af23f6b1ae56f9acdcb05f8cbcf0e9153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10afa648bf34693a7b6c377e126da20f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a10afa648bf34693a7b6c377e126da20f">OGRE_STATIC_MUTEX</a> (msDirtyHashListMutex)</td></tr>
<tr class="separator:a10afa648bf34693a7b6c377e126da20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25733e77cd0b2f558d62e5a7ab7592e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab25733e77cd0b2f558d62e5a7ab7592e">OGRE_STATIC_MUTEX</a> (msPassGraveyardMutex)</td></tr>
<tr class="separator:ab25733e77cd0b2f558d62e5a7ab7592e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bb76abae180b60dfcf9a6e1fdcd8fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_pass.html">Pass</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a15bb76abae180b60dfcf9a6e1fdcd8fe">operator=</a> (const <a class="el" href="class_ogre_1_1_pass.html">Pass</a> &amp;oth)</td></tr>
<tr class="memdesc:a15bb76abae180b60dfcf9a6e1fdcd8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator = overload.  <a href="class_ogre_1_1_pass.html#a15bb76abae180b60dfcf9a6e1fdcd8fe">More...</a><br /></td></tr>
<tr class="separator:a15bb76abae180b60dfcf9a6e1fdcd8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb16b94de537bda3140df7095090cc10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aeb16b94de537bda3140df7095090cc10">queueForDeletion</a> (void)</td></tr>
<tr class="memdesc:aeb16b94de537bda3140df7095090cc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue this pass for deletion when appropriate.  <a href="class_ogre_1_1_pass.html#aeb16b94de537bda3140df7095090cc10">More...</a><br /></td></tr>
<tr class="separator:aeb16b94de537bda3140df7095090cc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8942abf3ede0f3cb43584c85c4071734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8942abf3ede0f3cb43584c85c4071734">setCullingMode</a> (<a class="el" href="group___general.html#ga4766f4c65e0a47f0a71c5908944a7a3c">CullingMode</a> mode)</td></tr>
<tr class="memdesc:a8942abf3ede0f3cb43584c85c4071734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the culling mode for this pass based on the 'vertex winding'.  <a href="class_ogre_1_1_pass.html#a8942abf3ede0f3cb43584c85c4071734">More...</a><br /></td></tr>
<tr class="separator:a8942abf3ede0f3cb43584c85c4071734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d680bb28cd69415883313d9f03dc6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a30d680bb28cd69415883313d9f03dc6a">setIlluminationStage</a> (<a class="el" href="group___materials.html#gaa6fda2d6bac5df9dc239f566ceed77b6">IlluminationStage</a> is)</td></tr>
<tr class="memdesc:a30d680bb28cd69415883313d9f03dc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set which illumination stage this pass is a member of.  <a href="class_ogre_1_1_pass.html#a30d680bb28cd69415883313d9f03dc6a">More...</a><br /></td></tr>
<tr class="separator:a30d680bb28cd69415883313d9f03dc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d94474787abfd9eb9b07d5185ded0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a20d94474787abfd9eb9b07d5185ded0c">setLightClipPlanesEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a20d94474787abfd9eb9b07d5185ded0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not this pass will be clipped by user clips planes bounding the area covered by the light.  <a href="class_ogre_1_1_pass.html#a20d94474787abfd9eb9b07d5185ded0c">More...</a><br /></td></tr>
<tr class="separator:a20d94474787abfd9eb9b07d5185ded0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fe99447102afb8e2002f7f1339dd8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a26fe99447102afb8e2002f7f1339dd8c">setLightScissoringEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a26fe99447102afb8e2002f7f1339dd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not this pass will be clipped by a scissor rectangle encompassing the lights that are being used in it.  <a href="class_ogre_1_1_pass.html#a26fe99447102afb8e2002f7f1339dd8c">More...</a><br /></td></tr>
<tr class="separator:a26fe99447102afb8e2002f7f1339dd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63508d99fef116d0df14c080e0e1129"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab63508d99fef116d0df14c080e0e1129">setLineWidth</a> (float width)</td></tr>
<tr class="memdesc:ab63508d99fef116d0df14c080e0e1129"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the line width for this pass  <a href="class_ogre_1_1_pass.html#ab63508d99fef116d0df14c080e0e1129">More...</a><br /></td></tr>
<tr class="separator:ab63508d99fef116d0df14c080e0e1129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b528827b54f17b72bb204321640a6f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a3b528827b54f17b72bb204321640a6f7">setManualCullingMode</a> (<a class="el" href="group___general.html#ga67144aea217e56725c43541fb064af20">ManualCullingMode</a> mode)</td></tr>
<tr class="memdesc:a3b528827b54f17b72bb204321640a6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the manual culling mode, performed by CPU rather than hardware.  <a href="class_ogre_1_1_pass.html#a3b528827b54f17b72bb204321640a6f7">More...</a><br /></td></tr>
<tr class="separator:a3b528827b54f17b72bb204321640a6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03306f735122ec4e7d4c391f1528cf50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a03306f735122ec4e7d4c391f1528cf50">setName</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name)</td></tr>
<tr class="memdesc:a03306f735122ec4e7d4c391f1528cf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the pass.  <a href="class_ogre_1_1_pass.html#a03306f735122ec4e7d4c391f1528cf50">More...</a><br /></td></tr>
<tr class="separator:a03306f735122ec4e7d4c391f1528cf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00b9d37cf0d5d7af26d23a2a48f5541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad00b9d37cf0d5d7af26d23a2a48f5541">setNormaliseNormals</a> (bool normalise)</td></tr>
<tr class="memdesc:ad00b9d37cf0d5d7af26d23a2a48f5541"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to true, this forces normals to be normalised dynamically by the hardware for this pass.  <a href="class_ogre_1_1_pass.html#ad00b9d37cf0d5d7af26d23a2a48f5541">More...</a><br /></td></tr>
<tr class="separator:ad00b9d37cf0d5d7af26d23a2a48f5541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ff8c16ee57201651da61e649ea216b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a28ff8c16ee57201651da61e649ea216b">setPassIterationCount</a> (const size_t count)</td></tr>
<tr class="memdesc:a28ff8c16ee57201651da61e649ea216b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the number of iterations that this pass should perform when doing fast multi pass operation.  <a href="class_ogre_1_1_pass.html#a28ff8c16ee57201651da61e649ea216b">More...</a><br /></td></tr>
<tr class="separator:a28ff8c16ee57201651da61e649ea216b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d996b43e57fa45e660b23013855fe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a61d996b43e57fa45e660b23013855fe2">setPolygonMode</a> (<a class="el" href="group___general.html#ga2df30008578f1d062a70ec268d1ae016">PolygonMode</a> mode)</td></tr>
<tr class="memdesc:a61d996b43e57fa45e660b23013855fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of polygon rendering required.  <a href="class_ogre_1_1_pass.html#a61d996b43e57fa45e660b23013855fe2">More...</a><br /></td></tr>
<tr class="separator:a61d996b43e57fa45e660b23013855fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad681df78f0e0c61e1bc166e3ec85170f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad681df78f0e0c61e1bc166e3ec85170f">setPolygonModeOverrideable</a> (bool override)</td></tr>
<tr class="memdesc:ad681df78f0e0c61e1bc166e3ec85170f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the PolygonMode set on this pass can be downgraded by the camera.  <a href="class_ogre_1_1_pass.html#ad681df78f0e0c61e1bc166e3ec85170f">More...</a><br /></td></tr>
<tr class="separator:ad681df78f0e0c61e1bc166e3ec85170f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6c00297cd5d46bb365d981cd1764a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ade6c00297cd5d46bb365d981cd1764a6">setShadingMode</a> (<a class="el" href="group___general.html#ga12cb29cae690b696c0f1c4863d8c25a7">ShadeOptions</a> mode)</td></tr>
<tr class="memdesc:ade6c00297cd5d46bb365d981cd1764a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of light shading required.  <a href="class_ogre_1_1_pass.html#ade6c00297cd5d46bb365d981cd1764a6">More...</a><br /></td></tr>
<tr class="separator:ade6c00297cd5d46bb365d981cd1764a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b99af55835117cfd4c479ab6c3a2ae5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a2b99af55835117cfd4c479ab6c3a2ae5">setTransparentSortingEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a2b99af55835117cfd4c479ab6c3a2ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not transparent sorting is enabled.  <a href="class_ogre_1_1_pass.html#a2b99af55835117cfd4c479ab6c3a2ae5">More...</a><br /></td></tr>
<tr class="separator:a2b99af55835117cfd4c479ab6c3a2ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc75fe5011be72c0597535cb37d75d57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#adc75fe5011be72c0597535cb37d75d57">setTransparentSortingForced</a> (bool enabled)</td></tr>
<tr class="memdesc:adc75fe5011be72c0597535cb37d75d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not transparent sorting is forced.  <a href="class_ogre_1_1_pass.html#adc75fe5011be72c0597535cb37d75d57">More...</a><br /></td></tr>
<tr class="separator:adc75fe5011be72c0597535cb37d75d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Surface properties</div></td></tr>
<tr class="memitem:aba057d0d19159c21b9a79485512b6f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aba057d0d19159c21b9a79485512b6f9d">setAmbient</a> (float red, float green, float blue)</td></tr>
<tr class="memdesc:aba057d0d19159c21b9a79485512b6f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ambient colour reflectance properties of this pass.  <a href="class_ogre_1_1_pass.html#aba057d0d19159c21b9a79485512b6f9d">More...</a><br /></td></tr>
<tr class="separator:aba057d0d19159c21b9a79485512b6f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcffe5cb7cee6c8c5a5fd4c2f75164d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#abdcffe5cb7cee6c8c5a5fd4c2f75164d">setAmbient</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;ambient)</td></tr>
<tr class="memdesc:abdcffe5cb7cee6c8c5a5fd4c2f75164d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#abdcffe5cb7cee6c8c5a5fd4c2f75164d">More...</a><br /></td></tr>
<tr class="separator:abdcffe5cb7cee6c8c5a5fd4c2f75164d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823dd0856cf4d8bfa08abc3591c47c02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a823dd0856cf4d8bfa08abc3591c47c02">setDiffuse</a> (float red, float green, float blue, float alpha)</td></tr>
<tr class="memdesc:a823dd0856cf4d8bfa08abc3591c47c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the diffuse colour reflectance properties of this pass.  <a href="class_ogre_1_1_pass.html#a823dd0856cf4d8bfa08abc3591c47c02">More...</a><br /></td></tr>
<tr class="separator:a823dd0856cf4d8bfa08abc3591c47c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e3cb12113b4fc56b8d3d4cee03068a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a67e3cb12113b4fc56b8d3d4cee03068a">setDiffuse</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;diffuse)</td></tr>
<tr class="memdesc:a67e3cb12113b4fc56b8d3d4cee03068a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a67e3cb12113b4fc56b8d3d4cee03068a">More...</a><br /></td></tr>
<tr class="separator:a67e3cb12113b4fc56b8d3d4cee03068a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e47ea4922d6da5b58eb9879f7e9da09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4e47ea4922d6da5b58eb9879f7e9da09">setSpecular</a> (float red, float green, float blue, float alpha)</td></tr>
<tr class="memdesc:a4e47ea4922d6da5b58eb9879f7e9da09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specular colour reflectance properties of this pass.  <a href="class_ogre_1_1_pass.html#a4e47ea4922d6da5b58eb9879f7e9da09">More...</a><br /></td></tr>
<tr class="separator:a4e47ea4922d6da5b58eb9879f7e9da09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66770883c6420a761996a29b9d5f57bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a66770883c6420a761996a29b9d5f57bc">setSpecular</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;specular)</td></tr>
<tr class="memdesc:a66770883c6420a761996a29b9d5f57bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a66770883c6420a761996a29b9d5f57bc">More...</a><br /></td></tr>
<tr class="separator:a66770883c6420a761996a29b9d5f57bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0977cabd2a7fb79f9ee03078f79011a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af0977cabd2a7fb79f9ee03078f79011a">setShininess</a> (float val)</td></tr>
<tr class="memdesc:af0977cabd2a7fb79f9ee03078f79011a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the shininess of the pass, affecting the size of specular highlights.  <a href="class_ogre_1_1_pass.html#af0977cabd2a7fb79f9ee03078f79011a">More...</a><br /></td></tr>
<tr class="separator:af0977cabd2a7fb79f9ee03078f79011a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c36ae948d9e0357c11adb0ce6d5859"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a93c36ae948d9e0357c11adb0ce6d5859">setSelfIllumination</a> (float red, float green, float blue)</td></tr>
<tr class="memdesc:a93c36ae948d9e0357c11adb0ce6d5859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the amount of self-illumination an object has.  <a href="class_ogre_1_1_pass.html#a93c36ae948d9e0357c11adb0ce6d5859">More...</a><br /></td></tr>
<tr class="separator:a93c36ae948d9e0357c11adb0ce6d5859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed49cbeb67725747cb25376ca67c2bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4ed49cbeb67725747cb25376ca67c2bb">setSelfIllumination</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;selfIllum)</td></tr>
<tr class="memdesc:a4ed49cbeb67725747cb25376ca67c2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a4ed49cbeb67725747cb25376ca67c2bb">More...</a><br /></td></tr>
<tr class="separator:a4ed49cbeb67725747cb25376ca67c2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ad6543e0c24eb7f12b00f46e7124d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae3ad6543e0c24eb7f12b00f46e7124d8">setEmissive</a> (float red, float green, float blue)</td></tr>
<tr class="memdesc:ae3ad6543e0c24eb7f12b00f46e7124d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the amount of self-illumination an object has.  <a href="class_ogre_1_1_pass.html#ae3ad6543e0c24eb7f12b00f46e7124d8">More...</a><br /></td></tr>
<tr class="separator:ae3ad6543e0c24eb7f12b00f46e7124d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5653eb7430051fc4a81aa577c031186"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae5653eb7430051fc4a81aa577c031186">setEmissive</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;emissive)</td></tr>
<tr class="memdesc:ae5653eb7430051fc4a81aa577c031186"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#ae5653eb7430051fc4a81aa577c031186">More...</a><br /></td></tr>
<tr class="separator:ae5653eb7430051fc4a81aa577c031186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b32d92dd9d316ff9650affd08d16a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a30b32d92dd9d316ff9650affd08d16a2">setVertexColourTracking</a> (<a class="el" href="group___general.html#gaf3fdba7211d7078a43201a1721532f9e">TrackVertexColourType</a> tracking)</td></tr>
<tr class="memdesc:a30b32d92dd9d316ff9650affd08d16a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets which material properties follow the vertex colour.  <a href="class_ogre_1_1_pass.html#a30b32d92dd9d316ff9650affd08d16a2">More...</a><br /></td></tr>
<tr class="separator:a30b32d92dd9d316ff9650affd08d16a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025d29e0df7f5fa8209e37e3dbac057a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a025d29e0df7f5fa8209e37e3dbac057a">getAmbient</a> (void) const</td></tr>
<tr class="memdesc:a025d29e0df7f5fa8209e37e3dbac057a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ambient colour reflectance of the pass.  <a href="class_ogre_1_1_pass.html#a025d29e0df7f5fa8209e37e3dbac057a">More...</a><br /></td></tr>
<tr class="separator:a025d29e0df7f5fa8209e37e3dbac057a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41a5ed7aadfabec2111e3124f77cf71"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab41a5ed7aadfabec2111e3124f77cf71">getDiffuse</a> (void) const</td></tr>
<tr class="memdesc:ab41a5ed7aadfabec2111e3124f77cf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the diffuse colour reflectance of the pass.  <a href="class_ogre_1_1_pass.html#ab41a5ed7aadfabec2111e3124f77cf71">More...</a><br /></td></tr>
<tr class="separator:ab41a5ed7aadfabec2111e3124f77cf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9847a07e3a202069e91cd0cccc104de7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a9847a07e3a202069e91cd0cccc104de7">getSpecular</a> (void) const</td></tr>
<tr class="memdesc:a9847a07e3a202069e91cd0cccc104de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specular colour reflectance of the pass.  <a href="class_ogre_1_1_pass.html#a9847a07e3a202069e91cd0cccc104de7">More...</a><br /></td></tr>
<tr class="separator:a9847a07e3a202069e91cd0cccc104de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cc793a33a80097900866835aea9abd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a21cc793a33a80097900866835aea9abd">getSelfIllumination</a> (void) const</td></tr>
<tr class="memdesc:a21cc793a33a80097900866835aea9abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the self illumination colour of the pass.  <a href="class_ogre_1_1_pass.html#a21cc793a33a80097900866835aea9abd">More...</a><br /></td></tr>
<tr class="separator:a21cc793a33a80097900866835aea9abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c97de91cbc0c86e3ca06ccc22b9a12"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a57c97de91cbc0c86e3ca06ccc22b9a12">getEmissive</a> (void) const</td></tr>
<tr class="memdesc:a57c97de91cbc0c86e3ca06ccc22b9a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the self illumination colour of the pass.  <a href="class_ogre_1_1_pass.html#a57c97de91cbc0c86e3ca06ccc22b9a12">More...</a><br /></td></tr>
<tr class="separator:a57c97de91cbc0c86e3ca06ccc22b9a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031e484e234b00dc415a6122db64ba63"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a031e484e234b00dc415a6122db64ba63">getShininess</a> (void) const</td></tr>
<tr class="memdesc:a031e484e234b00dc415a6122db64ba63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 'shininess' property of the pass (affects specular highlights).  <a href="class_ogre_1_1_pass.html#a031e484e234b00dc415a6122db64ba63">More...</a><br /></td></tr>
<tr class="separator:a031e484e234b00dc415a6122db64ba63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f48ebbf2890d0744443f7da45acab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#gaf3fdba7211d7078a43201a1721532f9e">TrackVertexColourType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a36f48ebbf2890d0744443f7da45acab7">getVertexColourTracking</a> (void) const</td></tr>
<tr class="memdesc:a36f48ebbf2890d0744443f7da45acab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets which material properties follow the vertex colour.  <a href="class_ogre_1_1_pass.html#a36f48ebbf2890d0744443f7da45acab7">More...</a><br /></td></tr>
<tr class="separator:a36f48ebbf2890d0744443f7da45acab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6285f13a06eb7f00b83ea2754e434623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623">setLightingEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a6285f13a06eb7f00b83ea2754e434623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not dynamic lighting is enabled.  <a href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623">More...</a><br /></td></tr>
<tr class="separator:a6285f13a06eb7f00b83ea2754e434623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce35807758f26b84d29313cf70593cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#abce35807758f26b84d29313cf70593cd">getLightingEnabled</a> (void) const</td></tr>
<tr class="memdesc:abce35807758f26b84d29313cf70593cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not dynamic lighting is enabled.  <a href="class_ogre_1_1_pass.html#abce35807758f26b84d29313cf70593cd">More...</a><br /></td></tr>
<tr class="separator:abce35807758f26b84d29313cf70593cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Point Sprites</div></td></tr>
<tr class="memitem:a179a7abbb9ec8f4da2c8369691ad0032"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a179a7abbb9ec8f4da2c8369691ad0032">getPointSize</a> (void) const</td></tr>
<tr class="memdesc:a179a7abbb9ec8f4da2c8369691ad0032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the point size of the pass.  <a href="class_ogre_1_1_pass.html#a179a7abbb9ec8f4da2c8369691ad0032">More...</a><br /></td></tr>
<tr class="separator:a179a7abbb9ec8f4da2c8369691ad0032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490736f9eaeffd1c60611869d68931ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a490736f9eaeffd1c60611869d68931ee">setPointSize</a> (float ps)</td></tr>
<tr class="memdesc:a490736f9eaeffd1c60611869d68931ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the point size of this pass.  <a href="class_ogre_1_1_pass.html#a490736f9eaeffd1c60611869d68931ee">More...</a><br /></td></tr>
<tr class="separator:a490736f9eaeffd1c60611869d68931ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9683c2f40ed7c96b708eb2db5e02c842"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a9683c2f40ed7c96b708eb2db5e02c842">setPointSpritesEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a9683c2f40ed7c96b708eb2db5e02c842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether points will be rendered as textured quads or plain dots.  <a href="class_ogre_1_1_pass.html#a9683c2f40ed7c96b708eb2db5e02c842">More...</a><br /></td></tr>
<tr class="separator:a9683c2f40ed7c96b708eb2db5e02c842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70ccd332a1df548058917c31021f7df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af70ccd332a1df548058917c31021f7df">getPointSpritesEnabled</a> (void) const</td></tr>
<tr class="memdesc:af70ccd332a1df548058917c31021f7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether point sprites are enabled when rendering a point list.  <a href="class_ogre_1_1_pass.html#af70ccd332a1df548058917c31021f7df">More...</a><br /></td></tr>
<tr class="separator:af70ccd332a1df548058917c31021f7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3540a0dab9519f146edad630f3c89c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a3540a0dab9519f146edad630f3c89c22">setPointAttenuation</a> (bool enabled, float constant=0.0f, float linear=1.0f, float quadratic=0.0f)</td></tr>
<tr class="memdesc:a3540a0dab9519f146edad630f3c89c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets how points are attenuated with distance.  <a href="class_ogre_1_1_pass.html#a3540a0dab9519f146edad630f3c89c22">More...</a><br /></td></tr>
<tr class="separator:a3540a0dab9519f146edad630f3c89c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e358a5fd8a944c9845f8aee4ba54a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af5e358a5fd8a944c9845f8aee4ba54a6">isPointAttenuationEnabled</a> (void) const</td></tr>
<tr class="memdesc:af5e358a5fd8a944c9845f8aee4ba54a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether points are attenuated with distance.  <a href="class_ogre_1_1_pass.html#af5e358a5fd8a944c9845f8aee4ba54a6">More...</a><br /></td></tr>
<tr class="separator:af5e358a5fd8a944c9845f8aee4ba54a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d04fc4bd33d55bd6059c06db15f5f8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a58d04fc4bd33d55bd6059c06db15f5f8">getPointAttenuationConstant</a> (void) const</td></tr>
<tr class="memdesc:a58d04fc4bd33d55bd6059c06db15f5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant coefficient of point attenuation.  <a href="class_ogre_1_1_pass.html#a58d04fc4bd33d55bd6059c06db15f5f8">More...</a><br /></td></tr>
<tr class="separator:a58d04fc4bd33d55bd6059c06db15f5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27332810328f3be996516ccfd105ac2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af27332810328f3be996516ccfd105ac2">getPointAttenuationLinear</a> (void) const</td></tr>
<tr class="memdesc:af27332810328f3be996516ccfd105ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the linear coefficient of point attenuation.  <a href="class_ogre_1_1_pass.html#af27332810328f3be996516ccfd105ac2">More...</a><br /></td></tr>
<tr class="separator:af27332810328f3be996516ccfd105ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d25e05b830745ecfc6cbd09624ee17"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad7d25e05b830745ecfc6cbd09624ee17">getPointAttenuationQuadratic</a> (void) const</td></tr>
<tr class="memdesc:ad7d25e05b830745ecfc6cbd09624ee17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quadratic coefficient of point attenuation.  <a href="class_ogre_1_1_pass.html#ad7d25e05b830745ecfc6cbd09624ee17">More...</a><br /></td></tr>
<tr class="separator:ad7d25e05b830745ecfc6cbd09624ee17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb0e0f957c2dd23fb068a160dd4f8f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a272ffe59e216908cce70c5fd11eaa7ff">Vector4f</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a2eb0e0f957c2dd23fb068a160dd4f8f5">getPointAttenuation</a> () const</td></tr>
<tr class="memdesc:a2eb0e0f957c2dd23fb068a160dd4f8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">get all point attenuation params as (size, constant, linear, quadratic)  <a href="class_ogre_1_1_pass.html#a2eb0e0f957c2dd23fb068a160dd4f8f5">More...</a><br /></td></tr>
<tr class="separator:a2eb0e0f957c2dd23fb068a160dd4f8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a3e18e0d2c3e7f51a47cedcec0246c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a75a3e18e0d2c3e7f51a47cedcec0246c">setPointMinSize</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> min)</td></tr>
<tr class="memdesc:a75a3e18e0d2c3e7f51a47cedcec0246c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum point size, when point attenuation is in use.  <a href="class_ogre_1_1_pass.html#a75a3e18e0d2c3e7f51a47cedcec0246c">More...</a><br /></td></tr>
<tr class="separator:a75a3e18e0d2c3e7f51a47cedcec0246c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d799c8e3324a37e70d50f8fd1e5daac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8d799c8e3324a37e70d50f8fd1e5daac">getPointMinSize</a> (void) const</td></tr>
<tr class="memdesc:a8d799c8e3324a37e70d50f8fd1e5daac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum point size, when point attenuation is in use.  <a href="class_ogre_1_1_pass.html#a8d799c8e3324a37e70d50f8fd1e5daac">More...</a><br /></td></tr>
<tr class="separator:a8d799c8e3324a37e70d50f8fd1e5daac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463b59eaa324934370441a98b8b619b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a463b59eaa324934370441a98b8b619b3">setPointMaxSize</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> max)</td></tr>
<tr class="memdesc:a463b59eaa324934370441a98b8b619b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum point size, when point attenuation is in use.  <a href="class_ogre_1_1_pass.html#a463b59eaa324934370441a98b8b619b3">More...</a><br /></td></tr>
<tr class="separator:a463b59eaa324934370441a98b8b619b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf906d8abba9a4b4dde83f87daa0f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aeaf906d8abba9a4b4dde83f87daa0f4e">getPointMaxSize</a> (void) const</td></tr>
<tr class="memdesc:aeaf906d8abba9a4b4dde83f87daa0f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum point size, when point attenuation is in use.  <a href="class_ogre_1_1_pass.html#aeaf906d8abba9a4b4dde83f87daa0f4e">More...</a><br /></td></tr>
<tr class="separator:aeaf906d8abba9a4b4dde83f87daa0f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Texture Units</div></td></tr>
<tr class="memitem:adfee1e1da3564408697f6b1227102c63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#adfee1e1da3564408697f6b1227102c63">createTextureUnitState</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;textureName, unsigned short texCoordSet=0)</td></tr>
<tr class="memdesc:adfee1e1da3564408697f6b1227102c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> object into the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>.  <a href="class_ogre_1_1_pass.html#adfee1e1da3564408697f6b1227102c63">More...</a><br /></td></tr>
<tr class="separator:adfee1e1da3564408697f6b1227102c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b37124088b574d2cbb2652c0ee4272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af8b37124088b574d2cbb2652c0ee4272">createTextureUnitState</a> (void)</td></tr>
<tr class="memdesc:af8b37124088b574d2cbb2652c0ee4272"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#af8b37124088b574d2cbb2652c0ee4272">More...</a><br /></td></tr>
<tr class="separator:af8b37124088b574d2cbb2652c0ee4272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a4036c87d4778c20d19412e9530ff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a00a4036c87d4778c20d19412e9530ff2">addTextureUnitState</a> (<a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *state)</td></tr>
<tr class="memdesc:a00a4036c87d4778c20d19412e9530ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the passed in <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a>, to the existing <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>.  <a href="class_ogre_1_1_pass.html#a00a4036c87d4778c20d19412e9530ff2">More...</a><br /></td></tr>
<tr class="separator:a00a4036c87d4778c20d19412e9530ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a74a1797a61115107a70fad10e52c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a01a74a1797a61115107a70fad10e52c5">getTextureUnitState</a> (size_t index) const</td></tr>
<tr class="memdesc:a01a74a1797a61115107a70fad10e52c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a const pointer to a texture unit state.  <a href="class_ogre_1_1_pass.html#a01a74a1797a61115107a70fad10e52c5">More...</a><br /></td></tr>
<tr class="separator:a01a74a1797a61115107a70fad10e52c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe30c603d0dab1f4194463699c0091ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#afe30c603d0dab1f4194463699c0091ba">getTextureUnitState</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name) const</td></tr>
<tr class="memdesc:afe30c603d0dab1f4194463699c0091ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> Unit State matching name.  <a href="class_ogre_1_1_pass.html#afe30c603d0dab1f4194463699c0091ba">More...</a><br /></td></tr>
<tr class="separator:afe30c603d0dab1f4194463699c0091ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613a1145ae3ee981f223c00fc21b742e"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a613a1145ae3ee981f223c00fc21b742e">getTextureUnitStateIndex</a> (const <a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *state) const</td></tr>
<tr class="memdesc:a613a1145ae3ee981f223c00fc21b742e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the index of the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> Unit State in the pass.  <a href="class_ogre_1_1_pass.html#a613a1145ae3ee981f223c00fc21b742e">More...</a><br /></td></tr>
<tr class="separator:a613a1145ae3ee981f223c00fc21b742e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1513f6d3e1acb9037225d826ec99856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_pass.html#ac7bc2b00e42ad2699a1e2a1de340d3b4">TextureUnitStateIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac1513f6d3e1acb9037225d826ec99856">getTextureUnitStateIterator</a> (void)</td></tr>
<tr class="memdesc:ac1513f6d3e1acb9037225d826ec99856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator over the TextureUnitStates contained in this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>.  <a href="class_ogre_1_1_pass.html#ac1513f6d3e1acb9037225d826ec99856">More...</a><br /></td></tr>
<tr class="separator:ac1513f6d3e1acb9037225d826ec99856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185a8f17c108024b5b0683d895d5bcaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_pass.html#a98b42a4f4304f3f2d08fb9394cbefe83">ConstTextureUnitStateIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a185a8f17c108024b5b0683d895d5bcaf">getTextureUnitStateIterator</a> (void) const</td></tr>
<tr class="memdesc:a185a8f17c108024b5b0683d895d5bcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator over the TextureUnitStates contained in this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>.  <a href="class_ogre_1_1_pass.html#a185a8f17c108024b5b0683d895d5bcaf">More...</a><br /></td></tr>
<tr class="separator:a185a8f17c108024b5b0683d895d5bcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a57322ba3813c39d62bbd7a3ba01fb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_pass.html#a1054ecda87f96dad530ec49099379755">TextureUnitStates</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a27a57322ba3813c39d62bbd7a3ba01fb">getTextureUnitStates</a> () const</td></tr>
<tr class="memdesc:a27a57322ba3813c39d62bbd7a3ba01fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TextureUnitStates contained in this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>.  <a href="class_ogre_1_1_pass.html#a27a57322ba3813c39d62bbd7a3ba01fb">More...</a><br /></td></tr>
<tr class="separator:a27a57322ba3813c39d62bbd7a3ba01fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66085d80b0caa39850216b603cec40b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a66085d80b0caa39850216b603cec40b1">removeTextureUnitState</a> (unsigned short index)</td></tr>
<tr class="memdesc:a66085d80b0caa39850216b603cec40b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the indexed texture unit state from this pass.  <a href="class_ogre_1_1_pass.html#a66085d80b0caa39850216b603cec40b1">More...</a><br /></td></tr>
<tr class="separator:a66085d80b0caa39850216b603cec40b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86de1842654eb89c6f48785d02f07688"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a86de1842654eb89c6f48785d02f07688">removeAllTextureUnitStates</a> (void)</td></tr>
<tr class="memdesc:a86de1842654eb89c6f48785d02f07688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all texture unit settings.  <a href="class_ogre_1_1_pass.html#a86de1842654eb89c6f48785d02f07688">More...</a><br /></td></tr>
<tr class="separator:a86de1842654eb89c6f48785d02f07688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1044a438121427b138b1391d37854f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aca1044a438121427b138b1391d37854f">getNumTextureUnitStates</a> (void) const</td></tr>
<tr class="memdesc:aca1044a438121427b138b1391d37854f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of texture unit settings.  <a href="class_ogre_1_1_pass.html#aca1044a438121427b138b1391d37854f">More...</a><br /></td></tr>
<tr class="separator:aca1044a438121427b138b1391d37854f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f69f7e13e3665ba295ce9b4671fdc4c"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8f69f7e13e3665ba295ce9b4671fdc4c">_getTextureUnitWithContentTypeIndex</a> (<a class="el" href="class_ogre_1_1_texture_unit_state.html#a3a09898645eac12548f6598fcbb9ac60">TextureUnitState::ContentType</a> contentType, unsigned short index) const</td></tr>
<tr class="memdesc:a8f69f7e13e3665ba295ce9b4671fdc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 'nth' texture which references the given content type.  <a href="class_ogre_1_1_pass.html#a8f69f7e13e3665ba295ce9b4671fdc4c">More...</a><br /></td></tr>
<tr class="separator:a8f69f7e13e3665ba295ce9b4671fdc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abbb49b669a575991c17bb67bcae975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a5abbb49b669a575991c17bb67bcae975">setTextureFiltering</a> (<a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5">TextureFilterOptions</a> filterType)</td></tr>
<tr class="memdesc:a5abbb49b669a575991c17bb67bcae975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set texture filtering for every texture unit.  <a href="class_ogre_1_1_pass.html#a5abbb49b669a575991c17bb67bcae975">More...</a><br /></td></tr>
<tr class="separator:a5abbb49b669a575991c17bb67bcae975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388afa054c642dd6b0585fd168cd7b1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a388afa054c642dd6b0585fd168cd7b1a">setTextureAnisotropy</a> (unsigned int maxAniso)</td></tr>
<tr class="memdesc:a388afa054c642dd6b0585fd168cd7b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the anisotropy level to be used for all textures.  <a href="class_ogre_1_1_pass.html#a388afa054c642dd6b0585fd168cd7b1a">More...</a><br /></td></tr>
<tr class="separator:a388afa054c642dd6b0585fd168cd7b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scene Blending</div></td></tr>
<tr class="memitem:ae21d6f29c89eeff54ab6de5562818c02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae21d6f29c89eeff54ab6de5562818c02">setSceneBlending</a> (const <a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> sbt)</td></tr>
<tr class="memdesc:ae21d6f29c89eeff54ab6de5562818c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the kind of blending this pass has with the existing contents of the scene.  <a href="class_ogre_1_1_pass.html#ae21d6f29c89eeff54ab6de5562818c02">More...</a><br /></td></tr>
<tr class="separator:ae21d6f29c89eeff54ab6de5562818c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbd80d762d78838df626482df1ac81b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aefbd80d762d78838df626482df1ac81b">setSeparateSceneBlending</a> (const <a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> sbt, const <a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> sbta)</td></tr>
<tr class="memdesc:aefbd80d762d78838df626482df1ac81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the kind of blending this pass has with the existing contents of the scene, separately for color and alpha channels.  <a href="class_ogre_1_1_pass.html#aefbd80d762d78838df626482df1ac81b">More...</a><br /></td></tr>
<tr class="separator:aefbd80d762d78838df626482df1ac81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae2b0725a20fe90f1554834bafa7178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a6ae2b0725a20fe90f1554834bafa7178">setSceneBlending</a> (const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactor, const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactor)</td></tr>
<tr class="memdesc:a6ae2b0725a20fe90f1554834bafa7178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows very fine control of blending this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> with the existing contents of the scene.  <a href="class_ogre_1_1_pass.html#a6ae2b0725a20fe90f1554834bafa7178">More...</a><br /></td></tr>
<tr class="separator:a6ae2b0725a20fe90f1554834bafa7178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bba51e9a0cba1b9708bab99496c1a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aa4bba51e9a0cba1b9708bab99496c1a8">setSeparateSceneBlending</a> (const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactor, const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactor, const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactorAlpha, const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactorAlpha)</td></tr>
<tr class="memdesc:aa4bba51e9a0cba1b9708bab99496c1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows very fine control of blending this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> with the existing contents of the scene.  <a href="class_ogre_1_1_pass.html#aa4bba51e9a0cba1b9708bab99496c1a8">More...</a><br /></td></tr>
<tr class="separator:aa4bba51e9a0cba1b9708bab99496c1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a501c0f7f8842493dd277814e38812"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_colour_blend_state.html">ColourBlendState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab9a501c0f7f8842493dd277814e38812">getBlendState</a> () const</td></tr>
<tr class="memdesc:ab9a501c0f7f8842493dd277814e38812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the complete blend state of this pass.  <a href="class_ogre_1_1_pass.html#ab9a501c0f7f8842493dd277814e38812">More...</a><br /></td></tr>
<tr class="separator:ab9a501c0f7f8842493dd277814e38812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec14031d3e7e69c7ec4f734dc40f612d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aec14031d3e7e69c7ec4f734dc40f612d">getSourceBlendFactor</a> () const</td></tr>
<tr class="memdesc:aec14031d3e7e69c7ec4f734dc40f612d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the source blending factor for the material.  <a href="class_ogre_1_1_pass.html#aec14031d3e7e69c7ec4f734dc40f612d">More...</a><br /></td></tr>
<tr class="separator:aec14031d3e7e69c7ec4f734dc40f612d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e61c233c08848aa736bcfa7bdb58158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8e61c233c08848aa736bcfa7bdb58158">getDestBlendFactor</a> () const</td></tr>
<tr class="memdesc:a8e61c233c08848aa736bcfa7bdb58158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the destination blending factor for the material.  <a href="class_ogre_1_1_pass.html#a8e61c233c08848aa736bcfa7bdb58158">More...</a><br /></td></tr>
<tr class="separator:a8e61c233c08848aa736bcfa7bdb58158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040397cbf641fcd16ad1cc1846ccb0a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a040397cbf641fcd16ad1cc1846ccb0a0">getSourceBlendFactorAlpha</a> () const</td></tr>
<tr class="memdesc:a040397cbf641fcd16ad1cc1846ccb0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the alpha source blending factor for the material.  <a href="class_ogre_1_1_pass.html#a040397cbf641fcd16ad1cc1846ccb0a0">More...</a><br /></td></tr>
<tr class="separator:a040397cbf641fcd16ad1cc1846ccb0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89b9de8338da5bb1944b16145ee2f62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aa89b9de8338da5bb1944b16145ee2f62">getDestBlendFactorAlpha</a> () const</td></tr>
<tr class="memdesc:aa89b9de8338da5bb1944b16145ee2f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the alpha destination blending factor for the material.  <a href="class_ogre_1_1_pass.html#aa89b9de8338da5bb1944b16145ee2f62">More...</a><br /></td></tr>
<tr class="separator:aa89b9de8338da5bb1944b16145ee2f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae2570082185c2b6e237a2d46f9bb60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a9ae2570082185c2b6e237a2d46f9bb60">setSceneBlendingOperation</a> (<a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a">SceneBlendOperation</a> op)</td></tr>
<tr class="memdesc:a9ae2570082185c2b6e237a2d46f9bb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specific operation used to blend source and destination pixels together.  <a href="class_ogre_1_1_pass.html#a9ae2570082185c2b6e237a2d46f9bb60">More...</a><br /></td></tr>
<tr class="separator:a9ae2570082185c2b6e237a2d46f9bb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4313056341502f87ada68638cae334"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ace4313056341502f87ada68638cae334">setSeparateSceneBlendingOperation</a> (<a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a">SceneBlendOperation</a> op, <a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a">SceneBlendOperation</a> alphaOp)</td></tr>
<tr class="memdesc:ace4313056341502f87ada68638cae334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specific operation used to blend source and destination pixels together.  <a href="class_ogre_1_1_pass.html#ace4313056341502f87ada68638cae334">More...</a><br /></td></tr>
<tr class="separator:ace4313056341502f87ada68638cae334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4598b48a3cc36a3a9ac5c7f190440c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a">SceneBlendOperation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a0e4598b48a3cc36a3a9ac5c7f190440c">getSceneBlendingOperation</a> () const</td></tr>
<tr class="memdesc:a0e4598b48a3cc36a3a9ac5c7f190440c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current blending operation.  <a href="class_ogre_1_1_pass.html#a0e4598b48a3cc36a3a9ac5c7f190440c">More...</a><br /></td></tr>
<tr class="separator:a0e4598b48a3cc36a3a9ac5c7f190440c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c36e64352bf3b1d0d87a220d05f6dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a">SceneBlendOperation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a1c36e64352bf3b1d0d87a220d05f6dbf">getSceneBlendingOperationAlpha</a> () const</td></tr>
<tr class="memdesc:a1c36e64352bf3b1d0d87a220d05f6dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current alpha blending operation.  <a href="class_ogre_1_1_pass.html#a1c36e64352bf3b1d0d87a220d05f6dbf">More...</a><br /></td></tr>
<tr class="separator:a1c36e64352bf3b1d0d87a220d05f6dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbe37daba7e3be4349177374d4e40ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a3bbe37daba7e3be4349177374d4e40ee">setColourWriteEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a3bbe37daba7e3be4349177374d4e40ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not colour buffer writing is enabled for this Pass.  <a href="class_ogre_1_1_pass.html#a3bbe37daba7e3be4349177374d4e40ee">More...</a><br /></td></tr>
<tr class="separator:a3bbe37daba7e3be4349177374d4e40ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d61feca0e3c7cae4c3e1c2988540b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a51d61feca0e3c7cae4c3e1c2988540b0">getColourWriteEnabled</a> (void) const</td></tr>
<tr class="memdesc:a51d61feca0e3c7cae4c3e1c2988540b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if colour buffer writing is enabled for this pass i.e.  <a href="class_ogre_1_1_pass.html#a51d61feca0e3c7cae4c3e1c2988540b0">More...</a><br /></td></tr>
<tr class="separator:a51d61feca0e3c7cae4c3e1c2988540b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c85bd4eff471ca7b3c710d20dbf274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae8c85bd4eff471ca7b3c710d20dbf274">setColourWriteEnabled</a> (bool red, bool green, bool blue, bool alpha)</td></tr>
<tr class="memdesc:ae8c85bd4eff471ca7b3c710d20dbf274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets which colour buffer channels are enabled for writing for this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>.  <a href="class_ogre_1_1_pass.html#ae8c85bd4eff471ca7b3c710d20dbf274">More...</a><br /></td></tr>
<tr class="separator:ae8c85bd4eff471ca7b3c710d20dbf274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b25c9a64b05c3463a2da9e174be901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a40b25c9a64b05c3463a2da9e174be901">getColourWriteEnabled</a> (bool &amp;red, bool &amp;green, bool &amp;blue, bool &amp;alpha) const</td></tr>
<tr class="memdesc:a40b25c9a64b05c3463a2da9e174be901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which colour buffer channels are enabled for writing for this pass.  <a href="class_ogre_1_1_pass.html#a40b25c9a64b05c3463a2da9e174be901">More...</a><br /></td></tr>
<tr class="separator:a40b25c9a64b05c3463a2da9e174be901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Depth Testing</div></td></tr>
<tr class="memitem:ae454faee87f8cb0b8540810e48118788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788">setDepthCheckEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:ae454faee87f8cb0b8540810e48118788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not this pass renders with depth-buffer checking on or not.  <a href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788">More...</a><br /></td></tr>
<tr class="separator:ae454faee87f8cb0b8540810e48118788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648b0f3f74464f4b0e4472e64219f1a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a648b0f3f74464f4b0e4472e64219f1a1">getDepthCheckEnabled</a> (void) const</td></tr>
<tr class="memdesc:a648b0f3f74464f4b0e4472e64219f1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this pass renders with depth-buffer checking on or not.  <a href="class_ogre_1_1_pass.html#a648b0f3f74464f4b0e4472e64219f1a1">More...</a><br /></td></tr>
<tr class="separator:a648b0f3f74464f4b0e4472e64219f1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3e6c7c7b59e2c303c348b4850b1a3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aad3e6c7c7b59e2c303c348b4850b1a3a">setDepthWriteEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:aad3e6c7c7b59e2c303c348b4850b1a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not this pass renders with depth-buffer writing on or not.  <a href="class_ogre_1_1_pass.html#aad3e6c7c7b59e2c303c348b4850b1a3a">More...</a><br /></td></tr>
<tr class="separator:aad3e6c7c7b59e2c303c348b4850b1a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d6e2e30826d01e5ec19bef7446f447"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab2d6e2e30826d01e5ec19bef7446f447">getDepthWriteEnabled</a> (void) const</td></tr>
<tr class="memdesc:ab2d6e2e30826d01e5ec19bef7446f447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this pass renders with depth-buffer writing on or not.  <a href="class_ogre_1_1_pass.html#ab2d6e2e30826d01e5ec19bef7446f447">More...</a><br /></td></tr>
<tr class="separator:ab2d6e2e30826d01e5ec19bef7446f447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6c591b069aa6f7c65afc1419d47de6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aef6c591b069aa6f7c65afc1419d47de6">setDepthFunction</a> (<a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6">CompareFunction</a> func)</td></tr>
<tr class="memdesc:aef6c591b069aa6f7c65afc1419d47de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the function used to compare depth values when depth checking is on.  <a href="class_ogre_1_1_pass.html#aef6c591b069aa6f7c65afc1419d47de6">More...</a><br /></td></tr>
<tr class="separator:aef6c591b069aa6f7c65afc1419d47de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6912e985c09f72d8f8012494f1068a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6">CompareFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aed6912e985c09f72d8f8012494f1068a">getDepthFunction</a> (void) const</td></tr>
<tr class="memdesc:aed6912e985c09f72d8f8012494f1068a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function used to compare depth values when depth checking is on.  <a href="class_ogre_1_1_pass.html#aed6912e985c09f72d8f8012494f1068a">More...</a><br /></td></tr>
<tr class="separator:aed6912e985c09f72d8f8012494f1068a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35a3242a45176f8605bd8c866198b67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aa35a3242a45176f8605bd8c866198b67">setDepthBias</a> (float constantBias, float slopeScaleBias=0.0f)</td></tr>
<tr class="memdesc:aa35a3242a45176f8605bd8c866198b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the depth bias to be used for this material.  <a href="class_ogre_1_1_pass.html#aa35a3242a45176f8605bd8c866198b67">More...</a><br /></td></tr>
<tr class="separator:aa35a3242a45176f8605bd8c866198b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0327eac96a7858951a92d64dbdef8b31"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a0327eac96a7858951a92d64dbdef8b31">getDepthBiasConstant</a> (void) const</td></tr>
<tr class="memdesc:a0327eac96a7858951a92d64dbdef8b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the const depth bias value as set by setDepthBias.  <a href="class_ogre_1_1_pass.html#a0327eac96a7858951a92d64dbdef8b31">More...</a><br /></td></tr>
<tr class="separator:a0327eac96a7858951a92d64dbdef8b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2639336933c81b101f7b38b02c590518"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a2639336933c81b101f7b38b02c590518">getDepthBiasSlopeScale</a> (void) const</td></tr>
<tr class="memdesc:a2639336933c81b101f7b38b02c590518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the slope-scale depth bias value as set by setDepthBias.  <a href="class_ogre_1_1_pass.html#a2639336933c81b101f7b38b02c590518">More...</a><br /></td></tr>
<tr class="separator:a2639336933c81b101f7b38b02c590518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca462cd8e0708d90c3131ddd39e95674"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aca462cd8e0708d90c3131ddd39e95674">setIterationDepthBias</a> (float biasPerIteration)</td></tr>
<tr class="memdesc:aca462cd8e0708d90c3131ddd39e95674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a factor which derives an additional depth bias from the number of times a pass is iterated.  <a href="class_ogre_1_1_pass.html#aca462cd8e0708d90c3131ddd39e95674">More...</a><br /></td></tr>
<tr class="separator:aca462cd8e0708d90c3131ddd39e95674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb78aa549dc85cb36bd3dbc8abeee24"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#adcb78aa549dc85cb36bd3dbc8abeee24">getIterationDepthBias</a> () const</td></tr>
<tr class="memdesc:adcb78aa549dc85cb36bd3dbc8abeee24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a factor which derives an additional depth bias from the number of times a pass is iterated.  <a href="class_ogre_1_1_pass.html#adcb78aa549dc85cb36bd3dbc8abeee24">More...</a><br /></td></tr>
<tr class="separator:adcb78aa549dc85cb36bd3dbc8abeee24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Fogging</div></td></tr>
<tr class="memitem:a48a2a5f63407356c4e080cbea73b651b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a48a2a5f63407356c4e080cbea73b651b">setFog</a> (bool overrideScene, <a class="el" href="group___general.html#ga6467b107ce81cc71b8f2960409f7d897">FogMode</a> mode=<a class="el" href="group___general.html#gga6467b107ce81cc71b8f2960409f7d897ab7793a21880052c0214d4cc040992310">FOG_NONE</a>, const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;colour=<a class="el" href="class_ogre_1_1_colour_value.html#a8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a>, float expDensity=0.001f, float linearStart=0.0f, float linearEnd=1.0f)</td></tr>
<tr class="memdesc:a48a2a5f63407356c4e080cbea73b651b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fogging mode applied to this pass.  <a href="class_ogre_1_1_pass.html#a48a2a5f63407356c4e080cbea73b651b">More...</a><br /></td></tr>
<tr class="separator:a48a2a5f63407356c4e080cbea73b651b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8e2ca7f03f60cf41377da7d79c5d19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a3a8e2ca7f03f60cf41377da7d79c5d19">getFogOverride</a> (void) const</td></tr>
<tr class="memdesc:a3a8e2ca7f03f60cf41377da7d79c5d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass is to override the scene fog settings.  <a href="class_ogre_1_1_pass.html#a3a8e2ca7f03f60cf41377da7d79c5d19">More...</a><br /></td></tr>
<tr class="separator:a3a8e2ca7f03f60cf41377da7d79c5d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1713843694cb5213646bfa517875515c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga6467b107ce81cc71b8f2960409f7d897">FogMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a1713843694cb5213646bfa517875515c">getFogMode</a> (void) const</td></tr>
<tr class="memdesc:a1713843694cb5213646bfa517875515c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog mode for this pass.  <a href="class_ogre_1_1_pass.html#a1713843694cb5213646bfa517875515c">More...</a><br /></td></tr>
<tr class="separator:a1713843694cb5213646bfa517875515c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2a614a0b99daa23be0f73d88c1336f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#acc2a614a0b99daa23be0f73d88c1336f">getFogColour</a> (void) const</td></tr>
<tr class="memdesc:acc2a614a0b99daa23be0f73d88c1336f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog colour for the scene.  <a href="class_ogre_1_1_pass.html#acc2a614a0b99daa23be0f73d88c1336f">More...</a><br /></td></tr>
<tr class="separator:acc2a614a0b99daa23be0f73d88c1336f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54b3be2df752a5afd31ef8c3c4da055"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af54b3be2df752a5afd31ef8c3c4da055">getFogStart</a> (void) const</td></tr>
<tr class="memdesc:af54b3be2df752a5afd31ef8c3c4da055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog start distance for this pass.  <a href="class_ogre_1_1_pass.html#af54b3be2df752a5afd31ef8c3c4da055">More...</a><br /></td></tr>
<tr class="separator:af54b3be2df752a5afd31ef8c3c4da055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b770b4107b99c5f63d00e16e59ea84e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a1b770b4107b99c5f63d00e16e59ea84e">getFogEnd</a> (void) const</td></tr>
<tr class="memdesc:a1b770b4107b99c5f63d00e16e59ea84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog end distance for this pass.  <a href="class_ogre_1_1_pass.html#a1b770b4107b99c5f63d00e16e59ea84e">More...</a><br /></td></tr>
<tr class="separator:a1b770b4107b99c5f63d00e16e59ea84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bd26e7a9e62db9ab52c1b4af859f72"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aa9bd26e7a9e62db9ab52c1b4af859f72">getFogDensity</a> (void) const</td></tr>
<tr class="memdesc:aa9bd26e7a9e62db9ab52c1b4af859f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog density for this pass.  <a href="class_ogre_1_1_pass.html#aa9bd26e7a9e62db9ab52c1b4af859f72">More...</a><br /></td></tr>
<tr class="separator:aa9bd26e7a9e62db9ab52c1b4af859f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Alpha Rejection</div></td></tr>
<tr class="memitem:a9fe6fc3f542eade6b37d49cd0eadddde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a9fe6fc3f542eade6b37d49cd0eadddde">setAlphaRejectSettings</a> (<a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6">CompareFunction</a> func, unsigned char value, bool alphaToCoverageEnabled=false)</td></tr>
<tr class="memdesc:a9fe6fc3f542eade6b37d49cd0eadddde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the way the pass will have use alpha to totally reject pixels from the pipeline.  <a href="class_ogre_1_1_pass.html#a9fe6fc3f542eade6b37d49cd0eadddde">More...</a><br /></td></tr>
<tr class="separator:a9fe6fc3f542eade6b37d49cd0eadddde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f23af59e5f991f22a224f8e6b336af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4f23af59e5f991f22a224f8e6b336af3">setAlphaRejectFunction</a> (<a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6">CompareFunction</a> func)</td></tr>
<tr class="memdesc:a4f23af59e5f991f22a224f8e6b336af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the alpha reject function.  <a href="class_ogre_1_1_pass.html#a4f23af59e5f991f22a224f8e6b336af3">More...</a><br /></td></tr>
<tr class="separator:a4f23af59e5f991f22a224f8e6b336af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5c5f69be78ddd80cbb202f66649fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a6e5c5f69be78ddd80cbb202f66649fef">setAlphaRejectValue</a> (unsigned char val)</td></tr>
<tr class="memdesc:a6e5c5f69be78ddd80cbb202f66649fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the alpha reject value.  <a href="class_ogre_1_1_pass.html#a6e5c5f69be78ddd80cbb202f66649fef">More...</a><br /></td></tr>
<tr class="separator:a6e5c5f69be78ddd80cbb202f66649fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b0920d6ba670d5e2e85bf2282bd2ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6">CompareFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae1b0920d6ba670d5e2e85bf2282bd2ef">getAlphaRejectFunction</a> (void) const</td></tr>
<tr class="memdesc:ae1b0920d6ba670d5e2e85bf2282bd2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the alpha reject function.  <a href="class_ogre_1_1_pass.html#ae1b0920d6ba670d5e2e85bf2282bd2ef">More...</a><br /></td></tr>
<tr class="separator:ae1b0920d6ba670d5e2e85bf2282bd2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8336a42895b9429c0bbae528fcaa5a43"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8336a42895b9429c0bbae528fcaa5a43">getAlphaRejectValue</a> (void) const</td></tr>
<tr class="memdesc:a8336a42895b9429c0bbae528fcaa5a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the alpha reject value.  <a href="class_ogre_1_1_pass.html#a8336a42895b9429c0bbae528fcaa5a43">More...</a><br /></td></tr>
<tr class="separator:a8336a42895b9429c0bbae528fcaa5a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a98973675e2cf71b286ceb9e73ecd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae0a98973675e2cf71b286ceb9e73ecd3">setAlphaToCoverageEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:ae0a98973675e2cf71b286ceb9e73ecd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether to use alpha to coverage (A2C) when blending alpha rejected values.  <a href="class_ogre_1_1_pass.html#ae0a98973675e2cf71b286ceb9e73ecd3">More...</a><br /></td></tr>
<tr class="separator:ae0a98973675e2cf71b286ceb9e73ecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7582011f85937446047a843896c8382"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad7582011f85937446047a843896c8382">isAlphaToCoverageEnabled</a> () const</td></tr>
<tr class="memdesc:ad7582011f85937446047a843896c8382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether to use alpha to coverage (A2C) when blending alpha rejected values.  <a href="class_ogre_1_1_pass.html#ad7582011f85937446047a843896c8382">More...</a><br /></td></tr>
<tr class="separator:ad7582011f85937446047a843896c8382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Light Iteration</div></td></tr>
<tr class="memitem:a95a7a4006f26528ef4f6ce42ae56b09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a95a7a4006f26528ef4f6ce42ae56b09b">setMaxSimultaneousLights</a> (unsigned short maxLights)</td></tr>
<tr class="memdesc:a95a7a4006f26528ef4f6ce42ae56b09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of lights to be used by this pass.  <a href="class_ogre_1_1_pass.html#a95a7a4006f26528ef4f6ce42ae56b09b">More...</a><br /></td></tr>
<tr class="separator:a95a7a4006f26528ef4f6ce42ae56b09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd67db27426bb99e6e58e7299424c4bc"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#abd67db27426bb99e6e58e7299424c4bc">getMaxSimultaneousLights</a> (void) const</td></tr>
<tr class="memdesc:abd67db27426bb99e6e58e7299424c4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of lights to be used by this pass.  <a href="class_ogre_1_1_pass.html#abd67db27426bb99e6e58e7299424c4bc">More...</a><br /></td></tr>
<tr class="separator:abd67db27426bb99e6e58e7299424c4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b816cdd2b5b5fcc5cbe6744b6bb2dbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8b816cdd2b5b5fcc5cbe6744b6bb2dbd">setStartLight</a> (unsigned short startLight)</td></tr>
<tr class="memdesc:a8b816cdd2b5b5fcc5cbe6744b6bb2dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the light index that this pass will start at in the light list.  <a href="class_ogre_1_1_pass.html#a8b816cdd2b5b5fcc5cbe6744b6bb2dbd">More...</a><br /></td></tr>
<tr class="separator:a8b816cdd2b5b5fcc5cbe6744b6bb2dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fec71cb3076c1387cc6133f2996c78"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a53fec71cb3076c1387cc6133f2996c78">getStartLight</a> (void) const</td></tr>
<tr class="memdesc:a53fec71cb3076c1387cc6133f2996c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the light index that this pass will start at in the light list.  <a href="class_ogre_1_1_pass.html#a53fec71cb3076c1387cc6133f2996c78">More...</a><br /></td></tr>
<tr class="separator:a53fec71cb3076c1387cc6133f2996c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f14ed26740158970994057e48e562e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a9f14ed26740158970994057e48e562e9">setLightMask</a> (<a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> mask)</td></tr>
<tr class="memdesc:a9f14ed26740158970994057e48e562e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the light mask which can be matched to specific light flags to be handled by this pass.  <a href="class_ogre_1_1_pass.html#a9f14ed26740158970994057e48e562e9">More...</a><br /></td></tr>
<tr class="separator:a9f14ed26740158970994057e48e562e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7068c8fb5556c150126866373343ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8f7068c8fb5556c150126866373343ac">getLightMask</a> () const</td></tr>
<tr class="memdesc:a8f7068c8fb5556c150126866373343ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the light mask controlling which lights are used for this pass.  <a href="class_ogre_1_1_pass.html#a8f7068c8fb5556c150126866373343ac">More...</a><br /></td></tr>
<tr class="separator:a8f7068c8fb5556c150126866373343ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec98c9346a22a4a98acdaf5b8849a5c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aec98c9346a22a4a98acdaf5b8849a5c1">setIteratePerLight</a> (bool enabled, bool onlyForOneLightType=true, <a class="el" href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345">Light::LightTypes</a> lightType=<a class="el" href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345a0d59bfdcfeb338dbfe06e2e2999e752f">Light::LT_POINT</a>)</td></tr>
<tr class="memdesc:aec98c9346a22a4a98acdaf5b8849a5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not this pass should iterate per light or number of lights which can affect the object being rendered.  <a href="class_ogre_1_1_pass.html#aec98c9346a22a4a98acdaf5b8849a5c1">More...</a><br /></td></tr>
<tr class="separator:aec98c9346a22a4a98acdaf5b8849a5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606718035e449c4fdf91ae843adc4894"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a606718035e449c4fdf91ae843adc4894">getIteratePerLight</a> (void) const</td></tr>
<tr class="memdesc:a606718035e449c4fdf91ae843adc4894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this pass run once for every light in range?  <a href="class_ogre_1_1_pass.html#a606718035e449c4fdf91ae843adc4894">More...</a><br /></td></tr>
<tr class="separator:a606718035e449c4fdf91ae843adc4894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adea673c6a85f5fbc1c7403457c284f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a0adea673c6a85f5fbc1c7403457c284f">getRunOnlyForOneLightType</a> (void) const</td></tr>
<tr class="memdesc:a0adea673c6a85f5fbc1c7403457c284f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this pass run only for a single light type (if getIteratePerLight is true).  <a href="class_ogre_1_1_pass.html#a0adea673c6a85f5fbc1c7403457c284f">More...</a><br /></td></tr>
<tr class="separator:a0adea673c6a85f5fbc1c7403457c284f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371e62569a03de84662a286c875e45cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345">Light::LightTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a371e62569a03de84662a286c875e45cb">getOnlyLightType</a> () const</td></tr>
<tr class="memdesc:a371e62569a03de84662a286c875e45cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the single light type this pass runs for if getIteratePerLight and getRunOnlyForOneLightType are both true.  <a href="class_ogre_1_1_pass.html#a371e62569a03de84662a286c875e45cb">More...</a><br /></td></tr>
<tr class="separator:a371e62569a03de84662a286c875e45cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e40ca39a238f0afe5e2d3a0db0661ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a0e40ca39a238f0afe5e2d3a0db0661ce">setLightCountPerIteration</a> (unsigned short c)</td></tr>
<tr class="memdesc:a0e40ca39a238f0afe5e2d3a0db0661ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">If light iteration is enabled, determine the number of lights per iteration.  <a href="class_ogre_1_1_pass.html#a0e40ca39a238f0afe5e2d3a0db0661ce">More...</a><br /></td></tr>
<tr class="separator:a0e40ca39a238f0afe5e2d3a0db0661ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cbf809b449b317d01500220b25d82f"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a44cbf809b449b317d01500220b25d82f">getLightCountPerIteration</a> (void) const</td></tr>
<tr class="memdesc:a44cbf809b449b317d01500220b25d82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If light iteration is enabled, determine the number of lights per iteration.  <a href="class_ogre_1_1_pass.html#a44cbf809b449b317d01500220b25d82f">More...</a><br /></td></tr>
<tr class="separator:a44cbf809b449b317d01500220b25d82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Gpu Programs</div></td></tr>
<tr class="memitem:a4a247aa90883ca1435fb949d191d6110"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4a247aa90883ca1435fb949d191d6110">isProgrammable</a> (void) const</td></tr>
<tr class="memdesc:a4a247aa90883ca1435fb949d191d6110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass is programmable i.e. includes either a vertex or fragment program.  <a href="class_ogre_1_1_pass.html#a4a247aa90883ca1435fb949d191d6110">More...</a><br /></td></tr>
<tr class="separator:a4a247aa90883ca1435fb949d191d6110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dd187f9201fcf102c26a02d8f85412"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a61dd187f9201fcf102c26a02d8f85412">hasVertexProgram</a> (void) const</td></tr>
<tr class="memdesc:a61dd187f9201fcf102c26a02d8f85412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a programmable vertex pipeline.  <a href="class_ogre_1_1_pass.html#a61dd187f9201fcf102c26a02d8f85412">More...</a><br /></td></tr>
<tr class="separator:a61dd187f9201fcf102c26a02d8f85412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bffe16db4ccd90a26a257ded6e57c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a85bffe16db4ccd90a26a257ded6e57c4">hasFragmentProgram</a> (void) const</td></tr>
<tr class="memdesc:a85bffe16db4ccd90a26a257ded6e57c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a programmable fragment pipeline.  <a href="class_ogre_1_1_pass.html#a85bffe16db4ccd90a26a257ded6e57c4">More...</a><br /></td></tr>
<tr class="separator:a85bffe16db4ccd90a26a257ded6e57c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763b8993d64d234349ffa11932b912e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a763b8993d64d234349ffa11932b912e0">hasGeometryProgram</a> (void) const</td></tr>
<tr class="memdesc:a763b8993d64d234349ffa11932b912e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a programmable geometry pipeline.  <a href="class_ogre_1_1_pass.html#a763b8993d64d234349ffa11932b912e0">More...</a><br /></td></tr>
<tr class="separator:a763b8993d64d234349ffa11932b912e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2643f7594c827d2f1b8785029de280f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af2643f7594c827d2f1b8785029de280f">hasTessellationHullProgram</a> (void) const</td></tr>
<tr class="memdesc:af2643f7594c827d2f1b8785029de280f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a programmable tessellation control pipeline.  <a href="class_ogre_1_1_pass.html#af2643f7594c827d2f1b8785029de280f">More...</a><br /></td></tr>
<tr class="separator:af2643f7594c827d2f1b8785029de280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1d67d993a4b3fdd0eb3719704947bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a7a1d67d993a4b3fdd0eb3719704947bb">hasTessellationDomainProgram</a> (void) const</td></tr>
<tr class="memdesc:a7a1d67d993a4b3fdd0eb3719704947bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a programmable tessellation control pipeline.  <a href="class_ogre_1_1_pass.html#a7a1d67d993a4b3fdd0eb3719704947bb">More...</a><br /></td></tr>
<tr class="separator:a7a1d67d993a4b3fdd0eb3719704947bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d50f9c7cd1b11646ec88f463f0a27f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad1d50f9c7cd1b11646ec88f463f0a27f">hasComputeProgram</a> (void) const</td></tr>
<tr class="memdesc:ad1d50f9c7cd1b11646ec88f463f0a27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a programmable compute pipeline.  <a href="class_ogre_1_1_pass.html#ad1d50f9c7cd1b11646ec88f463f0a27f">More...</a><br /></td></tr>
<tr class="separator:ad1d50f9c7cd1b11646ec88f463f0a27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d96a83679d194ce380ad55b014f69b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac4d96a83679d194ce380ad55b014f69b">getGpuProgram</a> (<a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a> programType) const</td></tr>
<tr class="memdesc:ac4d96a83679d194ce380ad55b014f69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Gpu program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass.">_load()</a>  <a href="class_ogre_1_1_pass.html#ac4d96a83679d194ce380ad55b014f69b">More...</a><br /></td></tr>
<tr class="separator:ac4d96a83679d194ce380ad55b014f69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d00b9b7adf3c5b5f78aed3b100cc2ee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a9d00b9b7adf3c5b5f78aed3b100cc2ee">getVertexProgram</a> (void) const</td></tr>
<tr class="memdesc:a9d00b9b7adf3c5b5f78aed3b100cc2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a9d00b9b7adf3c5b5f78aed3b100cc2ee">More...</a><br /></td></tr>
<tr class="separator:a9d00b9b7adf3c5b5f78aed3b100cc2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49886b41c8e96ddfaea1d6b1c5264885"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a49886b41c8e96ddfaea1d6b1c5264885">getFragmentProgram</a> (void) const</td></tr>
<tr class="memdesc:a49886b41c8e96ddfaea1d6b1c5264885"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a49886b41c8e96ddfaea1d6b1c5264885">More...</a><br /></td></tr>
<tr class="separator:a49886b41c8e96ddfaea1d6b1c5264885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72637ef35c39efd6ac000ada7e96bb13"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a72637ef35c39efd6ac000ada7e96bb13">getGeometryProgram</a> (void) const</td></tr>
<tr class="memdesc:a72637ef35c39efd6ac000ada7e96bb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a72637ef35c39efd6ac000ada7e96bb13">More...</a><br /></td></tr>
<tr class="separator:a72637ef35c39efd6ac000ada7e96bb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad218fad32224eca7ed978b92e8b81895"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad218fad32224eca7ed978b92e8b81895">getTessellationHullProgram</a> (void) const</td></tr>
<tr class="memdesc:ad218fad32224eca7ed978b92e8b81895"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#ad218fad32224eca7ed978b92e8b81895">More...</a><br /></td></tr>
<tr class="separator:ad218fad32224eca7ed978b92e8b81895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d4c302e116ef27dea2b0a56705ccc4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad5d4c302e116ef27dea2b0a56705ccc4">getTessellationDomainProgram</a> (void) const</td></tr>
<tr class="memdesc:ad5d4c302e116ef27dea2b0a56705ccc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#ad5d4c302e116ef27dea2b0a56705ccc4">More...</a><br /></td></tr>
<tr class="separator:ad5d4c302e116ef27dea2b0a56705ccc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e4cdfc70411ee066cf68e1c7a817e4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a97e4cdfc70411ee066cf68e1c7a817e4">getComputeProgram</a> (void) const</td></tr>
<tr class="memdesc:a97e4cdfc70411ee066cf68e1c7a817e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a97e4cdfc70411ee066cf68e1c7a817e4">More...</a><br /></td></tr>
<tr class="separator:a97e4cdfc70411ee066cf68e1c7a817e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c2b23280ac2eca62b767ecebfa5888"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a50c2b23280ac2eca62b767ecebfa5888">hasGpuProgram</a> (<a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a> programType) const</td></tr>
<tr class="separator:a50c2b23280ac2eca62b767ecebfa5888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4978eca2f3387a7abec740ec760ad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a3d4978eca2f3387a7abec740ec760ad7">setGpuProgram</a> (<a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a> type, const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;prog, bool resetParams=true)</td></tr>
<tr class="memdesc:a3d4978eca2f3387a7abec740ec760ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the details of the program to use.  <a href="class_ogre_1_1_pass.html#a3d4978eca2f3387a7abec740ec760ad7">More...</a><br /></td></tr>
<tr class="separator:a3d4978eca2f3387a7abec740ec760ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee48df0d246eb685780d16b32b7f8f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#abee48df0d246eb685780d16b32b7f8f4">setGpuProgram</a> (<a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a> type, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:abee48df0d246eb685780d16b32b7f8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#abee48df0d246eb685780d16b32b7f8f4">More...</a><br /></td></tr>
<tr class="separator:abee48df0d246eb685780d16b32b7f8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3019e308b0759cc150ac0f45308d69b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a3019e308b0759cc150ac0f45308d69b3">setFragmentProgram</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:a3019e308b0759cc150ac0f45308d69b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a3019e308b0759cc150ac0f45308d69b3">More...</a><br /></td></tr>
<tr class="separator:a3019e308b0759cc150ac0f45308d69b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b2aab96fb146a8e92043c7dc771de4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af6b2aab96fb146a8e92043c7dc771de4">setGeometryProgram</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:af6b2aab96fb146a8e92043c7dc771de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#af6b2aab96fb146a8e92043c7dc771de4">More...</a><br /></td></tr>
<tr class="separator:af6b2aab96fb146a8e92043c7dc771de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adb72e47427f59f672e43b709c68038"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a5adb72e47427f59f672e43b709c68038">setTessellationDomainProgram</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:a5adb72e47427f59f672e43b709c68038"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a5adb72e47427f59f672e43b709c68038">More...</a><br /></td></tr>
<tr class="separator:a5adb72e47427f59f672e43b709c68038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6821e86c7c287fabcd28344117f772d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a6821e86c7c287fabcd28344117f772d0">setTessellationHullProgram</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:a6821e86c7c287fabcd28344117f772d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a6821e86c7c287fabcd28344117f772d0">More...</a><br /></td></tr>
<tr class="separator:a6821e86c7c287fabcd28344117f772d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0003996c1c200db9fb6466a2253a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aba0003996c1c200db9fb6466a2253a54">setVertexProgram</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:aba0003996c1c200db9fb6466a2253a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#aba0003996c1c200db9fb6466a2253a54">More...</a><br /></td></tr>
<tr class="separator:aba0003996c1c200db9fb6466a2253a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97deab966da4653d248875782b45a3f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a97deab966da4653d248875782b45a3f1">setComputeProgram</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:a97deab966da4653d248875782b45a3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a97deab966da4653d248875782b45a3f1">More...</a><br /></td></tr>
<tr class="separator:a97deab966da4653d248875782b45a3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bdef99c065c528a54572c99628841e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a91bdef99c065c528a54572c99628841e">getGpuProgramName</a> (<a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a> type) const</td></tr>
<tr class="memdesc:a91bdef99c065c528a54572c99628841e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the program used by this pass.  <a href="class_ogre_1_1_pass.html#a91bdef99c065c528a54572c99628841e">More...</a><br /></td></tr>
<tr class="separator:a91bdef99c065c528a54572c99628841e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289c78896d2777260cf5722b4cb8fd2d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a289c78896d2777260cf5722b4cb8fd2d">getFragmentProgramName</a> (void) const</td></tr>
<tr class="memdesc:a289c78896d2777260cf5722b4cb8fd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a289c78896d2777260cf5722b4cb8fd2d">More...</a><br /></td></tr>
<tr class="separator:a289c78896d2777260cf5722b4cb8fd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fdaa6b028d32a0302746ceeb79a6d3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac3fdaa6b028d32a0302746ceeb79a6d3">getGeometryProgramName</a> (void) const</td></tr>
<tr class="memdesc:ac3fdaa6b028d32a0302746ceeb79a6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#ac3fdaa6b028d32a0302746ceeb79a6d3">More...</a><br /></td></tr>
<tr class="separator:ac3fdaa6b028d32a0302746ceeb79a6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da495acb6aaea4832685156dfbf8975"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a0da495acb6aaea4832685156dfbf8975">getTessellationDomainProgramName</a> (void) const</td></tr>
<tr class="memdesc:a0da495acb6aaea4832685156dfbf8975"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a0da495acb6aaea4832685156dfbf8975">More...</a><br /></td></tr>
<tr class="separator:a0da495acb6aaea4832685156dfbf8975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0c89ec1367230c6e74eac585efd993"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#afb0c89ec1367230c6e74eac585efd993">getTessellationHullProgramName</a> (void) const</td></tr>
<tr class="memdesc:afb0c89ec1367230c6e74eac585efd993"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#afb0c89ec1367230c6e74eac585efd993">More...</a><br /></td></tr>
<tr class="separator:afb0c89ec1367230c6e74eac585efd993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1789ae3425e0bc04aeb7a1e14583abf9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a1789ae3425e0bc04aeb7a1e14583abf9">getVertexProgramName</a> (void) const</td></tr>
<tr class="memdesc:a1789ae3425e0bc04aeb7a1e14583abf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a1789ae3425e0bc04aeb7a1e14583abf9">More...</a><br /></td></tr>
<tr class="separator:a1789ae3425e0bc04aeb7a1e14583abf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06bed97a00cdda2522fff1faadcae27"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab06bed97a00cdda2522fff1faadcae27">getComputeProgramName</a> (void) const</td></tr>
<tr class="memdesc:ab06bed97a00cdda2522fff1faadcae27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#ab06bed97a00cdda2522fff1faadcae27">More...</a><br /></td></tr>
<tr class="separator:ab06bed97a00cdda2522fff1faadcae27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e78606a7cd3ea84536ab9f3198fa79f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a5e78606a7cd3ea84536ab9f3198fa79f">setGpuProgramParameters</a> (<a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a> type, const <a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> &amp;params)</td></tr>
<tr class="memdesc:a5e78606a7cd3ea84536ab9f3198fa79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Gpu program parameters.  <a href="class_ogre_1_1_pass.html#a5e78606a7cd3ea84536ab9f3198fa79f">More...</a><br /></td></tr>
<tr class="separator:a5e78606a7cd3ea84536ab9f3198fa79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc41cb1fe9251448002a2405405b8bd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#afc41cb1fe9251448002a2405405b8bd9">setVertexProgramParameters</a> (<a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:afc41cb1fe9251448002a2405405b8bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#afc41cb1fe9251448002a2405405b8bd9">More...</a><br /></td></tr>
<tr class="separator:afc41cb1fe9251448002a2405405b8bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c6cd9d16220e8ef358f8b3e072d261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae8c6cd9d16220e8ef358f8b3e072d261">setFragmentProgramParameters</a> (<a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:ae8c6cd9d16220e8ef358f8b3e072d261"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#ae8c6cd9d16220e8ef358f8b3e072d261">More...</a><br /></td></tr>
<tr class="separator:ae8c6cd9d16220e8ef358f8b3e072d261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd45b897ebc29d3ee40a2ee307682f35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#afd45b897ebc29d3ee40a2ee307682f35">setGeometryProgramParameters</a> (<a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:afd45b897ebc29d3ee40a2ee307682f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#afd45b897ebc29d3ee40a2ee307682f35">More...</a><br /></td></tr>
<tr class="separator:afd45b897ebc29d3ee40a2ee307682f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e6148122bd80d646f75364bbc3cbe0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a11e6148122bd80d646f75364bbc3cbe0">setTessellationHullProgramParameters</a> (<a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:a11e6148122bd80d646f75364bbc3cbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a11e6148122bd80d646f75364bbc3cbe0">More...</a><br /></td></tr>
<tr class="separator:a11e6148122bd80d646f75364bbc3cbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f6e70258ca9a870e3b0867792000e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae4f6e70258ca9a870e3b0867792000e6">setTessellationDomainProgramParameters</a> (<a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:ae4f6e70258ca9a870e3b0867792000e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#ae4f6e70258ca9a870e3b0867792000e6">More...</a><br /></td></tr>
<tr class="separator:ae4f6e70258ca9a870e3b0867792000e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58bed2ac47d40e65750c61c0ca36af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad58bed2ac47d40e65750c61c0ca36af3">setComputeProgramParameters</a> (<a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:ad58bed2ac47d40e65750c61c0ca36af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#ad58bed2ac47d40e65750c61c0ca36af3">More...</a><br /></td></tr>
<tr class="separator:ad58bed2ac47d40e65750c61c0ca36af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efc56272065eb16dc629380772d7d7f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a2efc56272065eb16dc629380772d7d7f">getGpuProgramParameters</a> (<a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a> type) const</td></tr>
<tr class="memdesc:a2efc56272065eb16dc629380772d7d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Gpu program parameters used by this pass.  <a href="class_ogre_1_1_pass.html#a2efc56272065eb16dc629380772d7d7f">More...</a><br /></td></tr>
<tr class="separator:a2efc56272065eb16dc629380772d7d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d16617c07bcfdc4f17e9ffed2f8591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac0d16617c07bcfdc4f17e9ffed2f8591">getVertexProgramParameters</a> (void) const</td></tr>
<tr class="memdesc:ac0d16617c07bcfdc4f17e9ffed2f8591"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#ac0d16617c07bcfdc4f17e9ffed2f8591">More...</a><br /></td></tr>
<tr class="separator:ac0d16617c07bcfdc4f17e9ffed2f8591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889ed9697e2a990143cb41f953878dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a889ed9697e2a990143cb41f953878dd3">getFragmentProgramParameters</a> (void) const</td></tr>
<tr class="memdesc:a889ed9697e2a990143cb41f953878dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a889ed9697e2a990143cb41f953878dd3">More...</a><br /></td></tr>
<tr class="separator:a889ed9697e2a990143cb41f953878dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48643d1a8dc67e86a712ff32f8371c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a48643d1a8dc67e86a712ff32f8371c5e">getGeometryProgramParameters</a> (void) const</td></tr>
<tr class="memdesc:a48643d1a8dc67e86a712ff32f8371c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a48643d1a8dc67e86a712ff32f8371c5e">More...</a><br /></td></tr>
<tr class="separator:a48643d1a8dc67e86a712ff32f8371c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6e32bc6812ed954daaa2c5518a2ac3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#abe6e32bc6812ed954daaa2c5518a2ac3">getTessellationHullProgramParameters</a> (void) const</td></tr>
<tr class="memdesc:abe6e32bc6812ed954daaa2c5518a2ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#abe6e32bc6812ed954daaa2c5518a2ac3">More...</a><br /></td></tr>
<tr class="separator:abe6e32bc6812ed954daaa2c5518a2ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22415cb613dea6b39a7940ceebaca32f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a22415cb613dea6b39a7940ceebaca32f">getTessellationDomainProgramParameters</a> (void) const</td></tr>
<tr class="memdesc:a22415cb613dea6b39a7940ceebaca32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a22415cb613dea6b39a7940ceebaca32f">More...</a><br /></td></tr>
<tr class="separator:a22415cb613dea6b39a7940ceebaca32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879780ade78dc1dce173c51ed5c6b3f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a879780ade78dc1dce173c51ed5c6b3f2">getComputeProgramParameters</a> (void) const</td></tr>
<tr class="memdesc:a879780ade78dc1dce173c51ed5c6b3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_pass.html#a879780ade78dc1dce173c51ed5c6b3f2">More...</a><br /></td></tr>
<tr class="separator:a879780ade78dc1dce173c51ed5c6b3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af1992ef39ef97e0b48e878c9aaa2badd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af1992ef39ef97e0b48e878c9aaa2badd">clearDirtyHashList</a> (void)</td></tr>
<tr class="memdesc:af1992ef39ef97e0b48e878c9aaa2badd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method to reset the list of passes which need their hash values recalculated.  <a href="class_ogre_1_1_pass.html#af1992ef39ef97e0b48e878c9aaa2badd">More...</a><br /></td></tr>
<tr class="separator:af1992ef39ef97e0b48e878c9aaa2badd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e11c662982c9ce7f2e08a71bc20167"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ogre_1_1_pass_1_1_hash_func.html">HashFunc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac2e11c662982c9ce7f2e08a71bc20167">getBuiltinHashFunction</a> (<a class="el" href="class_ogre_1_1_pass.html#a1d30a3c04994e1bd0e1de8cb343341a4">BuiltinHashFunction</a> builtin)</td></tr>
<tr class="memdesc:ac2e11c662982c9ce7f2e08a71bc20167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the builtin hash function.  <a href="class_ogre_1_1_pass.html#ac2e11c662982c9ce7f2e08a71bc20167">More...</a><br /></td></tr>
<tr class="separator:ac2e11c662982c9ce7f2e08a71bc20167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e656ed906b7378c5c74d338575c3f58"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_ogre_1_1_pass.html#aaedba8526ffd478f5d731507c4779caf">PassSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a5e656ed906b7378c5c74d338575c3f58">getDirtyHashList</a> (void)</td></tr>
<tr class="memdesc:a5e656ed906b7378c5c74d338575c3f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method to retrieve all the Passes which need their hash values recalculated.  <a href="class_ogre_1_1_pass.html#a5e656ed906b7378c5c74d338575c3f58">More...</a><br /></td></tr>
<tr class="separator:a5e656ed906b7378c5c74d338575c3f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf90d0436441d359280b3c939ee1e3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ogre_1_1_pass_1_1_hash_func.html">HashFunc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aedf90d0436441d359280b3c939ee1e3c">getHashFunction</a> (void)</td></tr>
<tr class="memdesc:aedf90d0436441d359280b3c939ee1e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hash function used for all passes.  <a href="class_ogre_1_1_pass.html#aedf90d0436441d359280b3c939ee1e3c">More...</a><br /></td></tr>
<tr class="separator:aedf90d0436441d359280b3c939ee1e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae403e739ce7fe033bc88ae943135e4"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_ogre_1_1_pass.html#aaedba8526ffd478f5d731507c4779caf">PassSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8ae403e739ce7fe033bc88ae943135e4">getPassGraveyard</a> (void)</td></tr>
<tr class="memdesc:a8ae403e739ce7fe033bc88ae943135e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method to retrieve all the Passes which are pending deletion.  <a href="class_ogre_1_1_pass.html#a8ae403e739ce7fe033bc88ae943135e4">More...</a><br /></td></tr>
<tr class="separator:a8ae403e739ce7fe033bc88ae943135e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989043a45609fd8f82235c3d1c402a23"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a989043a45609fd8f82235c3d1c402a23">processPendingPassUpdates</a> (void)</td></tr>
<tr class="memdesc:a989043a45609fd8f82235c3d1c402a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process all dirty and pending deletion passes.  <a href="class_ogre_1_1_pass.html#a989043a45609fd8f82235c3d1c402a23">More...</a><br /></td></tr>
<tr class="separator:a989043a45609fd8f82235c3d1c402a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686d4ade1581fba7b32609bc535ad9fc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a686d4ade1581fba7b32609bc535ad9fc">setHashFunction</a> (<a class="el" href="class_ogre_1_1_pass.html#a1d30a3c04994e1bd0e1de8cb343341a4">BuiltinHashFunction</a> builtin)</td></tr>
<tr class="memdesc:a686d4ade1581fba7b32609bc535ad9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets one of the default hash functions to be used.  <a href="class_ogre_1_1_pass.html#a686d4ade1581fba7b32609bc535ad9fc">More...</a><br /></td></tr>
<tr class="separator:a686d4ade1581fba7b32609bc535ad9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff774d55b700af010f57e2330101a610"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aff774d55b700af010f57e2330101a610">setHashFunction</a> (<a class="el" href="struct_ogre_1_1_pass_1_1_hash_func.html">HashFunc</a> *hashFunc)</td></tr>
<tr class="memdesc:aff774d55b700af010f57e2330101a610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the hash function used for all passes.  <a href="class_ogre_1_1_pass.html#aff774d55b700af010f57e2330101a610">More...</a><br /></td></tr>
<tr class="separator:aff774d55b700af010f57e2330101a610"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class defining a single pass of a <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> (of a <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Material</a>): a single rendering call. </p>
<p>If a pass does not explicitly use a vertex or fragment shader, Ogre will calculate lighting based on the <a href="https://docs.microsoft.com/en-us/windows/win32/direct3d9/mathematics-of-lighting">Direct3D Light Model</a> as:</p>
<p>If at least one shader is used, the pass is considered <em>programmable</em> and the lighting is up to the shader.</p>
<p>Rendering can be repeated with many passes for more complex effects.</p>
<p>Turning dynamic lighting off makes any ambient, diffuse, specular, emissive and shading properties for this pass redundant. If lighting is turned off, all objects rendered using the pass will be fully lit. When lighting is turned on, objects are lit according to their vertex normals for diffuse and specular light, and globally for ambient and emissive.</p>
<dl class="section user"><dt>Lighting disabled</dt><dd></dd></dl>
<p>$$ passBase = C $$</p>
<p>where \(C = (1, 1, 1)\) or a tracked vertex attribute if <a class="el" href="group___general.html#gga5d04131dcb51ec3cf219465196b6de85a09b4b4b6232b724f9d9b325a06f2067a">TVC_DIFFUSE</a> is set.</p>
<dl class="section user"><dt>Lighting enabled</dt><dd></dd></dl>
<p class="formulaDsp">
\[ passBase = G_a \cdot C_a + \sum^N_i ( C_d \cdot L^{(i)}_d + C_s \cdot L^{(i)}_s ) + C_e \]
</p>
<p>where</p><ul>
<li>\(G_a\) is the ambient colour defined by the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a></li>
<li>\(C_a\) is the pass ambient colour</li>
<li>\(C_e\) is the pass self-illumination colour or a tracked vertex attribute</li>
<li>\(N\) is the number of lights considered during light iteration</li>
<li>\(C_d\) is the pass diffuse colour or a tracked vertex attribute</li>
<li>\(C_s\) is the pass specular colour or a tracked vertex attribute</li>
<li>\(L_d^{(i)}\) is the (attenuated) diffuse colour of the i-th <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene.">Light</a></li>
<li>\(L_s^{(i)}\) is the (attenuated) specular colour of the i-th <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene.">Light</a></li>
</ul>
<dl class="section user"><dt>Programmable passes</dt><dd></dd></dl>
<p>Programmable passes are complex to define, because they require custom programs and you have to set all constant inputs to the programs (like the position of lights, any base material colours you wish to use etc), but they do give you much total flexibility over the algorithms used to render your pass, and you can create some effects which are impossible with a fixed-function pass. On the other hand, you can define a fixed-function pass in very little time, and you can use a range of fixed-function effects like environment mapping very easily, plus your pass will be more likely to be compatible with older hardware. There are pros and cons to both, just remember that if you use a programmable pass to create some great effects, allow more time for definition and testing. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1054ecda87f96dad530ec49099379755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1054ecda87f96dad530ec49099379755">&#9670;&nbsp;</a></span>TextureUnitStates</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a>*&gt; <a class="el" href="class_ogre_1_1_pass.html#a1054ecda87f96dad530ec49099379755">Ogre::Pass::TextureUnitStates</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaedba8526ffd478f5d731507c4779caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedba8526ffd478f5d731507c4779caf">&#9670;&nbsp;</a></span>PassSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="class_ogre_1_1_pass.html">Pass</a>*&gt; <a class="el" href="class_ogre_1_1_pass.html#aaedba8526ffd478f5d731507c4779caf">Ogre::Pass::PassSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7bc2b00e42ad2699a1e2a1de340d3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7bc2b00e42ad2699a1e2a1de340d3b4">&#9670;&nbsp;</a></span>TextureUnitStateIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_pass.html#a1054ecda87f96dad530ec49099379755">TextureUnitStates</a>&gt; <a class="el" href="class_ogre_1_1_pass.html#ac7bc2b00e42ad2699a1e2a1de340d3b4">Ogre::Pass::TextureUnitStateIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98b42a4f4304f3f2d08fb9394cbefe83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b42a4f4304f3f2d08fb9394cbefe83">&#9670;&nbsp;</a></span>ConstTextureUnitStateIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_pass.html#a1054ecda87f96dad530ec49099379755">TextureUnitStates</a>&gt; <a class="el" href="class_ogre_1_1_pass.html#a98b42a4f4304f3f2d08fb9394cbefe83">Ogre::Pass::ConstTextureUnitStateIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a1d30a3c04994e1bd0e1de8cb343341a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d30a3c04994e1bd0e1de8cb343341a4">&#9670;&nbsp;</a></span>BuiltinHashFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_pass.html#a1d30a3c04994e1bd0e1de8cb343341a4">Ogre::Pass::BuiltinHashFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>There are some default hash functions used to order passes so that render state changes are minimised, this enumerates them. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1d30a3c04994e1bd0e1de8cb343341a4aab72a14d25f118c99dd6e9d40953ca46"></a>MIN_TEXTURE_CHANGE&#160;</td><td class="fielddoc"><p>Try to minimise the number of texture changes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1d30a3c04994e1bd0e1de8cb343341a4a281f843d23df9554e590a19d1a3987e3"></a>MIN_GPU_PROGRAM_CHANGE&#160;</td><td class="fielddoc"><p>Try to minimise the number of GPU program changes. </p>
<dl class="section note"><dt>Note</dt><dd>Only really useful if you use GPU programs for all of your materials. </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7f36f2c48b62fd29b2abdee4425d6a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f36f2c48b62fd29b2abdee4425d6a2c">&#9670;&nbsp;</a></span>Pass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::Pass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_technique.html">Technique</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a2af67ca21bb1a91d6c228db8207384fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af67ca21bb1a91d6c228db8207384fc">&#9670;&nbsp;</a></span>Pass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::Pass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_technique.html">Technique</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_pass.html">Pass</a> &amp;&#160;</td>
          <td class="paramname"><em>oth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="a939fc6e2a02a7d753c84ec11219e97da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939fc6e2a02a7d753c84ec11219e97da">&#9670;&nbsp;</a></span>~Pass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::~Pass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a10afa648bf34693a7b6c377e126da20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10afa648bf34693a7b6c377e126da20f">&#9670;&nbsp;</a></span>OGRE_STATIC_MUTEX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::OGRE_STATIC_MUTEX </td>
          <td>(</td>
          <td class="paramtype">msDirtyHashListMutex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab25733e77cd0b2f558d62e5a7ab7592e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25733e77cd0b2f558d62e5a7ab7592e">&#9670;&nbsp;</a></span>OGRE_STATIC_MUTEX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::OGRE_STATIC_MUTEX </td>
          <td>(</td>
          <td class="paramtype">msPassGraveyardMutex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af23f6b1ae56f9acdcb05f8cbcf0e9153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23f6b1ae56f9acdcb05f8cbcf0e9153">&#9670;&nbsp;</a></span>OGRE_MUTEX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::OGRE_MUTEX </td>
          <td>(</td>
          <td class="paramtype">mTexUnitChangeMutex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3af180b9759ea13e557003abc84e594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3af180b9759ea13e557003abc84e594">&#9670;&nbsp;</a></span>OGRE_MUTEX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::OGRE_MUTEX </td>
          <td>(</td>
          <td class="paramtype">mGpuProgramChangeMutex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15bb76abae180b60dfcf9a6e1fdcd8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bb76abae180b60dfcf9a6e1fdcd8fe">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_pass.html">Pass</a>&amp; Ogre::Pass::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_pass.html">Pass</a> &amp;&#160;</td>
          <td class="paramname"><em>oth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator = overload. </p>

</div>
</div>
<a id="a76e0c135dbcacf5d12cc78a15452c7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e0c135dbcacf5d12cc78a15452c7dc">&#9670;&nbsp;</a></span>calculateSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Pass::calculateSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb3b4e8c3d0058a43cd2b855fc22199c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3b4e8c3d0058a43cd2b855fc22199c">&#9670;&nbsp;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Pass::getIndex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the index of this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in the parent <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>

</div>
</div>
<a id="a03306f735122ec4e7d4c391f1528cf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03306f735122ec4e7d4c391f1528cf50">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the name of the pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The name of the pass is optional. Its useful in material scripts where a material could inherit from another material and only want to modify a particular pass. </dd></dl>

</div>
</div>
<a id="a242acbbf397d9db273dcb42d9e4a653c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242acbbf397d9db273dcb42d9e4a653c">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Pass::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the pass. </p>

</div>
</div>
<a id="aba057d0d19159c21b9a79485512b6f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba057d0d19159c21b9a79485512b6f9d">&#9670;&nbsp;</a></span>setAmbient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setAmbient </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>blue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the ambient colour reflectance properties of this pass. </p>
<p>This property determines how much ambient light (directionless global light) is reflected. The default is full white, meaning objects are completely globally illuminated. Reduce this if you want to see diffuse or specular light effects, or change the blend of colours to make the object have a base colour other than white.</p>
<p>It is also possible to make the ambient reflectance track the vertex colour as defined in the mesh instead of the colour values. </p><dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see <a class="el" href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Ogre::Pass::setLightingEnabled</a>), or, if any texture layer has a <a class="el" href="group___materials.html#ggabcbb38d1ac195e4be401f85b7ab0da8fa870cf51ff1ccd919cf710bcb3b4e6432" title="Replace all colour with texture with no adjustment.">Ogre::LBO_REPLACE</a> attribute. </dd></dl>

</div>
</div>
<a id="abdcffe5cb7cee6c8c5a5fd4c2f75164d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcffe5cb7cee6c8c5a5fd4c2f75164d">&#9670;&nbsp;</a></span>setAmbient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setAmbient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>ambient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a823dd0856cf4d8bfa08abc3591c47c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823dd0856cf4d8bfa08abc3591c47c02">&#9670;&nbsp;</a></span>setDiffuse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setDiffuse </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the diffuse colour reflectance properties of this pass. </p>
<p>This property determines how much diffuse light (light from instances of the <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene.">Light</a> class in the scene) is reflected. The default is full white, meaning objects reflect the maximum white light they can from <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene.">Light</a> objects.</p>
<p>It is also possible to make the diffuse reflectance track the vertex colour as defined in the mesh instead of the colour values. </p><dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see <a class="el" href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Ogre::Pass::setLightingEnabled</a>), or, if any texture layer has a <a class="el" href="group___materials.html#ggabcbb38d1ac195e4be401f85b7ab0da8fa870cf51ff1ccd919cf710bcb3b4e6432" title="Replace all colour with texture with no adjustment.">Ogre::LBO_REPLACE</a> attribute. </dd></dl>

</div>
</div>
<a id="a67e3cb12113b4fc56b8d3d4cee03068a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e3cb12113b4fc56b8d3d4cee03068a">&#9670;&nbsp;</a></span>setDiffuse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setDiffuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>diffuse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4e47ea4922d6da5b58eb9879f7e9da09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e47ea4922d6da5b58eb9879f7e9da09">&#9670;&nbsp;</a></span>setSpecular() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSpecular </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specular colour reflectance properties of this pass. </p>
<p>This property determines how much specular light (highlights from instances of the <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene.">Light</a> class in the scene) is reflected. The default is to reflect no specular light.</p>
<p>It is also possible to make the specular reflectance track the vertex colour as defined in the mesh instead of the colour values. </p><dl class="section note"><dt>Note</dt><dd>The size of the specular highlights is determined by the separate 'shininess' property. </dd>
<dd>
This setting has no effect if dynamic lighting is disabled (see <a class="el" href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Ogre::Pass::setLightingEnabled</a>), or, if any texture layer has a <a class="el" href="group___materials.html#ggabcbb38d1ac195e4be401f85b7ab0da8fa870cf51ff1ccd919cf710bcb3b4e6432" title="Replace all colour with texture with no adjustment.">Ogre::LBO_REPLACE</a> attribute. </dd></dl>

</div>
</div>
<a id="a66770883c6420a761996a29b9d5f57bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66770883c6420a761996a29b9d5f57bc">&#9670;&nbsp;</a></span>setSpecular() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSpecular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>specular</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af0977cabd2a7fb79f9ee03078f79011a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0977cabd2a7fb79f9ee03078f79011a">&#9670;&nbsp;</a></span>setShininess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setShininess </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the shininess of the pass, affecting the size of specular highlights. </p>
<p>The higher the value of the shininess parameter, the sharper the highlight i.e. the radius is smaller. Beware of using shininess values in the range of 0 to 1 since this causes the the specular colour to be applied to the whole surface that has the material applied to it. When the viewing angle to the surface changes, ugly flickering will also occur when shininess is in the range of 0 to 1. Shininess values between 1 and 128 work best in both DirectX and OpenGL renderers. </p><dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see <a class="el" href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Ogre::Pass::setLightingEnabled</a>), or, if any texture layer has a <a class="el" href="group___materials.html#ggabcbb38d1ac195e4be401f85b7ab0da8fa870cf51ff1ccd919cf710bcb3b4e6432" title="Replace all colour with texture with no adjustment.">Ogre::LBO_REPLACE</a> attribute. </dd></dl>

</div>
</div>
<a id="a93c36ae948d9e0357c11adb0ce6d5859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c36ae948d9e0357c11adb0ce6d5859">&#9670;&nbsp;</a></span>setSelfIllumination() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSelfIllumination </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>blue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the amount of self-illumination an object has. </p>
<p>If an object is self-illuminating, it does not need external sources to light it, ambient or otherwise. It's like the object has it's own personal ambient light. This property is rarely useful since you can already specify per-pass ambient light, but is here for completeness.</p>
<p>It is also possible to make the emissive reflectance track the vertex colour as defined in the mesh instead of the colour values. </p><dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see <a class="el" href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Ogre::Pass::setLightingEnabled</a>), or, if any texture layer has a <a class="el" href="group___materials.html#ggabcbb38d1ac195e4be401f85b7ab0da8fa870cf51ff1ccd919cf710bcb3b4e6432" title="Replace all colour with texture with no adjustment.">Ogre::LBO_REPLACE</a> attribute. </dd></dl>

</div>
</div>
<a id="a4ed49cbeb67725747cb25376ca67c2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed49cbeb67725747cb25376ca67c2bb">&#9670;&nbsp;</a></span>setSelfIllumination() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSelfIllumination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>selfIllum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ae3ad6543e0c24eb7f12b00f46e7124d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ad6543e0c24eb7f12b00f46e7124d8">&#9670;&nbsp;</a></span>setEmissive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setEmissive </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>blue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the amount of self-illumination an object has. </p>
<p>If an object is self-illuminating, it does not need external sources to light it, ambient or otherwise. It's like the object has it's own personal ambient light. This property is rarely useful since you can already specify per-pass ambient light, but is here for completeness.</p>
<p>It is also possible to make the emissive reflectance track the vertex colour as defined in the mesh instead of the colour values. </p><dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see <a class="el" href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Ogre::Pass::setLightingEnabled</a>), or, if any texture layer has a <a class="el" href="group___materials.html#ggabcbb38d1ac195e4be401f85b7ab0da8fa870cf51ff1ccd919cf710bcb3b4e6432" title="Replace all colour with texture with no adjustment.">Ogre::LBO_REPLACE</a> attribute. </dd></dl>

</div>
</div>
<a id="ae5653eb7430051fc4a81aa577c031186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5653eb7430051fc4a81aa577c031186">&#9670;&nbsp;</a></span>setEmissive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setEmissive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>emissive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a30b32d92dd9d316ff9650affd08d16a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b32d92dd9d316ff9650affd08d16a2">&#9670;&nbsp;</a></span>setVertexColourTracking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setVertexColourTracking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#gaf3fdba7211d7078a43201a1721532f9e">TrackVertexColourType</a>&#160;</td>
          <td class="paramname"><em>tracking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets which material properties follow the vertex colour. </p>

</div>
</div>
<a id="a025d29e0df7f5fa8209e37e3dbac057a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025d29e0df7f5fa8209e37e3dbac057a">&#9670;&nbsp;</a></span>getAmbient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::Pass::getAmbient </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ambient colour reflectance of the pass. </p>

</div>
</div>
<a id="ab41a5ed7aadfabec2111e3124f77cf71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41a5ed7aadfabec2111e3124f77cf71">&#9670;&nbsp;</a></span>getDiffuse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::Pass::getDiffuse </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the diffuse colour reflectance of the pass. </p>

</div>
</div>
<a id="a9847a07e3a202069e91cd0cccc104de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9847a07e3a202069e91cd0cccc104de7">&#9670;&nbsp;</a></span>getSpecular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::Pass::getSpecular </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the specular colour reflectance of the pass. </p>

</div>
</div>
<a id="a21cc793a33a80097900866835aea9abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cc793a33a80097900866835aea9abd">&#9670;&nbsp;</a></span>getSelfIllumination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::Pass::getSelfIllumination </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the self illumination colour of the pass. </p>

</div>
</div>
<a id="a57c97de91cbc0c86e3ca06ccc22b9a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c97de91cbc0c86e3ca06ccc22b9a12">&#9670;&nbsp;</a></span>getEmissive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::Pass::getEmissive </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the self illumination colour of the pass. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a21cc793a33a80097900866835aea9abd" title="Gets the self illumination colour of the pass.">getSelfIllumination</a> </dd></dl>

</div>
</div>
<a id="a031e484e234b00dc415a6122db64ba63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031e484e234b00dc415a6122db64ba63">&#9670;&nbsp;</a></span>getShininess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Pass::getShininess </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 'shininess' property of the pass (affects specular highlights). </p>

</div>
</div>
<a id="a36f48ebbf2890d0744443f7da45acab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f48ebbf2890d0744443f7da45acab7">&#9670;&nbsp;</a></span>getVertexColourTracking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#gaf3fdba7211d7078a43201a1721532f9e">TrackVertexColourType</a> Ogre::Pass::getVertexColourTracking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets which material properties follow the vertex colour. </p>

</div>
</div>
<a id="a6285f13a06eb7f00b83ea2754e434623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6285f13a06eb7f00b83ea2754e434623">&#9670;&nbsp;</a></span>setLightingEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setLightingEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not dynamic lighting is enabled. </p>
<p>Turning dynamic lighting off makes any ambient, diffuse, specular, emissive and shading properties for this pass redundant. If lighting is turned off, all objects rendered using the pass will be fully lit. When lighting is turned on, objects are lit according to their vertex normals for diffuse and specular light, and globally for ambient and emissive. </p>

</div>
</div>
<a id="abce35807758f26b84d29313cf70593cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce35807758f26b84d29313cf70593cd">&#9670;&nbsp;</a></span>getLightingEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getLightingEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not dynamic lighting is enabled. </p>

</div>
</div>
<a id="ab63508d99fef116d0df14c080e0e1129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63508d99fef116d0df14c080e0e1129">&#9670;&nbsp;</a></span>setLineWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setLineWidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the line width for this pass </p>
<p>This property determines what width is used to render lines. </p><dl class="section note"><dt>Note</dt><dd>some drivers only support a value of 1.0 here </dd></dl>

</div>
</div>
<a id="a788b633913442314683050c34b2c3c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788b633913442314683050c34b2c3c9b">&#9670;&nbsp;</a></span>getLineWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Pass::getLineWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a179a7abbb9ec8f4da2c8369691ad0032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179a7abbb9ec8f4da2c8369691ad0032">&#9670;&nbsp;</a></span>getPointSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Pass::getPointSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the point size of the pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This property determines what point size is used to render a point list. </dd></dl>

</div>
</div>
<a id="a490736f9eaeffd1c60611869d68931ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490736f9eaeffd1c60611869d68931ee">&#9670;&nbsp;</a></span>setPointSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPointSize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the point size of this pass. </p>
<p>This setting allows you to change the size of points when rendering a point list, or a list of point sprites. The interpretation of this command depends on the <a class="el" href="class_ogre_1_1_pass.html#a3540a0dab9519f146edad630f3c89c22" title="Sets how points are attenuated with distance.">Ogre::Pass::setPointAttenuation</a> option - if it is off (the default), the point size is in screen pixels, if it is on, it expressed as normalised screen coordinates (1.0 is the height of the screen) when the point is at the origin. </p><dl class="section note"><dt>Note</dt><dd>Some drivers have an upper limit on the size of points they support - this can even vary between APIs on the same card! Don't rely on point sizes that cause the point sprites to get very large on screen, since they may get clamped on some cards. Upper sizes can range from 64 to 256 pixels. </dd></dl>

</div>
</div>
<a id="a9683c2f40ed7c96b708eb2db5e02c842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9683c2f40ed7c96b708eb2db5e02c842">&#9670;&nbsp;</a></span>setPointSpritesEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPointSpritesEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether points will be rendered as textured quads or plain dots. </p>
<p>This setting specifies whether or not hardware point sprite rendering is enabled for this pass. Enabling it means that a point list is rendered as a list of quads rather than a list of dots. It is very useful to use this option if you are using a <a class="el" href="class_ogre_1_1_billboard_set.html" title="A collection of billboards (faces which are always facing the given direction) with the same (default...">BillboardSet</a> and only need to use point oriented billboards which are all of the same size. You can also use it for any other point list render. </p>

</div>
</div>
<a id="af70ccd332a1df548058917c31021f7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70ccd332a1df548058917c31021f7df">&#9670;&nbsp;</a></span>getPointSpritesEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getPointSpritesEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether point sprites are enabled when rendering a point list. </p>

</div>
</div>
<a id="a3540a0dab9519f146edad630f3c89c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3540a0dab9519f146edad630f3c89c22">&#9670;&nbsp;</a></span>setPointAttenuation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPointAttenuation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>constant</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>linear</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>quadratic</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets how points are attenuated with distance. </p>
<p>When performing point rendering or point sprite rendering, point size can be attenuated with distance. The equation for doing this is</p>
<p>$$attenuation = 1 / (constant + linear * dist + quadratic * d^2)$$</p>
<p>For example, to disable distance attenuation (constant screensize) you would set constant to 1, and linear and quadratic to 0. A standard perspective attenuation would be 0, 1, 0 respectively.</p>
<p>The resulting size is clamped to the minimum and maximum point size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Whether point attenuation is enabled </td></tr>
    <tr><td class="paramname">constant,linear,quadratic</td><td>Parameters to the attenuation function defined above </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5e358a5fd8a944c9845f8aee4ba54a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e358a5fd8a944c9845f8aee4ba54a6">&#9670;&nbsp;</a></span>isPointAttenuationEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::isPointAttenuationEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether points are attenuated with distance. </p>

</div>
</div>
<a id="a58d04fc4bd33d55bd6059c06db15f5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d04fc4bd33d55bd6059c06db15f5f8">&#9670;&nbsp;</a></span>getPointAttenuationConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Pass::getPointAttenuationConstant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the constant coefficient of point attenuation. </p>

</div>
</div>
<a id="af27332810328f3be996516ccfd105ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27332810328f3be996516ccfd105ac2">&#9670;&nbsp;</a></span>getPointAttenuationLinear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Pass::getPointAttenuationLinear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the linear coefficient of point attenuation. </p>

</div>
</div>
<a id="ad7d25e05b830745ecfc6cbd09624ee17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d25e05b830745ecfc6cbd09624ee17">&#9670;&nbsp;</a></span>getPointAttenuationQuadratic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Pass::getPointAttenuationQuadratic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the quadratic coefficient of point attenuation. </p>

</div>
</div>
<a id="a2eb0e0f957c2dd23fb068a160dd4f8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb0e0f957c2dd23fb068a160dd4f8f5">&#9670;&nbsp;</a></span>getPointAttenuation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a272ffe59e216908cce70c5fd11eaa7ff">Vector4f</a>&amp; Ogre::Pass::getPointAttenuation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get all point attenuation params as (size, constant, linear, quadratic) </p>

</div>
</div>
<a id="a75a3e18e0d2c3e7f51a47cedcec0246c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a3e18e0d2c3e7f51a47cedcec0246c">&#9670;&nbsp;</a></span>setPointMinSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPointMinSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>min</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum point size, when point attenuation is in use. </p>

</div>
</div>
<a id="a8d799c8e3324a37e70d50f8fd1e5daac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d799c8e3324a37e70d50f8fd1e5daac">&#9670;&nbsp;</a></span>getPointMinSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Pass::getPointMinSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum point size, when point attenuation is in use. </p>

</div>
</div>
<a id="a463b59eaa324934370441a98b8b619b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463b59eaa324934370441a98b8b619b3">&#9670;&nbsp;</a></span>setPointMaxSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPointMaxSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum point size, when point attenuation is in use. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Setting this to 0 indicates the max size supported by the card. </dd></dl>

</div>
</div>
<a id="aeaf906d8abba9a4b4dde83f87daa0f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf906d8abba9a4b4dde83f87daa0f4e">&#9670;&nbsp;</a></span>getPointMaxSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Pass::getPointMaxSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum point size, when point attenuation is in use. </p>
<dl class="section remark"><dt>Remarks</dt><dd>0 indicates the max size supported by the card. </dd></dl>

</div>
</div>
<a id="adfee1e1da3564408697f6b1227102c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfee1e1da3564408697f6b1227102c63">&#9670;&nbsp;</a></span>createTextureUnitState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a>* Ogre::Pass::createTextureUnitState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>texCoordSet</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> object into the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This unit is is added on top of all previous units. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureName</td><td>The basic name of the texture e.g. brickwall.jpg, stonefloor.png </td></tr>
    <tr><td class="paramname">texCoordSet</td><td>The index of the texture coordinate set to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Applies to both fixed-function and programmable passes. </dd></dl>

</div>
</div>
<a id="af8b37124088b574d2cbb2652c0ee4272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b37124088b574d2cbb2652c0ee4272">&#9670;&nbsp;</a></span>createTextureUnitState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a>* Ogre::Pass::createTextureUnitState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a00a4036c87d4778c20d19412e9530ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a4036c87d4778c20d19412e9530ff2">&#9670;&nbsp;</a></span>addTextureUnitState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::addTextureUnitState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the passed in <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a>, to the existing <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> Unit State to be attached to this pass. It must not be attached to another pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Throws an exception if the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> is attached to another <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </dd></dl>

</div>
</div>
<a id="a01a74a1797a61115107a70fad10e52c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a74a1797a61115107a70fad10e52c5">&#9670;&nbsp;</a></span>getTextureUnitState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a>* Ogre::Pass::getTextureUnitState </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a const pointer to a texture unit state. </p>

</div>
</div>
<a id="afe30c603d0dab1f4194463699c0091ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe30c603d0dab1f4194463699c0091ba">&#9670;&nbsp;</a></span>getTextureUnitState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a>* Ogre::Pass::getTextureUnitState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> Unit State matching name. </p>
<p>Returns 0 if name match is not found. </p>

</div>
</div>
<a id="a613a1145ae3ee981f223c00fc21b742e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613a1145ae3ee981f223c00fc21b742e">&#9670;&nbsp;</a></span>getTextureUnitStateIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Pass::getTextureUnitStateIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the index of the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> Unit State in the pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> Unit State this is attached to this pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Throws an exception if the state is not attached to the pass. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000121">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_pass.html#a27a57322ba3813c39d62bbd7a3ba01fb" title="Get the TextureUnitStates contained in this Pass.">getTextureUnitStates()</a> </dd></dl>

</div>
</div>
<a id="ac1513f6d3e1acb9037225d826ec99856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1513f6d3e1acb9037225d826ec99856">&#9670;&nbsp;</a></span>getTextureUnitStateIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_pass.html#ac7bc2b00e42ad2699a1e2a1de340d3b4">TextureUnitStateIterator</a> Ogre::Pass::getTextureUnitStateIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator over the TextureUnitStates contained in this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000122">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_pass.html#a27a57322ba3813c39d62bbd7a3ba01fb" title="Get the TextureUnitStates contained in this Pass.">getTextureUnitStates()</a> </dd></dl>

</div>
</div>
<a id="a185a8f17c108024b5b0683d895d5bcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185a8f17c108024b5b0683d895d5bcaf">&#9670;&nbsp;</a></span>getTextureUnitStateIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_pass.html#a98b42a4f4304f3f2d08fb9394cbefe83">ConstTextureUnitStateIterator</a> Ogre::Pass::getTextureUnitStateIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator over the TextureUnitStates contained in this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000123">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_pass.html#a27a57322ba3813c39d62bbd7a3ba01fb" title="Get the TextureUnitStates contained in this Pass.">getTextureUnitStates()</a> </dd></dl>

</div>
</div>
<a id="a27a57322ba3813c39d62bbd7a3ba01fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a57322ba3813c39d62bbd7a3ba01fb">&#9670;&nbsp;</a></span>getTextureUnitStates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_pass.html#a1054ecda87f96dad530ec49099379755">TextureUnitStates</a>&amp; Ogre::Pass::getTextureUnitStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the TextureUnitStates contained in this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </p>

</div>
</div>
<a id="a66085d80b0caa39850216b603cec40b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66085d80b0caa39850216b603cec40b1">&#9670;&nbsp;</a></span>removeTextureUnitState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::removeTextureUnitState </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the indexed texture unit state from this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that removing a texture which is not the topmost will have a larger performance impact. </dd></dl>

</div>
</div>
<a id="a86de1842654eb89c6f48785d02f07688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86de1842654eb89c6f48785d02f07688">&#9670;&nbsp;</a></span>removeAllTextureUnitStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::removeAllTextureUnitStates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all texture unit settings. </p>

</div>
</div>
<a id="aca1044a438121427b138b1391d37854f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1044a438121427b138b1391d37854f">&#9670;&nbsp;</a></span>getNumTextureUnitStates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Pass::getNumTextureUnitStates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of texture unit settings. </p>

</div>
</div>
<a id="a8f69f7e13e3665ba295ce9b4671fdc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f69f7e13e3665ba295ce9b4671fdc4c">&#9670;&nbsp;</a></span>_getTextureUnitWithContentTypeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Pass::_getTextureUnitWithContentTypeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_unit_state.html#a3a09898645eac12548f6598fcbb9ac60">TextureUnitState::ContentType</a>&#160;</td>
          <td class="paramname"><em>contentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the 'nth' texture which references the given content type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the 'nth' texture unit which references the content type doesn't exist, then this method returns an arbitrary high-value outside the valid range to index texture units. </dd></dl>

</div>
</div>
<a id="a5abbb49b669a575991c17bb67bcae975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abbb49b669a575991c17bb67bcae975">&#9670;&nbsp;</a></span>setTextureFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setTextureFiltering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5">TextureFilterOptions</a>&#160;</td>
          <td class="paramname"><em>filterType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set texture filtering for every texture unit. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> class For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_unit_state.html#a30757c168b734902d03720e3f36c27d4" title="Set the texture filtering for this unit, using the simplified interface.">TextureUnitState::setTextureFiltering</a> </dd></dl>

</div>
</div>
<a id="a388afa054c642dd6b0585fd168cd7b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388afa054c642dd6b0585fd168cd7b1a">&#9670;&nbsp;</a></span>setTextureAnisotropy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setTextureAnisotropy </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxAniso</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the anisotropy level to be used for all textures. </p>
<dl class="section note"><dt>Note</dt><dd>This property has been moved to the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> class, which is accessible via the <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> and <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>, <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> and <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> instances and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_unit_state.html#abb2bc03bc72f2098e37c4240f637c5e5" title="Sets the anisotropy level to be used for this texture level.">TextureUnitState::setTextureAnisotropy</a> </dd></dl>

</div>
</div>
<a id="ae21d6f29c89eeff54ab6de5562818c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21d6f29c89eeff54ab6de5562818c02">&#9670;&nbsp;</a></span>setSceneBlending() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSceneBlending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&#160;</td>
          <td class="paramname"><em>sbt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the kind of blending this pass has with the existing contents of the scene. </p>
<p>Whereas the texture blending operations seen in the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> class are concerned with blending between texture layers, this blending is about combining the output of the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> as a whole with the existing contents of the rendering target. This blending therefore allows object transparency and other special effects. If all passes in a technique have a scene blend, then the whole technique is considered to be transparent.</p>
<p>This method allows you to select one of a number of predefined blending types. If you require more control than this, use the alternative version of this method which allows you to specify source and destination blend factors. </p><dl class="section note"><dt>Note</dt><dd>This method is applicable for both the fixed-function and programmable pipelines. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sbt</td><td>One of the predefined SceneBlendType blending types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefbd80d762d78838df626482df1ac81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbd80d762d78838df626482df1ac81b">&#9670;&nbsp;</a></span>setSeparateSceneBlending() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSeparateSceneBlending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&#160;</td>
          <td class="paramname"><em>sbt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&#160;</td>
          <td class="paramname"><em>sbta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the kind of blending this pass has with the existing contents of the scene, separately for color and alpha channels. </p>
<p>This method allows you to select one of a number of predefined blending types. If you require more control than this, use the alternative version of this method which allows you to specify source and destination blend factors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sbt</td><td>One of the predefined SceneBlendType blending types for the color channel </td></tr>
    <tr><td class="paramname">sbta</td><td>One of the predefined SceneBlendType blending types for the alpha channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ae2b0725a20fe90f1554834bafa7178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae2b0725a20fe90f1554834bafa7178">&#9670;&nbsp;</a></span>setSceneBlending() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSceneBlending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td>
          <td class="paramname"><em>sourceFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td>
          <td class="paramname"><em>destFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows very fine control of blending this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> with the existing contents of the scene. </p>
<p>This version of the method allows complete control over the blending operation, by specifying the source and destination blending factors.</p>
<p>By default the operation is <a class="el" href="group___materials.html#ggaa7a12a72231aedf6e33d58aafc11214aa188aee58620b3275f1a45c7c80df4bc7">Ogre::SBO_ADD</a>, which creates this equation</p>
<p>$$final = (passOutput * sourceFactor) + (frameBuffer * destFactor)$$</p>
<p>Each of the factors is specified as one of <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213" title="Blending factors for manually blending objects with the scene.">Ogre::SceneBlendFactor</a>.</p>
<p>By setting a different <a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a" title="Blending operations controls how objects are blended into the scene.">Ogre::SceneBlendOperation</a> you can achieve a different effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceFactor</td><td>The source factor in the above calculation, i.e. multiplied by the output of the Pass. </td></tr>
    <tr><td class="paramname">destFactor</td><td>The destination factor in the above calculation, i.e. multiplied by the Frame Buffer contents. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4bba51e9a0cba1b9708bab99496c1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bba51e9a0cba1b9708bab99496c1a8">&#9670;&nbsp;</a></span>setSeparateSceneBlending() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSeparateSceneBlending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td>
          <td class="paramname"><em>sourceFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td>
          <td class="paramname"><em>destFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td>
          <td class="paramname"><em>sourceFactorAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td>
          <td class="paramname"><em>destFactorAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows very fine control of blending this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> with the existing contents of the scene. </p>
<p>This version of the method allows complete control over the blending operation, by specifying the source and destination blending factors.</p>
<p>By default the operation is <a class="el" href="group___materials.html#ggaa7a12a72231aedf6e33d58aafc11214aa188aee58620b3275f1a45c7c80df4bc7">Ogre::SBO_ADD</a>, which creates this equation</p>
<p>$$final = (passOutput * sourceFactor) + (frameBuffer * destFactor)$$</p>
<p>Each of the factors is specified as one of <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213" title="Blending factors for manually blending objects with the scene.">Ogre::SceneBlendFactor</a>.</p>
<p>By setting a different <a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a" title="Blending operations controls how objects are blended into the scene.">Ogre::SceneBlendOperation</a> you can achieve a different effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceFactor</td><td>The source factor in the above calculation, i.e. multiplied by the output of the Pass. </td></tr>
    <tr><td class="paramname">destFactor</td><td>The destination factor in the above calculation, i.e. multiplied by the Frame Buffer contents. </td></tr>
    <tr><td class="paramname">sourceFactorAlpha</td><td>The alpha source factor in the above calculation, i.e. multiplied by the output of the Pass. </td></tr>
    <tr><td class="paramname">destFactorAlpha</td><td>The alpha destination factor in the above calculation, i.e. multiplied by the Frame Buffer alpha. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9a501c0f7f8842493dd277814e38812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a501c0f7f8842493dd277814e38812">&#9670;&nbsp;</a></span>getBlendState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_colour_blend_state.html">ColourBlendState</a>&amp; Ogre::Pass::getBlendState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the complete blend state of this pass. </p>

</div>
</div>
<a id="aec14031d3e7e69c7ec4f734dc40f612d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec14031d3e7e69c7ec4f734dc40f612d">&#9670;&nbsp;</a></span>getSourceBlendFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> Ogre::Pass::getSourceBlendFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the source blending factor for the material. </p>

<p class="reference">References <a class="el" href="struct_ogre_1_1_colour_blend_state.html#afcd73a71641f8bb2befcf147fd8bd982">Ogre::ColourBlendState::sourceFactor</a>.</p>

</div>
</div>
<a id="a8e61c233c08848aa736bcfa7bdb58158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e61c233c08848aa736bcfa7bdb58158">&#9670;&nbsp;</a></span>getDestBlendFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> Ogre::Pass::getDestBlendFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the destination blending factor for the material. </p>

<p class="reference">References <a class="el" href="struct_ogre_1_1_colour_blend_state.html#a2a86317b4a9efb0c6b4f3f8fe9ff0fbf">Ogre::ColourBlendState::destFactor</a>.</p>

</div>
</div>
<a id="a040397cbf641fcd16ad1cc1846ccb0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040397cbf641fcd16ad1cc1846ccb0a0">&#9670;&nbsp;</a></span>getSourceBlendFactorAlpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> Ogre::Pass::getSourceBlendFactorAlpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the alpha source blending factor for the material. </p>

<p class="reference">References <a class="el" href="struct_ogre_1_1_colour_blend_state.html#a4c9669f21aa6a880dac5b5380310e6b0">Ogre::ColourBlendState::sourceFactorAlpha</a>.</p>

</div>
</div>
<a id="aa89b9de8338da5bb1944b16145ee2f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89b9de8338da5bb1944b16145ee2f62">&#9670;&nbsp;</a></span>getDestBlendFactorAlpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> Ogre::Pass::getDestBlendFactorAlpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the alpha destination blending factor for the material. </p>

<p class="reference">References <a class="el" href="struct_ogre_1_1_colour_blend_state.html#a6efce17376a11ea819d298d22580ea6b">Ogre::ColourBlendState::destFactorAlpha</a>.</p>

</div>
</div>
<a id="a9ae2570082185c2b6e237a2d46f9bb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae2570082185c2b6e237a2d46f9bb60">&#9670;&nbsp;</a></span>setSceneBlendingOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSceneBlendingOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a">SceneBlendOperation</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specific operation used to blend source and destination pixels together. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_ogre_1_1_colour_blend_state.html" title="Describes the global blending factors for combining subsequent renders with the existing frame conten...">Ogre::ColourBlendState</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The blending operation mode to use for this pass </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace4313056341502f87ada68638cae334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4313056341502f87ada68638cae334">&#9670;&nbsp;</a></span>setSeparateSceneBlendingOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSeparateSceneBlendingOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a">SceneBlendOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a">SceneBlendOperation</a>&#160;</td>
          <td class="paramname"><em>alphaOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specific operation used to blend source and destination pixels together. </p>
<p>This function allows more control over blending since it allows you to select different blending modes for the color and alpha channels</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_ogre_1_1_colour_blend_state.html" title="Describes the global blending factors for combining subsequent renders with the existing frame conten...">Ogre::ColourBlendState</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The blending operation mode to use for this pass </td></tr>
    <tr><td class="paramname">alphaOp</td><td>The blending operation mode to use for alpha channels in this pass </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e4598b48a3cc36a3a9ac5c7f190440c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4598b48a3cc36a3a9ac5c7f190440c">&#9670;&nbsp;</a></span>getSceneBlendingOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a">SceneBlendOperation</a> Ogre::Pass::getSceneBlendingOperation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current blending operation. </p>

<p class="reference">References <a class="el" href="struct_ogre_1_1_colour_blend_state.html#a1a8d5d6033ad996dfadaafdad151e25d">Ogre::ColourBlendState::operation</a>.</p>

</div>
</div>
<a id="a1c36e64352bf3b1d0d87a220d05f6dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c36e64352bf3b1d0d87a220d05f6dbf">&#9670;&nbsp;</a></span>getSceneBlendingOperationAlpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a">SceneBlendOperation</a> Ogre::Pass::getSceneBlendingOperationAlpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current alpha blending operation. </p>

<p class="reference">References <a class="el" href="struct_ogre_1_1_colour_blend_state.html#a137130fbfd568631e517597aeebf1c03">Ogre::ColourBlendState::alphaOperation</a>.</p>

</div>
</div>
<a id="a3bbe37daba7e3be4349177374d4e40ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbe37daba7e3be4349177374d4e40ee">&#9670;&nbsp;</a></span>setColourWriteEnabled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setColourWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not colour buffer writing is enabled for this Pass. </p>
<p>If colour writing is off no visible pixels are written to the screen during this pass. You might think this is useless, but if you render with colour writing off, and with very minimal other settings, you can use this pass to initialise the depth buffer before subsequently rendering other passes which fill in the colour data. This can give you significant performance boosts on some newer cards, especially when using complex fragment programs, because if the depth check fails then the fragment program is never run. </p>

</div>
</div>
<a id="a51d61feca0e3c7cae4c3e1c2988540b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d61feca0e3c7cae4c3e1c2988540b0">&#9670;&nbsp;</a></span>getColourWriteEnabled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getColourWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if colour buffer writing is enabled for this pass i.e. </p>
<p>when at least one colour channel is enabled for writing. </p>

</div>
</div>
<a id="ae8c85bd4eff471ca7b3c710d20dbf274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c85bd4eff471ca7b3c710d20dbf274">&#9670;&nbsp;</a></span>setColourWriteEnabled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setColourWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets which colour buffer channels are enabled for writing for this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </p>

</div>
</div>
<a id="a40b25c9a64b05c3463a2da9e174be901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b25c9a64b05c3463a2da9e174be901">&#9670;&nbsp;</a></span>getColourWriteEnabled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::getColourWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which colour buffer channels are enabled for writing for this pass. </p>

</div>
</div>
<a id="a85a67b777d757d158c6cbc2b4f7ec76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a67b777d757d158c6cbc2b4f7ec76e">&#9670;&nbsp;</a></span>isTransparent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::isTransparent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this pass has some element of transparency. </p>

</div>
</div>
<a id="ae454faee87f8cb0b8540810e48118788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae454faee87f8cb0b8540810e48118788">&#9670;&nbsp;</a></span>setDepthCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setDepthCheckEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not this pass renders with depth-buffer checking on or not. </p>
<p>If depth-buffer checking is on, whenever a pixel is about to be written to the frame buffer the depth buffer is checked to see if the pixel is in front of all other pixels written at that point. If not, the pixel is not written.</p>
<p>If depth checking is off, pixels are written no matter what has been rendered before. Also see setDepthFunction for more advanced depth check configuration. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6" title="Comparison functions used for the depth/stencil buffer operations and others.">Ogre::CompareFunction</a> </dd></dl>

</div>
</div>
<a id="a648b0f3f74464f4b0e4472e64219f1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648b0f3f74464f4b0e4472e64219f1a1">&#9670;&nbsp;</a></span>getDepthCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getDepthCheckEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this pass renders with depth-buffer checking on or not. </p>

</div>
</div>
<a id="aad3e6c7c7b59e2c303c348b4850b1a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3e6c7c7b59e2c303c348b4850b1a3a">&#9670;&nbsp;</a></span>setDepthWriteEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setDepthWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not this pass renders with depth-buffer writing on or not. </p>
<p>If depth-buffer writing is on, whenever a pixel is written to the frame buffer the depth buffer is updated with the depth value of that new pixel, thus affecting future rendering operations if future pixels are behind this one.</p>
<p>If depth writing is off, pixels are written without updating the depth buffer Depth writing should normally be on but can be turned off when rendering static backgrounds or when rendering a collection of transparent objects at the end of a scene so that they overlap each other correctly. </p>

</div>
</div>
<a id="ab2d6e2e30826d01e5ec19bef7446f447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d6e2e30826d01e5ec19bef7446f447">&#9670;&nbsp;</a></span>getDepthWriteEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getDepthWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this pass renders with depth-buffer writing on or not. </p>

</div>
</div>
<a id="aef6c591b069aa6f7c65afc1419d47de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6c591b069aa6f7c65afc1419d47de6">&#9670;&nbsp;</a></span>setDepthFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setDepthFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6">CompareFunction</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the function used to compare depth values when depth checking is on. </p>
<p>If depth checking is enabled (see setDepthCheckEnabled) a comparison occurs between the depth value of the pixel to be written and the current contents of the buffer. This comparison is normally <a class="el" href="group___general.html#gga8e1c2888df9ea68a8fa31b64b6aa67d6a2272d0faefcf5a2e08bbf7d232d7520b" title="Write if (new_Z &lt;= existing_Z)">Ogre::CMPF_LESS_EQUAL</a>. </p>

</div>
</div>
<a id="aed6912e985c09f72d8f8012494f1068a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6912e985c09f72d8f8012494f1068a">&#9670;&nbsp;</a></span>getDepthFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6">CompareFunction</a> Ogre::Pass::getDepthFunction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the function used to compare depth values when depth checking is on. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#aef6c591b069aa6f7c65afc1419d47de6" title="Sets the function used to compare depth values when depth checking is on.">setDepthFunction</a> </dd></dl>

</div>
</div>
<a id="aa35a3242a45176f8605bd8c866198b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35a3242a45176f8605bd8c866198b67">&#9670;&nbsp;</a></span>setDepthBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setDepthBias </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>constantBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>slopeScaleBias</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the depth bias to be used for this material. </p>
<p>When polygons are coplanar, you can get problems with 'depth fighting' where the pixels from the two polys compete for the same screen pixel. This is particularly a problem for decals (polys attached to another surface to represent details such as bulletholes etc.).</p>
<p>A way to combat this problem is to use a depth bias to adjust the depth buffer value used for the decal such that it is slightly higher than the true value, ensuring that the decal appears on top. There are two aspects to the biasing, a constant bias value and a slope-relative biasing value, which varies according to the maximum depth slope relative to the camera, ie:</p>
<p>$$finalBias = maxSlope * slopeScaleBias + constantBias$$</p>
<p>Slope scale biasing is relative to the angle of the polygon to the camera, which makes for a more appropriate bias value, but this is ignored on some older hardware. Constant biasing is expressed as a factor of the minimum depth value, so a value of 1 will nudge the depth by one notch if you will. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constantBias</td><td>The constant bias value </td></tr>
    <tr><td class="paramname">slopeScaleBias</td><td>The slope-relative bias value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0327eac96a7858951a92d64dbdef8b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0327eac96a7858951a92d64dbdef8b31">&#9670;&nbsp;</a></span>getDepthBiasConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Pass::getDepthBiasConstant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the const depth bias value as set by setDepthBias. </p>

</div>
</div>
<a id="a2639336933c81b101f7b38b02c590518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2639336933c81b101f7b38b02c590518">&#9670;&nbsp;</a></span>getDepthBiasSlopeScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Pass::getDepthBiasSlopeScale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the slope-scale depth bias value as set by setDepthBias. </p>

</div>
</div>
<a id="aca462cd8e0708d90c3131ddd39e95674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca462cd8e0708d90c3131ddd39e95674">&#9670;&nbsp;</a></span>setIterationDepthBias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setIterationDepthBias </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>biasPerIteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a factor which derives an additional depth bias from the number of times a pass is iterated. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The Final depth bias will be the constant depth bias as set through setDepthBias, plus this value times the iteration number. </dd></dl>

</div>
</div>
<a id="adcb78aa549dc85cb36bd3dbc8abeee24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb78aa549dc85cb36bd3dbc8abeee24">&#9670;&nbsp;</a></span>getIterationDepthBias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Pass::getIterationDepthBias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a factor which derives an additional depth bias from the number of times a pass is iterated. </p>

</div>
</div>
<a id="a8942abf3ede0f3cb43584c85c4071734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8942abf3ede0f3cb43584c85c4071734">&#9670;&nbsp;</a></span>setCullingMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setCullingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga4766f4c65e0a47f0a71c5908944a7a3c">CullingMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the culling mode for this pass based on the 'vertex winding'. </p>
<p>A typical way for the rendering engine to cull triangles is based on the 'vertex winding' of triangles. Vertex winding refers to the direction in which the vertices are passed or indexed to in the rendering operation as viewed from the camera, and will either be clockwise or anticlockwise (that's 'counterclockwise' for you Americans out there ;) The default is <a class="el" href="group___general.html#gga4766f4c65e0a47f0a71c5908944a7a3ca50170ef4a0a12b9fc6bf0c53e582bdf0" title="Hardware culls triangles whose vertices are listed clockwise in the view (default).">Ogre::CULL_CLOCKWISE</a> i.e. that only triangles whose vertices are passed/indexed in anticlockwise order are rendered - this is a common approach and is used in 3D studio models for example. You can alter this culling mode if you wish but it is not advised unless you know what you are doing.</p>
<p>You may wish to use the <a class="el" href="group___general.html#gga4766f4c65e0a47f0a71c5908944a7a3ca7868e61bf90df40d5e04e3a951729248" title="Hardware never culls triangles and renders everything it receives.">Ogre::CULL_NONE</a> option for mesh data that you cull yourself where the vertex winding is uncertain or for creating 2-sided passes. </p>

</div>
</div>
<a id="aedb647950fbc40f52ae139eb166d602d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb647950fbc40f52ae139eb166d602d">&#9670;&nbsp;</a></span>getCullingMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga4766f4c65e0a47f0a71c5908944a7a3c">CullingMode</a> Ogre::Pass::getCullingMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the culling mode for geometry rendered with this pass. </p>
<p>See setCullingMode for more information. </p>

</div>
</div>
<a id="a3b528827b54f17b72bb204321640a6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b528827b54f17b72bb204321640a6f7">&#9670;&nbsp;</a></span>setManualCullingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setManualCullingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga67144aea217e56725c43541fb064af20">ManualCullingMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the manual culling mode, performed by CPU rather than hardware. </p>
<p>In some situations you want to use manual culling of triangles rather than sending the triangles to the hardware and letting it cull them. This setting only takes effect on <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a>'s that use it (since it is best used on large groups of planar world geometry rather than on movable geometry since this would be expensive), but if used can cull geometry before it is sent to the hardware.</p>
<p>In this case the culling is based on whether the back or front of the triangle is facing the camera - this definition is based on the face normal (a vector which sticks out of the front side of the polygon perpendicular to the face). Since Ogre expects face normals to be on anticlockwise side of the face, <a class="el" href="group___general.html#gga67144aea217e56725c43541fb064af20adbebf0c209be54ddb19d6097d4f7042f" title="Cull triangles whose normal is pointing away from the camera (default).">Ogre::MANUAL_CULL_BACK</a> is the software equivalent of <a class="el" href="group___general.html#gga4766f4c65e0a47f0a71c5908944a7a3ca50170ef4a0a12b9fc6bf0c53e582bdf0" title="Hardware culls triangles whose vertices are listed clockwise in the view (default).">Ogre::CULL_CLOCKWISE</a> setting, which is why they are both the default. The naming is different to reflect the way the culling is done though, since most of the time face normals are pre-calculated and they dont have to be the way Ogre expects - you could set <a class="el" href="group___general.html#gga4766f4c65e0a47f0a71c5908944a7a3ca7868e61bf90df40d5e04e3a951729248" title="Hardware never culls triangles and renders everything it receives.">Ogre::CULL_NONE</a> and completely cull in software based on your own face normals, if you have the right <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a> which uses them. </p>

</div>
</div>
<a id="acd99aaea7eec3026699bfccdd09310b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd99aaea7eec3026699bfccdd09310b0">&#9670;&nbsp;</a></span>getManualCullingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga67144aea217e56725c43541fb064af20">ManualCullingMode</a> Ogre::Pass::getManualCullingMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the manual culling mode for this pass. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a3b528827b54f17b72bb204321640a6f7" title="Sets the manual culling mode, performed by CPU rather than hardware.">setManualCullingMode</a> </dd></dl>

</div>
</div>
<a id="ade6c00297cd5d46bb365d981cd1764a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6c00297cd5d46bb365d981cd1764a6">&#9670;&nbsp;</a></span>setShadingMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setShadingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga12cb29cae690b696c0f1c4863d8c25a7">ShadeOptions</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the type of light shading required. </p>
<p>When dynamic lighting is turned on, the effect is to generate colour values at each vertex. Whether these values are interpolated across the face (and how) depends on this setting. The default shading method is <a class="el" href="group___general.html#gga12cb29cae690b696c0f1c4863d8c25a7a2973848ded9ca7c0f93a329e12181feb" title="Colour at each vertex is linearly interpolated across the face.">Ogre::SO_GOURAUD</a>. </p>

</div>
</div>
<a id="a5485f8b014bfa01d765a442999ad9ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5485f8b014bfa01d765a442999ad9ed3">&#9670;&nbsp;</a></span>getShadingMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga12cb29cae690b696c0f1c4863d8c25a7">ShadeOptions</a> Ogre::Pass::getShadingMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of light shading to be used. </p>

</div>
</div>
<a id="a61d996b43e57fa45e660b23013855fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d996b43e57fa45e660b23013855fe2">&#9670;&nbsp;</a></span>setPolygonMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPolygonMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga2df30008578f1d062a70ec268d1ae016">PolygonMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the type of polygon rendering required. </p>
<p>Sets how polygons should be rasterised, i.e. whether they should be filled in, or just drawn as lines or points. The default shading method is <a class="el" href="group___general.html#gga2df30008578f1d062a70ec268d1ae016a7e87bf8ec063f4e7bf022a7396346211" title="The normal situation - polygons are filled in.">Ogre::PM_SOLID</a>. </p>

</div>
</div>
<a id="a4791eea37712b82994052b3e4a360fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4791eea37712b82994052b3e4a360fa0">&#9670;&nbsp;</a></span>getPolygonMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga2df30008578f1d062a70ec268d1ae016">PolygonMode</a> Ogre::Pass::getPolygonMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of light shading to be used. </p>

</div>
</div>
<a id="ad681df78f0e0c61e1bc166e3ec85170f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad681df78f0e0c61e1bc166e3ec85170f">&#9670;&nbsp;</a></span>setPolygonModeOverrideable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPolygonModeOverrideable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>override</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the PolygonMode set on this pass can be downgraded by the camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">override</td><td>If set to false, this pass will always be rendered at its own chosen polygon mode no matter what the camera says. The default is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb5a5d646e84a1d6c0be32f1132419f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5a5d646e84a1d6c0be32f1132419f8">&#9670;&nbsp;</a></span>getPolygonModeOverrideable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getPolygonModeOverrideable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether this renderable's chosen detail level can be overridden (downgraded) by the camera setting. </p>

</div>
</div>
<a id="a48a2a5f63407356c4e080cbea73b651b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a2a5f63407356c4e080cbea73b651b">&#9670;&nbsp;</a></span>setFog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setFog </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overrideScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga6467b107ce81cc71b8f2960409f7d897">FogMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group___general.html#gga6467b107ce81cc71b8f2960409f7d897ab7793a21880052c0214d4cc040992310">FOG_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>colour</em> = <code><a class="el" href="class_ogre_1_1_colour_value.html#a8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>expDensity</em> = <code>0.001f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>linearStart</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>linearEnd</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fogging mode applied to this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Fogging is an effect that is applied as polys are rendered. Sometimes, you want fog to be applied to an entire scene. Other times, you want it to be applied to a few polygons only. This pass-level specification of fog parameters lets you easily manage both. </dd></dl>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a> class also has a setFog method which applies scene-level fog. This method lets you change the fog behaviour for this pass compared to the standard scene-level fog. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overrideScene</td><td>If true, you authorise this pass to override the scene's fog params with it's own settings. If you specify false, so other parameters are necessary, and this is the default behaviour for passes. </td></tr>
    <tr><td class="paramname">mode</td><td>Only applicable if overrideScene is true. You can disable fog which is turned on for the rest of the scene by specifying FOG_NONE. Otherwise, set a pass-specific fog mode as defined in the enum FogMode. </td></tr>
    <tr><td class="paramname">colour</td><td>The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </td></tr>
    <tr><td class="paramname">expDensity</td><td>The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 0.001. </td></tr>
    <tr><td class="paramname">linearStart</td><td>Distance in world units at which linear fog starts to encroach. Only applicable if mode is FOG_LINEAR. </td></tr>
    <tr><td class="paramname">linearEnd</td><td>Distance in world units at which linear fog becomes completely opaque. Only applicable if mode is FOG_LINEAR. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a8e2ca7f03f60cf41377da7d79c5d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8e2ca7f03f60cf41377da7d79c5d19">&#9670;&nbsp;</a></span>getFogOverride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getFogOverride </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass is to override the scene fog settings. </p>

</div>
</div>
<a id="a1713843694cb5213646bfa517875515c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1713843694cb5213646bfa517875515c">&#9670;&nbsp;</a></span>getFogMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga6467b107ce81cc71b8f2960409f7d897">FogMode</a> Ogre::Pass::getFogMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fog mode for this pass. </p>
<dl class="section note"><dt>Note</dt><dd>Only valid if getFogOverride is true. </dd></dl>

</div>
</div>
<a id="acc2a614a0b99daa23be0f73d88c1336f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2a614a0b99daa23be0f73d88c1336f">&#9670;&nbsp;</a></span>getFogColour()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::Pass::getFogColour </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fog colour for the scene. </p>

</div>
</div>
<a id="af54b3be2df752a5afd31ef8c3c4da055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54b3be2df752a5afd31ef8c3c4da055">&#9670;&nbsp;</a></span>getFogStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Pass::getFogStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fog start distance for this pass. </p>
<dl class="section note"><dt>Note</dt><dd>Only valid if getFogOverride is true. </dd></dl>

</div>
</div>
<a id="a1b770b4107b99c5f63d00e16e59ea84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b770b4107b99c5f63d00e16e59ea84e">&#9670;&nbsp;</a></span>getFogEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Pass::getFogEnd </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fog end distance for this pass. </p>
<dl class="section note"><dt>Note</dt><dd>Only valid if getFogOverride is true. </dd></dl>

</div>
</div>
<a id="aa9bd26e7a9e62db9ab52c1b4af859f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9bd26e7a9e62db9ab52c1b4af859f72">&#9670;&nbsp;</a></span>getFogDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Pass::getFogDensity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fog density for this pass. </p>
<dl class="section note"><dt>Note</dt><dd>Only valid if getFogOverride is true. </dd></dl>

</div>
</div>
<a id="a9fe6fc3f542eade6b37d49cd0eadddde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe6fc3f542eade6b37d49cd0eadddde">&#9670;&nbsp;</a></span>setAlphaRejectSettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setAlphaRejectSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6">CompareFunction</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alphaToCoverageEnabled</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the way the pass will have use alpha to totally reject pixels from the pipeline. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The default is CMPF_ALWAYS_PASS i.e. alpha is not used to reject pixels. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The comparison which must pass for the pixel to be written. </td></tr>
    <tr><td class="paramname">value</td><td>1 byte value against which alpha values will be tested(0-255) </td></tr>
    <tr><td class="paramname">alphaToCoverageEnabled</td><td>Whether to use alpha to coverage with MSAA. This option applies in both the fixed function and the programmable pipeline. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f23af59e5f991f22a224f8e6b336af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f23af59e5f991f22a224f8e6b336af3">&#9670;&nbsp;</a></span>setAlphaRejectFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setAlphaRejectFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6">CompareFunction</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the alpha reject function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a9fe6fc3f542eade6b37d49cd0eadddde" title="Sets the way the pass will have use alpha to totally reject pixels from the pipeline.">setAlphaRejectSettings</a> for more information. </dd></dl>

</div>
</div>
<a id="a6e5c5f69be78ddd80cbb202f66649fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5c5f69be78ddd80cbb202f66649fef">&#9670;&nbsp;</a></span>setAlphaRejectValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setAlphaRejectValue </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the alpha reject value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a9fe6fc3f542eade6b37d49cd0eadddde" title="Sets the way the pass will have use alpha to totally reject pixels from the pipeline.">setAlphaRejectSettings</a> for more information. </dd></dl>

</div>
</div>
<a id="ae1b0920d6ba670d5e2e85bf2282bd2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b0920d6ba670d5e2e85bf2282bd2ef">&#9670;&nbsp;</a></span>getAlphaRejectFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6">CompareFunction</a> Ogre::Pass::getAlphaRejectFunction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the alpha reject function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a9fe6fc3f542eade6b37d49cd0eadddde" title="Sets the way the pass will have use alpha to totally reject pixels from the pipeline.">setAlphaRejectSettings</a> for more information. </dd></dl>

</div>
</div>
<a id="a8336a42895b9429c0bbae528fcaa5a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8336a42895b9429c0bbae528fcaa5a43">&#9670;&nbsp;</a></span>getAlphaRejectValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char Ogre::Pass::getAlphaRejectValue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the alpha reject value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a9fe6fc3f542eade6b37d49cd0eadddde" title="Sets the way the pass will have use alpha to totally reject pixels from the pipeline.">setAlphaRejectSettings</a> for more information. </dd></dl>

</div>
</div>
<a id="ae0a98973675e2cf71b286ceb9e73ecd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a98973675e2cf71b286ceb9e73ecd3">&#9670;&nbsp;</a></span>setAlphaToCoverageEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setAlphaToCoverageEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether to use alpha to coverage (A2C) when blending alpha rejected values. </p>
<p>Alpha to coverage performs multisampling on the edges of alpha-rejected textures to produce a smoother result. It is only supported when multisampling is already enabled on the render target, and when the hardware supports alpha to coverage (see <a class="el" href="class_ogre_1_1_render_system_capabilities.html" title="This class stores the capabilities of the graphics card.">RenderSystemCapabilities</a>). The common use for alpha to coverage is foliage rendering and chain-link fence style textures. </p>

</div>
</div>
<a id="ad7582011f85937446047a843896c8382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7582011f85937446047a843896c8382">&#9670;&nbsp;</a></span>isAlphaToCoverageEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::isAlphaToCoverageEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether to use alpha to coverage (A2C) when blending alpha rejected values. </p>

</div>
</div>
<a id="a2b99af55835117cfd4c479ab6c3a2ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b99af55835117cfd4c479ab6c3a2ae5">&#9670;&nbsp;</a></span>setTransparentSortingEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setTransparentSortingEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not transparent sorting is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>If false depth sorting of this material will be disabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>By default all transparent materials are sorted such that renderables furthest away from the camera are rendered first. This is usually the desired behaviour but in certain cases this depth sorting may be unnecessary and undesirable. If for example it is necessary to ensure the rendering order does not change from one frame to the next. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This will have no effect on non-transparent materials. </dd></dl>

</div>
</div>
<a id="a4a6ab6d3bce34b620675e9ccd2dfb89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6ab6d3bce34b620675e9ccd2dfb89f">&#9670;&nbsp;</a></span>getTransparentSortingEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getTransparentSortingEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not transparent sorting is enabled. </p>

</div>
</div>
<a id="adc75fe5011be72c0597535cb37d75d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc75fe5011be72c0597535cb37d75d57">&#9670;&nbsp;</a></span>setTransparentSortingForced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setTransparentSortingForced </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not transparent sorting is forced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>If true depth sorting of this material will be depend only on the value of <a class="el" href="class_ogre_1_1_pass.html#a4a6ab6d3bce34b620675e9ccd2dfb89f" title="Returns whether or not transparent sorting is enabled.">getTransparentSortingEnabled()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>By default even if transparent sorting is enabled, depth sorting will only be performed when the material is transparent and depth write/check are disabled. This function disables these extra conditions. </dd></dl>

</div>
</div>
<a id="a9729c4faa36b1a38ce0a8c14a3627dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9729c4faa36b1a38ce0a8c14a3627dbe">&#9670;&nbsp;</a></span>getTransparentSortingForced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getTransparentSortingForced </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not transparent sorting is forced. </p>

</div>
</div>
<a id="a95a7a4006f26528ef4f6ce42ae56b09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a7a4006f26528ef4f6ce42ae56b09b">&#9670;&nbsp;</a></span>setMaxSimultaneousLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setMaxSimultaneousLights </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>maxLights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum number of lights to be used by this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>During rendering, if lighting is enabled (or if the pass uses an automatic program parameter based on a light) the engine will request the nearest lights to the object being rendered in order to work out which ones to use. This parameter sets the limit on the number of lights which should apply to objects rendered with this pass. </dd></dl>

</div>
</div>
<a id="abd67db27426bb99e6e58e7299424c4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd67db27426bb99e6e58e7299424c4bc">&#9670;&nbsp;</a></span>getMaxSimultaneousLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Pass::getMaxSimultaneousLights </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of lights to be used by this pass. </p>

</div>
</div>
<a id="a8b816cdd2b5b5fcc5cbe6744b6bb2dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b816cdd2b5b5fcc5cbe6744b6bb2dbd">&#9670;&nbsp;</a></span>setStartLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setStartLight </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>startLight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the light index that this pass will start at in the light list. </p>
<p>Normally the lights passed to a pass will start from the beginning of the light list for this object. This option allows you to make this pass start from a higher light index, for example if one of your earlier passes could deal with lights 0-3, and this pass dealt with lights 4+. This option also has an interaction with pass iteration, in that if you choose to iterate this pass per light too, the iteration will only begin from light 4. </p>

</div>
</div>
<a id="a53fec71cb3076c1387cc6133f2996c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fec71cb3076c1387cc6133f2996c78">&#9670;&nbsp;</a></span>getStartLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Pass::getStartLight </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the light index that this pass will start at in the light list. </p>

</div>
</div>
<a id="a9f14ed26740158970994057e48e562e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f14ed26740158970994057e48e562e9">&#9670;&nbsp;</a></span>setLightMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setLightMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the light mask which can be matched to specific light flags to be handled by this pass. </p>

</div>
</div>
<a id="a8f7068c8fb5556c150126866373343ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7068c8fb5556c150126866373343ac">&#9670;&nbsp;</a></span>getLightMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> Ogre::Pass::getLightMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the light mask controlling which lights are used for this pass. </p>

</div>
</div>
<a id="aec98c9346a22a4a98acdaf5b8849a5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec98c9346a22a4a98acdaf5b8849a5c1">&#9670;&nbsp;</a></span>setIteratePerLight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setIteratePerLight </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyForOneLightType</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345">Light::LightTypes</a>&#160;</td>
          <td class="paramname"><em>lightType</em> = <code><a class="el" href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345a0d59bfdcfeb338dbfe06e2e2999e752f">Light::LT_POINT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not this pass should iterate per light or number of lights which can affect the object being rendered. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The default behaviour for a pass (when this option is 'false'), is for a pass to be rendered only once (or the number of times set in setPassIterationCount), with all the lights which could affect this object set at the same time (up to the maximum lights allowed in the render system, which is typically 8). </dd></dl>
<dl class="section user"><dt></dt><dd>Setting this option to 'true' changes this behaviour, such that instead of trying to issue render this pass once per object, it is run <b>per light</b>, or for a group of 'n' lights each time which can affect this object, the number of times set in setPassIterationCount (default is once). In this case, only light index 0 is ever used, and is a different light every time the pass is issued, up to the total number of lights which is affecting this object. This has 2 advantages: <ul>
<li>
There is no limit on the number of lights which can be supported </li>
<li>
It's easier to write vertex / fragment programs for this because a single program can be used for any number of lights </li>
</ul>
However, this technique is more expensive, and typically you will want an additional ambient pass, because if no lights are affecting the object it will not be rendered at all, which will look odd even if ambient light is zero (imagine if there are lit objects behind it - the objects silhouette would not show up). Therefore, use this option with care, and you would be well advised to provide a less expensive fallback technique for use in the distance. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of times this pass runs is still limited by the maximum number of lights allowed as set in setMaxSimultaneousLights, so you will never get more passes than this. Also, the iteration is started from the 'start light' as set in <a class="el" href="class_ogre_1_1_pass.html#a8b816cdd2b5b5fcc5cbe6744b6bb2dbd" title="Sets the light index that this pass will start at in the light list.">Pass::setStartLight</a>, and the number of passes is the number of lights to iterate over divided by the number of lights per iteration (default 1, set by setLightCountPerIteration). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Whether this feature is enabled </td></tr>
    <tr><td class="paramname">onlyForOneLightType</td><td>If true, the pass will only be run for a single type of light, other light types will be ignored. </td></tr>
    <tr><td class="paramname">lightType</td><td>The single light type which will be considered for this pass </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a606718035e449c4fdf91ae843adc4894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606718035e449c4fdf91ae843adc4894">&#9670;&nbsp;</a></span>getIteratePerLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getIteratePerLight </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this pass run once for every light in range? </p>

</div>
</div>
<a id="a0adea673c6a85f5fbc1c7403457c284f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adea673c6a85f5fbc1c7403457c284f">&#9670;&nbsp;</a></span>getRunOnlyForOneLightType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getRunOnlyForOneLightType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this pass run only for a single light type (if getIteratePerLight is true). </p>

</div>
</div>
<a id="a371e62569a03de84662a286c875e45cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371e62569a03de84662a286c875e45cb">&#9670;&nbsp;</a></span>getOnlyLightType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345">Light::LightTypes</a> Ogre::Pass::getOnlyLightType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the single light type this pass runs for if getIteratePerLight and getRunOnlyForOneLightType are both true. </p>

</div>
</div>
<a id="a0e40ca39a238f0afe5e2d3a0db0661ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e40ca39a238f0afe5e2d3a0db0661ce">&#9670;&nbsp;</a></span>setLightCountPerIteration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setLightCountPerIteration </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If light iteration is enabled, determine the number of lights per iteration. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The default for this setting is 1, so if you enable light iteration (<a class="el" href="class_ogre_1_1_pass.html#aec98c9346a22a4a98acdaf5b8849a5c1" title="Sets whether or not this pass should iterate per light or number of lights which can affect the objec...">Pass::setIteratePerLight</a>), the pass is rendered once per light. If you set this value higher, the passes will occur once per 'n' lights. The start of the iteration is set by <a class="el" href="class_ogre_1_1_pass.html#a8b816cdd2b5b5fcc5cbe6744b6bb2dbd" title="Sets the light index that this pass will start at in the light list.">Pass::setStartLight</a> and the end by <a class="el" href="class_ogre_1_1_pass.html#a95a7a4006f26528ef4f6ce42ae56b09b" title="Sets the maximum number of lights to be used by this pass.">Pass::setMaxSimultaneousLights</a>. </dd></dl>

</div>
</div>
<a id="a44cbf809b449b317d01500220b25d82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cbf809b449b317d01500220b25d82f">&#9670;&nbsp;</a></span>getLightCountPerIteration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Pass::getLightCountPerIteration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If light iteration is enabled, determine the number of lights per iteration. </p>

</div>
</div>
<a id="a224fe87a1d87d16212184331ef8a4906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224fe87a1d87d16212184331ef8a4906">&#9670;&nbsp;</a></span>getParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_technique.html">Technique</a>* Ogre::Pass::getParent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the parent <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>

</div>
</div>
<a id="a0bd99345b312bfb24c297b147b7665c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd99345b312bfb24c297b147b7665c5">&#9670;&nbsp;</a></span>getResourceGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Pass::getResourceGroup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the resource group of the ultimate parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Material</a>. </p>

</div>
</div>
<a id="a4a247aa90883ca1435fb949d191d6110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a247aa90883ca1435fb949d191d6110">&#9670;&nbsp;</a></span>isProgrammable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::isProgrammable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass is programmable i.e. includes either a vertex or fragment program. </p>

</div>
</div>
<a id="a61dd187f9201fcf102c26a02d8f85412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dd187f9201fcf102c26a02d8f85412">&#9670;&nbsp;</a></span>hasVertexProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasVertexProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a programmable vertex pipeline. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96ea3d96c54ace718f26c66067503efd56a3">Ogre::GPT_VERTEX_PROGRAM</a>.</p>

</div>
</div>
<a id="a85bffe16db4ccd90a26a257ded6e57c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bffe16db4ccd90a26a257ded6e57c4">&#9670;&nbsp;</a></span>hasFragmentProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasFragmentProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a programmable fragment pipeline. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96eac9a00b013e9075bc061b0585cf9a6c3b">Ogre::GPT_FRAGMENT_PROGRAM</a>.</p>

</div>
</div>
<a id="a763b8993d64d234349ffa11932b912e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763b8993d64d234349ffa11932b912e0">&#9670;&nbsp;</a></span>hasGeometryProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasGeometryProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a programmable geometry pipeline. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96ea78fc6b12cad0b4a28e86c802ee50bcdd">Ogre::GPT_GEOMETRY_PROGRAM</a>.</p>

</div>
</div>
<a id="af2643f7594c827d2f1b8785029de280f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2643f7594c827d2f1b8785029de280f">&#9670;&nbsp;</a></span>hasTessellationHullProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasTessellationHullProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a programmable tessellation control pipeline. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96eaea74d7930cd8f25545bd629b91f210dd">Ogre::GPT_HULL_PROGRAM</a>.</p>

</div>
</div>
<a id="a7a1d67d993a4b3fdd0eb3719704947bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1d67d993a4b3fdd0eb3719704947bb">&#9670;&nbsp;</a></span>hasTessellationDomainProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasTessellationDomainProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a programmable tessellation control pipeline. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96ea670018be566e85e99ad45105bfda8993">Ogre::GPT_DOMAIN_PROGRAM</a>.</p>

</div>
</div>
<a id="ad1d50f9c7cd1b11646ec88f463f0a27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d50f9c7cd1b11646ec88f463f0a27f">&#9670;&nbsp;</a></span>hasComputeProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasComputeProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a programmable compute pipeline. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96ea81238638cb2fdf78cc0860b6c4c16a4b">Ogre::GPT_COMPUTE_PROGRAM</a>.</p>

</div>
</div>
<a id="ac4d96a83679d194ce380ad55b014f69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d96a83679d194ce380ad55b014f69b">&#9670;&nbsp;</a></span>getGpuProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getGpuProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a>&#160;</td>
          <td class="paramname"><em>programType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Gpu program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass.">_load()</a> </p>

</div>
</div>
<a id="a9d00b9b7adf3c5b5f78aed3b100cc2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d00b9b7adf3c5b5f78aed3b100cc2ee">&#9670;&nbsp;</a></span>getVertexProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getVertexProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96ea3d96c54ace718f26c66067503efd56a3">Ogre::GPT_VERTEX_PROGRAM</a>.</p>

</div>
</div>
<a id="a49886b41c8e96ddfaea1d6b1c5264885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49886b41c8e96ddfaea1d6b1c5264885">&#9670;&nbsp;</a></span>getFragmentProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getFragmentProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96eac9a00b013e9075bc061b0585cf9a6c3b">Ogre::GPT_FRAGMENT_PROGRAM</a>.</p>

</div>
</div>
<a id="a72637ef35c39efd6ac000ada7e96bb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72637ef35c39efd6ac000ada7e96bb13">&#9670;&nbsp;</a></span>getGeometryProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getGeometryProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96ea78fc6b12cad0b4a28e86c802ee50bcdd">Ogre::GPT_GEOMETRY_PROGRAM</a>.</p>

</div>
</div>
<a id="ad218fad32224eca7ed978b92e8b81895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad218fad32224eca7ed978b92e8b81895">&#9670;&nbsp;</a></span>getTessellationHullProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getTessellationHullProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96eaea74d7930cd8f25545bd629b91f210dd">Ogre::GPT_HULL_PROGRAM</a>.</p>

</div>
</div>
<a id="ad5d4c302e116ef27dea2b0a56705ccc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d4c302e116ef27dea2b0a56705ccc4">&#9670;&nbsp;</a></span>getTessellationDomainProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getTessellationDomainProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96ea670018be566e85e99ad45105bfda8993">Ogre::GPT_DOMAIN_PROGRAM</a>.</p>

</div>
</div>
<a id="a97e4cdfc70411ee066cf68e1c7a817e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e4cdfc70411ee066cf68e1c7a817e4">&#9670;&nbsp;</a></span>getComputeProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getComputeProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96ea81238638cb2fdf78cc0860b6c4c16a4b">Ogre::GPT_COMPUTE_PROGRAM</a>.</p>

</div>
</div>
<a id="a50c2b23280ac2eca62b767ecebfa5888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c2b23280ac2eca62b767ecebfa5888">&#9670;&nbsp;</a></span>hasGpuProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasGpuProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a>&#160;</td>
          <td class="paramname"><em>programType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d4978eca2f3387a7abec740ec760ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4978eca2f3387a7abec740ec760ad7">&#9670;&nbsp;</a></span>setGpuProgram() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setGpuProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the details of the program to use. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes, this sets the details of the program to use in this pass. The program will not be loaded until the parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Material</a> is loaded. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The program. If this parameter is <code>NULL</code>, any program of the type in this pass is disabled. </td></tr>
    <tr><td class="paramname">type</td><td>The type of program </td></tr>
    <tr><td class="paramname">resetParams</td><td>If true, this will create a fresh set of parameters from the new program being linked, so if you had previously set parameters you will have to set them again. If you set this to false, you must be absolutely sure that the parameters match perfectly, and in the case of named parameters refers to the indexes underlying them, not just the names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abee48df0d246eb685780d16b32b7f8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee48df0d246eb685780d16b32b7f8f4">&#9670;&nbsp;</a></span>setGpuProgram() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setGpuProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a3019e308b0759cc150ac0f45308d69b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3019e308b0759cc150ac0f45308d69b3">&#9670;&nbsp;</a></span>setFragmentProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setFragmentProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af6b2aab96fb146a8e92043c7dc771de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b2aab96fb146a8e92043c7dc771de4">&#9670;&nbsp;</a></span>setGeometryProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setGeometryProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5adb72e47427f59f672e43b709c68038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adb72e47427f59f672e43b709c68038">&#9670;&nbsp;</a></span>setTessellationDomainProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setTessellationDomainProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6821e86c7c287fabcd28344117f772d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6821e86c7c287fabcd28344117f772d0">&#9670;&nbsp;</a></span>setTessellationHullProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setTessellationHullProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aba0003996c1c200db9fb6466a2253a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0003996c1c200db9fb6466a2253a54">&#9670;&nbsp;</a></span>setVertexProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setVertexProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a97deab966da4653d248875782b45a3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97deab966da4653d248875782b45a3f1">&#9670;&nbsp;</a></span>setComputeProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setComputeProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a91bdef99c065c528a54572c99628841e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bdef99c065c528a54572c99628841e">&#9670;&nbsp;</a></span>getGpuProgramName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Pass::getGpuProgramName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the program used by this pass. </p>

</div>
</div>
<a id="a289c78896d2777260cf5722b4cb8fd2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289c78896d2777260cf5722b4cb8fd2d">&#9670;&nbsp;</a></span>getFragmentProgramName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Pass::getFragmentProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96eac9a00b013e9075bc061b0585cf9a6c3b">Ogre::GPT_FRAGMENT_PROGRAM</a>.</p>

</div>
</div>
<a id="ac3fdaa6b028d32a0302746ceeb79a6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fdaa6b028d32a0302746ceeb79a6d3">&#9670;&nbsp;</a></span>getGeometryProgramName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Pass::getGeometryProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96ea78fc6b12cad0b4a28e86c802ee50bcdd">Ogre::GPT_GEOMETRY_PROGRAM</a>.</p>

</div>
</div>
<a id="a0da495acb6aaea4832685156dfbf8975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da495acb6aaea4832685156dfbf8975">&#9670;&nbsp;</a></span>getTessellationDomainProgramName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Pass::getTessellationDomainProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96ea670018be566e85e99ad45105bfda8993">Ogre::GPT_DOMAIN_PROGRAM</a>.</p>

</div>
</div>
<a id="afb0c89ec1367230c6e74eac585efd993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0c89ec1367230c6e74eac585efd993">&#9670;&nbsp;</a></span>getTessellationHullProgramName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Pass::getTessellationHullProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96eaea74d7930cd8f25545bd629b91f210dd">Ogre::GPT_HULL_PROGRAM</a>.</p>

</div>
</div>
<a id="a1789ae3425e0bc04aeb7a1e14583abf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1789ae3425e0bc04aeb7a1e14583abf9">&#9670;&nbsp;</a></span>getVertexProgramName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Pass::getVertexProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96ea3d96c54ace718f26c66067503efd56a3">Ogre::GPT_VERTEX_PROGRAM</a>.</p>

</div>
</div>
<a id="ab06bed97a00cdda2522fff1faadcae27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06bed97a00cdda2522fff1faadcae27">&#9670;&nbsp;</a></span>getComputeProgramName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Pass::getComputeProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="group___resources.html#ggafe603a6463467ab5f7e43721fe8ef96ea81238638cb2fdf78cc0860b6c4c16a4b">Ogre::GPT_COMPUTE_PROGRAM</a>.</p>

</div>
</div>
<a id="a5e78606a7cd3ea84536ab9f3198fa79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e78606a7cd3ea84536ab9f3198fa79f">&#9670;&nbsp;</a></span>setGpuProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setGpuProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Gpu program parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes, and this particular call is designed for low-level programs; use the named parameter methods for setting high-level program parameters. </dd></dl>

</div>
</div>
<a id="afc41cb1fe9251448002a2405405b8bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc41cb1fe9251448002a2405405b8bd9">&#9670;&nbsp;</a></span>setVertexProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setVertexProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ae8c6cd9d16220e8ef358f8b3e072d261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c6cd9d16220e8ef358f8b3e072d261">&#9670;&nbsp;</a></span>setFragmentProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setFragmentProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="afd45b897ebc29d3ee40a2ee307682f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd45b897ebc29d3ee40a2ee307682f35">&#9670;&nbsp;</a></span>setGeometryProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setGeometryProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a11e6148122bd80d646f75364bbc3cbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e6148122bd80d646f75364bbc3cbe0">&#9670;&nbsp;</a></span>setTessellationHullProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setTessellationHullProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ae4f6e70258ca9a870e3b0867792000e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f6e70258ca9a870e3b0867792000e6">&#9670;&nbsp;</a></span>setTessellationDomainProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setTessellationDomainProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad58bed2ac47d40e65750c61c0ca36af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58bed2ac47d40e65750c61c0ca36af3">&#9670;&nbsp;</a></span>setComputeProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setComputeProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2efc56272065eb16dc629380772d7d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efc56272065eb16dc629380772d7d7f">&#9670;&nbsp;</a></span>getGpuProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a>&amp; Ogre::Pass::getGpuProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Gpu program parameters used by this pass. </p>

</div>
</div>
<a id="ac0d16617c07bcfdc4f17e9ffed2f8591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d16617c07bcfdc4f17e9ffed2f8591">&#9670;&nbsp;</a></span>getVertexProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> Ogre::Pass::getVertexProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a889ed9697e2a990143cb41f953878dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889ed9697e2a990143cb41f953878dd3">&#9670;&nbsp;</a></span>getFragmentProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> Ogre::Pass::getFragmentProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a48643d1a8dc67e86a712ff32f8371c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48643d1a8dc67e86a712ff32f8371c5e">&#9670;&nbsp;</a></span>getGeometryProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> Ogre::Pass::getGeometryProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="abe6e32bc6812ed954daaa2c5518a2ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6e32bc6812ed954daaa2c5518a2ac3">&#9670;&nbsp;</a></span>getTessellationHullProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> Ogre::Pass::getTessellationHullProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a22415cb613dea6b39a7940ceebaca32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22415cb613dea6b39a7940ceebaca32f">&#9670;&nbsp;</a></span>getTessellationDomainProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> Ogre::Pass::getTessellationDomainProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a879780ade78dc1dce173c51ed5c6b3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879780ade78dc1dce173c51ed5c6b3f2">&#9670;&nbsp;</a></span>getComputeProgramParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aff0eec6634048fd4d65b785264243e6c">GpuProgramParametersSharedPtr</a> Ogre::Pass::getComputeProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4934405e476e98dd05912a1ff42b7b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4934405e476e98dd05912a1ff42b7b2c">&#9670;&nbsp;</a></span>_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_pass.html">Pass</a>* Ogre::Pass::_split </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>numUnits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> to one which can be handled in the number of texture units specified. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only works on non-programmable passes, programmable passes cannot be split, it's up to the author to ensure that there is a fallback <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> for less capable cards. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numUnits</td><td>The target number of texture units </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> which contains the remaining units, and a scene_blend setting appropriate to approximate the multitexture. This <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> will be attached to the parent <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> of this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </dd></dl>

</div>
</div>
<a id="afaa52a3826a08569b8263834f043a83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa52a3826a08569b8263834f043a83f">&#9670;&nbsp;</a></span>_notifyIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_notifyIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method to adjust pass index. </p>

</div>
</div>
<a id="ab85cf60f49c52c53671d5bb5105231e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85cf60f49c52c53671d5bb5105231e8">&#9670;&nbsp;</a></span>_prepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_prepare </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for preparing to load this pass. </p>

</div>
</div>
<a id="a928061c8f56d923808add7e8ba9cdee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928061c8f56d923808add7e8ba9cdee8">&#9670;&nbsp;</a></span>_unprepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_unprepare </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for undoing the load preparartion for this pass. </p>

</div>
</div>
<a id="ac1e07d3bccdb7f6c437c107c92e4ae46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e07d3bccdb7f6c437c107c92e4ae46">&#9670;&nbsp;</a></span>_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_load </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for loading this pass. </p>

</div>
</div>
<a id="a5766787845b1be6dfbf45cac068fc825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5766787845b1be6dfbf45cac068fc825">&#9670;&nbsp;</a></span>_unload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_unload </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for unloading this pass. </p>

</div>
</div>
<a id="a36390b119257048ddb35ab0439eed63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36390b119257048ddb35ab0439eed63d">&#9670;&nbsp;</a></span>isLoaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::isLoaded </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this loaded? </p>

</div>
</div>
<a id="a6096fdb876d7929f8d78d4fabae44a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6096fdb876d7929f8d78d4fabae44a25">&#9670;&nbsp;</a></span>getHash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8f2f90fa4c83c075e3fae75456ae5ded">uint32</a> Ogre::Pass::getHash </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 'hash' of this pass, ie a precomputed number to use for sorting. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This hash is used to sort passes, and for this reason the pass is hashed using firstly its index (so that all passes are rendered in order), then by the textures which it's <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> instances are using. </dd></dl>

</div>
</div>
<a id="a44c84896039e6a9f3a44da8468591fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c84896039e6a9f3a44da8468591fb3">&#9670;&nbsp;</a></span>_dirtyHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_dirtyHash </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the hash as dirty. </p>

</div>
</div>
<a id="a367a1affcb2e26d61a5b5e3594b0ce6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367a1affcb2e26d61a5b5e3594b0ce6a">&#9670;&nbsp;</a></span>_recalculateHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_recalculateHash </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for recalculating the hash. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Do not call this unless you are sure the old hash is not still being used by anything. If in doubt, call _dirtyHash if you want to force recalculation of the has next time. </dd></dl>

</div>
</div>
<a id="a6d9af04b4a643df1d81cc0443ca34ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9af04b4a643df1d81cc0443ca34ab2">&#9670;&nbsp;</a></span>_notifyNeedsRecompile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_notifyNeedsRecompile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the pass that it needs recompilation. </p>

</div>
</div>
<a id="ad17196c5383815e1af157fc9617c474b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17196c5383815e1af157fc9617c474b">&#9670;&nbsp;</a></span>_updateAutoParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_updateAutoParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_auto_param_data_source.html">AutoParamDataSource</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">uint16</a>&#160;</td>
          <td class="paramname"><em>variabilityMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update automatic parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source of the parameters </td></tr>
    <tr><td class="paramname">variabilityMask</td><td>A mask of GpuParamVariability which identifies which autos will need updating </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad00b9d37cf0d5d7af26d23a2a48f5541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00b9d37cf0d5d7af26d23a2a48f5541">&#9670;&nbsp;</a></span>setNormaliseNormals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setNormaliseNormals </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalise</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set to true, this forces normals to be normalised dynamically by the hardware for this pass. </p>
<p>This option can be used to prevent lighting variations when scaling an object - normally because this scaling is hardware based, the normals get scaled too which causes lighting to become inconsistent. By default the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">SceneManager</a> detects scaled objects and does this for you, but this has an overhead so you might want to turn that off through Ogre::SceneManager::setNormaliseNormalsOnScale(false) and only do it per-Pass when you need to.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000124">Deprecated:</a></b></dt><dd>Only used by fixed function APIs. Use shaders if you rely on this. </dd></dl>

</div>
</div>
<a id="a858b9c564570fd84e19c77a9b84da557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858b9c564570fd84e19c77a9b84da557">&#9670;&nbsp;</a></span>getNormaliseNormals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getNormaliseNormals </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass has auto-normalisation of normals set. </p>

</div>
</div>
<a id="a5e656ed906b7378c5c74d338575c3f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e656ed906b7378c5c74d338575c3f58">&#9670;&nbsp;</a></span>getDirtyHashList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_ogre_1_1_pass.html#aaedba8526ffd478f5d731507c4779caf">PassSet</a>&amp; Ogre::Pass::getDirtyHashList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method to retrieve all the Passes which need their hash values recalculated. </p>

</div>
</div>
<a id="a8ae403e739ce7fe033bc88ae943135e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae403e739ce7fe033bc88ae943135e4">&#9670;&nbsp;</a></span>getPassGraveyard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_ogre_1_1_pass.html#aaedba8526ffd478f5d731507c4779caf">PassSet</a>&amp; Ogre::Pass::getPassGraveyard </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method to retrieve all the Passes which are pending deletion. </p>

</div>
</div>
<a id="af1992ef39ef97e0b48e878c9aaa2badd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1992ef39ef97e0b48e878c9aaa2badd">&#9670;&nbsp;</a></span>clearDirtyHashList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Pass::clearDirtyHashList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method to reset the list of passes which need their hash values recalculated. </p>
<dl class="section remark"><dt>Remarks</dt><dd>For performance, the dirty list is not updated progressively as the hashes are recalculated, instead we expect the processor of the dirty hash list to clear the list when they are done. </dd></dl>

</div>
</div>
<a id="a989043a45609fd8f82235c3d1c402a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989043a45609fd8f82235c3d1c402a23">&#9670;&nbsp;</a></span>processPendingPassUpdates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Pass::processPendingPassUpdates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process all dirty and pending deletion passes. </p>

</div>
</div>
<a id="aeb16b94de537bda3140df7095090cc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb16b94de537bda3140df7095090cc10">&#9670;&nbsp;</a></span>queueForDeletion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::queueForDeletion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue this pass for deletion when appropriate. </p>

</div>
</div>
<a id="a8ff736f5d1d0eb3e3caa23b1d7c79997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff736f5d1d0eb3e3caa23b1d7c79997">&#9670;&nbsp;</a></span>isAmbientOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::isAmbientOnly </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this pass is ambient only. </p>

</div>
</div>
<a id="a28ff8c16ee57201651da61e649ea216b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ff8c16ee57201651da61e649ea216b">&#9670;&nbsp;</a></span>setPassIterationCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPassIterationCount </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the number of iterations that this pass should perform when doing fast multi pass operation. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable for programmable passes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of iterations to perform fast multi pass operations. A value greater than 1 will cause the pass to be executed count number of times without changing the render state. This is very useful for passes that use programmable shaders that have to iterate more than once but don't need a render state change. Using multi pass can dramatically speed up rendering for materials that do things like fur, blur. A value of 1 turns off multi pass operation and the pass does the normal pass operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad51f3602ae69b8d0f219582aa6b16d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51f3602ae69b8d0f219582aa6b16d48">&#9670;&nbsp;</a></span>getPassIterationCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Pass::getPassIterationCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pass iteration count value. </p>

</div>
</div>
<a id="a26fe99447102afb8e2002f7f1339dd8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26fe99447102afb8e2002f7f1339dd8c">&#9670;&nbsp;</a></span>setLightScissoringEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setLightScissoringEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not this pass will be clipped by a scissor rectangle encompassing the lights that are being used in it. </p>
<p>In order to cut down on fillrate when you have a number of fixed-range lights in the scene, you can enable this option to request that during rendering, only the region of the screen which is covered by the lights is rendered. This region is the screen-space rectangle covering the union of the spheres making up the light ranges. Directional lights are ignored for this.</p>
<p>This is only likely to be useful for multipass additive lighting algorithms, where the scene has already been 'seeded' with an ambient pass and this pass is just adding light in affected areas.</p>
<p>When using <a class="el" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af6e22c7a699e9d05015cecff7b68c52a" title="Stencil shadow technique which renders each light as a separate additive pass to the scene.">Ogre::SHADOWTYPE_STENCIL_ADDITIVE</a> or <a class="el" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103" title="Texture-based shadow technique which involves a render-to-texture of the shadow caster and a projecti...">Ogre::SHADOWTYPE_TEXTURE_ADDITIVE</a>, this option is implicitly used for all per-light passes and does not need to be specified. If you are not using shadows or are using a modulative or <a class="el" href="_shadows.html#Integrated-Texture-Shadows">Integrated Texture Shadows</a> then this could be useful. </p>

</div>
</div>
<a id="a27766dcc987d75b836519d8be88fc6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27766dcc987d75b836519d8be88fc6f6">&#9670;&nbsp;</a></span>getLightScissoringEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getLightScissoringEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether or not this pass will be clipped by a scissor rectangle encompassing the lights that are being used in it. </p>

</div>
</div>
<a id="a20d94474787abfd9eb9b07d5185ded0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d94474787abfd9eb9b07d5185ded0c">&#9670;&nbsp;</a></span>setLightClipPlanesEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setLightClipPlanesEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not this pass will be clipped by user clips planes bounding the area covered by the light. </p>
<p>This option will only function if there is a single non-directional light being used in this pass. If there is more than one light, or only directional lights, then no clipping will occur. If there are no lights at all then the objects wont be rendered at all.</p>
<p>In order to cut down on the geometry set up to render this pass when you have a single fixed-range light being rendered through it, you can enable this option to request that during triangle setup, clip planes are defined to bound the range of the light. In the case of a point light these planes form a cube, and in the case of a spotlight they form a pyramid. Directional lights are never clipped.</p>
<p>This option is only likely to be useful for multipass additive lighting algorithms, where the scene has already been 'seeded' with an ambient pass and this pass is just adding light in affected areas. In addition, it will only be honoured if there is exactly one non-directional light being used in this pass. Also, these clip planes override any user clip planes set on <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a>.</p>
<p>When using <a class="el" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af6e22c7a699e9d05015cecff7b68c52a" title="Stencil shadow technique which renders each light as a separate additive pass to the scene.">Ogre::SHADOWTYPE_STENCIL_ADDITIVE</a> or <a class="el" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103" title="Texture-based shadow technique which involves a render-to-texture of the shadow caster and a projecti...">Ogre::SHADOWTYPE_TEXTURE_ADDITIVE</a>, this option is automatically used for all per-light passes if you enable <a class="el" href="class_ogre_1_1_scene_manager.html#a40f296de8599657b70b7072921cbaa16" title="Sets whether when using a built-in additive shadow mode, user clip planes should be used to restrict ...">Ogre::SceneManager::setShadowUseLightClipPlanes</a> and does not need to be specified. It is disabled by default since clip planes have a cost of their own which may not always exceed the benefits they give you. Generally the smaller your lights are the more chance youll see a benefit rather than a penalty from clipping.</p>
<dl class="section note"><dt>Note</dt><dd>Only has an effect with the fixed-function pipeline. Exceptions:<ul>
<li>with D3D9, clip planes are even available when shaders are used</li>
<li>with GL1, shaders must write to gl_ClipVertex </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0c32f4167d3ac2bfedb5ff536ab87594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c32f4167d3ac2bfedb5ff536ab87594">&#9670;&nbsp;</a></span>getLightClipPlanesEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getLightClipPlanesEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether or not this pass will be clipped by user clips planes bounding the area covered by the light. </p>

</div>
</div>
<a id="a30d680bb28cd69415883313d9f03dc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d680bb28cd69415883313d9f03dc6a">&#9670;&nbsp;</a></span>setIlluminationStage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setIlluminationStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___materials.html#gaa6fda2d6bac5df9dc239f566ceed77b6">IlluminationStage</a>&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually set which illumination stage this pass is a member of. </p>
<p>When using an additive lighting mode (<a class="el" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af6e22c7a699e9d05015cecff7b68c52a" title="Stencil shadow technique which renders each light as a separate additive pass to the scene.">Ogre::SHADOWTYPE_STENCIL_ADDITIVE</a> or <a class="el" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103" title="Texture-based shadow technique which involves a render-to-texture of the shadow caster and a projecti...">Ogre::SHADOWTYPE_TEXTURE_ADDITIVE</a>), the scene is rendered in 3 discrete stages, ambient (or pre-lighting), per-light (once per light, with shadowing) and decal (or post-lighting). Usually OGRE figures out how to categorise your passes automatically, but there are some effects you cannot achieve without manually controlling the illumination. For example specular effects are muted by the typical sequence because all textures are saved until the <a class="el" href="group___materials.html#ggaa6fda2d6bac5df9dc239f566ceed77b6a55b9a19dea33fdf42c614c99c136a52e" title="Post-lighting rendering.">Ogre::IS_DECAL</a> stage which mutes the specular effect. Instead, you could do texturing within the per-light stage if it's possible for your material and thus add the specular on after the decal texturing, and have no post-light rendering.</p>
<p>If you assign an illumination stage to a pass you have to assign it to all passes in the technique otherwise it will be ignored. Also note that whilst you can have more than one pass in each group, they cannot alternate, ie all ambient passes will be before all per-light passes, which will also be before all decal passes. Within their categories the passes will retain their ordering though. </p>

</div>
</div>
<a id="a77551778f0d1989cdf7541cd0a71faf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77551778f0d1989cdf7541cd0a71faf8">&#9670;&nbsp;</a></span>getIlluminationStage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___materials.html#gaa6fda2d6bac5df9dc239f566ceed77b6">IlluminationStage</a> Ogre::Pass::getIlluminationStage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the manually assigned illumination stage, if any. </p>

</div>
</div>
<a id="a686d4ade1581fba7b32609bc535ad9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686d4ade1581fba7b32609bc535ad9fc">&#9670;&nbsp;</a></span>setHashFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Pass::setHashFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_pass.html#a1d30a3c04994e1bd0e1de8cb343341a4">BuiltinHashFunction</a>&#160;</td>
          <td class="paramname"><em>builtin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets one of the default hash functions to be used. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You absolutely must not change the hash function whilst any <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instances exist in the render queue. The only time you can do this is either before you render anything, or directly after you manuall call RenderQueue::clear(true) to completely destroy the queue structures. The default is MIN_GPU_PROGRAM_CHANGE. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>You can also implement your own hash function, see the alternate version of this method. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_ogre_1_1_pass_1_1_hash_func.html" title="Definition of a functor for calculating the hashcode of a Pass.">HashFunc</a> </dd></dl>

</div>
</div>
<a id="aff774d55b700af010f57e2330101a610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff774d55b700af010f57e2330101a610">&#9670;&nbsp;</a></span>setHashFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Pass::setHashFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_pass_1_1_hash_func.html">HashFunc</a> *&#160;</td>
          <td class="paramname"><em>hashFunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the hash function used for all passes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You absolutely must not change the hash function whilst any <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instances exist in the render queue. The only time you can do this is either before you render anything, or directly after you manuall call RenderQueue::clear(true) to completely destroy the queue structures. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>You can also use one of the built-in hash functions, see the alternate version of this method. The default is MIN_GPU_PROGRAM_CHANGE. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_ogre_1_1_pass_1_1_hash_func.html" title="Definition of a functor for calculating the hashcode of a Pass.">HashFunc</a> </dd></dl>

</div>
</div>
<a id="aedf90d0436441d359280b3c939ee1e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf90d0436441d359280b3c939ee1e3c">&#9670;&nbsp;</a></span>getHashFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ogre_1_1_pass_1_1_hash_func.html">HashFunc</a>* Ogre::Pass::getHashFunction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the hash function used for all passes. </p>

</div>
</div>
<a id="ac2e11c662982c9ce7f2e08a71bc20167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e11c662982c9ce7f2e08a71bc20167">&#9670;&nbsp;</a></span>getBuiltinHashFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ogre_1_1_pass_1_1_hash_func.html">HashFunc</a>* Ogre::Pass::getBuiltinHashFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_pass.html#a1d30a3c04994e1bd0e1de8cb343341a4">BuiltinHashFunction</a>&#160;</td>
          <td class="paramname"><em>builtin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the builtin hash function. </p>

</div>
</div>
<a id="adc70de42e8b22b4d8ccedf6868bbbfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc70de42e8b22b4d8ccedf6868bbbfc0">&#9670;&nbsp;</a></span>getUserObjectBindings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::Pass::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class that provides convenient interface to establish a linkage between custom user application objects and Ogre core classes. </p>

</div>
</div>
<a id="a1a272de4bac1f7ab74ad965217f163ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a272de4bac1f7ab74ad965217f163ec">&#9670;&nbsp;</a></span>getUserObjectBindings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::Pass::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_pass_8h.html">OgrePass.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_pass.html">Pass</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
