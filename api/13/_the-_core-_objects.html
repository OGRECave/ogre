<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: The Core Objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">13.6</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_the-_core-_objects.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The Core Objects </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md29">Overview from 10,000 feet</a></li>
<li class="level1"><a href="#The-Root-Object">The Root object</a></li>
<li class="level1"><a href="#The-RenderSystem-object">The RenderSystem object</a></li>
<li class="level1"><a href="#The-SceneManager-object">The SceneManager object</a></li>
<li class="level1"><a href="#The-ResourceGroupManager-Object">The ResourceGroupManager Object</a></li>
<li class="level1"><a href="#The-Mesh-Object">The Mesh Object</a></li>
<li class="level1"><a href="#Entities">Entities</a></li>
<li class="level1"><a href="#Materials">Materials</a></li>
<li class="level1"><a href="#Overlays">Overlays</a><ul><li class="level2"><a href="#autotoc_md30">Notes on Integration</a></li>
<li class="level2"><a href="#autotoc_md31">Creating 2D Elements</a></li>
<li class="level2"><a href="#autotoc_md32">Adding 2D Elements to the Overlay</a></li>
<li class="level2"><a href="#autotoc_md33">A word about 2D coordinates</a></li>
<li class="level2"><a href="#autotoc_md34">Transforming Overlays</a></li>
<li class="level2"><a href="#autotoc_md35">GUI systems</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This tutorial gives you a quick summary of the core objects that you will use in OGRE and what they are used for.</p>
<p><a class="anchor" id="Overview-from-10_002c000-feet"></a></p>
<h1><a class="anchor" id="autotoc_md29"></a>
Overview from 10,000 feet</h1>
<p>Shown below is a diagram of some of the core objects and where they ’sit’ in the grand scheme of things. This is not all the classes by a long shot, just a few examples of the more more significant ones to give you an idea of how it slots together.</p>
<p>At the very top of the diagram is the Root object. This is your ’way in’ to the OGRE system, and it’s where you tend to create the top-level objects that you need to deal with, like scene managers, rendering systems and render windows, loading plugins, all the fundamental stuff. If you don’t know where to start, Root is it for almost everything, although often it will just give you another object which will actually do the detail work, since Root itself is more of an organiser and facilitator object.</p>
<p>The majority of rest of OGRE’s classes fall into one of 3 roles:</p>
<dl class="section user"><dt>Scene Management</dt><dd>This is about the contents of your scene, how it’s structured, how it’s viewed from cameras, etc. Objects in this area are responsible for giving you a natural declarative interface to the world you’re building; i.e. you don’t tell OGRE "set these render states and then render 3 polygons", you tell it "I want an object here, here and here, with these materials on them, rendered from this view", and let it get on with it.</dd></dl>
<dl class="section user"><dt>Resource Management</dt><dd>All rendering needs resources, whether it’s geometry, textures, fonts, whatever. It’s important to manage the loading, re-use and unloading of these things carefully, so that’s what classes in this area do.</dd></dl>
<dl class="section user"><dt>Rendering</dt><dd>Finally, there’s getting the visuals on the screen - this is about the lower-level end of the rendering pipeline, the specific rendering system API objects like buffers, render states and the like and pushing it all down the pipeline. Classes in the Scene Management subsystem use this to get their higher-level scene information onto the screen.</dd></dl>
<p><img src="uml-overview.svg" alt="" style="pointer-events: none;" class="inline"/></p>
<p>You’ll notice that scattered around the edge are a number of plugins. OGRE is designed to be extended, and plugins are the usual way to go about it. Many of the classes in OGRE can be subclassed and extended, whether it’s changing the scene organisation through a custom SceneManager, adding a new render system implementation (e.g. Direct3D or OpenGL), or providing a way to load resources from another source (say from a web location or a database). Again this is just a small smattering of the kinds of things plugins can do, but as you can see they can plug in to almost any aspect of the system. This way, OGRE isn’t just a solution for one narrowly defined problem, it can extend to pretty much anything you need it to do.</p>
<h1><a class="anchor" id="The-Root-Object"></a>
The Root object</h1>
<p>The <a class="el" href="class_ogre_1_1_root.html" title="The root class of the Ogre system.">Ogre::Root</a> object is the entry point to the OGRE system. This object MUST be the first one to be created, and the last one to be destroyed. In the example applications I chose to make an instance of Root a member of my application object which ensured that it was created as soon as my application object was, and deleted when the application object was deleted.</p>
<p>The root object lets you configure the system, for example through the <a class="el" href="class_ogre_1_1_root.html#aedc76ef3bdc6514bd4655be0d70d6bcd" title="Displays a dialog asking the user to choose system settings.">Ogre::Root::showConfigDialog</a> method which is an extremely handy method which performs all render system options detection and shows a dialog for the user to customise resolution, colour depth, full screen options etc. It also sets the options the user selects so that you can initialise the system directly afterwards.</p>
<p>The root object is also your method for obtaining pointers to other objects in the system, such as the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">Ogre::RenderSystem</a> and various other resource managers. See below for details.</p>
<p>Finally, if you run OGRE in continuous rendering mode, i.e. you want to always refresh all the rendering targets as fast as possible (the norm for games and demos, but not for windowed utilities), the root object has a method called <a class="el" href="class_ogre_1_1_root.html#a8eda253befda1255cbfd3b298f62449e" title="Starts / restarts the automatic rendering cycle.">Ogre::Root::startRendering</a>, which when called will enter a continuous rendering loop which will only end when all rendering windows are closed, or any <a class="el" href="class_ogre_1_1_frame_listener.html" title="A interface class defining a listener which can be used to receive notifications of frame events.">Ogre::FrameListener</a> objects indicate that they want to stop the cycle (see below for details of <a class="el" href="class_ogre_1_1_frame_listener.html" title="A interface class defining a listener which can be used to receive notifications of frame events.">Ogre::FrameListener</a> objects).</p>
<h1><a class="anchor" id="The-RenderSystem-object"></a>
The RenderSystem object</h1>
<p>The <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">Ogre::RenderSystem</a> object is actually an abstract class which defines the interface to the underlying 3D API. It is responsible for sending rendering operations to the API and setting all the various rendering options. This class is abstract because all the implementation is rendering API specific - there are API-specific subclasses for each rendering API (e.g. D3DRenderSystem for Direct3D). After the system has been initialised through <a class="el" href="class_ogre_1_1_root.html#a6ab8f204bbfb150ad180eb6e78e4639c" title="Initialises the renderer.">Ogre::Root::initialise</a>, the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">Ogre::RenderSystem</a> object for the selected rendering API is available via the <a class="el" href="class_ogre_1_1_root.html#ab8ca3d5abebba7a14650db5f618286d0" title="Retrieve a pointer to the currently selected render system.">Ogre::Root::getRenderSystem()</a> method.</p>
<p>However, a typical application should not normally need to manipulate the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">Ogre::RenderSystem</a> object directly - everything you need for rendering objects and customising settings should be available on the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a>, Material and other scene-oriented classes. It’s only if you want to create multiple rendering windows (completely separate windows in this case, not multiple viewports like a split-screen effect which is done via the RenderWindow class) or access other advanced features that you need access to the RenderSystem object.</p>
<p>For this reason I will not discuss the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">Ogre::RenderSystem</a> object further in these tutorials. You can assume the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a> handles the calls to the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">Ogre::RenderSystem</a> at the appropriate times.</p>
<h1><a class="anchor" id="The-SceneManager-object"></a>
The SceneManager object</h1>
<p>Apart from the <a class="el" href="class_ogre_1_1_root.html" title="The root class of the Ogre system.">Ogre::Root</a> object, this is probably the most critical part of the system from the application’s point of view. Certainly it will be the object which is most used by the application. The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a> is in charge of the contents of the scene which is to be rendered by the engine. It is responsible for organising the contents using whatever technique it deems best, for creating and managing all the cameras, movable objects (entities), lights and materials (surface properties of objects), and for managing the ’world geometry’ which is the sprawling static geometry usually used to represent the immovable parts of a scene.</p>
<p>It is to the SceneManager that you go when you want to create a camera for the scene. It’s also where you go to retrieve or to remove a light from the scene. There is no need for your application to keep lists of objects, the SceneManager keeps a named set of all of the scene objects for you to access, should you need them. Look in the main documentation under the getCamera, getLight, getEntity etc methods.</p>
<p>The SceneManager also sends the scene to the RenderSystem object when it is time to render the scene. You never have to call the <a class="el" href="class_ogre_1_1_scene_manager.html#a70f86c8feca6c2b5cf140df244cf8ac5" title="Prompts the class to send its contents to the renderer.">Ogre::SceneManager::_renderScene</a> method directly though - it is called automatically whenever a rendering target is asked to update (see <a class="el" href="class_ogre_1_1_root.html#aeaad25268c0ad8007ce8961a32242c77" title="Updates all the render targets automatically.">Ogre::Root::renderOneFrame</a> for details).</p>
<p>So most of your interaction with the SceneManager is during scene setup. You’re likely to call a great number of methods (perhaps driven by some input file containing the scene data) in order to set up your scene. You can also modify the contents of the scene dynamically during the rendering cycle if you create your own FrameListener object (see later).</p>
<p>Because different scene types require very different algorithmic approaches to deciding which objects get sent to the RenderSystem in order to attain good rendering performance, the SceneManager class is designed to be subclassed for different scene types. The default SceneManager object will render a scene, but it does little or no scene organisation and you should not expect the results to be high performance in the case of large scenes. The intention is that specialisations will be created for each type of scene such that under the surface the subclass will optimise the scene organisation for best performance given assumptions which can be made for that scene type. An example is the <code>OctreeSceneManager</code> which optimises rendering for large levels based on the Octree partitioning scheme.</p>
<p>You can specify the SceneManager type you want as the parameter of <a class="el" href="class_ogre_1_1_root.html#a8bb8655f823a98007775f69278c1b0f9" title="create a default scene manager">Ogre::Root::createSceneManager</a>. If you do not specify any parameter, OGRE will use to the default SceneManager, which is well suited for small and moderate sized scenes.</p>
<h1><a class="anchor" id="The-ResourceGroupManager-Object"></a>
The ResourceGroupManager Object</h1>
<p>The <a class="el" href="class_ogre_1_1_resource_group_manager.html" title="This singleton class manages the list of resource groups, and notifying the various resource managers...">Ogre::ResourceGroupManager</a> class is actually a ’hub’ for loading of reusable resources like textures and meshes. It is the place that you define groups for your resources, so they may be unloaded and reloaded when you want. Servicing it are a number of ResourceManagers which manage the individual types of resource, like <a class="el" href="class_ogre_1_1_texture_manager.html" title="Class for loading &amp; managing textures.">Ogre::TextureManager</a> or <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources.">Ogre::MeshManager</a>. In this context, resources are sets of data which must be loaded from somewhere to provide OGRE with the data it needs.</p>
<p>ResourceManagers ensure that resources are only loaded once and shared throughout the OGRE engine. They also manage the memory requirements of the resources they look after. They can also search in a number of locations for the resources they need, including multiple search paths and compressed archives (ZIP files).</p>
<p>Most of the time you won’t interact with resource managers directly. Resource managers will be called by other parts of the OGRE system as required, for example when you request for a texture to be added to a Material, the <a class="el" href="class_ogre_1_1_texture_manager.html" title="Class for loading &amp; managing textures.">Ogre::TextureManager</a> will be called for you. If you like, you can call the appropriate resource manager directly to preload resources (if for example you want to prevent disk access later on) but most of the time it’s ok to let OGRE decide when to do it.</p>
<p>One thing you will want to do is to tell the resource managers where to look for resources. You do this via <a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Adds a location to the list of searchable locations for a Resource type.">Ogre::ResourceGroupManager::addResourceLocation</a>.</p>
<p>As its name already tells, the ResourceGroupManager keeps resources organized in Groups. These define a set of Resources that shall be loaded / unloaded as a unit. For example, it might be all the resources used for the level of a game. By default the "General" group is used, which will only be unloaded on shutdown. To define your own groups use <a class="el" href="class_ogre_1_1_resource_group_manager.html#a9c1ba0f11d134d0b5614391ca836844c" title="Create a resource group.">Ogre::ResourceGroupManager::createResourceGroup</a>.</p>
<p>Because there is only ever 1 instance of each resource manager in the engine, if you do want to get a reference to a resource manager use the following syntax:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_texture_manager.html#ac6fb858ee86f3b7b75de32e3e04ee5c8">Ogre::TextureManager::getSingleton</a>().someMethod()</div>
<div class="line"><a class="code" href="class_ogre_1_1_mesh_manager.html#a2efefa307b7987c5fcff7e8c47f79758">Ogre::MeshManager::getSingleton</a>().someMethod()</div>
<div class="ttc" id="aclass_ogre_1_1_mesh_manager_html_a2efefa307b7987c5fcff7e8c47f79758"><div class="ttname"><a href="class_ogre_1_1_mesh_manager.html#a2efefa307b7987c5fcff7e8c47f79758">Ogre::MeshManager::getSingleton</a></div><div class="ttdeci">static MeshManager &amp; getSingleton(void)</div><div class="ttdoc">Get the singleton instance.</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_manager_html_ac6fb858ee86f3b7b75de32e3e04ee5c8"><div class="ttname"><a href="class_ogre_1_1_texture_manager.html#ac6fb858ee86f3b7b75de32e3e04ee5c8">Ogre::TextureManager::getSingleton</a></div><div class="ttdeci">static TextureManager &amp; getSingleton(void)</div><div class="ttdoc">Get the singleton instance.</div></div>
</div><!-- fragment --> <h1><a class="anchor" id="The-Mesh-Object"></a>
The Mesh Object</h1>
<p>A <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Ogre::Mesh</a> object represents a discrete model, a set of geometry which is self-contained and is typically fairly small on a world scale. <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Ogre::Mesh</a> objects are assumed to represent movable objects and are not used for the sprawling level geometry typically used to create backgrounds.</p>
<p><a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Ogre::Mesh</a> objects are a type of resource, and are managed by the MeshManager resource manager. They are typically loaded from OGRE’s custom object format, the ’.mesh’ format. Mesh files are typically created by exporting from a modelling tool See <a class="el" href="_mesh-_tools.html#Exporters">Exporters</a> and can be manipulated through various <a class="el" href="_mesh-_tools.html">Mesh Tools</a></p>
<p>You can also create Mesh objects manually by calling the <a class="el" href="class_ogre_1_1_mesh_manager.html#ad99f5f2e2d045e5a4af301974e45c918" title="Creates a new Mesh specifically for manual definition rather than loading from an object file.">Ogre::MeshManager::createManual</a> method. This way you can define the geometry yourself, but this is outside the scope of this manual.</p>
<p>Mesh objects are the basis for the individual movable objects in the world, which are called <a class="el" href="_the-_core-_objects.html#Entities">Entities</a>.</p>
<p>Mesh objects can also be animated using See <a class="el" href="_animation.html#Skeletal-Animation">Skeletal Animation</a>.</p>
<h1><a class="anchor" id="Entities"></a>
Entities</h1>
<p>An entity is an instance of a movable object in the scene. It could be a car, a person, a dog, a shuriken, whatever. The only assumption is that it does not necessarily have a fixed position in the world.</p>
<p>Entities are based on discrete meshes, i.e. collections of geometry which are self-contained and typically fairly small on a world scale, which are represented by the <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Ogre::Mesh</a> object. Multiple entities can be based on the same mesh, since often you want to create multiple copies of the same type of object in a scene.</p>
<p>You create an entity by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185" title="Create an Entity (instance of a discrete mesh).">Ogre::SceneManager::createEntity</a> method, giving it a name and specifying the name of the mesh object which it will be based on (e.g. ’muscleboundhero.mesh’). The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a> will ensure that the mesh is loaded by calling the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources.">Ogre::MeshManager</a> resource manager for you. Only one copy of the Mesh will be loaded.</p>
<p>Ogre::Entities are not deemed to be a part of the scene until you attach them to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph.">Ogre::SceneNode</a> (see the section below). By attaching entities to SceneNodes, you can create complex hierarchical relationships between the positions and orientations of entities. You then modify the positions of the nodes to indirectly affect the entity positions.</p>
<p>When a <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Ogre::Mesh</a> is loaded, it automatically comes with a number of materials defined. It is possible to have more than one material attached to a mesh - different parts of the mesh may use different materials. Any entity created from the mesh will automatically use the default materials. However, you can change this on a per-entity basis if you like so you can create a number of entities based on the same mesh but with different textures etc.</p>
<p>To understand how this works, you have to know that all Mesh objects are actually composed of <a class="el" href="class_ogre_1_1_sub_mesh.html" title="Defines a part of a complete mesh.">Ogre::SubMesh</a> objects, each of which represents a part of the mesh using one Material. If a <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Ogre::Mesh</a> uses only one <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Ogre::Material</a>, it will only have one <a class="el" href="class_ogre_1_1_sub_mesh.html" title="Defines a part of a complete mesh.">Ogre::SubMesh</a>.</p>
<p>When an <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Ogre::Entity</a> is created based on this Mesh, it is composed of (possibly) multiple <a class="el" href="class_ogre_1_1_sub_entity.html" title="Utility class which defines the sub-parts of an Entity.">Ogre::SubEntity</a> objects, each matching 1 for 1 with the <a class="el" href="class_ogre_1_1_sub_mesh.html" title="Defines a part of a complete mesh.">Ogre::SubMesh</a> objects from the original Mesh. You can access the <a class="el" href="class_ogre_1_1_sub_entity.html" title="Utility class which defines the sub-parts of an Entity.">Ogre::SubEntity</a> objects using the <a class="el" href="class_ogre_1_1_entity.html#a23fc34c5e2eff03aae4cbf800c142724" title="Gets a pointer to a SubEntity, ie a part of an Entity.">Ogre::Entity::getSubEntity</a> method. Once you have a reference to a <a class="el" href="class_ogre_1_1_sub_entity.html" title="Utility class which defines the sub-parts of an Entity.">Ogre::SubEntity</a>, you can change the material it uses by calling it’s setMaterialName method. In this way you can make an <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Ogre::Entity</a> deviate from the default materials and thus create an individual looking version of it.</p>
<h1><a class="anchor" id="Materials"></a>
Materials</h1>
<p>The <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Ogre::Material</a> object controls how objects in the scene are rendered. It specifies what basic surface properties objects have such as reflectance of colours, shininess etc, how many texture layers are present, what images are on them and how they are blended together, what special effects are applied such as environment mapping, what culling mode is used, how the textures are filtered etc.</p>
<p>Materials can either be set up programmatically, by calling <a class="el" href="class_ogre_1_1_material_manager.html#a3068599a5b10421e6203d568006f5f93" title="Create a new material.">Ogre::MaterialManager::create</a> and tweaking the settings, or by specifying it in a ’script’ which is loaded at runtime. See <a class="el" href="_material-_scripts.html">Material Scripts</a> for more info.</p>
<p>Basically everything about the appearance of an object apart from it’s shape is controlled by the Material class.</p>
<p>The <a class="el" href="class_ogre_1_1_material_manager.html" title="Class for managing Material settings for Ogre.">Ogre::MaterialManager</a> class manages the master list of materials available to the scene. The list can be added to by the application by calling <a class="el" href="class_ogre_1_1_material_manager.html#a3068599a5b10421e6203d568006f5f93" title="Create a new material.">Ogre::MaterialManager::create</a>, or by loading a Mesh (which will in turn load material properties).</p>
<p>The default settings begin as a single Technique with a single, non-programmable Pass:</p>
<ul>
<li>ambient = ColourValue::White</li>
<li>diffuse = ColourValue::White</li>
<li>specular = ColourValue::Black</li>
<li>emissive = ColourValue::Black</li>
<li>shininess = 0 (not shiny)</li>
<li>No texture unit settings (&amp; hence no textures)</li>
<li>SourceBlendFactor = <a class="el" href="group___materials.html#gga41c76d419d6c9c205a6c1d3b42872213ad2741858a9d9f668a47ea75b82ae0318" title="Constant value of 1.0.">Ogre::SBF_ONE</a></li>
<li>DestBlendFactor = <a class="el" href="group___materials.html#gga41c76d419d6c9c205a6c1d3b42872213a04732209b3c7a16b5f0a2c829e6f6c34" title="Constant value of 0.0.">Ogre::SBF_ZERO</a> (no blend, replace with new colour)</li>
<li>Depth buffer checking on</li>
<li>Depth buffer writing on</li>
<li>Depth buffer comparison function = <a class="el" href="group___general.html#gga8e1c2888df9ea68a8fa31b64b6aa67d6a2272d0faefcf5a2e08bbf7d232d7520b" title="Write if (new_Z &lt;= existing_Z)">Ogre::CMPF_LESS_EQUAL</a></li>
<li>Colour buffer writing on for all channels</li>
<li>Culling mode = <a class="el" href="group___general.html#gga4766f4c65e0a47f0a71c5908944a7a3ca50170ef4a0a12b9fc6bf0c53e582bdf0" title="Hardware culls triangles whose vertices are listed clockwise in the view (default).">Ogre::CULL_CLOCKWISE</a></li>
<li>Ambient lighting = ColourValue(0.5, 0.5, 0.5) (mid-grey)</li>
<li>Dynamic lighting enabled</li>
<li>Gourad shading mode</li>
<li>Bilinear texture filtering</li>
</ul>
<p>You can alter these settings by calling <a class="el" href="class_ogre_1_1_material_manager.html#ac70230fa9f123976d7f2b1257bd94bd4" title="Returns a pointer to the default Material settings.">Ogre::MaterialManager::getDefaultSettings()</a> and making the required changes to the Material which is returned.</p>
<p>Entities automatically have Material’s associated with them if they use a <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Ogre::Mesh</a> object, since the <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Ogre::Mesh</a> object typically sets up it’s required materials on loading. You can also customise the material used by an entity as described in <a class="el" href="_the-_core-_objects.html#Entities">Entities</a>. Just create a new Material, set it up how you like (you can copy an existing material into it if you like using a standard assignment statement) and point the SubEntity entries at it using <a class="el" href="class_ogre_1_1_sub_entity.html#ab8af6685128c68a5d7863bb5238ebc0f" title="Sets the name of the Material to be used.">Ogre::SubEntity::setMaterialName()</a>.</p>
<h1><a class="anchor" id="Overlays"></a>
Overlays</h1>
<p>Overlays allow you to render 2D and 3D elements on top of the normal scene contents to create effects like heads-up displays (HUDs), menu systems, status panels etc. The frame rate statistics panel which comes as standard with OGRE is an example of an overlay. Overlays can contain 2D or 3D elements. 2D elements are used for HUDs, and 3D elements can be used to create cockpits or any other 3D object which you wish to be rendered on top of the rest of the scene.</p>
<p>You can create overlays either through the <a class="el" href="class_ogre_1_1_overlay_manager.html#ab6eb3dcc484ba5b06904ab2fb6b1aa23" title="Create a new Overlay.">Ogre::OverlayManager::create</a> method, or you can define them in an .overlay script. See <a class="el" href="_overlay-_scripts.html">Overlay Scripts</a> for more info. In reality the latter is likely to be the most practical because it is easier to tweak (without the need to recompile the code). Note that you can define as many overlays as you like: they all start off life hidden, and you display them by calling <a class="el" href="class_ogre_1_1_overlay.html#a3c565f3e5cf61f43fa33542d713e8ccf" title="Shows the overlay if it was hidden.">Ogre::Overlay::show</a>. You can also show multiple overlays at once, and their Z order is determined by the <a class="el" href="class_ogre_1_1_overlay.html#a5d8481d5fa0990846e53345f1a1cc705" title="Alters the Z-order of this overlay.">Ogre::Overlay::setZOrder()</a> method.</p>
<p><a class="anchor" id="Notes-on-Integration"></a></p>
<h2><a class="anchor" id="autotoc_md30"></a>
Notes on Integration</h2>
<p>The OverlaySystem is its own component, you need to manually initialize it, with the following two lines of code (mSceneMgr is a pointer to your current <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39;: a collection of objects and potentially world ge...">Ogre::SceneManager</a>):</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_overlay_system.html">Ogre::OverlaySystem</a>* pOverlaySystem = <span class="keyword">new</span> <a class="code" href="class_ogre_1_1_overlay_system.html">Ogre::OverlaySystem</a>();</div>
<div class="line">mSceneMgr-&gt;addRenderQueueListener(pOverlaySystem);</div>
<div class="ttc" id="aclass_ogre_1_1_overlay_system_html"><div class="ttname"><a href="class_ogre_1_1_overlay_system.html">Ogre::OverlaySystem</a></div><div class="ttdoc">This class simplify initialization / finalization of the overlay system.</div><div class="ttdef"><b>Definition:</b> OgreOverlaySystem.h:60</div></div>
</div><!-- fragment --><p>One <a class="el" href="class_ogre_1_1_overlay_system.html" title="This class simplify initialization / finalization of the overlay system.">Ogre::OverlaySystem</a> per application is enough but you need to call addRenderQueueListener once per SceneManager.</p>
<p><a class="anchor" id="Creating-2D-Elements"></a></p>
<h2><a class="anchor" id="autotoc_md31"></a>
Creating 2D Elements</h2>
<p>The <a class="el" href="class_ogre_1_1_overlay_element.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">Ogre::OverlayElement</a> class abstracts the details of 2D elements which are added to overlays. All items which can be added to overlays are derived from this class. It is possible (and encouraged) for users of OGRE to define their own custom subclasses of OverlayElement in order to provide their own user controls. The key common features of all OverlayElements are things like size, position, basic material name etc. Subclasses extend this behaviour to include more complex properties and behaviour.</p>
<p>An important built-in subclass of OverlayElement is <a class="el" href="class_ogre_1_1_overlay_container.html" title="A 2D element which contains other OverlayElement instances.">Ogre::OverlayContainer</a>. OverlayContainer is the same as a OverlayElement, except that it can contain other OverlayElements, grouping them together (allowing them to be moved together for example) and providing them with a local coordinate origin for easier lineup.</p>
<p>The third important class is <a class="el" href="class_ogre_1_1_overlay_manager.html" title="Manages Overlay objects, parsing them from .overlay files and storing a lookup library of them.">Ogre::OverlayManager</a>. Whenever an application wishes to create a 2D element to add to an overlay (or a container), it should call <a class="el" href="class_ogre_1_1_overlay_manager.html#adcc9a39a336f61b0ff51382e3d6d945a" title="Creates a new OverlayElement of the type requested.">Ogre::OverlayManager::createOverlayElement</a>. The type of element you wish to create is identified by a string, the reason being that it allows plugins to register new types of OverlayElement for you to create without you having to link specifically to those libraries. For example, to create a panel (a plain rectangular area which can contain other OverlayElements) you would call <code>OverlayManager::getSingleton().createOverlayElement("Panel", "myNewPanel");</code>.</p>
<p><a class="anchor" id="Adding-2D-Elements-to-the-Overlay"></a></p>
<h2><a class="anchor" id="autotoc_md32"></a>
Adding 2D Elements to the Overlay</h2>
<p>Only OverlayContainers can be added direct to an overlay. The reason is that each level of container establishes the Zorder of the elements contained within it, so if you nest several containers, inner containers have a higher Z-order than outer ones to ensure they are displayed correctly. To add a container (such as a Panel) to the overlay, simply call <a class="el" href="class_ogre_1_1_overlay.html#a702b15ebaa6d3f8dbb2918500b76c9f0" title="Adds a 2D &#39;container&#39; to the overlay.">Ogre::Overlay::add2D</a>.</p>
<p>If you wish to add child elements to that container, call <a class="el" href="class_ogre_1_1_overlay_container.html#aa9eec8f6dca98ac61766fc4785b84661" title="Adds another OverlayElement to this container.">Ogre::OverlayContainer::addChild</a>. Child elements can be Ogre::OverlayElements or <a class="el" href="class_ogre_1_1_overlay_container.html" title="A 2D element which contains other OverlayElement instances.">Ogre::OverlayContainer</a> instances themselves. Remember that the position of a child element is relative to the top-left corner of it’s parent.</p>
<p><a class="anchor" id="A-word-about-2D-coordinates"></a></p>
<h2><a class="anchor" id="autotoc_md33"></a>
A word about 2D coordinates</h2>
<p>OGRE allows you to place and size elements based on 2 coordinate systems: <b>relative</b> and <b>pixel</b> based.</p>
<dl compact="compact">
<dt>Pixel Mode </dt>
<dd><p class="startdd"></p>
<p class="interdd">This mode is useful when you want to specify an exact size for your overlay items, and you don’t mind if those items get smaller on the screen if you increase the screen resolution (in fact you might want this). In this mode the only way to put something in the middle or at the right or bottom of the screen reliably in any resolution is to use the aligning options, whilst in relative mode you can do it just by using the right relative coordinates. This mode is very simple, the top-left of the screen is (0,0) and the bottom-right of the screen depends on the resolution. As mentioned above, you can use the aligning options to make the horizontal and vertical coordinate origins the right, bottom or center of the screen if you want to place pixel items in these locations without knowing the resolution.</p>
<p class="enddd"></p>
</dd>
<dt>Relative Mode </dt>
<dd><p class="startdd"></p>
<p class="interdd">This mode is useful when you want items in the overlay to be the same size on the screen no matter what the resolution. In relative mode, the top-left of the screen is (0,0) and the bottom-right is (1,1). So if you place an element at (0.5, 0.5), it’s top-left corner is placed exactly in the center of the screen, no matter what resolution the application is running in. The same principle applies to sizes; if you set the width of an element to 0.5, it covers half the width of the screen. Note that because the aspect ratio of the screen is typically 1.3333 : 1 (width : height), an element with dimensions (0.25, 0.25) will not be square, but it will take up exactly 1/16th of the screen in area terms. If you want square-looking areas you will have to compensate using the typical aspect ratio e.g. use (0.1875, 0.25) instead.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="Transforming-Overlays"></a> </p>
<h2><a class="anchor" id="autotoc_md34"></a>
Transforming Overlays</h2>
<p>Another nice feature of overlays is being able to rotate, scroll and scale them as a whole. You can use this for zooming in / out menu systems, dropping them in from off screen and other nice effects. See the <a class="el" href="class_ogre_1_1_overlay.html#ae07b1a57498aad0299f0781b09ca9b39" title="Scrolls the overlay by the offsets provided.">Ogre::Overlay::scroll</a>, <a class="el" href="class_ogre_1_1_overlay.html#a8282553a59253170ddd0488ab7179792" title="Adds the passed in angle to the rotation applied to this overlay.">Ogre::Overlay::rotate</a> and <a class="el" href="class_ogre_1_1_overlay.html#adea3b88baa3697a657e7b5785f0ffedb" title="Sets the scaling factor of this overlay.">Ogre::Overlay::setScale</a> methods for more information.</p>
<p><a class="anchor" id="GUI-systems"></a></p>
<h2><a class="anchor" id="autotoc_md35"></a>
GUI systems</h2>
<p>Overlays are only really designed for non-interactive screen elements, although you can create a simple GUI using the <a class="el" href="trays.html">Trays System</a>. For a far more complete GUI solution, we recommend or <a href="https://github.com/OGRECave/ogre-imgui">Dear ImGui</a>, <a href="http://www.cegui.org.uk">CEGui</a> or <a href="http://mygui.info/">MyGUI</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
