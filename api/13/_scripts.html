<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Scripts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">13.6</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_scripts.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Scripts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md66">Loading scripts</a></li>
<li class="level1"><a href="#Format">Format</a><ul><li class="level2"><a href="#Script-Inheritance">Script Inheritance</a><ul><li class="level3"><a href="#Advanced-Script-Inheritance">Advanced Script Inheritance</a></li>
</ul>
</li>
<li class="level2"><a href="#Script-Variables">Script Variables</a></li>
<li class="level2"><a href="#Script-Import-Directive">Script Import Directive</a></li>
</ul>
</li>
<li class="level1"><a href="#custom-translators">Custom Translators</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_scripts"></a> OGRE drives many of its features through scripts in order to make it easier to set up. The scripts are simply plain text files which can be edited in any standard text editor, and modifying them immediately takes effect on your OGRE-based applications, without any need to recompile. This makes prototyping a lot faster. Here are the items that OGRE lets you script:</p>
<ul>
<li><a class="el" href="_material-_scripts.html">Material Scripts</a></li>
<li><a class="el" href="_high-level-_programs.html">GPU Program Scripts</a></li>
<li><a class="el" href="_compositor-_scripts.html">Compositor Scripts</a></li>
<li><a class="el" href="_particle-_scripts.html">Particle Scripts</a></li>
<li><a class="el" href="_overlay-_scripts.html">Overlay Scripts</a></li>
<li><a class="el" href="_font-_definition-_scripts.html">Font Definition Scripts</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md66"></a>
Loading scripts</h1>
<p>Scripts are loaded when resource groups are initialised: OGRE looks in all resource locations associated with the group (see <a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Adds a location to the list of searchable locations for a Resource type.">Ogre::ResourceGroupManager::addResourceLocation</a>) for files with the respective extension (e.g. ’.material’, ’.compositor’, ..) and parses them. If you want to parse files manually, use <a class="el" href="class_ogre_1_1_script_compiler_manager.html#a4526cdfb54f683b2c36e0d95be0914da" title="Parse a script file.">Ogre::ScriptCompilerManager::parseScript</a>.</p>
<p>The file extension does not actually restrict the items that can be specified inside the file; e.g. Ogre is perfectly fine with loading a particle-system from a ’.compositor’ file - but it will lead you straight to maintenance-hell if you do that. The extensions, however, do specify the order in which the scripts are parsed, which is as follows:</p>
<ol type="1">
<li>"*.program"</li>
<li>"*.material"</li>
<li>"*.particle"</li>
<li>"*.compositor"</li>
<li>"*.os"</li>
</ol>
<h1><a class="anchor" id="Format"></a>
Format</h1>
<p>Several script objects may be defined in a single file. The script format is pseudo-C++, with sections delimited by curly braces ({}), and comments indicated by starting a line with ’//’. The general format is shown below:</p>
<div class="fragment"><div class="line"><span class="comment">// This is a comment</span></div>
<div class="line">object_keyword Example/ObjectName</div>
<div class="line">{</div>
<div class="line">    attribute_name <span class="stringliteral">&quot;some value&quot;</span></div>
<div class="line"> </div>
<div class="line">    object_keyword2 <span class="stringliteral">&quot;Nested Object&quot;</span></div>
<div class="line">    {</div>
<div class="line">        other_attribute 1 2 3</div>
<div class="line">        <span class="comment">// and so on..</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Every script object must be given a name, which is the line ’object_keyword &lt;name&gt;’ before the first opening ’{’. This name must be globally unique. It can include path characters (as in the example) to logically divide up the objects, and also to avoid duplicate names, but the engine does not treat the name as hierarchical, just as a string. Names can include spaces but must be surrounded by double quotes i.e. <code>compositor "My Name"</code>.</p>
<dl class="section note"><dt>Note</dt><dd>’:’ is the delimiter for specifying inheritance in the script so it can’t be used as part of the name.</dd></dl>
<p>An script object can inherit from a previously defined object by using a <em>colon</em> ’:’ after the name followed by the name of the reference object to inherit from. You can in fact even inherit just <em>parts</em> of a script object from others; all this is covered in <a class="el" href="_scripts.html#Script-Inheritance">Script Inheritance</a>). You can also use variables in your script which can be replaced in inheriting versions, see <a class="el" href="_scripts.html#Script-Variables">Script Variables</a>.</p>
<h2><a class="anchor" id="Script-Inheritance"></a>
Script Inheritance</h2>
<p>When creating new script objects that are only slight variations of another object, it’s good to avoid copying and pasting between scripts. Script inheritance lets you do this; in this section we’ll use material scripts as an example, but this applies to all scripts parsed with the script compilers in Ogre 1.6 onwards.</p>
<p>For example, to make a new material that is based on one previously defined, add a <em>colon</em> ’:’ after the new material name followed by the name of the material that is to be copied.</p>
<p>Example </p><div class="fragment"><div class="line">material &lt;NewUniqueChildName&gt; : &lt;ReferenceParentMaterial&gt;</div>
</div><!-- fragment --><p>The only caveat is that a parent material must have been defined/parsed prior to the child material script being parsed. The easiest way to achieve this is to either place parents at the beginning of the material script file, or to use the <a class="el" href="_scripts.html#Script-Import-Directive">Script Import Directive</a>. Note that inheritance is actually a copy - after scripts are loaded into <a class="el" href="namespace_ogre.html">Ogre</a>, objects no longer maintain their copy inheritance structure. If a parent material is modified through code at runtime, the changes have no effect on child materials that were copied from it in the script.</p>
<p>Material copying within the script alleviates some drudgery from copy/paste but having the ability to identify specific techniques, passes, and texture units to modify makes material copying easier. Techniques, passes, texture units can be identified directly in the child material without having to layout previous techniques, passes, texture units by associating a name with them, Techniques and passes can take a name and texture units can be numbered within the material script. You can also use variables, See <a class="el" href="_scripts.html#Script-Variables">Script Variables</a>.</p>
<p>Names become very useful in materials that copy from other materials. In order to override values they must be in the correct technique, pass, texture unit etc. The script could be lain out using the sequence of techniques, passes, texture units in the child material but if only one parameter needs to change in say the 5th pass then the first four passes prior to the fifth would have to be placed in the script:</p>
<p>Here is an example:</p>
<div class="fragment"><div class="line">material test2 : test1</div>
<div class="line">{</div>
<div class="line">  technique</div>
<div class="line">  {</div>
<div class="line">    pass</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    pass</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    pass</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    pass</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    pass</div>
<div class="line">    {</div>
<div class="line">      ambient 0.5 0.7 0.3 1.0</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This method is tedious for materials that only have slight variations to their parent. An easier way is to name the pass directly without listing the previous passes:<br  />
</p>
<div class="fragment"><div class="line">material test2 : test1</div>
<div class="line">{</div>
<div class="line">  technique</div>
<div class="line">  {</div>
<div class="line">    pass <span class="stringliteral">&quot;Fifth Pass&quot;</span></div>
<div class="line">    {</div>
<div class="line">      ambient 0.5 0.7 0.3 1.0</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The parent pass name must be known and the pass must be in the correct technique in order for this to work correctly. Specifying the technique name and the pass name is the best method.</p>
<h3><a class="anchor" id="Advanced-Script-Inheritance"></a>
Advanced Script Inheritance</h3>
<p>Script objects can also inherit from each other more generally. The previous concept of inheritance, material copying, was restricted only to the top-level material objects. Now, any level of object can take advantage of inheritance (for instance, techniques, passes, and compositor targets).</p>
<div class="fragment"><div class="line">material Test</div>
<div class="line">{</div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        pass : ParentPass</div>
<div class="line">        {</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Notice that the pass inherits from ParentPass. This allows for the creation of more fine-grained inheritance hierarchies.</p>
<p>Along with the more generalized inheritance system comes an important new keyword: "abstract." This keyword is used at a top-level object declaration (not inside any other object) to denote that it is not something that the compiler should actually attempt to compile, but rather that it is only for the purpose of inheritance. For example, a material declared with the abstract keyword will never be turned into an actual usable material in the material framework. Objects which cannot be at a top-level in the document (like a pass) but that you would like to declare as such for inheriting purpose must be declared with the abstract keyword.</p>
<div class="fragment"><div class="line"><span class="keyword">abstract</span> pass ParentPass</div>
<div class="line">{</div>
<div class="line">    diffuse 1 0 0 1</div>
<div class="line">}</div>
</div><!-- fragment --><p>That declares the ParentPass object which was inherited from in the above example. Notice the abstract keyword which informs the compiler that it should not attempt to actually turn this object into any sort of <a class="el" href="namespace_ogre.html">Ogre</a> resource. If it did attempt to do so, then it would obviously fail, since a pass all on its own like that is not valid.</p>
<p>The final matching option is based on wildcards. Using the ’*’ character, you can make a powerful matching scheme and override multiple objects at once, even if you don’t know exact names or positions of those objects in the inherited object.</p>
<div class="fragment"><div class="line"><span class="keyword">abstract</span> technique Overrider</div>
<div class="line">{</div>
<div class="line">   pass *colour*</div>
<div class="line">   {</div>
<div class="line">      diffuse 0 0 0 0</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This technique, when included in a material, will override all passes matching the wildcard "\*color\*" (color has to appear in the name somewhere) and turn their diffuse properties black. It does not matter their position or exact name in the inherited technique, this will match them.</p>
<h2><a class="anchor" id="Script-Variables"></a>
Script Variables</h2>
<p>A very powerful new feature in <a class="el" href="namespace_ogre.html">Ogre</a> 1.6 is variables. Variables allow you to parameterize data in materials so that they can become more generalized. This enables greater reuse of scripts by targeting specific customization points. Using variables along with inheritance allows for huge amounts of overrides and easy object reuse.</p>
<div class="fragment"><div class="line"><span class="keyword">abstract</span> pass ParentPass</div>
<div class="line">{</div>
<div class="line">   diffuse $diffuse_colour</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">material Test</div>
<div class="line">{</div>
<div class="line">   technique</div>
<div class="line">   {</div>
<div class="line">       pass : ParentPass</div>
<div class="line">       {</div>
<div class="line">           set $diffuse_colour <span class="stringliteral">&quot;1 0 0 1&quot;</span></div>
<div class="line">       }</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The ParentPass object declares a variable called "diffuse\_colour" which is then overridden in the Test material’s pass. The "set" keyword is used to set the value of that variable. The variable assignment follows lexical scoping rules, which means that the value of "1 0 0 1" is only valid inside that pass definition. Variable assignment in outer scopes carry over into inner scopes.</p>
<div class="fragment"><div class="line">material Test</div>
<div class="line">{</div>
<div class="line">    set $diffuse_colour <span class="stringliteral">&quot;1 0 0 1&quot;</span></div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        pass : ParentPass</div>
<div class="line">        {</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The $diffuse_colour assignment carries down through the technique and into the pass.</p>
<h2><a class="anchor" id="Script-Import-Directive"></a>
Script Import Directive</h2>
<p>Imports are a feature introduced to remove ambiguity from script dependencies. When using scripts that inherit from each other but which are defined in separate files sometimes errors occur because the scripts are loaded in incorrect order. Using imports removes this issue. The script which is inheriting another can explicitly import its parent’s definition which will ensure that no errors occur because the parent’s definition was not found.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> * from <span class="stringliteral">&quot;parent.material&quot;</span></div>
<div class="line">material Child : Parent</div>
<div class="line">{</div>
<div class="line">}</div>
</div><!-- fragment --><p>The material "Parent" is defined in parent.material and the import ensures that those definitions are found properly. You can also import specific targets from within a file.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> Parent from <span class="stringliteral">&quot;parent.material&quot;</span></div>
</div><!-- fragment --><p>If there were other definitions in the parent.material file, they would not be imported.</p>
<dl class="section note"><dt>Note</dt><dd>Importing does not actually cause objects in the imported script to be fully parsed &amp; created, it just makes the definitions available for inheritance. This has a specific ramification for vertex / fragment program definitions, which must be loaded before any parameters can be specified. You should continue to put common program definitions in .program files to ensure they are fully parsed before being referenced in multiple .material files. The ’import’ command just makes sure you can resolve dependencies between equivalent script definitions (e.g. material to material).</dd></dl>
<h1><a class="anchor" id="custom-translators"></a>
Custom Translators</h1>
<p>Writing a custom translators allows you to extend <a class="el" href="namespace_ogre.html">Ogre</a>'s standard compilers with completely new functionality. The same scripting interfaces can be used to define application-specific functionality. Here's how you do it.</p>
<p>The first step is creating a custom translator class which extends <a class="el" href="class_ogre_1_1_script_translator.html" title="This class translates script AST (abstract syntax tree) into Ogre resources.">Ogre::ScriptTranslator</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>FontTranslator : <span class="keyword">public</span> ScriptTranslator</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> translate(ScriptCompiler* compiler, <span class="keyword">const</span> <a class="code" href="group___script.html#ga15cfb375beeafed87e1bdd96ef10ff36">AbstractNodePtr</a>&amp; node) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> parseAttribute(ScriptCompiler* compiler, <a class="code" href="group___overlays.html#ga6fc186106cde55e3a7b867798fe28e89">FontPtr</a>&amp; pFont, PropertyAbstractNode* prop);</div>
<div class="line">};</div>
<div class="ttc" id="agroup___overlays_html_ga6fc186106cde55e3a7b867798fe28e89"><div class="ttname"><a href="group___overlays.html#ga6fc186106cde55e3a7b867798fe28e89">Ogre::FontPtr</a></div><div class="ttdeci">SharedPtr&lt; Font &gt; FontPtr</div><div class="ttdef"><b>Definition:</b> OgreFont.h:347</div></div>
<div class="ttc" id="agroup___script_html_ga15cfb375beeafed87e1bdd96ef10ff36"><div class="ttname"><a href="group___script.html#ga15cfb375beeafed87e1bdd96ef10ff36">Ogre::AbstractNodePtr</a></div><div class="ttdeci">SharedPtr&lt; AbstractNode &gt; AbstractNodePtr</div><div class="ttdef"><b>Definition:</b> OgreScriptCompiler.h:86</div></div>
</div><!-- fragment --><p> This class defines the important function to override: translate. This is called when the TestTranslator needs to process a sub-set of the parsed script. The definition of this function might look something like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> FontTranslator::translate(ScriptCompiler* compiler, <span class="keyword">const</span> <a class="code" href="group___script.html#ga15cfb375beeafed87e1bdd96ef10ff36">AbstractNodePtr</a>&amp; node)</div>
<div class="line">{</div>
<div class="line">    ObjectAbstractNode* obj = <span class="keyword">static_cast&lt;</span>ObjectAbstractNode*<span class="keyword">&gt;</span>(node.get());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Must have a name - unless we are in legacy mode. Then the class is the name.</span></div>
<div class="line">    <span class="keywordflow">if</span> (obj-&gt;name.empty() &amp;&amp; obj-&gt;cls == <span class="stringliteral">&quot;font&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        compiler-&gt;addError(ScriptCompiler::CE_OBJECTNAMEEXPECTED, obj-&gt;file, obj-&gt;line,</div>
<div class="line">                           <span class="stringliteral">&quot;font must be given a name&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; name = obj-&gt;cls == <span class="stringliteral">&quot;font&quot;</span> ? obj-&gt;name : obj-&gt;cls;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group___overlays.html#ga6fc186106cde55e3a7b867798fe28e89">FontPtr</a> font = FontManager::getSingleton().create(name, compiler-&gt;getResourceGroup());</div>
<div class="line">    font-&gt;<a class="code" href="class_ogre_1_1_resource.html#a7e248a1cca0662418d4ab3f63c2e7cf6">_notifyOrigin</a>(obj-&gt;file);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; c : obj-&gt;children)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (c-&gt;type == <a class="code" href="group___script.html#gga788dd054963542ec3375d9b83255bc98aea41df7725177862840cf90b4016008a">ANT_PROPERTY</a>)</div>
<div class="line">        {</div>
<div class="line">            parseAttribute(compiler, font, <span class="keyword">static_cast&lt;</span>PropertyAbstractNode*<span class="keyword">&gt;</span>(c.get()));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_ogre_1_1_resource_html_a7e248a1cca0662418d4ab3f63c2e7cf6"><div class="ttname"><a href="class_ogre_1_1_resource.html#a7e248a1cca0662418d4ab3f63c2e7cf6">Ogre::Resource::_notifyOrigin</a></div><div class="ttdeci">void _notifyOrigin(const String &amp;origin)</div><div class="ttdoc">Notify this resource of it's origin.</div><div class="ttdef"><b>Definition:</b> OgreResource.h:412</div></div>
<div class="ttc" id="agroup___script_html_gga788dd054963542ec3375d9b83255bc98aea41df7725177862840cf90b4016008a"><div class="ttname"><a href="group___script.html#gga788dd054963542ec3375d9b83255bc98aea41df7725177862840cf90b4016008a">Ogre::ANT_PROPERTY</a></div><div class="ttdeci">@ ANT_PROPERTY</div><div class="ttdef"><b>Definition:</b> OgreScriptCompiler.h:81</div></div>
<div class="ttc" id="anamespace_ogre_html_aaf6cdc855bf9ae5edbf48a7e7dcb27f8"><div class="ttname"><a href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">Ogre::String</a></div><div class="ttdeci">std::string String</div><div class="ttdef"><b>Definition:</b> OgrePrerequisites.h:320</div></div>
</div><!-- fragment --><p> The translate function here expects all children to be atomic properties. Sub-objects can also be processed by checking if the child node type is <a class="el" href="group___script.html#gga788dd054963542ec3375d9b83255bc98a235f619027a81559883aba536d1a3cd6">Ogre::ANT_OBJECT</a>.</p>
<p>From here you need to register the translator to be invoked when the proper object is found in the scripts. To do this we need to create a <a class="el" href="class_ogre_1_1_script_translator_manager.html" title="The ScriptTranslatorManager manages the lifetime and access to script translators.">Ogre::ScriptTranslatorManager</a> object to create your custom translator. The relevant parts look like this:</p>
<div class="fragment"><div class="line">    ScriptCompilerManager::getSingleton().addTranslatorManager(<span class="keyword">this</span>);</div>
<div class="line">    ID_FONT = ScriptCompilerManager::getSingleton().registerCustomWordId(<span class="stringliteral">&quot;font&quot;</span>);</div>
</div><!-- fragment --><p> Note how we use <a class="el" href="class_ogre_1_1_script_compiler_manager.html#af3f78dbda6c8200e06a6d72981e3de92" title="Adds a custom word id which can be used for custom script translators.">Ogre::ScriptCompilerManager::registerCustomWordId</a> to avoid string comparisons in our code.</p>
<div class="fragment"><div class="line">ScriptTranslator* OverlayTranslatorManager::getTranslator(<span class="keyword">const</span> <a class="code" href="group___script.html#ga15cfb375beeafed87e1bdd96ef10ff36">AbstractNodePtr</a>&amp; node)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (node-&gt;type != <a class="code" href="group___script.html#gga788dd054963542ec3375d9b83255bc98a235f619027a81559883aba536d1a3cd6">ANT_OBJECT</a>)</div>
<div class="line">        <span class="keywordflow">return</span> NULL;</div>
<div class="line"> </div>
<div class="line">    ObjectAbstractNode* obj = <span class="keyword">static_cast&lt;</span>ObjectAbstractNode*<span class="keyword">&gt;</span>(node.get());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (obj-&gt;id == ID_FONT)</div>
<div class="line">        <span class="keywordflow">return</span> &amp;mFontTranslator;</div>
<div class="ttc" id="agroup___script_html_gga788dd054963542ec3375d9b83255bc98a235f619027a81559883aba536d1a3cd6"><div class="ttname"><a href="group___script.html#gga788dd054963542ec3375d9b83255bc98a235f619027a81559883aba536d1a3cd6">Ogre::ANT_OBJECT</a></div><div class="ttdeci">@ ANT_OBJECT</div><div class="ttdef"><b>Definition:</b> OgreScriptCompiler.h:80</div></div>
</div><!-- fragment --><p> No new translators are created here, just returned when requested. This is because our translator does not require separate instances to properly parse scripts, and so it is easier to only create one instance and reuse it. Often this strategy will work.</p>
<p>The order that custom translator managers are registered will make a difference. When the system is attempting to find translators to handle pieces of a script, it will query the translator managers one-by-one until it finds one that handles that script object. It is a first-come-first-served basis.</p>
<p>An important note is that this will recognize the above pattern no matter where in the script it is. That means that this may appear at the top-level of a script or inside several sub-objects. If this is not what you want then you can change the translator manager to do more advanced processing in the getTranslator function. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
