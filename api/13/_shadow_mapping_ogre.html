<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">13.6</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non) Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a><ul><li class="level2"><a href="#autotoc_md64">Debugging Shadows</a></li>
<li class="level2"><a href="#autotoc_md65">Improving Shadow Quality</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_ogre_shadows"></a> </p>
<h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams &#160;<a class="el" href="citelist.html#CITEREF_WIL78">[16]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<p><img src="depthbias.svg" alt="" style="pointer-events: none;" class="inline"/> Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</p>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span><em>ad hoc</em></span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span><em>light space</em></span> and compute what the offset for a particular sample should be in <span><em>light image space</em></span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in &#160;<a class="el" href="citelist.html#CITEREF_RSC87">[13]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>Those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>Those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps &#160;<a class="el" href="citelist.html#CITEREF_LV00">[8]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community &#160;<a class="el" href="citelist.html#CITEREF_DL06">[5]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>The inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>The inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps <a class="el" href="citelist.html#CITEREF_FFB01">[6]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm &#160;<a class="el" href="citelist.html#CITEREF_Chong04">[2]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<p><img src="optfrust.svg" alt="" style="pointer-events: none;" class="inline"/> Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</p>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references &#160;<a class="el" href="citelist.html#CITEREF_Chong06">[3]</a> and &#160;<a class="el" href="citelist.html#CITEREF_Chong04">[2]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non) Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps &#160;<a class="el" href="citelist.html#CITEREF_MT04">[9]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps &#160;<a class="el" href="citelist.html#CITEREF_SD02">[14]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See &#160;<a class="el" href="citelist.html#CITEREF_Chong06">[3]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div>
<div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf57a48d6f90676eb2d9230127960412b">PF_DEPTH16</a>);</div>
<div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div>
<div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div>
<div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div>
<div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div>
<div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div>
<div class="ttc" id="agroup___general_html_gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103"><div class="ttname"><a href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">Ogre::SHADOWTYPE_TEXTURE_ADDITIVE</a></div><div class="ttdeci">@ SHADOWTYPE_TEXTURE_ADDITIVE</div><div class="ttdoc">Texture-based shadow technique which involves a render-to-texture of the shadow caster and a projecti...</div><div class="ttdef"><b>Definition:</b> OgreCommon.h:261</div></div>
<div class="ttc" id="agroup___image_html_gga7e0353e7d36d4c2e8468641b7303d39caf57a48d6f90676eb2d9230127960412b"><div class="ttname"><a href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf57a48d6f90676eb2d9230127960412b">Ogre::PF_DEPTH16</a></div><div class="ttdeci">@ PF_DEPTH16</div><div class="ttdoc">Depth texture format, with 16-bit unsigned integer.</div><div class="ttdef"><b>Definition:</b> OgrePixelFormat.h:118</div></div>
</div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html">Ogre</a> to use a 16-bit depth texture. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a material script. They tell <a class="el" href="namespace_ogre.html">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div>
<div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div>
<div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Base ambient pass</span></div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div>
<div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div>
<div class="line">            ambient 1 1 1</div>
<div class="line">            diffuse 0 0 0 </div>
<div class="line">            specular 0 0 0 0 </div>
<div class="line">            </div>
<div class="line">            depth_bias -1</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Now do the lighting pass</span></div>
<div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div>
<div class="line">        pass lighting</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div>
<div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div>
<div class="line">            ambient 0 0 0 </div>
<div class="line">            </div>
<div class="line">            <span class="comment">// do this for each light</span></div>
<div class="line">            iteration once_per_light</div>
<div class="line"> </div>
<div class="line">        </div>
<div class="line">            scene_blend add</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Vertex program reference</span></div>
<div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Fragment program</span></div>
<div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// using integrated shadows</span></div>
<div class="line">            texture_unit</div>
<div class="line">            {</div>
<div class="line">                tex_address_mode clamp</div>
<div class="line">                filtering none</div>
<div class="line">                content_type shadow</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Decal pass</span></div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div>
<div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div>
<div class="line">            lighting off</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">            scene_blend dest_colour zero</div>
<div class="line"> </div>
<div class="line">            depth_bias 1</div>
<div class="line">            </div>
<div class="line">            texture_unit</div>
<div class="line">            {</div>
<div class="line">                texture rockwall.tga</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="anamespace_ogre_html"><div class="ttname"><a href="namespace_ogre.html">Ogre</a></div><div class="ttdef"><b>Definition:</b> OgreAlignedAllocator.h:34</div></div>
</div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line">uniform mat4 worldViewProjMatrix;</div>
<div class="line">attribute vec4 vertex;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// This is the view space position</span></div>
<div class="line">    gl_Position = worldViewProjMatrix * vertex;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    gl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Just write out the depth values here. The bias and derivatives are handled by the <code>depth_bias</code> set in the pass.</p>
<div class="fragment"><div class="line">uniform mat4 world;</div>
<div class="line">uniform mat4 worldIT;</div>
<div class="line">uniform mat4 worldViewProj;</div>
<div class="line">uniform mat4 texViewProj;</div>
<div class="line">uniform vec4 lightPosition;</div>
<div class="line">uniform vec4 lightColour;</div>
<div class="line"> </div>
<div class="line">attribute vec4 vertex;</div>
<div class="line">attribute vec3 normal;</div>
<div class="line"> </div>
<div class="line">varying vec4 oUv;</div>
<div class="line">varying vec4 outColor;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    gl_Position = worldViewProj * vertex;</div>
<div class="line">    </div>
<div class="line">    vec4 worldPos = world * vertex;</div>
<div class="line"> </div>
<div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div>
<div class="line">    vec3 lightDir = normalize(</div>
<div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div>
<div class="line"> </div>
<div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// calculate shadow map coords</span></div>
<div class="line">    oUv = texViewProj * worldPos;</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if PCF</span></div>
<div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">uniform sampler2D shadowMap;</div>
<div class="line"> </div>
<div class="line">varying vec4 oUv;</div>
<div class="line">varying vec4 outColor;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    vec4 shadowUV = oUv;</div>
<div class="line">    <span class="comment">// point on shadowmap</span></div>
<div class="line">    shadowUV = shadowUV / shadowUV.w;</div>
<div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef OGRE_REVERSED_Z</span></div>
<div class="line">    shadowUV.z = shadowUV.z * 0.5 + 0.5; <span class="comment">// convert -1..1 to 0..1</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div>
<div class="line"><span class="preprocessor">#if PCF</span></div>
<div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div>
<div class="line">    vec4 depths = vec4(</div>
<div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0.0)).x,</div>
<div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0.0)).x,</div>
<div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0.0, -pixeloffset)).x,</div>
<div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0.0, +pixeloffset)).x);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (centerdepth &gt; shadowUV.z) ? 1.0 : 0.0;</div>
<div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div>
<div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div>
<div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div>
<div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">final</span> *= 0.2;</div>
<div class="line"> </div>
<div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1.0);</div>
<div class="line">    </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
Debugging Shadows</h2>
<p>Since shadows are a difficult subject, so it is a good idea to have the Shadow Map projected on a Mini-Screen where it is possible to see how the Depth Caster is performing.</p>
<p>Material definition: <code>shadow_debug.material</code> </p><div class="fragment"><div class="line">material ShadowDebug</div>
<div class="line">{</div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            lighting off</div>
<div class="line"> </div>
<div class="line">            texture_unit ShadowMap</div>
<div class="line">            {</div>
<div class="line">                tex_address_mode clamp</div>
<div class="line">                filtering none</div>
<div class="line">                content_type shadow</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>With only this material definition the <a class="el" href="rtss.html">RTSS (Realtime Shader System)</a> takes care of generating the proper shader to project the Shadow Map on the Mini Screen.</p>
<p>Source code to create a Rectangle on the screen and project the Shadow Map texture: </p><div class="fragment"><div class="line"><span class="comment">// Create rectangle for the Mini-Screen and attach to node</span></div>
<div class="line"><a class="code" href="class_ogre_1_1_rectangle2_d.html">Ogre::Rectangle2D</a>* miniScreen = mSceneMgr-&gt;createScreenSpaceRect(<span class="keyword">true</span>);</div>
<div class="line">miniScreen-&gt;<a class="code" href="class_ogre_1_1_rectangle2_d.html#aed40fe896d3057e028d56c86bea2af4b">setCorners</a>(.5, 1.0, 1.0, .5);</div>
<div class="line">miniScreen-&gt;<a class="code" href="class_ogre_1_1_simple_renderable.html#a29048e3cee8fa41f3129f79dc5f61988">setBoundingBox</a>(<a class="code" href="class_ogre_1_1_axis_aligned_box.html#ad1b10226c7dd82d5714f8d50c5fd4e04">Ogre::AxisAlignedBox::BOX_INFINITE</a>);</div>
<div class="line">miniScreen-&gt;<a class="code" href="class_ogre_1_1_simple_renderable.html#a8008f933439df61c42c2c4b7a243459c">setMaterial</a>(<a class="code" href="class_ogre_1_1_material_manager.html#a17b3b6ea6c91c7713769854606a58889">Ogre::MaterialManager::getSingletonPtr</a>()-&gt;getByName(<span class="stringliteral">&quot;ShadowDebug&quot;</span>));</div>
<div class="line"> </div>
<div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* miniScreenNode = mSceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div>
<div class="line">miniScreenNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(miniScreen);</div>
<div class="ttc" id="aclass_ogre_1_1_axis_aligned_box_html_ad1b10226c7dd82d5714f8d50c5fd4e04"><div class="ttname"><a href="class_ogre_1_1_axis_aligned_box.html#ad1b10226c7dd82d5714f8d50c5fd4e04">Ogre::AxisAlignedBox::BOX_INFINITE</a></div><div class="ttdeci">static const AxisAlignedBox BOX_INFINITE</div><div class="ttdef"><b>Definition:</b> OgreAxisAlignedBox.h:803</div></div>
<div class="ttc" id="aclass_ogre_1_1_material_manager_html_a17b3b6ea6c91c7713769854606a58889"><div class="ttname"><a href="class_ogre_1_1_material_manager.html#a17b3b6ea6c91c7713769854606a58889">Ogre::MaterialManager::getSingletonPtr</a></div><div class="ttdeci">static MaterialManager * getSingletonPtr(void)</div><div class="ttdoc">Get the singleton instance.</div></div>
<div class="ttc" id="aclass_ogre_1_1_rectangle2_d_html"><div class="ttname"><a href="class_ogre_1_1_rectangle2_d.html">Ogre::Rectangle2D</a></div><div class="ttdoc">Allows the rendering of a simple 2D rectangle This class renders a simple 2D rectangle; this rectangl...</div><div class="ttdef"><b>Definition:</b> OgreRectangle2D.h:50</div></div>
<div class="ttc" id="aclass_ogre_1_1_rectangle2_d_html_aed40fe896d3057e028d56c86bea2af4b"><div class="ttname"><a href="class_ogre_1_1_rectangle2_d.html#aed40fe896d3057e028d56c86bea2af4b">Ogre::Rectangle2D::setCorners</a></div><div class="ttdeci">void setCorners(float left, float top, float right, float bottom, bool updateAABB=false)</div><div class="ttdoc">Sets the corners of the rectangle, in relative coordinates.</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_node_html"><div class="ttname"><a href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a></div><div class="ttdoc">Class representing a node in the scene graph.</div><div class="ttdef"><b>Definition:</b> OgreSceneNode.h:61</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_node_html_a51052c58747a77a6cf7451b700e7eb87"><div class="ttname"><a href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">Ogre::SceneNode::attachObject</a></div><div class="ttdeci">virtual void attachObject(MovableObject *obj)</div><div class="ttdoc">Adds an instance of a scene object to this node.</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_node_html_aeaee9cb1cb0c23fab2cc9bab08f51181"><div class="ttname"><a href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">Ogre::SceneNode::createChildSceneNode</a></div><div class="ttdeci">virtual SceneNode * createChildSceneNode(const Vector3 &amp;translate=Vector3::ZERO, const Quaternion &amp;rotate=Quaternion::IDENTITY)</div><div class="ttdoc">Creates an unnamed new SceneNode as a child of this node.</div></div>
<div class="ttc" id="aclass_ogre_1_1_simple_renderable_html_a29048e3cee8fa41f3129f79dc5f61988"><div class="ttname"><a href="class_ogre_1_1_simple_renderable.html#a29048e3cee8fa41f3129f79dc5f61988">Ogre::SimpleRenderable::setBoundingBox</a></div><div class="ttdeci">void setBoundingBox(const AxisAlignedBox &amp;box)</div></div>
<div class="ttc" id="aclass_ogre_1_1_simple_renderable_html_a8008f933439df61c42c2c4b7a243459c"><div class="ttname"><a href="class_ogre_1_1_simple_renderable.html#a8008f933439df61c42c2c4b7a243459c">Ogre::SimpleRenderable::setMaterial</a></div><div class="ttdeci">virtual void setMaterial(const MaterialPtr &amp;mat)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md65"></a>
Improving Shadow Quality</h2>
<p>The default projection used when rendering shadow textures is a uniform frustum. This is pretty straight forward but doesn't make the best use of the space in the shadow map since texels closer to the camera will be larger, resulting in 'jaggies'. There are several ways to distribute the texels in the shadow texture differently. <a class="el" href="namespace_ogre.html">Ogre</a> is provided with several alternative shadow camera setups:</p><ul>
<li><a class="el" href="class_ogre_1_1_focused_shadow_camera_setup.html" title="Implements the uniform shadow mapping algorithm in focused mode.">Ogre::FocusedShadowCameraSetup</a>: Implements the uniform shadow mapping algorithm in focused mode.</li>
<li><a class="el" href="class_ogre_1_1_li_s_p_s_m_shadow_camera_setup.html" title="Implements the Light Space Perspective Shadow Mapping Algorithm .">Ogre::LiSPSMShadowCameraSetup</a>: Implements the Light Space Perspective Shadow Mapping Algorithm.</li>
<li><a class="el" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html" title="Parallel Split Shadow Map (PSSM) shadow camera setup.">Ogre::PSSMShadowCameraSetup</a>: Parallel Split Shadow Map (PSSM) shadow camera setup.</li>
<li><a class="el" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html" title="Implements the plane optimal shadow camera algorithm.">Ogre::PlaneOptimalShadowCameraSetup</a>: Implements the plane optimal shadow camera algorithm.</li>
</ul>
<p>These Shadow Camera Setups can be enabled for the whole Scene with SceneManager::setShadowCameraSetup or per light with Light::setCustomShadowCameraSetup</p>
<p>The following shows how to activate Plane Optimal Shadow Mapping given some pointer to a MovablePlane and a pointer to a light. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_movable_plane.html">Ogre::MovablePlane</a> *movablePlane = <span class="keyword">new</span> <a class="code" href="class_ogre_1_1_movable_plane.html">Ogre::MovablePlane</a>( Ogre::Vector3::UNIT_Y, 0 );</div>
<div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = mSceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;Floor.mesh&quot;</span> );</div>
<div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = mSceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div>
<div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div>
<div class="line"><a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a> shadowCameraSetup = <a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html#aaab9fdf433d40a446a78c67828291812">Ogre::PlaneOptimalShadowCameraSetup::create</a>(movablePlane);</div>
<div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(shadowCameraSetup));</div>
<div class="ttc" id="aclass_ogre_1_1_entity_html"><div class="ttname"><a href="class_ogre_1_1_entity.html">Ogre::Entity</a></div><div class="ttdoc">Defines an instance of a discrete, movable object based on a Mesh.</div><div class="ttdef"><b>Definition:</b> OgreEntity.h:80</div></div>
<div class="ttc" id="aclass_ogre_1_1_movable_plane_html"><div class="ttname"><a href="class_ogre_1_1_movable_plane.html">Ogre::MovablePlane</a></div><div class="ttdoc">Definition of a Plane that may be attached to a node, and the derived details of it retrieved simply.</div><div class="ttdef"><b>Definition:</b> OgreMovablePlane.h:55</div></div>
<div class="ttc" id="aclass_ogre_1_1_plane_optimal_shadow_camera_setup_html_aaab9fdf433d40a446a78c67828291812"><div class="ttname"><a href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html#aaab9fdf433d40a446a78c67828291812">Ogre::PlaneOptimalShadowCameraSetup::create</a></div><div class="ttdeci">static ShadowCameraSetupPtr create(const MovablePlane *plane)</div><div class="ttdoc">Constructor – requires a plane of interest.</div><div class="ttdef"><b>Definition:</b> OgreShadowCameraSetupPlaneOptimal.h:79</div></div>
<div class="ttc" id="aclass_ogre_1_1_shared_ptr_html"><div class="ttname"><a href="class_ogre_1_1_shared_ptr.html">Ogre::SharedPtr&lt; ShadowCameraSetup &gt;</a></div></div>
</div><!-- fragment --><p>Another example, using LiSPSM Camera Setup: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a> shadowCameraSetup = <a class="code" href="class_ogre_1_1_default_shadow_camera_setup.html#a9341b479af2dda3b8ff36a5dd1a1d613">Ogre::LiSPSMShadowCameraSetup::create</a>();</div>
<div class="line">mSceneMgr-&gt;setShadowCameraSetup(shadowCameraSetup);</div>
<div class="ttc" id="aclass_ogre_1_1_default_shadow_camera_setup_html_a9341b479af2dda3b8ff36a5dd1a1d613"><div class="ttname"><a href="class_ogre_1_1_default_shadow_camera_setup.html#a9341b479af2dda3b8ff36a5dd1a1d613">Ogre::DefaultShadowCameraSetup::create</a></div><div class="ttdeci">static ShadowCameraSetupPtr create()</div><div class="ttdef"><b>Definition:</b> OgreShadowCameraSetup.h:90</div></div>
</div><!-- fragment --><p>For big scenes with directional lights one of the better performing Shadow Camera Setups is PSSM. A PSSM shadow system uses multiple shadow maps per light and maps each texture into a region of space, progressing away from the camera. As such it is most appropriate for directional light setups. A more in depth explanation can be found in the wiki: <a href="https://wiki.ogre3d.org/Parallel+Split+Shadow+Mapping">Parallel Split Shadow Mapping</a></p>
<div class="fragment"><div class="line"><span class="comment">// General scene setup</span></div>
<div class="line">mSceneMgr-&gt;setShadowTechnique(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6ac29b9727942e113575ea3947a89ae047">Ogre::SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED</a>);</div>
<div class="line">mSceneMgr-&gt;setShadowTextureCasterMaterial(<a class="code" href="class_ogre_1_1_material_manager.html#a17b3b6ea6c91c7713769854606a58889">Ogre::MaterialManager::getSingletonPtr</a>()-&gt;getByName(<span class="stringliteral">&quot;PSSMCaster&quot;</span>));</div>
<div class="line">mSceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>);</div>
<div class="line">mSceneMgr-&gt;setShadowFarDistance(3000);</div>
<div class="line"><span class="comment">// 3 textures per directional light (PSSM)</span></div>
<div class="line">mSceneMgr-&gt;setShadowTextureCountPerLightType(<a class="code" href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345a4c5582d28848ce40c2b652488494b4a3">Ogre::Light::LT_DIRECTIONAL</a>, 3);</div>
<div class="line">mSceneMgr-&gt;setShadowTextureCount(3);</div>
<div class="line">mSceneMgr-&gt;setShadowTextureConfig(0, 2048, 2048, <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf57a48d6f90676eb2d9230127960412b">Ogre::PF_DEPTH16</a>);</div>
<div class="line">mSceneMgr-&gt;setShadowTextureConfig(1, 1024, 1024, <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf57a48d6f90676eb2d9230127960412b">Ogre::PF_DEPTH16</a>);</div>
<div class="line">mSceneMgr-&gt;setShadowTextureConfig(2, 512, 512, <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf57a48d6f90676eb2d9230127960412b">Ogre::PF_DEPTH16</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html">Ogre::PSSMShadowCameraSetup</a>* pssmSetup = <span class="keyword">new</span> <a class="code" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html">Ogre::PSSMShadowCameraSetup</a>(); <span class="comment">//static_cast&lt;Ogre::PSSMShadowCameraSetup*&gt;(shadowCameraSetup-&gt;getPointer());</span></div>
<div class="line">pssmSetup-&gt;<a class="code" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a5000b20f43bea556bcdd994550f1f0ab">setSplitPadding</a>(1);</div>
<div class="line">pssmSetup-&gt;<a class="code" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a1038abc3af65c1177d192ecc5bebf04a">calculateSplitPoints</a>(3, 1, mSceneMgr-&gt;getShadowFarDistance());</div>
<div class="line">pssmSetup-&gt;<a class="code" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a4f16797f8c4fcee30141e5dd0690e647">setOptimalAdjustFactor</a>(0, 2);</div>
<div class="line">pssmSetup-&gt;<a class="code" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a4f16797f8c4fcee30141e5dd0690e647">setOptimalAdjustFactor</a>(1, 1);</div>
<div class="line">pssmSetup-&gt;<a class="code" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a4f16797f8c4fcee30141e5dd0690e647">setOptimalAdjustFactor</a>(2, 0.5);</div>
<div class="line">mSceneMgr-&gt;setShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(pssmSetup));</div>
<div class="ttc" id="aclass_ogre_1_1_light_html_af20fe2bb87447be7a9a5327c65dee345a4c5582d28848ce40c2b652488494b4a3"><div class="ttname"><a href="class_ogre_1_1_light.html#af20fe2bb87447be7a9a5327c65dee345a4c5582d28848ce40c2b652488494b4a3">Ogre::Light::LT_DIRECTIONAL</a></div><div class="ttdeci">@ LT_DIRECTIONAL</div><div class="ttdoc">Directional lights simulate parallel light beams from a distant source, hence have direction but no p...</div><div class="ttdef"><b>Definition:</b> OgreLight.h:108</div></div>
<div class="ttc" id="aclass_ogre_1_1_p_s_s_m_shadow_camera_setup_html"><div class="ttname"><a href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html">Ogre::PSSMShadowCameraSetup</a></div><div class="ttdoc">Parallel Split Shadow Map (PSSM) shadow camera setup.</div><div class="ttdef"><b>Definition:</b> OgreShadowCameraSetupPSSM.h:57</div></div>
<div class="ttc" id="aclass_ogre_1_1_p_s_s_m_shadow_camera_setup_html_a1038abc3af65c1177d192ecc5bebf04a"><div class="ttname"><a href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a1038abc3af65c1177d192ecc5bebf04a">Ogre::PSSMShadowCameraSetup::calculateSplitPoints</a></div><div class="ttdeci">void calculateSplitPoints(uint splitCount, Real nearDist, Real farDist, Real lambda=0.95f)</div><div class="ttdoc">Calculate a new splitting scheme.</div></div>
<div class="ttc" id="aclass_ogre_1_1_p_s_s_m_shadow_camera_setup_html_a4f16797f8c4fcee30141e5dd0690e647"><div class="ttname"><a href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a4f16797f8c4fcee30141e5dd0690e647">Ogre::PSSMShadowCameraSetup::setOptimalAdjustFactor</a></div><div class="ttdeci">void setOptimalAdjustFactor(size_t splitIndex, Real factor)</div><div class="ttdoc">Set the LiSPSM optimal adjust factor for a given split (call after configuring splits).</div></div>
<div class="ttc" id="aclass_ogre_1_1_p_s_s_m_shadow_camera_setup_html_a5000b20f43bea556bcdd994550f1f0ab"><div class="ttname"><a href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#a5000b20f43bea556bcdd994550f1f0ab">Ogre::PSSMShadowCameraSetup::setSplitPadding</a></div><div class="ttdeci">void setSplitPadding(Real pad)</div><div class="ttdoc">Set the padding factor to apply to the near &amp; far distances when matching up splits to one another,...</div><div class="ttdef"><b>Definition:</b> OgreShadowCameraSetupPSSM.h:106</div></div>
<div class="ttc" id="agroup___general_html_gga79dcd426d291c31072c1ad6f183715d6ac29b9727942e113575ea3947a89ae047"><div class="ttname"><a href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6ac29b9727942e113575ea3947a89ae047">Ogre::SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED</a></div><div class="ttdeci">@ SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED</div><div class="ttdoc">Texture-based shadow technique which involves a render-to-texture of the shadow caster and a projecti...</div><div class="ttdef"><b>Definition:</b> OgreCommon.h:278</div></div>
</div><!-- fragment --><p>The Shadow Caster Vertex and Fragment programs are the same as the regular shadow mapping techniques.</p>
<p>But some changes have to be made to the shaders of the Shadow Receiver as well as the program definition, because now we are sending three shadow map splits (in this example).</p>
<p>Material definition: </p><div class="fragment"><div class="line">sampler DepthSampler</div>
<div class="line">{</div>
<div class="line">    filtering none</div>
<div class="line">    tex_address_mode clamp</div>
<div class="line">    tex_border_colour 1.0 1.0 1.0 1.0</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">material PSSMShadowReceiver</div>
<div class="line">{</div>
<div class="line">    technique default</div>
<div class="line">    {</div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            vertex_program_ref PSSMShadowReceiverVP {}</div>
<div class="line">            fragment_program_ref PSSMShadowReceiverFP {}</div>
<div class="line"> </div>
<div class="line">            texture_unit ShadowMap0</div>
<div class="line">            {</div>
<div class="line">                content_type shadow</div>
<div class="line">                sampler_ref DepthSampler</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            texture_unit ShadowMap1</div>
<div class="line">            {</div>
<div class="line">                content_type shadow</div>
<div class="line">                sampler_ref DepthSampler</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            texture_unit ShadowMap2</div>
<div class="line">            {</div>
<div class="line">                content_type shadow</div>
<div class="line">                sampler_ref DepthSampler</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Program definition: </p><div class="fragment"><div class="line">vertex_program PSSMShadowReceiverVP glsl</div>
<div class="line">{</div>
<div class="line">    source PSSMShadowReceiver.vert</div>
<div class="line"> </div>
<div class="line">    default_params</div>
<div class="line">    {</div>
<div class="line">        param_named_auto world world_matrix</div>
<div class="line">        param_named_auto worldIT inverse_transpose_world_matrix</div>
<div class="line">        param_named_auto worldViewProj worldviewproj_matrix</div>
<div class="line">        param_named_auto lightPosition light_position 0</div>
<div class="line">        param_named_auto lightColour light_diffuse_colour 0</div>
<div class="line"> </div>
<div class="line">        param_named_auto texViewProj0 texture_viewproj_matrix 0</div>
<div class="line">        param_named_auto texViewProj1 texture_viewproj_matrix 1</div>
<div class="line">        param_named_auto texViewProj2 texture_viewproj_matrix 2</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment_program PSSMShadowReceiverFP glsl</div>
<div class="line">{</div>
<div class="line">    source PSSMShadowReceiver.frag</div>
<div class="line"> </div>
<div class="line">    default_params</div>
<div class="line">    {</div>
<div class="line">        param_named shadowMap0 int 0</div>
<div class="line">        param_named shadowMap1 int 1</div>
<div class="line">        param_named shadowMap2 int 2</div>
<div class="line"> </div>
<div class="line">        param_named pssmSplitPoints float4 0 0 0 0</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The vertex shader now includes three texture projection matrixes </p><div class="fragment"><div class="line"><span class="preprocessor">#version 330 core</span></div>
<div class="line"> </div>
<div class="line">layout (location = 0) in vec4 vertex;</div>
<div class="line">layout (location = 2) in vec3 normal;</div>
<div class="line"> </div>
<div class="line">uniform mat4 world;</div>
<div class="line">uniform mat4 worldIT;</div>
<div class="line">uniform mat4 worldViewProj;</div>
<div class="line">uniform vec4 lightPosition;</div>
<div class="line">uniform vec4 lightColour;</div>
<div class="line"> </div>
<div class="line">uniform mat4 texViewProj0;</div>
<div class="line">uniform mat4 texViewProj1;</div>
<div class="line">uniform mat4 texViewProj2;</div>
<div class="line"> </div>
<div class="line">out vec4 outColor;</div>
<div class="line"> </div>
<div class="line">out vec4 oUv0;</div>
<div class="line">out vec4 oUv1;</div>
<div class="line">out vec4 oUv2;</div>
<div class="line"> </div>
<div class="line">out <span class="keywordtype">float</span> depth;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    gl_Position = worldViewProj * vertex;</div>
<div class="line">    depth = gl_Position.z;</div>
<div class="line"> </div>
<div class="line">    vec4 worldPos = world * vertex;</div>
<div class="line"> </div>
<div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div>
<div class="line">    vec3 lightDir = normalize(lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div>
<div class="line"> </div>
<div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// calculate shadow map coords</span></div>
<div class="line">    oUv0 = texViewProj0 * worldPos;</div>
<div class="line">    oUv1 = texViewProj1 * worldPos;</div>
<div class="line">    oUv2 = texViewProj2 * worldPos;</div>
<div class="line">}</div>
</div><!-- fragment --><p>And the fragment shader has to be accommodated to select the correct Shadow Map according to the camera distance </p><div class="fragment"><div class="line"><span class="preprocessor">#version 330 core</span></div>
<div class="line"> </div>
<div class="line">in vec4 oUv0;</div>
<div class="line">in vec4 oUv1;</div>
<div class="line">in vec4 oUv2;</div>
<div class="line"> </div>
<div class="line">in vec4 outColor;</div>
<div class="line"> </div>
<div class="line">in <span class="keywordtype">float</span> depth;</div>
<div class="line"> </div>
<div class="line">uniform sampler2D shadowMap0;</div>
<div class="line">uniform sampler2D shadowMap1;</div>
<div class="line">uniform sampler2D shadowMap2;</div>
<div class="line"> </div>
<div class="line">uniform vec4 pssmSplitPoints;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> shadowFilter( sampler2D shadowMap, vec4 oUv, vec3 splitColour )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Perform perspective divide</span></div>
<div class="line">    vec4 shadowUV = oUv;</div>
<div class="line">    shadowUV = shadowUV / shadowUV.w;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Transform [-1, 1] to [0, 1] range</span></div>
<div class="line">    shadowUV.z = shadowUV.z * 0.5 + 0.5;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get closest depth value from light&#39;s perspective (using [0,1] range fragPosLight as coords)</span></div>
<div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Check whether current frag pos is in shadow</span></div>
<div class="line">    gl_FragColor = (finalCenterDepth &gt; shadowUV.z) ? vec4(outColor.xyz * splitColour, 1.0) : vec4(0.0, 0.0, 0.0, 1.0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>( depth &lt;= pssmSplitPoints.y )</div>
<div class="line">    {</div>
<div class="line">        shadowFilter( shadowMap0, oUv0, vec3( 1.0, 0.0, 0.0 ) );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( depth &lt;= pssmSplitPoints.z )</div>
<div class="line">    {</div>
<div class="line">        shadowFilter( shadowMap1, oUv1, vec3( 0.0, 1.0, 0.0 ) );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( depth &lt;= pssmSplitPoints.w )</div>
<div class="line">    {</div>
<div class="line">        shadowFilter( shadowMap2, oUv2, vec3( 0.0, 0.0, 1.0 ) );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        discard;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
