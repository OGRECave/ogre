<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Math</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">13.6</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Math<div class="ingroups"><a class="el" href="group___core.html">Core</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_affine3.html">Ogre::Affine3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform specialization for 3D Affine - encapsulating a 3x4 Matrix.  <a href="class_ogre_1_1_affine3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_angle.html">Ogre::Angle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class which identifies a value as the currently default angle type, as defined by <a class="el" href="class_ogre_1_1_math.html#afb791263d1e8508fc75f698a20d96b87" title="These functions used to set the assumed angle units (radians or degrees) expected when using the Angl...">Math::setAngleUnit</a>.  <a href="class_ogre_1_1_angle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_axis_aligned_box.html">Ogre::AxisAlignedBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D box aligned with the x/y/z axes.  <a href="class_ogre_1_1_axis_aligned_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bitwise.html">Ogre::Bitwise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for manipulating bit patterns.  <a href="class_ogre_1_1_bitwise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_convex_body.html">Ogre::ConvexBody</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a solid representation of a convex body.  <a href="class_ogre_1_1_convex_body.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_degree.html">Ogre::Degree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class which indicates a given angle value is in Degrees.  <a href="class_ogre_1_1_degree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_dual_quaternion.html">Ogre::DualQuaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a dual quaternion, i.e.  <a href="class_ogre_1_1_dual_quaternion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_edge_data.html">Ogre::EdgeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the information required to describe the edge connectivity of a given set of vertices and indexes.  <a href="class_ogre_1_1_edge_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_edge_list_builder.html">Ogre::EdgeListBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General utility class for building edge lists for geometry.  <a href="class_ogre_1_1_edge_list_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_math.html">Ogre::Math</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to provide access to common mathematical functions.  <a href="class_ogre_1_1_math.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_matrix3.html">Ogre::Matrix3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix which can represent rotations around axes.  <a href="class_ogre_1_1_matrix3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_matrix4.html">Ogre::Matrix4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform specialization for projective - encapsulating a 4x4 Matrix.  <a href="class_ogre_1_1_matrix4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_numeric_solver.html">Ogre::NumericSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides numeric solvers for <a class="el" href="namespace_ogre.html">Ogre</a>.  <a href="class_ogre_1_1_numeric_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_optimised_util.html">Ogre::OptimisedUtil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for provides optimised functions.  <a href="class_ogre_1_1_optimised_util.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_plane.html">Ogre::Plane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a plane in 3D space.  <a href="class_ogre_1_1_plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_plane_bounded_volume.html">Ogre::PlaneBoundedVolume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a convex volume bounded by planes.  <a href="class_ogre_1_1_plane_bounded_volume.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_polygon.html">Ogre::Polygon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class represents a polygon in 3D space.  <a href="class_ogre_1_1_polygon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_quaternion.html">Ogre::Quaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a <a class="el" href="class_ogre_1_1_quaternion.html" title="Implementation of a Quaternion, i.e.">Quaternion</a>, i.e.  <a href="class_ogre_1_1_quaternion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_radian.html">Ogre::Radian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class which indicates a given angle value is in Radians.  <a href="class_ogre_1_1_radian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_ray.html">Ogre::Ray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a ray in space, i.e.  <a href="class_ogre_1_1_ray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_rotational_spline.html">Ogre::RotationalSpline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class interpolates orientations (rotations) along a spline using derivatives of quaternions.  <a href="class_ogre_1_1_rotational_spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_simple_spline.html">Ogre::SimpleSpline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very simple spline class which implements the Catmull-Rom class of splines.  <a href="class_ogre_1_1_simple_spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_sphere.html">Ogre::Sphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sphere primitive, mostly used for bounds checking.  <a href="class_ogre_1_1_sphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_tangent_space_calc.html">Ogre::TangentSpaceCalc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for calculating a tangent space basis.  <a href="class_ogre_1_1_tangent_space_calc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_transform_base.html">Ogre::TransformBase&lt; rows, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class encapsulating a standard 4x4 homogeneous matrix.  <a href="class_ogre_1_1_transform_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_transform_base_real.html">Ogre::TransformBaseReal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vector.html">Ogre::Vector&lt; dims, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard N-dimensional vector.  <a href="class_ogre_1_1_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase&lt; dims, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class to implement legacy API. Notably x, y, z access  <a href="struct_ogre_1_1_vector_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_vector_base_3_012_00_01_real_01_4.html">Ogre::VectorBase&lt; 2, Real &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_vector_base_3_013_00_01_real_01_4.html">Ogre::VectorBase&lt; 3, Real &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_vector_base_3_014_00_01_real_01_4.html">Ogre::VectorBase&lt; 4, Real &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf6bda7879d1ac92561a02cbd1833e1b1"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="class_ogre_1_1_plane_bounded_volume.html">PlaneBoundedVolume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaf6bda7879d1ac92561a02cbd1833e1b1">Ogre::PlaneBoundedVolumeList</a></td></tr>
<tr class="separator:gaf6bda7879d1ac92561a02cbd1833e1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cfa65f236aec1767fc85022e87059a0"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga4cfa65f236aec1767fc85022e87059a0">Ogre::PlaneList</a></td></tr>
<tr class="separator:ga4cfa65f236aec1767fc85022e87059a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f791f5ff19bd8395f0008085e68bf10"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; bool, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">Ogre::RayTestResult</a></td></tr>
<tr class="memdesc:ga3f791f5ff19bd8395f0008085e68bf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair structure where the first element indicates whether an intersection occurs.  <a href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">More...</a><br /></td></tr>
<tr class="separator:ga3f791f5ff19bd8395f0008085e68bf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae928a6c0bafde7b018e386ed94d76a84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gae928a6c0bafde7b018e386ed94d76a84">Ogre::Radian::Radian</a> (const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;d)</td></tr>
<tr class="separator:gae928a6c0bafde7b018e386ed94d76a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga088106a9fc8539d9e0912c04a11f4ee6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga088106a9fc8539d9e0912c04a11f4ee6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga088106a9fc8539d9e0912c04a11f4ee6">Ogre::advanceRawPointer</a> (const T *&amp;ptr, ptrdiff_t offset)</td></tr>
<tr class="memdesc:ga088106a9fc8539d9e0912c04a11f4ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the pointer with raw offset.  <a href="group___math.html#ga088106a9fc8539d9e0912c04a11f4ee6">More...</a><br /></td></tr>
<tr class="separator:ga088106a9fc8539d9e0912c04a11f4ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11dd7b55041c012f5d6e82d98d39cce1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga11dd7b55041c012f5d6e82d98d39cce1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga11dd7b55041c012f5d6e82d98d39cce1">Ogre::advanceRawPointer</a> (T *&amp;ptr, ptrdiff_t offset)</td></tr>
<tr class="separator:ga11dd7b55041c012f5d6e82d98d39cce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a92915df275eae8161441024d88c815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga7a92915df275eae8161441024d88c815">Ogre::VectorBase&lt; 2, Real &gt;::angleTo</a> (const <a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> &amp;other) const</td></tr>
<tr class="memdesc:ga7a92915df275eae8161441024d88c815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the oriented angle between 2 vectors.  <a href="group___math.html#ga7a92915df275eae8161441024d88c815">More...</a><br /></td></tr>
<tr class="separator:ga7a92915df275eae8161441024d88c815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga813d02a0ee4c69dab452767fba1cef8a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga813d02a0ee4c69dab452767fba1cef8a">Ogre::Math::calculateBasicFaceNormal</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v1, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v2, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v3)</td></tr>
<tr class="memdesc:ga813d02a0ee4c69dab452767fba1cef8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a face normal, no w-information.  <a href="group___math.html#ga813d02a0ee4c69dab452767fba1cef8a">More...</a><br /></td></tr>
<tr class="separator:ga813d02a0ee4c69dab452767fba1cef8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcc5bd946f4c1fb73b851493e17b11b3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gabcc5bd946f4c1fb73b851493e17b11b3">Ogre::Math::calculateBasicFaceNormalWithoutNormalize</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v1, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v2, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v3)</td></tr>
<tr class="memdesc:gabcc5bd946f4c1fb73b851493e17b11b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a face normal without normalize, no w-information.  <a href="group___math.html#gabcc5bd946f4c1fb73b851493e17b11b3">More...</a><br /></td></tr>
<tr class="separator:gabcc5bd946f4c1fb73b851493e17b11b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ba1fde5b6a0056fd637d4e6b781a2a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gae5ba1fde5b6a0056fd637d4e6b781a2a">Ogre::Math::calculateFaceNormal</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v1, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v2, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v3)</td></tr>
<tr class="memdesc:gae5ba1fde5b6a0056fd637d4e6b781a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a face normal, including the w component which is the offset from the origin.  <a href="group___math.html#gae5ba1fde5b6a0056fd637d4e6b781a2a">More...</a><br /></td></tr>
<tr class="separator:gae5ba1fde5b6a0056fd637d4e6b781a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc24b5e11a3a613f60dc44f6056dc61c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gabc24b5e11a3a613f60dc44f6056dc61c">Ogre::Math::calculateFaceNormalWithoutNormalize</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v1, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v2, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v3)</td></tr>
<tr class="memdesc:gabc24b5e11a3a613f60dc44f6056dc61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a face normal without normalize, including the w component which is the offset from the origin.  <a href="group___math.html#gabc24b5e11a3a613f60dc44f6056dc61c">More...</a><br /></td></tr>
<tr class="separator:gabc24b5e11a3a613f60dc44f6056dc61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe9157bbe30e69645edd5c3eddea141f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gafe9157bbe30e69645edd5c3eddea141f">Ogre::VectorBase&lt; 3, Real &gt;::crossProduct</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;rkVector) const</td></tr>
<tr class="memdesc:gafe9157bbe30e69645edd5c3eddea141f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cross-product of 2 vectors, i.e.  <a href="group___math.html#gafe9157bbe30e69645edd5c3eddea141f">More...</a><br /></td></tr>
<tr class="separator:gafe9157bbe30e69645edd5c3eddea141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67db81d99c63e2483ff8bc314bfd36c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gad67db81d99c63e2483ff8bc314bfd36c">Ogre::VectorBase&lt; 3, Real &gt;::directionEquals</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;rhs, const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;tolerance) const</td></tr>
<tr class="memdesc:gad67db81d99c63e2483ff8bc314bfd36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this vector is within a directional tolerance of another vector.  <a href="group___math.html#gad67db81d99c63e2483ff8bc314bfd36c">More...</a><br /></td></tr>
<tr class="separator:gad67db81d99c63e2483ff8bc314bfd36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ef79da21101ef5a671b0473b849bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gac6ef79da21101ef5a671b0473b849bc3">Ogre::VectorBase&lt; 3, Real &gt;::getRotationTo</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;dest, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;fallbackAxis=<a class="el" href="struct_ogre_1_1_vector_base_3_013_00_01_real_01_4.html#a683a3ae0ddceb4a01a94c0727ca63362">ZERO</a>) const</td></tr>
<tr class="memdesc:gac6ef79da21101ef5a671b0473b849bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shortest arc quaternion to rotate this vector to the destination vector.  <a href="group___math.html#gac6ef79da21101ef5a671b0473b849bc3">More...</a><br /></td></tr>
<tr class="separator:gac6ef79da21101ef5a671b0473b849bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e9b9df69bd3255f3b64254e66c3321"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gab3e9b9df69bd3255f3b64254e66c3321">Ogre::Math::intersects</a> (const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;plane, const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;box)</td></tr>
<tr class="memdesc:gab3e9b9df69bd3255f3b64254e66c3321"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_plane.html" title="Defines a plane in 3D space.">Plane</a> / box intersection test.  <a href="group___math.html#gab3e9b9df69bd3255f3b64254e66c3321">More...</a><br /></td></tr>
<tr class="separator:gab3e9b9df69bd3255f3b64254e66c3321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc5955de7b6ba0dfa860cc751c6321db"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">RayTestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gafc5955de7b6ba0dfa860cc751c6321db">Ogre::Math::intersects</a> (const <a class="el" href="class_ogre_1_1_ray.html">Ray</a> &amp;ray, const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;plane)</td></tr>
<tr class="memdesc:gafc5955de7b6ba0dfa860cc751c6321db"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_ray.html" title="Representation of a ray in space, i.e.">Ray</a> / plane intersection.  <a href="group___math.html#gafc5955de7b6ba0dfa860cc751c6321db">More...</a><br /></td></tr>
<tr class="separator:gafc5955de7b6ba0dfa860cc751c6321db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64ed9272da4fcaccd8b1009a31358c61"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">RayTestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga64ed9272da4fcaccd8b1009a31358c61">Ogre::Math::intersects</a> (const <a class="el" href="class_ogre_1_1_ray.html">Ray</a> &amp;ray, const <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> &amp;sphere, bool discardInside=true)</td></tr>
<tr class="memdesc:ga64ed9272da4fcaccd8b1009a31358c61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_ray.html" title="Representation of a ray in space, i.e.">Ray</a> / sphere intersection.  <a href="group___math.html#ga64ed9272da4fcaccd8b1009a31358c61">More...</a><br /></td></tr>
<tr class="separator:ga64ed9272da4fcaccd8b1009a31358c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04786a5e338650d6eafc987b394d221c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga04786a5e338650d6eafc987b394d221c">Ogre::Math::intersects</a> (const <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> &amp;sphere, const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;plane)</td></tr>
<tr class="memdesc:ga04786a5e338650d6eafc987b394d221c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_sphere.html" title="A sphere primitive, mostly used for bounds checking.">Sphere</a> / plane intersection test.  <a href="group___math.html#ga04786a5e338650d6eafc987b394d221c">More...</a><br /></td></tr>
<tr class="separator:ga04786a5e338650d6eafc987b394d221c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40391520c06bafb34a8647931fab8e1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gae40391520c06bafb34a8647931fab8e1">Ogre::Math::lookRotation</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;direction, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;yaw)</td></tr>
<tr class="memdesc:gae40391520c06bafb34a8647931fab8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rotation matrix from direction and yaw.  <a href="group___math.html#gae40391520c06bafb34a8647931fab8e1">More...</a><br /></td></tr>
<tr class="separator:gae40391520c06bafb34a8647931fab8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4345346666fd54473efb51a8d194f5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga4345346666fd54473efb51a8d194f5e0">Ogre::VectorBase&lt; 2, Real &gt;::midPoint</a> (const <a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> &amp;vec) const</td></tr>
<tr class="memdesc:ga4345346666fd54473efb51a8d194f5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector at a point half way between this and the passed in vector.  <a href="group___math.html#ga4345346666fd54473efb51a8d194f5e0">More...</a><br /></td></tr>
<tr class="separator:ga4345346666fd54473efb51a8d194f5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929562516cfb30c38030d9df84945bf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga929562516cfb30c38030d9df84945bf3">Ogre::VectorBase&lt; 3, Real &gt;::midPoint</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;vec) const</td></tr>
<tr class="memdesc:ga929562516cfb30c38030d9df84945bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector at a point half way between this and the passed in vector.  <a href="group___math.html#ga929562516cfb30c38030d9df84945bf3">More...</a><br /></td></tr>
<tr class="separator:ga929562516cfb30c38030d9df84945bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166c0b2a2264eac93345461f93005b6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga166c0b2a2264eac93345461f93005b6e">Ogre::Angle::operator Degree</a> () const</td></tr>
<tr class="separator:ga166c0b2a2264eac93345461f93005b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f6b1190c20ab261874497f6bbb7dfd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaf5f6b1190c20ab261874497f6bbb7dfd">Ogre::Angle::operator Radian</a> () const</td></tr>
<tr class="separator:gaf5f6b1190c20ab261874497f6bbb7dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ad543ded2a895ca3cb655acde809d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_affine3.html">Affine3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga4ad543ded2a895ca3cb655acde809d6f">Ogre::operator*</a> (const <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;m, const <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;m2)</td></tr>
<tr class="separator:ga4ad543ded2a895ca3cb655acde809d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b5572666ec9a5a8c199d5289cd93bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga15b5572666ec9a5a8c199d5289cd93bc">Ogre::operator*</a> (const <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;m, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v)</td></tr>
<tr class="memdesc:ga15b5572666ec9a5a8c199d5289cd93bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group___math.html#ga15b5572666ec9a5a8c199d5289cd93bc">More...</a><br /></td></tr>
<tr class="separator:ga15b5572666ec9a5a8c199d5289cd93bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3edf0891dcf445e20821a0504f53b5c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga3edf0891dcf445e20821a0504f53b5c4">Ogre::operator*</a> (const <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;m, const <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> &amp;v)</td></tr>
<tr class="separator:ga3edf0891dcf445e20821a0504f53b5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4194c1302dc1f5f13904688d5aa0bc1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga4194c1302dc1f5f13904688d5aa0bc1c">Ogre::operator*</a> (const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;m, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v)</td></tr>
<tr class="memdesc:ga4194c1302dc1f5f13904688d5aa0bc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix * vector [3x3 * 3x1 = 3x1].  <a href="group___math.html#ga4194c1302dc1f5f13904688d5aa0bc1c">More...</a><br /></td></tr>
<tr class="separator:ga4194c1302dc1f5f13904688d5aa0bc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8283a37796cfb2426008099ba8a46e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga8283a37796cfb2426008099ba8a46e5f">Ogre::operator*</a> (const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m, const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="separator:ga8283a37796cfb2426008099ba8a46e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fec6369363b2abbb7a66f363c25c765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga0fec6369363b2abbb7a66f363c25c765">Ogre::operator*</a> (const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;v)</td></tr>
<tr class="memdesc:ga0fec6369363b2abbb7a66f363c25c765"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_vector.html" title="Standard N-dimensional vector.">Vector</a> transformation using '*'.  <a href="group___math.html#ga0fec6369363b2abbb7a66f363c25c765">More...</a><br /></td></tr>
<tr class="separator:ga0fec6369363b2abbb7a66f363c25c765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74f8fe372c36a629f723be7ad92b9573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga74f8fe372c36a629f723be7ad92b9573">Ogre::operator*</a> (const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m, const <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> &amp;v)</td></tr>
<tr class="separator:ga74f8fe372c36a629f723be7ad92b9573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a819ee09ac0c63510f0079ba2bf2a3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_plane.html">Plane</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga2a819ee09ac0c63510f0079ba2bf2a3f">Ogre::operator*</a> (const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;mat, const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;p)</td></tr>
<tr class="separator:ga2a819ee09ac0c63510f0079ba2bf2a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98d9fe8e0bd1f28f9fed1009cd745dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gab98d9fe8e0bd1f28f9fed1009cd745dd">Ogre::operator*</a> (const <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> &amp;v, const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;mat)</td></tr>
<tr class="separator:gab98d9fe8e0bd1f28f9fed1009cd745dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a0c74584c55abd8651c0e87321a485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_degree.html">Degree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga98a0c74584c55abd8651c0e87321a485">Ogre::operator*</a> (float a, const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;b)</td></tr>
<tr class="separator:ga98a0c74584c55abd8651c0e87321a485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2866120e163a6ec8c8b03d2c9ca3951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaa2866120e163a6ec8c8b03d2c9ca3951">Ogre::operator*</a> (float a, const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;b)</td></tr>
<tr class="separator:gaa2866120e163a6ec8c8b03d2c9ca3951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aee68f4913cf646f4fa3c046a18ee60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga6aee68f4913cf646f4fa3c046a18ee60">Ogre::Radian::operator+</a> (const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;d) const</td></tr>
<tr class="separator:ga6aee68f4913cf646f4fa3c046a18ee60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd40f27f78ed1fe8e59df586b53be488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gadd40f27f78ed1fe8e59df586b53be488">Ogre::operator+</a> (const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m, const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="memdesc:gadd40f27f78ed1fe8e59df586b53be488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix addition.  <a href="group___math.html#gadd40f27f78ed1fe8e59df586b53be488">More...</a><br /></td></tr>
<tr class="separator:gadd40f27f78ed1fe8e59df586b53be488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5147935125e28f53cb19d70055bc88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaed5147935125e28f53cb19d70055bc88">Ogre::Radian::operator+=</a> (const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;d)</td></tr>
<tr class="separator:gaed5147935125e28f53cb19d70055bc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05fd614aac352a71e17d8eb559578d7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga05fd614aac352a71e17d8eb559578d7b">Ogre::Radian::operator-</a> (const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;d) const</td></tr>
<tr class="separator:ga05fd614aac352a71e17d8eb559578d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6c12700fc4b4d2d5947166ef459ae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga7c6c12700fc4b4d2d5947166ef459ae3">Ogre::operator-</a> (const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m, const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;m2)</td></tr>
<tr class="memdesc:ga7c6c12700fc4b4d2d5947166ef459ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix subtraction.  <a href="group___math.html#ga7c6c12700fc4b4d2d5947166ef459ae3">More...</a><br /></td></tr>
<tr class="separator:ga7c6c12700fc4b4d2d5947166ef459ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223a82b9ff74351959eee91a335e7cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga223a82b9ff74351959eee91a335e7cdb">Ogre::Radian::operator-=</a> (const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;d)</td></tr>
<tr class="separator:ga223a82b9ff74351959eee91a335e7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec05237e1f0696cbd0f50393e4aea0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_degree.html">Degree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga5ec05237e1f0696cbd0f50393e4aea0e">Ogre::operator/</a> (float a, const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;b)</td></tr>
<tr class="separator:ga5ec05237e1f0696cbd0f50393e4aea0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c940df49c0d61086dfe8525247a15ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga6c940df49c0d61086dfe8525247a15ab">Ogre::operator/</a> (float a, const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;b)</td></tr>
<tr class="separator:ga6c940df49c0d61086dfe8525247a15ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafab8ce89cde3034f3cc5c2537d5ea6fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gafab8ce89cde3034f3cc5c2537d5ea6fd">Ogre::Radian::operator=</a> (const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;d)</td></tr>
<tr class="separator:gafab8ce89cde3034f3cc5c2537d5ea6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00e57f3eda32e31277c439e6a9c929a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga00e57f3eda32e31277c439e6a9c929a1">Ogre::VectorBase&lt; 2, Real &gt;::perpendicular</a> (void) const</td></tr>
<tr class="memdesc:ga00e57f3eda32e31277c439e6a9c929a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a vector perpendicular to this vector (eg an 'up' vector).  <a href="group___math.html#ga00e57f3eda32e31277c439e6a9c929a1">More...</a><br /></td></tr>
<tr class="separator:ga00e57f3eda32e31277c439e6a9c929a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b50a2b2697ec1ac684d66af82a03296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga5b50a2b2697ec1ac684d66af82a03296">Ogre::VectorBase&lt; 3, Real &gt;::perpendicular</a> (void) const</td></tr>
<tr class="memdesc:ga5b50a2b2697ec1ac684d66af82a03296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a vector perpendicular to this vector (eg an 'up' vector).  <a href="group___math.html#ga5b50a2b2697ec1ac684d66af82a03296">More...</a><br /></td></tr>
<tr class="separator:ga5b50a2b2697ec1ac684d66af82a03296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24dd46458beb0ea8175bfbf916f09e47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga24dd46458beb0ea8175bfbf916f09e47">Ogre::VectorBase&lt; 3, Real &gt;::positionCloses</a> (const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;rhs, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> tolerance=1e-03f) const</td></tr>
<tr class="memdesc:ga24dd46458beb0ea8175bfbf916f09e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this vector is within a positional tolerance of another vector, also take scale of the vectors into account.  <a href="group___math.html#ga24dd46458beb0ea8175bfbf916f09e47">More...</a><br /></td></tr>
<tr class="separator:ga24dd46458beb0ea8175bfbf916f09e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad52e72c687842e8475a5f24cde8cd858"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gad52e72c687842e8475a5f24cde8cd858">Ogre::VectorBase&lt; 3, Real &gt;::primaryAxis</a> () const</td></tr>
<tr class="memdesc:gad52e72c687842e8475a5f24cde8cd858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the primary (dominant) axis from this direction vector.  <a href="group___math.html#gad52e72c687842e8475a5f24cde8cd858">More...</a><br /></td></tr>
<tr class="separator:gad52e72c687842e8475a5f24cde8cd858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f54a2dd6b60dd327fcc8347fc4d853d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga4f54a2dd6b60dd327fcc8347fc4d853d">Ogre::VectorBase&lt; 3, Real &gt;::randomDeviant</a> (const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;up=<a class="el" href="struct_ogre_1_1_vector_base_3_013_00_01_real_01_4.html#a683a3ae0ddceb4a01a94c0727ca63362">ZERO</a>) const</td></tr>
<tr class="memdesc:ga4f54a2dd6b60dd327fcc8347fc4d853d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new random vector which deviates from this vector by a given angle in a random direction.  <a href="group___math.html#ga4f54a2dd6b60dd327fcc8347fc4d853d">More...</a><br /></td></tr>
<tr class="separator:ga4f54a2dd6b60dd327fcc8347fc4d853d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba43517feb82c40ccf1cc571f519866c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaba43517feb82c40ccf1cc571f519866c">Ogre::VectorBase&lt; 2, Real &gt;::randomDeviant</a> (<a class="el" href="class_ogre_1_1_radian.html">Radian</a> angle) const</td></tr>
<tr class="memdesc:gaba43517feb82c40ccf1cc571f519866c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new random vector which deviates from this vector by a given angle in a random direction.  <a href="group___math.html#gaba43517feb82c40ccf1cc571f519866c">More...</a><br /></td></tr>
<tr class="separator:gaba43517feb82c40ccf1cc571f519866c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37718ed052d89b36dcbe72aba8093333"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga37718ed052d89b36dcbe72aba8093333"><td class="memTemplItemLeft" align="right" valign="top">static const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga37718ed052d89b36dcbe72aba8093333">Ogre::rawOffsetPointer</a> (const T *ptr, ptrdiff_t offset)</td></tr>
<tr class="memdesc:ga37718ed052d89b36dcbe72aba8093333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns raw offsetted of the given pointer.  <a href="group___math.html#ga37718ed052d89b36dcbe72aba8093333">More...</a><br /></td></tr>
<tr class="separator:ga37718ed052d89b36dcbe72aba8093333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0cae8459b68eaf79cb62da1c90567e2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae0cae8459b68eaf79cb62da1c90567e2"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gae0cae8459b68eaf79cb62da1c90567e2">Ogre::rawOffsetPointer</a> (T *ptr, ptrdiff_t offset)</td></tr>
<tr class="separator:gae0cae8459b68eaf79cb62da1c90567e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebc7c568cc1d6f13405a756be1af73fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaebc7c568cc1d6f13405a756be1af73fa">Ogre::TransformBaseReal::transpose</a> () const</td></tr>
<tr class="separator:gaebc7c568cc1d6f13405a756be1af73fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0e1b281e33d85e3364aeaa49c8ef2f5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gae0e1b281e33d85e3364aeaa49c8ef2f5">Ogre::Radian::valueAngleUnits</a> () const</td></tr>
<tr class="separator:gae0e1b281e33d85e3364aeaa49c8ef2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fd64f1fc097bf4724b4713ff76cdfcd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga1fd64f1fc097bf4724b4713ff76cdfcd">Ogre::Degree::valueAngleUnits</a> () const</td></tr>
<tr class="separator:ga1fd64f1fc097bf4724b4713ff76cdfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac273cad14f6c100d692d7235919fe7f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaac273cad14f6c100d692d7235919fe7f">Ogre::Radian::valueDegrees</a> () const</td></tr>
<tr class="separator:gaac273cad14f6c100d692d7235919fe7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01235157bea1375e48ed73634a6f9a18"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga01235157bea1375e48ed73634a6f9a18">Ogre::Degree::valueRadians</a> () const</td></tr>
<tr class="separator:ga01235157bea1375e48ed73634a6f9a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga3f791f5ff19bd8395f0008085e68bf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f791f5ff19bd8395f0008085e68bf10">&#9670;&nbsp;</a></span>RayTestResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;bool, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&gt; <a class="el" href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">Ogre::RayTestResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pair structure where the first element indicates whether an intersection occurs. </p>
<p>if true, the second element will indicate the distance along the ray at which it intersects. This can be converted to a point in space by calling <a class="el" href="class_ogre_1_1_ray.html#a81a7ec16f410cedf5c279152230bf67b" title="Gets the position of a point t units along the ray.">Ray::getPoint()</a>. </p>

</div>
</div>
<a id="ga4cfa65f236aec1767fc85022e87059a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cfa65f236aec1767fc85022e87059a0">&#9670;&nbsp;</a></span>PlaneList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_ogre_1_1_plane.html">Plane</a>&gt; <a class="el" href="group___math.html#ga4cfa65f236aec1767fc85022e87059a0">Ogre::PlaneList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf6bda7879d1ac92561a02cbd1833e1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6bda7879d1ac92561a02cbd1833e1b1">&#9670;&nbsp;</a></span>PlaneBoundedVolumeList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_ogre_1_1_plane_bounded_volume.html">PlaneBoundedVolume</a>&gt; <a class="el" href="group___math.html#gaf6bda7879d1ac92561a02cbd1833e1b1">Ogre::PlaneBoundedVolumeList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa2866120e163a6ec8c8b03d2c9ca3951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2866120e163a6ec8c8b03d2c9ca3951">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> Ogre::operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_radian.html#accbf4796a0cf6d9703fc8dff822933c9">Ogre::Radian::valueRadians()</a>.</p>

</div>
</div>
<a id="ga6c940df49c0d61086dfe8525247a15ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c940df49c0d61086dfe8525247a15ab">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> Ogre::operator/ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_radian.html#accbf4796a0cf6d9703fc8dff822933c9">Ogre::Radian::valueRadians()</a>.</p>

</div>
</div>
<a id="ga98a0c74584c55abd8651c0e87321a485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98a0c74584c55abd8651c0e87321a485">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_degree.html">Degree</a> Ogre::operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_degree.html#ae7ec7b667395a6e9fb79a92c55a9c5ec">Ogre::Degree::valueDegrees()</a>.</p>

</div>
</div>
<a id="ga5ec05237e1f0696cbd0f50393e4aea0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ec05237e1f0696cbd0f50393e4aea0e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_degree.html">Degree</a> Ogre::operator/ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_degree.html#ae7ec7b667395a6e9fb79a92c55a9c5ec">Ogre::Degree::valueDegrees()</a>.</p>

</div>
</div>
<a id="ga4194c1302dc1f5f13904688d5aa0bc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4194c1302dc1f5f13904688d5aa0bc1c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> Ogre::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix * vector [3x3 * 3x1 = 3x1]. </p>

</div>
</div>
<a id="ga8283a37796cfb2426008099ba8a46e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8283a37796cfb2426008099ba8a46e5f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> Ogre::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gadd40f27f78ed1fe8e59df586b53be488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd40f27f78ed1fe8e59df586b53be488">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> Ogre::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix addition. </p>

</div>
</div>
<a id="ga7c6c12700fc4b4d2d5947166ef459ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c6c12700fc4b4d2d5947166ef459ae3">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> Ogre::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix subtraction. </p>

</div>
</div>
<a id="ga4ad543ded2a895ca3cb655acde809d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ad543ded2a895ca3cb655acde809d6f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> Ogre::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0fec6369363b2abbb7a66f363c25c765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fec6369363b2abbb7a66f363c25c765">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> Ogre::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_vector.html" title="Standard N-dimensional vector.">Vector</a> transformation using '*'. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Transforms the given 3-D vector by the matrix, projecting the result back into <em>w</em> = 1. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This means that the initial <em>w</em> is considered to be 1.0, and then all the tree elements of the resulting 3-D vector are divided by the resulting <em>w</em>. </dd></dl>

</div>
</div>
<a id="ga15b5572666ec9a5a8c199d5289cd93bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15b5572666ec9a5a8c199d5289cd93bc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> Ogre::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga74f8fe372c36a629f723be7ad92b9573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74f8fe372c36a629f723be7ad92b9573">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> Ogre::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3edf0891dcf445e20821a0504f53b5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3edf0891dcf445e20821a0504f53b5c4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> Ogre::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_affine3.html">Affine3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gab98d9fe8e0bd1f28f9fed1009cd745dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab98d9fe8e0bd1f28f9fed1009cd745dd">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> Ogre::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga37718ed052d89b36dcbe72aba8093333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37718ed052d89b36dcbe72aba8093333">&#9670;&nbsp;</a></span>rawOffsetPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const T* Ogre::rawOffsetPointer </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns raw offsetted of the given pointer. </p>
<dl class="section note"><dt>Note</dt><dd>The offset are in bytes, no matter what type of the pointer. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group___math.html#ga088106a9fc8539d9e0912c04a11f4ee6">Ogre::advanceRawPointer()</a>.</p>

</div>
</div>
<a id="gae0cae8459b68eaf79cb62da1c90567e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0cae8459b68eaf79cb62da1c90567e2">&#9670;&nbsp;</a></span>rawOffsetPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T* Ogre::rawOffsetPointer </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga088106a9fc8539d9e0912c04a11f4ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga088106a9fc8539d9e0912c04a11f4ee6">&#9670;&nbsp;</a></span>advanceRawPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::advanceRawPointer </td>
          <td>(</td>
          <td class="paramtype">const T *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance the pointer with raw offset. </p>
<dl class="section note"><dt>Note</dt><dd>The offset are in bytes, no matter what type of the pointer. </dd></dl>

<p class="reference">References <a class="el" href="group___math.html#ga37718ed052d89b36dcbe72aba8093333">Ogre::rawOffsetPointer()</a>.</p>

</div>
</div>
<a id="ga11dd7b55041c012f5d6e82d98d39cce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11dd7b55041c012f5d6e82d98d39cce1">&#9670;&nbsp;</a></span>advanceRawPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::advanceRawPointer </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group___math.html#ga37718ed052d89b36dcbe72aba8093333">Ogre::rawOffsetPointer()</a>.</p>

</div>
</div>
<a id="ga2a819ee09ac0c63510f0079ba2bf2a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a819ee09ac0c63510f0079ba2bf2a3f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_plane.html">Plane</a> Ogre::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_plane.html#a8e7de1712320968bee111002bc2938b8">Ogre::Plane::d</a>, <a class="el" href="class_ogre_1_1_matrix4.html#acd0397dd92f1e5d8c3c5ee7bd269472b">Ogre::Matrix4::inverse()</a>, <a class="el" href="class_ogre_1_1_plane.html#a3f97462d3822f6add8c070048f6c2d92">Ogre::Plane::normal</a>, <a class="el" href="class_ogre_1_1_vector.html#a2d9b321bec779fc06de480897cda2027">Ogre::Vector&lt; dims, T &gt;::normalise()</a>, and <a class="el" href="group___math.html#gaebc7c568cc1d6f13405a756be1af73fa">Ogre::TransformBaseReal::transpose()</a>.</p>

</div>
</div>
<a id="gae928a6c0bafde7b018e386ed94d76a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae928a6c0bafde7b018e386ed94d76a84">&#9670;&nbsp;</a></span>Radian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Radian::Radian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gafab8ce89cde3034f3cc5c2537d5ea6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafab8ce89cde3034f3cc5c2537d5ea6fd">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp; Ogre::Radian::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group___math.html#ga01235157bea1375e48ed73634a6f9a18">Ogre::Degree::valueRadians()</a>.</p>

</div>
</div>
<a id="ga6aee68f4913cf646f4fa3c046a18ee60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aee68f4913cf646f4fa3c046a18ee60">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> Ogre::Radian::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_radian.html#a60fa2965b76b7dda53384610683d5c54">Ogre::Radian::Radian()</a>, and <a class="el" href="group___math.html#ga01235157bea1375e48ed73634a6f9a18">Ogre::Degree::valueRadians()</a>.</p>

</div>
</div>
<a id="gaed5147935125e28f53cb19d70055bc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed5147935125e28f53cb19d70055bc88">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp; Ogre::Radian::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group___math.html#ga01235157bea1375e48ed73634a6f9a18">Ogre::Degree::valueRadians()</a>.</p>

</div>
</div>
<a id="ga05fd614aac352a71e17d8eb559578d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05fd614aac352a71e17d8eb559578d7b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> Ogre::Radian::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_radian.html#a60fa2965b76b7dda53384610683d5c54">Ogre::Radian::Radian()</a>, and <a class="el" href="group___math.html#ga01235157bea1375e48ed73634a6f9a18">Ogre::Degree::valueRadians()</a>.</p>

</div>
</div>
<a id="ga223a82b9ff74351959eee91a335e7cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga223a82b9ff74351959eee91a335e7cdb">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp; Ogre::Radian::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_degree.html">Degree</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group___math.html#ga01235157bea1375e48ed73634a6f9a18">Ogre::Degree::valueRadians()</a>.</p>

</div>
</div>
<a id="gaac273cad14f6c100d692d7235919fe7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac273cad14f6c100d692d7235919fe7f">&#9670;&nbsp;</a></span>valueDegrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Radian::valueDegrees </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#a157a69d3d7d991975dd3b000842156b2">Ogre::Math::RadiansToDegrees()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_degree.html#a77fbb11439e3b9f3ce56af331737484d">Ogre::Degree::operator+()</a>, <a class="el" href="class_ogre_1_1_degree.html#a58a04cfaf38cca2eff31bfa35c7e47db">Ogre::Degree::operator+=()</a>, <a class="el" href="class_ogre_1_1_degree.html#a830559610ea7662565d6ea1107952e51">Ogre::Degree::operator-()</a>, <a class="el" href="class_ogre_1_1_degree.html#adb219a3126dceab35444e0d792108ce9">Ogre::Degree::operator-=()</a>, and <a class="el" href="class_ogre_1_1_degree.html#a88066c650a6e3e2033a9d74820569063">Ogre::Degree::operator=()</a>.</p>

</div>
</div>
<a id="gae0e1b281e33d85e3364aeaa49c8ef2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0e1b281e33d85e3364aeaa49c8ef2f5">&#9670;&nbsp;</a></span>valueAngleUnits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Radian::valueAngleUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#ac9ce627d71a4d3f824c585339c0a0a0b">Ogre::Math::RadiansToAngleUnits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_string_converter.html#aa331e97f9c49e38ac4951c6643f02fbf">Ogre::StringConverter::toString()</a>.</p>

</div>
</div>
<a id="ga01235157bea1375e48ed73634a6f9a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01235157bea1375e48ed73634a6f9a18">&#9670;&nbsp;</a></span>valueRadians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Degree::valueRadians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#ab346b48871b04bd46ae9d877fe30b416">Ogre::Math::DegreesToRadians()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group___math.html#ga6aee68f4913cf646f4fa3c046a18ee60">Ogre::Radian::operator+()</a>, <a class="el" href="group___math.html#gaed5147935125e28f53cb19d70055bc88">Ogre::Radian::operator+=()</a>, <a class="el" href="group___math.html#ga05fd614aac352a71e17d8eb559578d7b">Ogre::Radian::operator-()</a>, <a class="el" href="group___math.html#ga223a82b9ff74351959eee91a335e7cdb">Ogre::Radian::operator-=()</a>, and <a class="el" href="group___math.html#gafab8ce89cde3034f3cc5c2537d5ea6fd">Ogre::Radian::operator=()</a>.</p>

</div>
</div>
<a id="ga1fd64f1fc097bf4724b4713ff76cdfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fd64f1fc097bf4724b4713ff76cdfcd">&#9670;&nbsp;</a></span>valueAngleUnits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::Degree::valueAngleUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#a27e1b2fedaf091309de50261765b8c88">Ogre::Math::DegreesToAngleUnits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_string_converter.html#ad52e12f6ae6c1b1fec0a9bbaeff4b83d">Ogre::StringConverter::toString()</a>.</p>

</div>
</div>
<a id="gaf5f6b1190c20ab261874497f6bbb7dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5f6b1190c20ab261874497f6bbb7dfd">&#9670;&nbsp;</a></span>operator Radian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Angle::operator <a class="el" href="class_ogre_1_1_radian.html">Radian</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#a983534f23650772465406a8c40cef903">Ogre::Math::AngleUnitsToRadians()</a>.</p>

</div>
</div>
<a id="ga166c0b2a2264eac93345461f93005b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga166c0b2a2264eac93345461f93005b6e">&#9670;&nbsp;</a></span>operator Degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Angle::operator <a class="el" href="class_ogre_1_1_degree.html">Degree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#acb4fc64359cf3081588bf8a99e0492a6">Ogre::Math::AngleUnitsToDegrees()</a>.</p>

</div>
</div>
<a id="gae40391520c06bafb34a8647931fab8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40391520c06bafb34a8647931fab8e1">&#9670;&nbsp;</a></span>lookRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> Ogre::Math::lookRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rotation matrix from direction and yaw. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>the direction to look in. Must be normalised. </td></tr>
    <tr><td class="paramname">yaw</td><td>the yaw axis to use </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_matrix3.html#ad904362ff107e91ed2881a9802d11979">Ogre::Matrix3::FromAxes()</a>, and <a class="el" href="class_ogre_1_1_vector.html#a43169cee2146a35d14ef47016f565d23">Ogre::Vector&lt; dims, T &gt;::normalisedCopy()</a>.</p>

</div>
</div>
<a id="gaebc7c568cc1d6f13405a756be1af73fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebc7c568cc1d6f13405a756be1af73fa">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> Ogre::TransformBaseReal::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="group___math.html#ga2a819ee09ac0c63510f0079ba2bf2a3f">Ogre::operator*()</a>.</p>

</div>
</div>
<a id="gab3e9b9df69bd3255f3b64254e66c3321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3e9b9df69bd3255f3b64254e66c3321">&#9670;&nbsp;</a></span>intersects() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Math::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_plane.html" title="Defines a plane in 3D space.">Plane</a> / box intersection test. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_plane.html#aa5d44b14d6f032f3e0a26e83589180bca44420e1c49338ae721f298826e164935">Ogre::Plane::BOTH_SIDE</a>, and <a class="el" href="class_ogre_1_1_plane.html#a519225d752a20f3459d2f0cc20346468">Ogre::Plane::getSide()</a>.</p>

</div>
</div>
<a id="gafc5955de7b6ba0dfa860cc751c6321db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc5955de7b6ba0dfa860cc751c6321db">&#9670;&nbsp;</a></span>intersects() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">RayTestResult</a> Ogre::Math::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_ray.html" title="Representation of a ray in space, i.e.">Ray</a> / plane intersection. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_ray.html#afa5b7d11cf16bf35f212f6762a3d40e0">Ogre::Ray::intersects()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_sphere.html#a77798ca00493f6b1f9da7f3eff782642">Ogre::Sphere::intersects()</a>, <a class="el" href="class_ogre_1_1_ray.html#a45ddd7bccb4269f11a9bfebe5bc767c3">Ogre::Ray::intersects()</a>, <a class="el" href="class_ogre_1_1_plane_bounded_volume.html#ae4528e95f68402ad6fea0ff6414dbeb7">Ogre::PlaneBoundedVolume::intersects()</a>, and <a class="el" href="class_ogre_1_1_axis_aligned_box.html#a5a508f817edab7a8d084cffe051d08a7">Ogre::AxisAlignedBox::intersects()</a>.</p>

</div>
</div>
<a id="ga64ed9272da4fcaccd8b1009a31358c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64ed9272da4fcaccd8b1009a31358c61">&#9670;&nbsp;</a></span>intersects() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___math.html#ga3f791f5ff19bd8395f0008085e68bf10">RayTestResult</a> Ogre::Math::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discardInside</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_ray.html" title="Representation of a ray in space, i.e.">Ray</a> / sphere intersection. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_ray.html#afa5b7d11cf16bf35f212f6762a3d40e0">Ogre::Ray::intersects()</a>.</p>

</div>
</div>
<a id="ga04786a5e338650d6eafc987b394d221c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04786a5e338650d6eafc987b394d221c">&#9670;&nbsp;</a></span>intersects() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Math::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_sphere.html" title="A sphere primitive, mostly used for bounds checking.">Sphere</a> / plane intersection test. </p>
<dl class="section remark"><dt>Remarks</dt><dd>NB just do a plane.getDistance(sphere.getCenter()) for more detail! </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_sphere.html#a01e832a0542bde80df107ab6b26b56f9">Ogre::Sphere::intersects()</a>.</p>

</div>
</div>
<a id="ga4345346666fd54473efb51a8d194f5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4345346666fd54473efb51a8d194f5e0">&#9670;&nbsp;</a></span>midPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 2, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::midPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector at a point half way between this and the passed in vector. </p>

</div>
</div>
<a id="gaba43517feb82c40ccf1cc571f519866c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba43517feb82c40ccf1cc571f519866c">&#9670;&nbsp;</a></span>randomDeviant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 2, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::randomDeviant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_radian.html">Radian</a>&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a new random vector which deviates from this vector by a given angle in a random direction. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method assumes that the random number generator has already been seeded appropriately. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle at which to deviate in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random vector which deviates from this vector by angle. This vector will not be normalised, normalise it if you wish afterwards. </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#a8070c3fc4eea76025ce9a9072087e540">Ogre::Math::Cos()</a>, <a class="el" href="class_ogre_1_1_math.html#afedce6fa2a819ea7a2420e10fb00a189">Ogre::Math::RangeRandom()</a>, and <a class="el" href="class_ogre_1_1_math.html#a4bf7e39baab4d061f052a9e193d61a1f">Ogre::Math::Sin()</a>.</p>

</div>
</div>
<a id="ga7a92915df275eae8161441024d88c815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a92915df275eae8161441024d88c815">&#9670;&nbsp;</a></span>angleTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_radian.html">Radian</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 2, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::angleTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the oriented angle between 2 vectors. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Vectors do not have to be unit-length but must represent directions. The angle is comprised between 0 and 2 PI. </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#a284c156c5effd4b0d222e4e75ef54af2">Ogre::Math::TWO_PI</a>.</p>

</div>
</div>
<a id="ga00e57f3eda32e31277c439e6a9c929a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00e57f3eda32e31277c439e6a9c929a1">&#9670;&nbsp;</a></span>perpendicular() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8542e5da4c0e0bda0d0bf5745329ea88">Vector2</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 2, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::perpendicular </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a vector perpendicular to this vector (eg an 'up' vector). </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method will return a vector which is perpendicular to this vector. There are an infinite number of possibilities but this method will guarantee to generate one of them. If you need more control you should use the <a class="el" href="class_ogre_1_1_quaternion.html" title="Implementation of a Quaternion, i.e.">Quaternion</a> class. </dd></dl>

</div>
</div>
<a id="ga5b50a2b2697ec1ac684d66af82a03296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b50a2b2697ec1ac684d66af82a03296">&#9670;&nbsp;</a></span>perpendicular() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::perpendicular </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a vector perpendicular to this vector (eg an 'up' vector). </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method will return a vector which is perpendicular to this vector. There are an infinite number of possibilities but this method will guarantee to generate one of them. If you need more control you should use the <a class="el" href="class_ogre_1_1_quaternion.html" title="Implementation of a Quaternion, i.e.">Quaternion</a> class. </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#ae9e2434f05aed3c19b600af6b48c59b7">Ogre::Math::Abs()</a>, and <a class="el" href="class_ogre_1_1_vector.html#a43169cee2146a35d14ef47016f565d23">Ogre::Vector&lt; dims, T &gt;::normalisedCopy()</a>.</p>

</div>
</div>
<a id="gafe9157bbe30e69645edd5c3eddea141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe9157bbe30e69645edd5c3eddea141f">&#9670;&nbsp;</a></span>crossProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::crossProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rkVector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cross-product of 2 vectors, i.e. </p>
<p>the vector that lies perpendicular to them both. </p><dl class="section remark"><dt>Remarks</dt><dd>The cross-product is normally used to calculate the normal vector of a plane, by calculating the cross-product of 2 non-equivalent vectors which lie on the plane (e.g. 2 edges of a triangle). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rkVector</td><td><a class="el" href="class_ogre_1_1_vector.html" title="Standard N-dimensional vector.">Vector</a> which, together with this one, will be used to calculate the cross-product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector which is the result of the cross-product. This vector will <b>NOT</b> be normalised, to maximise efficiency<ul>
<li>call <a class="el" href="class_ogre_1_1_vector.html#a2d9b321bec779fc06de480897cda2027" title="Normalises the vector.">Vector3::normalise</a> on the result if you wish this to be done. As for which side the resultant vector will be on, the returned vector will be on the side from which the arc from 'this' to rkVector is anticlockwise, e.g. UNIT_Y.crossProduct(UNIT_Z) = UNIT_X, whilst UNIT_Z.crossProduct(UNIT_Y) = -UNIT_X. This is because OGRE uses a right-handed coordinate system. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>For a clearer explanation, look a the left and the bottom edges of your monitor's screen. Assume that the first vector is the left edge and the second vector is the bottom edge, both of them starting from the lower-left corner of the screen. The resulting vector is going to be perpendicular to both of them and will go <em>inside</em> the screen, towards the cathode tube (assuming you're using a CRT monitor, of course). </dd></dl>

</div>
</div>
<a id="ga929562516cfb30c38030d9df84945bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga929562516cfb30c38030d9df84945bf3">&#9670;&nbsp;</a></span>midPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::midPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector at a point half way between this and the passed in vector. </p>

</div>
</div>
<a id="ga4f54a2dd6b60dd327fcc8347fc4d853d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f54a2dd6b60dd327fcc8347fc4d853d">&#9670;&nbsp;</a></span>randomDeviant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::randomDeviant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>up</em> = <code><a class="el" href="struct_ogre_1_1_vector_base_3_013_00_01_real_01_4.html#a683a3ae0ddceb4a01a94c0727ca63362">ZERO</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a new random vector which deviates from this vector by a given angle in a random direction. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method assumes that the random number generator has already been seeded appropriately. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle at which to deviate </td></tr>
    <tr><td class="paramname">up</td><td><a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> vector perpendicular to this one (which could generated by cross-product of this vector and any other non-colinear vector). If you choose not to provide this the function will derive one on it's own, however if you provide one yourself the function will be faster (this allows you to reuse up vectors if you call this method more than once) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random vector which deviates from this vector by angle. This vector will not be normalised, normalise it if you wish afterwards. </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_quaternion.html#ac3328c1bb86d17e870c57d52720e2e32">Ogre::Quaternion::FromAngleAxis()</a>, <a class="el" href="class_ogre_1_1_math.html#a284c156c5effd4b0d222e4e75ef54af2">Ogre::Math::TWO_PI</a>, and <a class="el" href="class_ogre_1_1_math.html#ac59f83c8d52180fb9e408bb92d808533">Ogre::Math::UnitRandom()</a>.</p>

</div>
</div>
<a id="gac6ef79da21101ef5a671b0473b849bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6ef79da21101ef5a671b0473b849bc3">&#9670;&nbsp;</a></span>getRotationTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::getRotationTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>fallbackAxis</em> = <code><a class="el" href="struct_ogre_1_1_vector_base_3_013_00_01_real_01_4.html#a683a3ae0ddceb4a01a94c0727ca63362">ZERO</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the shortest arc quaternion to rotate this vector to the destination vector. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If you call this with a dest vector that is close to the inverse of this vector, we will rotate 180 degrees around the 'fallbackAxis' (if specified, or a generated axis if not) since in this case ANY axis of rotation is valid. </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#ae9e2434f05aed3c19b600af6b48c59b7">Ogre::Math::Abs()</a>, <a class="el" href="class_ogre_1_1_vector.html#ae610ff4982860298852e56af6b2fe36c">Ogre::Vector&lt; dims, T &gt;::dotProduct()</a>, <a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Ogre::Quaternion::IDENTITY</a>, <a class="el" href="class_ogre_1_1_quaternion.html#aee94ec9c7de50fe7f774ae4c7e760b65">Ogre::Quaternion::normalise()</a>, <a class="el" href="class_ogre_1_1_math.html#a890336e0e4b6914024bfefd79c08f432">Ogre::Math::RealEqual()</a>, <a class="el" href="class_ogre_1_1_math.html#ab1ee8b71699ce68bd8cf91113ead793e">Ogre::Math::Sqrt()</a>, and <a class="el" href="class_ogre_1_1_vector.html#ae3644507471a16eb79a5b5480a8f4d9f">Ogre::Vector&lt; dims, T &gt;::squaredLength()</a>.</p>

</div>
</div>
<a id="ga24dd46458beb0ea8175bfbf916f09e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24dd46458beb0ea8175bfbf916f09e47">&#9670;&nbsp;</a></span>positionCloses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::positionCloses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-03f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this vector is within a positional tolerance of another vector, also take scale of the vectors into account. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The vector to compare with </td></tr>
    <tr><td class="paramname">tolerance</td><td>The amount (related to the scale of vectors) that distance of the vector may vary by and still be considered close </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_vector.html#ae3644507471a16eb79a5b5480a8f4d9f">Ogre::Vector&lt; dims, T &gt;::squaredLength()</a>.</p>

</div>
</div>
<a id="gad67db81d99c63e2483ff8bc314bfd36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad67db81d99c63e2483ff8bc314bfd36c">&#9670;&nbsp;</a></span>directionEquals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::directionEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this vector is within a directional tolerance of another vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The vector to compare with </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum angle by which the vectors may vary and still be considered equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Both vectors should be normalised. </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#ae9e2434f05aed3c19b600af6b48c59b7">Ogre::Math::Abs()</a>, <a class="el" href="class_ogre_1_1_math.html#a53869f3197b0f991aea7f5edf6b620e2">Ogre::Math::ACos()</a>, <a class="el" href="class_ogre_1_1_vector.html#ae610ff4982860298852e56af6b2fe36c">Ogre::Vector&lt; dims, T &gt;::dotProduct()</a>, and <a class="el" href="class_ogre_1_1_radian.html#accbf4796a0cf6d9703fc8dff822933c9">Ogre::Radian::valueRadians()</a>.</p>

</div>
</div>
<a id="gad52e72c687842e8475a5f24cde8cd858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad52e72c687842e8475a5f24cde8cd858">&#9670;&nbsp;</a></span>primaryAxis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp; <a class="el" href="struct_ogre_1_1_vector_base.html">Ogre::VectorBase</a>&lt; 3, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::primaryAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the primary (dominant) axis from this direction vector. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_math.html#ae9e2434f05aed3c19b600af6b48c59b7">Ogre::Math::Abs()</a>.</p>

</div>
</div>
<a id="ga813d02a0ee4c69dab452767fba1cef8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga813d02a0ee4c69dab452767fba1cef8a">&#9670;&nbsp;</a></span>calculateBasicFaceNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> Ogre::Math::calculateBasicFaceNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a face normal, no w-information. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_vector.html#a2d9b321bec779fc06de480897cda2027">Ogre::Vector&lt; dims, T &gt;::normalise()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group___math.html#gae5ba1fde5b6a0056fd637d4e6b781a2a">Ogre::Math::calculateFaceNormal()</a>, <a class="el" href="struct_ogre_1_1_lod_data_1_1_triangle.html#a4fbb1fc10853e3adc0116c3f5660487e">Ogre::LodData::Triangle::computeNormal()</a>, and <a class="el" href="class_ogre_1_1_plane.html#a93b10ba23a8142123cbcac6e4094f15c">Ogre::Plane::redefine()</a>.</p>

</div>
</div>
<a id="gae5ba1fde5b6a0056fd637d4e6b781a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5ba1fde5b6a0056fd637d4e6b781a2a">&#9670;&nbsp;</a></span>calculateFaceNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> Ogre::Math::calculateFaceNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a face normal, including the w component which is the offset from the origin. </p>

<p class="reference">References <a class="el" href="group___math.html#ga813d02a0ee4c69dab452767fba1cef8a">Ogre::Math::calculateBasicFaceNormal()</a>, and <a class="el" href="class_ogre_1_1_vector.html#ae610ff4982860298852e56af6b2fe36c">Ogre::Vector&lt; dims, T &gt;::dotProduct()</a>.</p>

</div>
</div>
<a id="gabcc5bd946f4c1fb73b851493e17b11b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcc5bd946f4c1fb73b851493e17b11b3">&#9670;&nbsp;</a></span>calculateBasicFaceNormalWithoutNormalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> Ogre::Math::calculateBasicFaceNormalWithoutNormalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a face normal without normalize, no w-information. </p>

<p class="reference">Referenced by <a class="el" href="group___math.html#gabc24b5e11a3a613f60dc44f6056dc61c">Ogre::Math::calculateFaceNormalWithoutNormalize()</a>.</p>

</div>
</div>
<a id="gabc24b5e11a3a613f60dc44f6056dc61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc24b5e11a3a613f60dc44f6056dc61c">&#9670;&nbsp;</a></span>calculateFaceNormalWithoutNormalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a> Ogre::Math::calculateFaceNormalWithoutNormalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac94fc4008c1165dea017263fee56b273">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a face normal without normalize, including the w component which is the offset from the origin. </p>

<p class="reference">References <a class="el" href="group___math.html#gabcc5bd946f4c1fb73b851493e17b11b3">Ogre::Math::calculateBasicFaceNormalWithoutNormalize()</a>, and <a class="el" href="class_ogre_1_1_vector.html#ae610ff4982860298852e56af6b2fe36c">Ogre::Vector&lt; dims, T &gt;::dotProduct()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
