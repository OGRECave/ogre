<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Material Scripts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">13.6</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_material-_scripts.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Material Scripts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Material">Material</a><ul><li class="level2"><a href="#autotoc_md113">lod_strategy</a></li>
<li class="level2"><a href="#autotoc_md114">lod_values</a></li>
<li class="level2"><a href="#autotoc_md115">lod_distances</a></li>
<li class="level2"><a href="#autotoc_md116">receive_shadows</a></li>
<li class="level2"><a href="#autotoc_md117">transparency_casts_shadows</a></li>
<li class="level2"><a href="#autotoc_md118">set_texture_alias</a></li>
</ul>
</li>
<li class="level1"><a href="#Techniques">Techniques</a><ul><li class="level2"><a href="#autotoc_md119">scheme</a></li>
<li class="level2"><a href="#autotoc_md120">lod_index</a></li>
<li class="level2"><a href="#autotoc_md121">shadow_caster_material</a></li>
<li class="level2"><a href="#autotoc_md122">shadow_receiver_material</a></li>
<li class="level2"><a href="#autotoc_md123">gpu_vendor_rule and gpu_device_rule</a></li>
</ul>
</li>
<li class="level1"><a href="#Passes">Passes</a></li>
<li class="level1"><a href="#autotoc_md124">Attribute Descriptions</a><ul><li class="level2"><a href="#autotoc_md125">ambient</a></li>
<li class="level2"><a href="#autotoc_md126">diffuse</a></li>
<li class="level2"><a href="#autotoc_md127">specular</a></li>
<li class="level2"><a href="#autotoc_md128">emissive</a></li>
<li class="level2"><a href="#autotoc_md129">scene_blend</a></li>
<li class="level2"><a href="#autotoc_md130">separate_scene_blend</a></li>
<li class="level2"><a href="#autotoc_md131">scene_blend_op</a></li>
<li class="level2"><a href="#autotoc_md132">separate_scene_blend_op</a></li>
<li class="level2"><a href="#autotoc_md133">depth_check</a></li>
<li class="level2"><a href="#autotoc_md134">depth_write</a></li>
<li class="level2"><a href="#autotoc_md135">depth_func</a></li>
<li class="level2"><a href="#autotoc_md136">depth_bias</a></li>
<li class="level2"><a href="#autotoc_md137">iteration_depth_bias</a></li>
<li class="level2"><a href="#autotoc_md138">alpha_rejection</a></li>
<li class="level2"><a href="#autotoc_md139">alpha_to_coverage</a></li>
<li class="level2"><a href="#autotoc_md140">light_scissor</a></li>
<li class="level2"><a href="#autotoc_md141">light_clip_planes</a></li>
<li class="level2"><a href="#illumination_005fstage">illumination_stage</a></li>
<li class="level2"><a href="#autotoc_md142">normalise_normals</a></li>
<li class="level2"><a href="#autotoc_md143">transparent_sorting</a></li>
<li class="level2"><a href="#autotoc_md144">cull_hardware</a></li>
<li class="level2"><a href="#autotoc_md145">cull_software</a></li>
<li class="level2"><a href="#autotoc_md146">lighting</a></li>
<li class="level2"><a href="#autotoc_md147">shading</a></li>
<li class="level2"><a href="#autotoc_md148">polygon_mode</a></li>
<li class="level2"><a href="#autotoc_md149">polygon_mode_overrideable</a></li>
<li class="level2"><a href="#autotoc_md150">fog_override</a></li>
<li class="level2"><a href="#autotoc_md151">colour_write</a></li>
<li class="level2"><a href="#autotoc_md152">start_light</a></li>
<li class="level2"><a href="#autotoc_md153">max_lights</a></li>
<li class="level2"><a href="#iteration">iteration</a></li>
<li class="level2"><a href="#autotoc_md154">point_size</a></li>
<li class="level2"><a href="#autotoc_md155">point_sprites</a></li>
<li class="level2"><a href="#autotoc_md156">point_size_attenuation</a></li>
<li class="level2"><a href="#autotoc_md157">point_size_min</a></li>
<li class="level2"><a href="#autotoc_md158">point_size_max</a></li>
<li class="level2"><a href="#autotoc_md159">line_width</a></li>
</ul>
</li>
<li class="level1"><a href="#Texture-Units">Texture Units</a><ul><li class="level2"><a href="#autotoc_md160">Available Texture Unit Attributes</a></li>
<li class="level2"><a href="#autotoc_md161">Attribute Descriptions</a></li>
<li class="level2"><a href="#autotoc_md162">texture_alias</a></li>
<li class="level2"><a href="#autotoc_md163">texture</a></li>
<li class="level2"><a href="#autotoc_md164">anim_texture</a></li>
<li class="level2"><a href="#autotoc_md165">cubic_texture</a></li>
<li class="level2"><a href="#autotoc_md166">content_type</a></li>
<li class="level2"><a href="#autotoc_md167">tex_coord_set</a></li>
<li class="level2"><a href="#autotoc_md168">colour_op</a></li>
<li class="level2"><a href="#autotoc_md169">colour_op_ex</a></li>
<li class="level2"><a href="#autotoc_md170">colour_op_multipass_fallback</a></li>
<li class="level2"><a href="#autotoc_md171">alpha_op_ex</a></li>
<li class="level2"><a href="#autotoc_md172">env_map</a></li>
<li class="level2"><a href="#autotoc_md173">scroll</a></li>
<li class="level2"><a href="#autotoc_md174">scroll_anim</a></li>
<li class="level2"><a href="#autotoc_md175">rotate</a></li>
<li class="level2"><a href="#autotoc_md176">rotate_anim</a></li>
<li class="level2"><a href="#autotoc_md177">scale</a></li>
<li class="level2"><a href="#autotoc_md178">wave_xform</a></li>
<li class="level2"><a href="#autotoc_md179">transform</a></li>
<li class="level2"><a href="#autotoc_md180">sampler_ref</a></li>
<li class="level2"><a href="#autotoc_md181">unordered_access_mip</a></li>
</ul>
</li>
<li class="level1"><a href="#Samplers">Samplers</a><ul><li class="level2"><a href="#autotoc_md182">Available parameters</a></li>
<li class="level2"><a href="#autotoc_md183">tex_address_mode</a></li>
<li class="level2"><a href="#autotoc_md184">tex_border_colour</a></li>
<li class="level2"><a href="#autotoc_md185">filtering</a><ul><li class="level3"><a href="#autotoc_md186">Simple Format</a></li>
<li class="level3"><a href="#autotoc_md187">Complex Format</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md188">max_anisotropy</a></li>
<li class="level2"><a href="#autotoc_md189">mipmap_bias</a></li>
<li class="level2"><a href="#autotoc_md190">compare_test</a></li>
<li class="level2"><a href="#autotoc_md191">comp_func</a></li>
</ul>
</li>
<li class="level1"><a href="#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass">Using GPU Programs in a Pass</a></li>
<li class="level1"><a href="#Adding-new-Techniques_002c-Passes_002c-to-copied-materials_003a">Adding new Techniques, Passes, to copied materials</a></li>
<li class="level1"><a href="#Identifying-Texture-Units-to-override-values">Identifying Texture Units to override values</a></li>
</ul>
</div>
<div class="textblock"><p>Sets the specific operation used to blend source and destination pixels together.</p>
<p><a class="anchor" id="md_material_scripts"></a> Material scripts offer you the ability to define complex materials in a script which can be reused easily. Whilst you could set up all materials for a scene in code using the methods of the Material and TextureLayer classes, in practice it's a bit unwieldy. Instead you can store material definitions in text files which can then be loaded whenever required.</p>
<p>It’s important to realise that materials are not loaded completely by the parsing process: only the definition is loaded, no textures or other resources are loaded. This is because it is common to have a large library of materials, but only use a relatively small subset of them in any one scene. To load every material completely in every script would therefore cause unnecessary memory overhead. You can access a ’deferred load’ Material in the normal way (<a class="el" href="class_ogre_1_1_material_manager.html#a100f413d9d2316028e7ae740e5a43161" title="Get the singleton instance.">Ogre::MaterialManager::getSingleton()</a>.getByName()), but you must call the ’load’ method before trying to use it. <a class="el" href="namespace_ogre.html">Ogre</a> does this for you when using the normal material assignment methods of entities etc.</p>
<p>To start with, we only consider fixed-function materials which don’t use vertex, geometry or fragment programs, these are covered later:</p>
<div class="fragment"><div class="line"><span class="comment">// This is a comment</span></div>
<div class="line">material walls/funkywall1</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// first, preferred technique</span></div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// first pass</span></div>
<div class="line">        pass</div>
<div class="line">        {</div>
<div class="line">            ambient 0.5 0.5 0.5</div>
<div class="line">            diffuse 1.0 1.0 1.0</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Texture unit 0</span></div>
<div class="line">            texture_unit </div>
<div class="line">            {</div>
<div class="line">                texture wibbly.jpg</div>
<div class="line">                scroll_anim 0.1 0.0</div>
<div class="line">                wave_xform scale sine 0.0 0.7 0.0 1.0</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// Texture unit 1 (this is a multitexture pass)</span></div>
<div class="line">            texture_unit</div>
<div class="line">            {</div>
<div class="line">                texture wobbly.png</div>
<div class="line">                rotate_anim 0.25</div>
<div class="line">                colour_op add</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Additional RT Shader system options</span></div>
<div class="line">            rtshader_system</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Do lighting calculations per-pixel </span></div>
<div class="line">                lighting_stage per_pixel</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Second technique, can be used as a fallback or LOD level</span></div>
<div class="line">    technique</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// .. and so on</span></div>
<div class="line">    }   </div>
<div class="line">}</div>
</div><!-- fragment --><p>A material can be made up of many <a class="el" href="_material-_scripts.html#Techniques">Techniques</a> - a technique is one way of achieving the effect you are looking for. You can supply more than one technique in order to provide fallback approaches where a card does not have the ability to render the preferred technique, or where you wish to define lower level of detail versions of the material in order to conserve rendering power when objects are more distant.</p>
<p>Each technique can be made up of many <a class="el" href="_material-_scripts.html#Passes">Passes</a>, that is a complete render of the object can be performed multiple times with different settings in order to produce composite effects. <a class="el" href="namespace_ogre.html">Ogre</a> may also split the passes you have defined into many passes at runtime, if you define a pass which uses too many texture units for the card you are currently running on (note that it can only do this if you are not using a fragment program). Each pass has a number of top-level attributes such as ’ambient’ to set the amount &amp; colour of the ambient light reflected by the material. Some of these options do not apply if you are using vertex programs, See <a class="el" href="_material-_scripts.html#Passes">Passes</a> for more details.</p>
<p>Within each pass, there can be zero or many <a class="el" href="_material-_scripts.html#Texture-Units">Texture Units</a> in use. These define the texture to be used, and optionally some blending operations (which use multitexturing) and texture effects.</p>
<p>You can also reference vertex and fragment programs (or vertex and pixel shaders, if you want to use that terminology) in a pass with a given set of parameters. Programs themselves are declared in separate .program scripts (See <a class="el" href="_high-level-_programs.html#Declaring-Vertex_002fGeometry_002fFragment-Programs">GPU Program Scripts</a>) and are used as described in <a class="el" href="_material-_scripts.html#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass">Using GPU Programs in a Pass</a>.</p>
<p><a class="anchor" id="Top_002dlevel-material-attributes"></a></p>
<h1><a class="anchor" id="Material"></a>
Material</h1>
<p>The outermost section of a material definition does not have a lot of attributes of its own (most of the configurable parameters are within the child sections. However, it does have some, and here they are:</p>
<p><a class="anchor" id="lod_005fstrategy"></a> <a class="anchor" id="lod_005fstrategy-1"></a></p>
<h2><a class="anchor" id="autotoc_md113"></a>
lod_strategy</h2>
<p>Sets the name of the LOD strategy to use. Defaults to ’Distance’ which means LOD changes based on distance from the camera. Also supported is ’PixelCount’ which changes LOD based on an estimate of the screen-space pixels affected. </p><dl class="section user"><dt></dt><dd>Format: lod_strategy &lt;name&gt;<br  />
 Default: lod_strategy Distance</dd></dl>
<p><a class="anchor" id="lod_005fvalues"></a> <a class="anchor" id="lod_005fvalues-1"></a></p>
<h2><a class="anchor" id="autotoc_md114"></a>
lod_values</h2>
<p>This attribute defines the values used to control the LOD transition for this material. By setting this attribute, you indicate that you want this material to alter the Technique that it uses based on some metric, such as the distance from the camera, or the approximate screen space coverage. The exact meaning of these values is determined by the option you select for <a href="#lod_005fstrategy">lod_strategy</a> - it is a list of distances for the ’Distance’ strategy, and a list of pixel counts for the ’PixelCount’ strategy, for example. You must give it a list of values, in order from highest LOD value to lowest LOD value, each one indicating the point at which the material will switch to the next LOD. Implicitly, all materials activate LOD index 0 for values less than the first entry, so you do not have to specify ’0’ at the start of the list. You must ensure that there is at least one Technique with a <a href="#lod_005findex">lod_index</a> value for each value in the list (so if you specify 3 values, you must have techniques for LOD indexes 0, 1, 2 and 3). Note you must always have at least one Technique at lod_index 0.</p>
<dl class="section user"><dt></dt><dd>Format: lod_values &lt;value0&gt; &lt;value1&gt; &lt;value2&gt; ...<br  />
 Default: none </dd></dl>
<dl class="section user"><dt></dt><dd>Example: <br  />
 lod_strategy Distance lod_values 300.0 600.5 1200</dd></dl>
<p>The above example would cause the material to use the best Technique at lod_index 0 up to a distance of 300 world units, the best from lod_index 1 from 300 up to 600, lod_index 2 from 600 to 1200, and lod_index 3 from 1200 upwards.</p>
<p><a class="anchor" id="lod_005fdistances"></a> </p>
<h2><a class="anchor" id="autotoc_md115"></a>
lod_distances</h2>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000320">Deprecated:</a></b></dt><dd>This option is deprecated in favour of <a href="#lod_005fvalues">lod_values</a> now. <br  />
</dd></dl>
<p><a class="anchor" id="receive_005fshadows"></a><a class="anchor" id="receive_005fshadows-1"></a></p>
<h2><a class="anchor" id="autotoc_md116"></a>
receive_shadows</h2>
<p>This attribute controls whether objects using this material can have shadows cast upon them.</p>
<dl class="section user"><dt></dt><dd>Format: receive_shadows &lt;on|off&gt;<br  />
 Default: on</dd></dl>
<p>Whether or not an object receives a shadow is the combination of a number of factors, See <a class="el" href="_shadows.html">Shadows</a> for full details; however this allows you to make a material opt-out of receiving shadows if required. Note that transparent materials never receive shadows so this option only has an effect on solid materials.</p>
<p><a class="anchor" id="transparency_005fcasts_005fshadows"></a><a class="anchor" id="transparency_005fcasts_005fshadows-1"></a></p>
<h2><a class="anchor" id="autotoc_md117"></a>
transparency_casts_shadows</h2>
<p>This attribute controls whether transparent materials can cast certain kinds of shadow.</p>
<dl class="section user"><dt></dt><dd>Format: transparency_casts_shadows &lt;on|off&gt;<br  />
 Default: off</dd></dl>
<p>Whether or not an object casts a shadow is the combination of a number of factors, See <a class="el" href="_shadows.html">Shadows</a> for full details; however this allows you to make a transparent material cast shadows, when it would otherwise not. For example, when using texture shadows, transparent materials are normally not rendered into the shadow texture because they should not block light. This flag overrides that.</p>
<p><a class="anchor" id="set_005ftexture_005falias"></a><a class="anchor" id="set_005ftexture_005falias-1"></a></p>
<h2><a class="anchor" id="autotoc_md118"></a>
set_texture_alias</h2>
<p>This attribute associates a texture alias with a texture name.</p>
<dl class="section user"><dt></dt><dd>Format: set_texture_alias &lt;alias name&gt; &lt;texture name&gt;</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000321">Deprecated:</a></b></dt><dd>texture aliases are a restricted version of <a class="el" href="_scripts.html#Script-Variables">Script Variables</a>, which you should instead.</dd></dl>
<h1><a class="anchor" id="Techniques"></a>
Techniques</h1>
<p>A "technique" section in your material script encapsulates a single method of rendering an object. The simplest of material definitions only contains a single technique, however since PC hardware varies quite greatly in it’s capabilities, you can only do this if you are sure that every card for which you intend to target your application will support the capabilities which your technique requires. In addition, it can be useful to define simpler ways to render a material if you wish to use material LOD, such that more distant objects use a simpler, less performance-hungry technique.</p>
<p>When a material is used for the first time, it is ’compiled’. That involves scanning the techniques which have been defined, and marking which of them are supportable using the current rendering API and graphics card. If no techniques are supportable, your material will render as blank white. The compilation examines a number of things, such as:</p>
<ul>
<li>The number of texture_unit entries in each pass<br  />
 Note that if the number of texture_unit entries exceeds the number of texture units in the current graphics card, the technique may still be supportable so long as a fragment program is not being used. In this case, <a class="el" href="namespace_ogre.html">Ogre</a> will split the pass which has too many entries into multiple passes for the less capable card, and the multitexture blend will be turned into a multipass blend (See <a href="#colour_005fop_005fmultipass_005ffallback">colour_op_multipass_fallback</a>).</li>
<li>Whether vertex, geometry or fragment programs are used, and if so which syntax they use (e.g. vs_1_1, ps_2_x, arbfp1 etc.)</li>
<li>Other effects like cube mapping and dot3 blending</li>
<li>Whether the vendor or device name of the current graphics card matches some user-specified rules</li>
</ul>
<p><br  />
</p>
<p>In a material script, techniques must be listed in order of preference, i.e. the earlier techniques are preferred over the later techniques. This normally means you will list your most advanced, most demanding techniques first in the script, and list fallbacks afterwards.</p>
<p>To help clearly identify what each technique is used for, the technique can be named but its optional. Techniques not named within the script will take on a name that is the technique index number. For example: the first technique in a material is index 0, its name would be "0" if it was not given a name in the script. The technique name must be unique within the material or else the final technique is the resulting merge of all techniques with the same name in the material. A warning message is posted in the Ogre.log if this occurs. Named techniques can help when inheriting a material and modifying an existing technique: (See <a class="el" href="_scripts.html#Script-Inheritance">Script Inheritance</a>)</p>
<dl class="section user"><dt></dt><dd>Format: technique name</dd></dl>
<p>Techniques have only a small number of attributes of their own:</p>
<ul>
<li><a href="#scheme">scheme</a></li>
<li><a href="#lod_005findex">lod_index</a> (and also see <a href="#lod_005fdistances">lod_distances</a> in the parent material)</li>
<li><a href="#shadow_005fcaster_005fmaterial">shadow_caster_material</a></li>
<li><a href="#shadow_005freceiver_005fmaterial">shadow_receiver_material</a></li>
<li><a href="#gpu_005fvendor_005frule">gpu_vendor_rule</a></li>
<li><a href="#gpu_005fdevice_005frule">gpu_device_rule</a></li>
</ul>
<p><a class="anchor" id="scheme"></a><a class="anchor" id="scheme-1"></a></p>
<h2><a class="anchor" id="autotoc_md119"></a>
scheme</h2>
<p>Sets the ’scheme’ this Technique belongs to. Material schemes are used to control top-level switching from one set of techniques to another. For example, you might use this to define ’high’, ’medium’ and ’low’ complexity levels on materials to allow a user to pick a performance / quality ratio. Another possibility is that you have a fully HDR-enabled pipeline for top machines, rendering all objects using unclamped shaders, and a simpler pipeline for others; this can be implemented using schemes. The active scheme is typically controlled at a viewport level, and the active one defaults to ’Default’.</p>
<dl class="section user"><dt></dt><dd>Format: scheme &lt;name&gt;<br  />
 Example: scheme hdr<br  />
 Default: scheme Default</dd></dl>
<p><a class="anchor" id="lod_005findex"></a><a class="anchor" id="lod_005findex-1"></a></p>
<h2><a class="anchor" id="autotoc_md120"></a>
lod_index</h2>
<p>Sets the level-of-detail (LOD) index this Technique belongs to.</p>
<dl class="section user"><dt></dt><dd>Format: lod_index &lt;number&gt;<br  />
 NB Valid values are 0 (highest level of detail) to 65535, although this is unlikely. You should not leave gaps in the LOD indexes between Techniques.</dd></dl>
<dl class="section user"><dt></dt><dd>Example: lod_index 1</dd></dl>
<p>All techniques must belong to a LOD index, by default they all belong to index 0, i.e. the highest LOD. Increasing indexes denote lower levels of detail. You can (and often will) assign more than one technique to the same LOD index, what this means is that OGRE will pick the best technique of the ones listed at the same LOD index. For readability, it is advised that you list your techniques in order of LOD, then in order of preference, although the latter is the only prerequisite (OGRE determines which one is ’best’ by which one is listed first). You must always have at least one Technique at lod_index 0. The distance at which a LOD level is applied is determined by the lod_distances attribute of the containing material, See <a href="#lod_005fdistances">lod_distances</a> for details.</p>
<dl class="section user"><dt></dt><dd>Default: lod_index 0</dd></dl>
<p>Techniques also contain one or more <a class="el" href="_material-_scripts.html#Passes">Passes</a> (and there must be at least one).</p>
<p><a class="anchor" id="shadow_005fcaster_005fmaterial"></a><a class="anchor" id="shadow_005fcaster_005fmaterial-1"></a></p>
<h2><a class="anchor" id="autotoc_md121"></a>
shadow_caster_material</h2>
<p>When using <a class="el" href="_shadows.html#Texture_002dbased-Shadows">Texture-based Shadows</a> you can specify an alternate material to use when rendering the object using this material into the shadow texture. This is like a more advanced version of using <code>shadow_caster_vertex_program</code>, however note that for the moment you are expected to render the shadow in one pass, i.e. only the first pass is respected.</p>
<p><a class="anchor" id="shadow_005freceiver_005fmaterial"></a><a class="anchor" id="shadow_005freceiver_005fmaterial-1"></a></p>
<h2><a class="anchor" id="autotoc_md122"></a>
shadow_receiver_material</h2>
<p>When using <a class="el" href="_shadows.html#Texture_002dbased-Shadows">Texture-based Shadows</a> you can specify an alternate material to use when performing the receiver shadow pass. This is like a more advanced version of using <code>shadow_receiver_vertex_program</code> and <code>shadow_receiver_fragment_program</code>, however note that for the moment you are expected to render the shadow in one pass, i.e. only the first pass is respected.</p>
<dl class="section note"><dt>Note</dt><dd>This explicit ’receiver’ pass is only done when you’re <b>not</b> using <a class="el" href="_shadows.html#Integrated-Texture-Shadows">Integrated Texture Shadows</a> - i.e. the shadow rendering is done separately (either as a modulative pass, or a masked light pass).</dd></dl>
<p><a class="anchor" id="gpu_005fvendor_005frule"></a><a class="anchor" id="gpu_005fdevice_005frule"></a><a class="anchor" id="gpu_005fvendor_005frule-and-gpu_005fdevice_005frule"></a></p>
<h2><a class="anchor" id="autotoc_md123"></a>
gpu_vendor_rule and gpu_device_rule</h2>
<p>Although <a class="el" href="namespace_ogre.html">Ogre</a> does a good job of detecting the capabilities of graphics cards and setting the supportability of techniques from that, occasionally card-specific behaviour exists which is not necessarily detectable and you may want to ensure that your materials go down a particular path to either use or avoid that behaviour. This is what these rules are for - you can specify matching rules so that a technique will be considered supportable only on cards from a particular vendor, or which match a device name pattern, or will be considered supported only if they <b>don’t</b> fulfil such matches. The format of the rules are as follows:</p>
<dl class="section user"><dt></dt><dd>gpu_vendor_rule &lt;include|exclude&gt; &lt;vendor_name&gt;<br  />
 gpu_device_rule &lt;include|exclude&gt; &lt;device_pattern&gt; [case_sensitive]</dd></dl>
<p>An ’include’ rule means that the technique will only be supported if one of the include rules is matched (if no include rules are provided, anything will pass). An ’exclude’ rules means that the technique is considered unsupported if any of the exclude rules are matched. You can provide as many rules as you like, although &lt;vendor_name&gt; and &lt;device_pattern&gt; must obviously be unique. The valid list of &lt;vendor_name&gt; values is currently ’nvidia’, ’ati’, ’intel’, ’s3’, ’matrox’ and ’3dlabs’. &lt;device_pattern&gt; can be any string, and you can use wildcards (’*’) if you need to match variants. Here’s an example:</p>
<dl class="section user"><dt></dt><dd>gpu_vendor_rule include nvidia<br  />
 gpu_vendor_rule include intel<br  />
 gpu_device_rule exclude *950*</dd></dl>
<p>These rules, if all included in one technique, will mean that the technique will only be considered supported on graphics cards made by NVIDIA and Intel, and so long as the device name doesn’t have ’950’ in it.</p>
<p>Note that these rules can only mark a technique ’unsupported’ when it would otherwise be considered ’supported’ judging by the hardware capabilities. Even if a technique passes these rules, it is still subject to the usual hardware support tests.</p>
<h1><a class="anchor" id="Passes"></a>
Passes</h1>
<p>A pass is a single render of the geometry in question; a single call to the rendering API with a certain set of rendering properties. A technique can have between one and 16 passes, although clearly the more passes you use, the more expensive the technique will be to render.</p>
<p>To help clearly identify what each pass is used for, the pass can be named but its optional. Passes not named within the script will take on a name that is the pass index number. For example: the first pass in a technique is index 0 so its name would be "0" if it was not given a name in the script. The pass name must be unique within the technique or else the final pass is the resulting merge of all passes with the same name in the technique. A warning message is posted in the Ogre.log if this occurs. Named passes can help when inheriting a material and modifying an existing pass: (See <a class="el" href="_scripts.html#Script-Inheritance">Script Inheritance</a>)</p>
<p>Passes have a set of global attributes (described below) and optionally</p><ul>
<li>zero or more nested texture_unit entries (See <a class="el" href="_material-_scripts.html#Texture-Units">Texture Units</a>)</li>
<li>references to shader programs (See <a class="el" href="_material-_scripts.html#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass">Using GPU Programs in a Pass</a>)</li>
<li>additional instructions for the RTSS (See <a class="el" href="rtss.html#rtss_custom_mat">RTSS Pass properties</a>)</li>
</ul>
<p>Here are the attributes you can use in a ’pass’ section of a .material script:</p>
<ul>
<li><a href="#ambient">ambient</a></li>
<li><a href="#diffuse">diffuse</a></li>
<li><a href="#specular">specular</a></li>
<li><a href="#emissive">emissive</a></li>
<li><a href="#scene_005fblend">scene_blend</a></li>
<li><a href="#separate_005fscene_005fblend">separate_scene_blend</a></li>
<li><a href="#scene_005fblend_005fop">scene_blend_op</a></li>
<li><a href="#separate_005fscene_005fblend_005fop">separate_scene_blend_op</a></li>
<li><a href="#depth_005fcheck">depth_check</a></li>
<li><a href="#depth_005fwrite">depth_write</a></li>
<li><a href="#depth_005ffunc">depth_func</a></li>
<li><a href="#depth_005fbias">depth_bias</a></li>
<li><a href="#iteration_005fdepth_005fbias">iteration_depth_bias</a></li>
<li><a href="#alpha_005frejection">alpha_rejection</a></li>
<li><a href="#alpha_005fto_005fcoverage">alpha_to_coverage</a></li>
<li><a href="#light_005fscissor">light_scissor</a></li>
<li><a href="#light_005fclip_005fplanes">light_clip_planes</a></li>
<li><a href="#illumination_005fstage">illumination_stage</a></li>
<li><a href="#transparent_005fsorting">transparent_sorting</a></li>
<li><a href="#normalise_005fnormals">normalise_normals</a></li>
<li><a href="#cull_005fhardware">cull_hardware</a></li>
<li><a href="#cull_005fsoftware">cull_software</a></li>
<li><a href="#lighting">lighting</a></li>
<li><a href="#shading">shading</a></li>
<li><a href="#polygon_005fmode">polygon_mode</a></li>
<li><a href="#polygon_005fmode_005foverrideable">polygon_mode_overrideable</a></li>
<li><a href="#fog_005foverride">fog_override</a></li>
<li><a href="#colour_005fwrite">colour_write</a></li>
<li><a href="#max_005flights">max_lights</a></li>
<li><a href="#start_005flight">start_light</a></li>
<li><a href="#iteration">iteration</a></li>
<li><a href="#point_005fsize">point_size</a></li>
<li><a href="#point_005fsprites">point_sprites</a></li>
<li><a href="#point_005fsize_005fattenuation">point_size_attenuation</a></li>
<li><a href="#point_005fsize_005fmin">point_size_min</a></li>
<li><a href="#point_005fsize_005fmax">point_size_max</a></li>
<li><a href="#line_width">line_width</a></li>
</ul>
<p><a class="anchor" id="Attribute-Descriptions"></a></p>
<h1><a class="anchor" id="autotoc_md124"></a>
Attribute Descriptions</h1>
<p><a class="anchor" id="ambient"></a><a class="anchor" id="ambient-1"></a></p>
<h2><a class="anchor" id="autotoc_md125"></a>
ambient</h2>
<p>Sets the ambient colour reflectance properties of this pass.</p>
<dl class="section user"><dt></dt><dd>Format: ambient (&lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]| vertexcolour)<br  />
 NB valid colour values are between 0.0 and 1.0.</dd></dl>
<p>This property determines how much ambient light (directionless global light) is reflected. The default is full white, meaning objects are completely globally illuminated. Reduce this if you want to see diffuse or specular light effects, or change the blend of colours to make the object have a base colour other than white.</p>
<p>It is also possible to make the ambient reflectance track the vertex colour as defined in the mesh instead of the colour values. </p><dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see <a class="el" href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Ogre::Pass::setLightingEnabled</a>), or, if any texture layer has a <a class="el" href="group___materials.html#ggabcbb38d1ac195e4be401f85b7ab0da8fa870cf51ff1ccd919cf710bcb3b4e6432" title="Replace all colour with texture with no adjustment.">Ogre::LBO_REPLACE</a> attribute. </dd>
<dd>
When using shader programs, you have to explicitely forward this property in the <a class="el" href="_high-level-_programs.html#Program-Parameter-Specification">Parameter specification</a></dd></dl>
<dl class="section user"><dt></dt><dd>Example: ambient 0.0 0.8 0.0 </dd></dl>
<dl class="section user"><dt></dt><dd>Default: ambient 1.0 1.0 1.0 1.0</dd></dl>
<p><a class="anchor" id="diffuse"></a><a class="anchor" id="diffuse-1"></a></p>
<h2><a class="anchor" id="autotoc_md126"></a>
diffuse</h2>
<p>Sets the diffuse colour reflectance properties of this pass. </p><dl class="section user"><dt></dt><dd>Format: diffuse (&lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]| vertexcolour)<br  />
 NB valid colour values are between 0.0 and 1.0.</dd></dl>
<p>This property determines how much diffuse light (light from instances of the Light class in the scene) is reflected. The default is full white, meaning objects reflect the maximum white light they can from Light objects.</p>
<p>It is also possible to make the diffuse reflectance track the vertex colour as defined in the mesh instead of the colour values. </p><dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see <a class="el" href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Ogre::Pass::setLightingEnabled</a>), or, if any texture layer has a <a class="el" href="group___materials.html#ggabcbb38d1ac195e4be401f85b7ab0da8fa870cf51ff1ccd919cf710bcb3b4e6432" title="Replace all colour with texture with no adjustment.">Ogre::LBO_REPLACE</a> attribute. </dd>
<dd>
When using shader programs, you have to explicitely forward this property in the <a class="el" href="_high-level-_programs.html#Program-Parameter-Specification">Parameter specification</a></dd></dl>
<dl class="section user"><dt></dt><dd>Example: diffuse 1.0 0.5 0.5 </dd></dl>
<dl class="section user"><dt></dt><dd>Default: diffuse 1.0 1.0 1.0 1.0</dd></dl>
<p><a class="anchor" id="specular"></a><a class="anchor" id="specular-1"></a></p>
<h2><a class="anchor" id="autotoc_md127"></a>
specular</h2>
<p>Sets the specular colour reflectance properties of this pass. </p><dl class="section user"><dt></dt><dd>Format: specular (&lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]| vertexcolour) &lt;shininess&gt;<br  />
 NB valid colour values are between 0.0 and 1.0. Shininess can be any value greater than 0.</dd></dl>
<p>This property determines how much specular light (highlights from instances of the Light class in the scene) is reflected. The default is to reflect no specular light. The colour of the specular highlights is determined by the colour parameters, and the size of the highlights by the separate shininess parameter. It is also possible to make the specular reflectance track the vertex colour as defined in the mesh instead of the colour values.</p>
<p>The higher the value of the shininess parameter, the sharper the highlight i.e. the radius is smaller. Beware of using shininess values in the range of 0 to 1 since this causes the the specular colour to be applied to the whole surface that has the material applied to it. When the viewing angle to the surface changes, ugly flickering will also occur when shininess is in the range of 0 to 1. Shininess values between 1 and 128 work best in both DirectX and OpenGL renderers. </p><dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see <a class="el" href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Ogre::Pass::setLightingEnabled</a>), or, if any texture layer has a <a class="el" href="group___materials.html#ggabcbb38d1ac195e4be401f85b7ab0da8fa870cf51ff1ccd919cf710bcb3b4e6432" title="Replace all colour with texture with no adjustment.">Ogre::LBO_REPLACE</a> attribute. </dd>
<dd>
When using shader programs, you have to explicitely forward this property in the <a class="el" href="_high-level-_programs.html#Program-Parameter-Specification">Parameter specification</a></dd></dl>
<dl class="section user"><dt></dt><dd>Example: specular 1.0 1.0 1.0 12.5</dd></dl>
<dl class="section user"><dt></dt><dd>Default: specular 0.0 0.0 0.0 0.0 0.0</dd></dl>
<p><a class="anchor" id="emissive"></a><a class="anchor" id="emissive-1"></a></p>
<h2><a class="anchor" id="autotoc_md128"></a>
emissive</h2>
<p>Sets the amount of self-illumination an object has.</p>
<dl class="section user"><dt></dt><dd>Format: emissive (&lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]| vertexcolour)<br  />
 NB valid colour values are between 0.0 and 1.0.</dd></dl>
<p>Unlike the name suggests, this object doesn’t act as a light source for other objects in the scene (if you want it to, you have to create a light which is centered on the object). If an object is self-illuminating, it does not need external sources to light it, ambient or otherwise. It's like the object has it's own personal ambient light. This property is rarely useful since you can already specify per-pass ambient light, but is here for completeness.</p>
<p>It is also possible to make the emissive reflectance track the vertex colour as defined in the mesh instead of the colour values. </p><dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see <a class="el" href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Ogre::Pass::setLightingEnabled</a>), or, if any texture layer has a <a class="el" href="group___materials.html#ggabcbb38d1ac195e4be401f85b7ab0da8fa870cf51ff1ccd919cf710bcb3b4e6432" title="Replace all colour with texture with no adjustment.">Ogre::LBO_REPLACE</a> attribute. </dd>
<dd>
When using shader programs, you have to explicitely forward this property in the <a class="el" href="_high-level-_programs.html#Program-Parameter-Specification">Parameter specification</a></dd></dl>
<dl class="section user"><dt></dt><dd>Example: emissive 1.0 0.0 0.0 </dd></dl>
<dl class="section user"><dt></dt><dd>Default: emissive 0.0 0.0 0.0 0.0</dd></dl>
<p><a class="anchor" id="scene_005fblend"></a><a class="anchor" id="scene_005fblend-1"></a></p>
<h2><a class="anchor" id="autotoc_md129"></a>
scene_blend</h2>
<p>Sets the kind of blending this pass has with the existing contents of the scene.</p>
<p>Whereas the texture blending operations seen in the texture_unit entries are concerned with blending between texture layers, this blending is about combining the output of this pass as a whole with the existing contents of the rendering target. This blending therefore allows object transparency and other special effects.</p>
<p>There are 2 formats, one using predefined blend types, the other allowing a roll-your-own approach using source and destination factors. </p><dl class="section user"><dt></dt><dd>Format1: scene_blend &lt;blend_type&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: scene_blend add</dd></dl>
<p>This is the simpler form, where the most commonly used blending modes are enumerated using a single parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend_type</td><td><dl compact="compact">
<dt>add </dt>
<dd><p class="startdd">The colour of the rendering output is added to the scene. Good for explosions, flares, lights, ghosts etc.</p>
<p class="enddd">Equivalent to ’scene_blend one one’. </p>
</dd>
<dt>modulate </dt>
<dd><p class="startdd">The colour of the rendering output is multiplied with the scene contents. Generally colours and darkens the scene, good for smoked glass, semi-transparent objects etc.</p>
<p class="enddd">Equivalent to ’scene_blend dest_colour zero’. </p>
</dd>
<dt>colour_blend </dt>
<dd><p class="startdd">Colour the scene based on the brightness of the input colours, but don’t darken.</p>
<p class="enddd">Equivalent to ’scene_blend src_colour one_minus_src_colour’ </p>
</dd>
<dt>alpha_blend </dt>
<dd><p class="startdd">The alpha value of the rendering output is used as a mask.</p>
<p class="enddd">Equivalent to ’scene_blend src_alpha one_minus_src_alpha’ </p>
</dd>
</dl>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd>Format2: scene_blend &lt;sourceFactor&gt; &lt;destFactor&gt;</dd></dl>
<p>This version of the method allows complete control over the blending operation, by specifying the source and destination blending factors.</p>
<p>By default the operation is <a class="el" href="group___materials.html#ggaa7a12a72231aedf6e33d58aafc11214aa188aee58620b3275f1a45c7c80df4bc7">Ogre::SBO_ADD</a>, which creates this equation</p>
<p>$$final = (passOutput * sourceFactor) + (frameBuffer * destFactor)$$</p>
<p>Each of the factors is specified as one of <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213" title="Blending factors for manually blending objects with the scene.">Ogre::SceneBlendFactor</a>.</p>
<p>By setting a different <a class="el" href="group___materials.html#gaa7a12a72231aedf6e33d58aafc11214a" title="Blending operations controls how objects are blended into the scene.">Ogre::SceneBlendOperation</a> you can achieve a different effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceFactor</td><td>The source factor in the above calculation, i.e. multiplied by the output of the Pass. </td></tr>
    <tr><td class="paramname">destFactor</td><td>The destination factor in the above calculation, i.e. multiplied by the Frame Buffer contents.</td></tr>
  </table>
  </dd>
</dl>
<p>Valid values for both parameters are one of <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213" title="Blending factors for manually blending objects with the scene.">Ogre::SceneBlendFactor</a> without the <code>SBF_</code> prefix. E.g. <code>SBF_DEST_COLOUR</code> becomes <code>dest_colour</code>.</p>
<dl class="section user"><dt></dt><dd>Example: scene_blend one one_minus_dest_alpha</dd></dl>
<dl class="section user"><dt></dt><dd>Default: scene_blend one zero (opaque) <br  />
</dd></dl>
<p>Also see <a href="#separate_005fscene_005fblend">separate_scene_blend</a>.</p>
<p><a class="anchor" id="separate_005fscene_005fblend"></a><a class="anchor" id="separate_005fscene_005fblend-1"></a></p>
<h2><a class="anchor" id="autotoc_md130"></a>
separate_scene_blend</h2>
<p>This option operates in exactly the same way as <a href="#scene_005fblend">scene_blend</a>, except that it allows you to specify the operations to perform between the rendered pixel and the frame buffer separately for colour and alpha components. By nature this option is only useful when rendering to targets which have an alpha channel which you’ll use for later processing, such as a render texture. </p><dl class="section user"><dt></dt><dd>Format1: separate_scene_blend &lt;simple_colour_blend&gt; &lt;simple_alpha_blend&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: separate_scene_blend add modulate</dd></dl>
<p>This example would add colour components but multiply alpha components. The blend modes available are as in <a href="#scene_005fblend">scene_blend</a>. The more advanced form is also available: </p><dl class="section user"><dt></dt><dd>Format2: separate_scene_blend &lt;colour_src_factor&gt; &lt;colour_dest_factor&gt; &lt;alpha_src_factor&gt; &lt;alpha_dest_factor&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: separate_scene_blend one one_minus_dest_alpha one one</dd></dl>
<p>Again the options available in the second format are the same as those in the second format of <a href="#scene_005fblend">scene_blend</a>.</p>
<p><a class="anchor" id="scene_005fblend_005fop"></a><a class="anchor" id="scene_005fblend_005fop-1"></a></p>
<h2><a class="anchor" id="autotoc_md131"></a>
scene_blend_op</h2>
<p>This directive changes the operation which is applied between the two components of the scene blending equation</p>
<dl class="section user"><dt></dt><dd>Format: scene_blend_op &lt;op&gt;</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_ogre_1_1_colour_blend_state.html" title="Describes the global blending factors for combining subsequent renders with the existing frame conten...">Ogre::ColourBlendState</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The blending operation mode to use for this pass You may change this to ’add’, ’subtract’, ’reverse_subtract’, ’min’ or ’max’.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="separate_005fscene_005fblend_005fop"></a><a class="anchor" id="separate_005fscene_005fblend_005fop-1"></a></p>
<h2><a class="anchor" id="autotoc_md132"></a>
separate_scene_blend_op</h2>
<p>This directive is as scene_blend_op, except that you can set the operation for colour and alpha separately. </p><dl class="section user"><dt></dt><dd>Format: separate_scene_blend_op &lt;colourOp&gt; &lt;alphaOp&gt; Default: separate_scene_blend_op add add</dd></dl>
<p><a class="anchor" id="depth_005fcheck"></a><a class="anchor" id="depth_005fcheck-1"></a></p>
<h2><a class="anchor" id="autotoc_md133"></a>
depth_check</h2>
<p>Sets whether or not this pass renders with depth-buffer checking on or not. </p><dl class="section user"><dt></dt><dd>Format: depth_check &lt;on|off&gt;</dd></dl>
<p>If depth-buffer checking is on, whenever a pixel is about to be written to the frame buffer the depth buffer is checked to see if the pixel is in front of all other pixels written at that point. If not, the pixel is not written.</p>
<p>If depth checking is off, pixels are written no matter what has been rendered before. Also see setDepthFunction for more advanced depth check configuration. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6" title="Comparison functions used for the depth/stencil buffer operations and others.">Ogre::CompareFunction</a></dd></dl>
<p>Default: depth_check on</p>
<p><a class="anchor" id="depth_005fwrite"></a><a class="anchor" id="depth_005fwrite-1"></a></p>
<h2><a class="anchor" id="autotoc_md134"></a>
depth_write</h2>
<p>Sets whether or not this pass renders with depth-buffer writing on or not.</p>
<dl class="section user"><dt></dt><dd>Format: depth_write &lt;on|off&gt;</dd></dl>
<p>If depth-buffer writing is on, whenever a pixel is written to the frame buffer the depth buffer is updated with the depth value of that new pixel, thus affecting future rendering operations if future pixels are behind this one.</p>
<p>If depth writing is off, pixels are written without updating the depth buffer Depth writing should normally be on but can be turned off when rendering static backgrounds or when rendering a collection of transparent objects at the end of a scene so that they overlap each other correctly.</p>
<dl class="section user"><dt></dt><dd>Default: depth_write on<br  />
</dd></dl>
<p><a class="anchor" id="depth_005ffunc"></a><a class="anchor" id="depth_005ffunc-1"></a></p>
<h2><a class="anchor" id="autotoc_md135"></a>
depth_func</h2>
<p>Sets the function used to compare depth values when depth checking is on. </p><dl class="section user"><dt></dt><dd>Format: depth_func &lt;func&gt;</dd></dl>
<p>If depth checking is enabled (see setDepthCheckEnabled) a comparison occurs between the depth value of the pixel to be written and the current contents of the buffer. This comparison is normally <a class="el" href="group___general.html#gga8e1c2888df9ea68a8fa31b64b6aa67d6a2272d0faefcf5a2e08bbf7d232d7520b" title="Write if (new_Z &lt;= existing_Z)">Ogre::CMPF_LESS_EQUAL</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>one of <a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6" title="Comparison functions used for the depth/stencil buffer operations and others.">Ogre::CompareFunction</a> without the <code>CMPF_</code> prefix. E.g. <code>CMPF_LESS_EQUAL</code> becomes <code>less_equal</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd>Default: depth_func less_equal</dd></dl>
<p><a class="anchor" id="depth_005fbias"></a><a class="anchor" id="depth_005fbias-1"></a></p>
<h2><a class="anchor" id="autotoc_md136"></a>
depth_bias</h2>
<p>Sets the bias applied to the depth value of this pass. </p><dl class="section user"><dt></dt><dd>Format: depth_bias &lt;constantBias&gt; [&lt;slopeScaleBias&gt;]</dd></dl>
<p>When polygons are coplanar, you can get problems with 'depth fighting' where the pixels from the two polys compete for the same screen pixel. This is particularly a problem for decals (polys attached to another surface to represent details such as bulletholes etc.).</p>
<p>A way to combat this problem is to use a depth bias to adjust the depth buffer value used for the decal such that it is slightly higher than the true value, ensuring that the decal appears on top. There are two aspects to the biasing, a constant bias value and a slope-relative biasing value, which varies according to the maximum depth slope relative to the camera, ie:</p>
<p>$$finalBias = maxSlope * slopeScaleBias + constantBias$$</p>
<p>Slope scale biasing is relative to the angle of the polygon to the camera, which makes for a more appropriate bias value, but this is ignored on some older hardware. Constant biasing is expressed as a factor of the minimum depth value, so a value of 1 will nudge the depth by one ’notch’ if you will. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constantBias</td><td>The constant bias value </td></tr>
    <tr><td class="paramname">slopeScaleBias</td><td>The slope-relative bias value</td></tr>
  </table>
  </dd>
</dl>
<p>Also see <a href="#iteration_005fdepth_005fbias">iteration_depth_bias</a></p>
<p><a class="anchor" id="iteration_005fdepth_005fbias"></a><a class="anchor" id="iteration_005fdepth_005fbias-1"></a></p>
<h2><a class="anchor" id="autotoc_md137"></a>
iteration_depth_bias</h2>
<p>Sets an additional bias derived from the number of times a given pass has been iterated. Operates just like <a href="#depth_005fbias">depth_bias</a> except that it applies an additional bias factor to the base depth_bias value, multiplying the provided value by the number of times this pass has been iterated before, through one of the <a href="#iteration">iteration</a> variants. So the first time the pass will get the depth_bias value, the second time it will get depth_bias + iteration_depth_bias, the third time it will get depth_bias + iteration_depth_bias * 2, and so on. The default is zero. </p><dl class="section user"><dt></dt><dd>Format: iteration_depth_bias &lt;bias_per_iteration&gt;</dd></dl>
<p><a class="anchor" id="alpha_005frejection"></a><a class="anchor" id="alpha_005frejection-1"></a></p>
<h2><a class="anchor" id="autotoc_md138"></a>
alpha_rejection</h2>
<p>Sets the way the pass will have use alpha to totally reject pixels from the pipeline. </p><dl class="section user"><dt></dt><dd>Format: alpha_rejection &lt;function&gt; &lt;value&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: alpha_rejection greater_equal 128</dd></dl>
<p>The function parameter can be any of the options listed in the material depth_function attribute. The value parameter can theoretically be any value between 0 and 255, but is best limited to 0 or 128 for hardware compatibility.</p>
<dl class="section note"><dt>Note</dt><dd>Only has an effect with the fixed-function pipeline or the <a class="el" href="rtss.html">Runtime Shader Generation</a></dd></dl>
<dl class="section user"><dt></dt><dd>Default: alpha_rejection always_pass</dd></dl>
<p><a class="anchor" id="alpha_005fto_005fcoverage"></a><a class="anchor" id="alpha_005fto_005fcoverage-1"></a></p>
<h2><a class="anchor" id="autotoc_md139"></a>
alpha_to_coverage</h2>
<p>Sets whether this pass will use ’alpha to coverage’,</p>
<dl class="section user"><dt></dt><dd>Format: alpha_to_coverage &lt;on|off&gt;</dd></dl>
<p>Alpha to coverage performs multisampling on the edges of alpha-rejected textures to produce a smoother result. It is only supported when multisampling is already enabled on the render target, and when the hardware supports alpha to coverage (see RenderSystemCapabilities). The common use for alpha to coverage is foliage rendering and chain-link fence style textures.</p>
<dl class="section user"><dt></dt><dd>Default: alpha_to_coverage off <a class="anchor" id="light_005fscissor"></a></dd></dl>
<p><a class="anchor" id="light_005fscissor-1"></a></p>
<h2><a class="anchor" id="autotoc_md140"></a>
light_scissor</h2>
<p>Sets whether when rendering this pass, rendering will be limited to a screen-space scissor rectangle representing the coverage of the light(s) being used in this pass. </p><dl class="section user"><dt></dt><dd>Format: light_scissor &lt;on|off&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: light_scissor off</dd></dl>
<p>In order to cut down on fillrate when you have a number of fixed-range lights in the scene, you can enable this option to request that during rendering, only the region of the screen which is covered by the lights is rendered. This region is the screen-space rectangle covering the union of the spheres making up the light ranges. Directional lights are ignored for this.</p>
<p>This is only likely to be useful for multipass additive lighting algorithms, where the scene has already been 'seeded' with an ambient pass and this pass is just adding light in affected areas.</p>
<p>When using <a class="el" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af6e22c7a699e9d05015cecff7b68c52a" title="Stencil shadow technique which renders each light as a separate additive pass to the scene.">Ogre::SHADOWTYPE_STENCIL_ADDITIVE</a> or <a class="el" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103" title="Texture-based shadow technique which involves a render-to-texture of the shadow caster and a projecti...">Ogre::SHADOWTYPE_TEXTURE_ADDITIVE</a>, this option is implicitly used for all per-light passes and does not need to be specified. If you are not using shadows or are using a modulative or <a class="el" href="_shadows.html#Integrated-Texture-Shadows">Integrated Texture Shadows</a> then this could be useful.</p>
<p><a class="anchor" id="light_005fclip_005fplanes"></a><a class="anchor" id="light_005fclip_005fplanes-1"></a></p>
<h2><a class="anchor" id="autotoc_md141"></a>
light_clip_planes</h2>
<p>Sets whether when rendering this pass, triangle setup will be limited to clipping volume covered by the light. </p><dl class="section user"><dt></dt><dd>Format: light_clip_planes &lt;on|off&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: light_clip_planes off</dd></dl>
<p>This option will only function if there is a single non-directional light being used in this pass. If there is more than one light, or only directional lights, then no clipping will occur. If there are no lights at all then the objects won’t be rendered at all.</p>
<p>In order to cut down on the geometry set up to render this pass when you have a single fixed-range light being rendered through it, you can enable this option to request that during triangle setup, clip planes are defined to bound the range of the light. In the case of a point light these planes form a cube, and in the case of a spotlight they form a pyramid. Directional lights are never clipped.</p>
<p>This option is only likely to be useful for multipass additive lighting algorithms, where the scene has already been 'seeded' with an ambient pass and this pass is just adding light in affected areas. In addition, it will only be honoured if there is exactly one non-directional light being used in this pass. Also, these clip planes override any user clip planes set on Camera.</p>
<p>When using <a class="el" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af6e22c7a699e9d05015cecff7b68c52a" title="Stencil shadow technique which renders each light as a separate additive pass to the scene.">Ogre::SHADOWTYPE_STENCIL_ADDITIVE</a> or <a class="el" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103" title="Texture-based shadow technique which involves a render-to-texture of the shadow caster and a projecti...">Ogre::SHADOWTYPE_TEXTURE_ADDITIVE</a>, this option is automatically used for all per-light passes if you enable <a class="el" href="class_ogre_1_1_scene_manager.html#a40f296de8599657b70b7072921cbaa16" title="Sets whether when using a built-in additive shadow mode, user clip planes should be used to restrict ...">Ogre::SceneManager::setShadowUseLightClipPlanes</a> and does not need to be specified. It is disabled by default since clip planes have a cost of their own which may not always exceed the benefits they give you. Generally the smaller your lights are the more chance you’ll see a benefit rather than a penalty from clipping.</p>
<dl class="section note"><dt>Note</dt><dd>Only has an effect with the fixed-function pipeline. Exceptions:<ul>
<li>with D3D9, clip planes are even available when shaders are used</li>
<li>with GL1, shaders must write to gl_ClipVertex</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_shadows.html#Integrated-Texture-Shadows">Integrated Texture Shadows</a></dd></dl>
<h2><a class="anchor" id="illumination_005fstage"></a>
illumination_stage</h2>
<p>When using an additive lighting mode (<a class="el" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af6e22c7a699e9d05015cecff7b68c52a" title="Stencil shadow technique which renders each light as a separate additive pass to the scene.">Ogre::SHADOWTYPE_STENCIL_ADDITIVE</a> or <a class="el" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103" title="Texture-based shadow technique which involves a render-to-texture of the shadow caster and a projecti...">Ogre::SHADOWTYPE_TEXTURE_ADDITIVE</a>), the scene is rendered in 3 discrete stages, ambient (or pre-lighting), per-light (once per light, with shadowing) and decal (or post-lighting). Usually OGRE figures out how to categorise your passes automatically, but there are some effects you cannot achieve without manually controlling the illumination. For example specular effects are muted by the typical sequence because all textures are saved until the <a class="el" href="group___materials.html#ggaa6fda2d6bac5df9dc239f566ceed77b6a55b9a19dea33fdf42c614c99c136a52e" title="Post-lighting rendering.">Ogre::IS_DECAL</a> stage which mutes the specular effect. Instead, you could do texturing within the per-light stage if it's possible for your material and thus add the specular on after the decal texturing, and have no post-light rendering.</p>
<p>If you assign an illumination stage to a pass you have to assign it to all passes in the technique otherwise it will be ignored. Also note that whilst you can have more than one pass in each group, they cannot alternate, ie all ambient passes will be before all per-light passes, which will also be before all decal passes. Within their categories the passes will retain their ordering though.</p>
<dl class="section user"><dt></dt><dd>Format: illumination_stage &lt;ambient|per_light|decal&gt; Default: none (autodetect)</dd></dl>
<p><a class="anchor" id="normalise_005fnormals"></a><a class="anchor" id="normalise_005fnormals-1"></a></p>
<h2><a class="anchor" id="autotoc_md142"></a>
normalise_normals</h2>
<p>Sets whether or not this pass renders with all vertex normals being automatically re-normalised.<br  />
 </p><dl class="section user"><dt></dt><dd>Format: normalise_normals &lt;on|off&gt;</dd></dl>
<p>This option can be used to prevent lighting variations when scaling an object - normally because this scaling is hardware based, the normals get scaled too which causes lighting to become inconsistent. By default the SceneManager detects scaled objects and does this for you, but this has an overhead so you might want to turn that off through Ogre::SceneManager::setNormaliseNormalsOnScale(false) and only do it per-Pass when you need to.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000124">Deprecated:</a></b></dt><dd>Only used by fixed function APIs. Use shaders if you rely on this. </dd></dl>
<dl class="section user"><dt></dt><dd>Default: normalise_normals off<br  />
</dd></dl>
<p><a class="anchor" id="transparent_005fsorting"></a><a class="anchor" id="transparent_005fsorting-1"></a></p>
<h2><a class="anchor" id="autotoc_md143"></a>
transparent_sorting</h2>
<p>Sets if transparent textures should be sorted by depth or not. </p><dl class="section user"><dt></dt><dd>Format: transparent_sorting &lt;on|off|force&gt;</dd></dl>
<p>By default all transparent materials are sorted such that renderables furthest away from the camera are rendered first. This is usually the desired behaviour but in certain cases this depth sorting may be unnecessary and undesirable. If for example it is necessary to ensure the rendering order does not change from one frame to the next. In this case you could set the value to ’off’ to prevent sorting.</p>
<p>You can also use the keyword ’force’ to force transparent sorting on, regardless of other circumstances. Usually sorting is only used when the pass is also transparent, and has a depth write or read which indicates it cannot reliably render without sorting. By using ’force’, you tell OGRE to sort this pass no matter what other circumstances are present. </p><dl class="section user"><dt></dt><dd>Default: transparent_sorting on</dd></dl>
<p><a class="anchor" id="cull_005fhardware"></a><a class="anchor" id="cull_005fhardware-1"></a></p>
<h2><a class="anchor" id="autotoc_md144"></a>
cull_hardware</h2>
<p>Sets the hardware culling mode for this pass. </p><dl class="section user"><dt></dt><dd>Format: cull_hardware &lt;clockwise|anticlockwise|none&gt;</dd></dl>
<p>A typical way for the rendering engine to cull triangles is based on the 'vertex winding' of triangles. Vertex winding refers to the direction in which the vertices are passed or indexed to in the rendering operation as viewed from the camera, and will either be clockwise or anticlockwise (that's 'counterclockwise' for you Americans out there ;) The default is <a class="el" href="group___general.html#gga4766f4c65e0a47f0a71c5908944a7a3ca50170ef4a0a12b9fc6bf0c53e582bdf0" title="Hardware culls triangles whose vertices are listed clockwise in the view (default).">Ogre::CULL_CLOCKWISE</a> i.e. that only triangles whose vertices are passed/indexed in anticlockwise order are rendered - this is a common approach and is used in 3D studio models for example. You can alter this culling mode if you wish but it is not advised unless you know what you are doing.</p>
<p>You may wish to use the <a class="el" href="group___general.html#gga4766f4c65e0a47f0a71c5908944a7a3ca7868e61bf90df40d5e04e3a951729248" title="Hardware never culls triangles and renders everything it receives.">Ogre::CULL_NONE</a> option for mesh data that you cull yourself where the vertex winding is uncertain or for creating 2-sided passes.</p>
<dl class="section user"><dt></dt><dd>Default: cull_hardware clockwise<br  />
 NB this is the same as OpenGL’s default but the opposite of Direct3D’s default (because <a class="el" href="namespace_ogre.html">Ogre</a> uses a right-handed coordinate system like OpenGL).</dd></dl>
<p><a class="anchor" id="cull_005fsoftware"></a><a class="anchor" id="cull_005fsoftware-1"></a></p>
<h2><a class="anchor" id="autotoc_md145"></a>
cull_software</h2>
<p>Sets the software culling mode for this pass. </p><dl class="section user"><dt></dt><dd>Format: cull_software &lt;back|front|none&gt;</dd></dl>
<p>In some situations you want to use manual culling of triangles rather than sending the triangles to the hardware and letting it cull them. This setting only takes effect on SceneManager's that use it (since it is best used on large groups of planar world geometry rather than on movable geometry since this would be expensive), but if used can cull geometry before it is sent to the hardware.</p>
<p>In this case the culling is based on whether the ’back’ or ’front’ of the triangle is facing the camera - this definition is based on the face normal (a vector which sticks out of the front side of the polygon perpendicular to the face). Since Ogre expects face normals to be on anticlockwise side of the face, <a class="el" href="group___general.html#gga67144aea217e56725c43541fb064af20adbebf0c209be54ddb19d6097d4f7042f" title="Cull triangles whose normal is pointing away from the camera (default).">Ogre::MANUAL_CULL_BACK</a> is the software equivalent of <a class="el" href="group___general.html#gga4766f4c65e0a47f0a71c5908944a7a3ca50170ef4a0a12b9fc6bf0c53e582bdf0" title="Hardware culls triangles whose vertices are listed clockwise in the view (default).">Ogre::CULL_CLOCKWISE</a> setting, which is why they are both the default. The naming is different to reflect the way the culling is done though, since most of the time face normals are pre-calculated and they don’t have to be the way Ogre expects - you could set <a class="el" href="group___general.html#gga4766f4c65e0a47f0a71c5908944a7a3ca7868e61bf90df40d5e04e3a951729248" title="Hardware never culls triangles and renders everything it receives.">Ogre::CULL_NONE</a> and completely cull in software based on your own face normals, if you have the right SceneManager which uses them.</p>
<dl class="section user"><dt></dt><dd>Default: cull_software back</dd></dl>
<p><a class="anchor" id="lighting"></a><a class="anchor" id="lighting-1"></a></p>
<h2><a class="anchor" id="autotoc_md146"></a>
lighting</h2>
<p>Sets whether or not dynamic lighting is turned on for this pass or not.</p>
<dl class="section user"><dt></dt><dd>Format: lighting &lt;on|off&gt;</dd></dl>
<p>Turning dynamic lighting off makes any ambient, diffuse, specular, emissive and shading properties for this pass redundant. If lighting is turned off, all objects rendered using the pass will be fully lit. When lighting is turned on, objects are lit according to their vertex normals for diffuse and specular light, and globally for ambient and emissive. </p><dl class="section user"><dt></dt><dd>Default: lighting on</dd></dl>
<p><a class="anchor" id="shading"></a><a class="anchor" id="shading-1"></a></p>
<h2><a class="anchor" id="autotoc_md147"></a>
shading</h2>
<p>Sets the kind of shading which should be used for representing dynamic lighting for this pass. </p><dl class="section user"><dt></dt><dd>Format: shading &lt;mode&gt;</dd></dl>
<p>When dynamic lighting is turned on, the effect is to generate colour values at each vertex. Whether these values are interpolated across the face (and how) depends on this setting. The default shading method is <a class="el" href="group___general.html#gga12cb29cae690b696c0f1c4863d8c25a7a2973848ded9ca7c0f93a329e12181feb" title="Colour at each vertex is linearly interpolated across the face.">Ogre::SO_GOURAUD</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>one of <a class="el" href="group___general.html#ga12cb29cae690b696c0f1c4863d8c25a7" title="Light shading modes.">Ogre::ShadeOptions</a> without the <code>SO_</code> prefix. E.g. <code>SO_FLAT</code> becomes <code>flat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd>Default: shading gouraud</dd></dl>
<p><a class="anchor" id="polygon_005fmode"></a><a class="anchor" id="polygon_005fmode-1"></a></p>
<h2><a class="anchor" id="autotoc_md148"></a>
polygon_mode</h2>
<p>Sets how polygons should be rasterised, i.e. whether they should be filled in, or just drawn as lines or points. The default shading method is <a class="el" href="group___general.html#gga2df30008578f1d062a70ec268d1ae016a7e87bf8ec063f4e7bf022a7396346211" title="The normal situation - polygons are filled in.">Ogre::PM_SOLID</a>.</p>
<dl class="section user"><dt></dt><dd>Format: polygon_mode &lt;solid|wireframe|points&gt;</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>one of <a class="el" href="group___general.html#ga2df30008578f1d062a70ec268d1ae016" title="The polygon mode to use when rasterising.">Ogre::PolygonMode</a> without the <code>PM_</code> prefix. E.g. <code>PM_SOLID</code> becomes <code>solid</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd>Default: polygon_mode solid</dd></dl>
<p><a class="anchor" id="polygon_005fmode_005foverrideable"></a><a class="anchor" id="polygon_005fmode_005foverrideable-1"></a></p>
<h2><a class="anchor" id="autotoc_md149"></a>
polygon_mode_overrideable</h2>
<p>Sets whether or not the <a href="#polygon_005fmode">polygon_mode</a> set on this pass can be downgraded by the camera</p>
<dl class="section user"><dt></dt><dd>Format: polygon_mode_overrideable &lt;override&gt;</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">override</td><td>If set to false, this pass will always be rendered at its own chosen polygon mode no matter what the camera says. The default is true.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="fog_005foverride"></a><a class="anchor" id="fog_005foverride-1"></a></p>
<h2><a class="anchor" id="autotoc_md150"></a>
fog_override</h2>
<p>Tells the pass whether it should override the scene fog settings, and enforce it’s own. Very useful for things that you don’t want to be affected by fog when the rest of the scene is fogged, or vice versa. </p><dl class="section user"><dt></dt><dd>Format: fog_override &lt;override?&gt; [&lt;type&gt; &lt;colour&gt; &lt;density&gt; &lt;start&gt; &lt;end&gt;] </dd></dl>
<dl class="section user"><dt></dt><dd>Default: fog_override false</dd></dl>
<p>If you specify ’true’ for the first parameter and you supply the rest of the parameters, you are telling the pass to use these fog settings in preference to the scene settings, whatever they might be. If you specify ’true’ but provide no further parameters, you are telling this pass to never use fogging no matter what the scene says.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td><b>none</b> = No fog, equivalent of just using ’fog_override true’<br  />
 <b>linear</b> = Linear fog from the &lt;start&gt; and &lt;end&gt; distances<br  />
 <b>exp</b> = Fog increases exponentially from the camera (fog = 1/e^(distance * density)), use &lt;density&gt; param to control it<br  />
 <b>exp2</b> = Fog increases at the square of FOG_EXP, i.e. even quicker (fog = 1/e^(distance * density)^2), use &lt;density&gt; param to control it</td></tr>
    <tr><td class="paramname">colour</td><td>Sequence of 3 floating point values from 0 to 1 indicating the red, green and blue intensities</td></tr>
    <tr><td class="paramname">density</td><td>The density parameter used in the ’exp’ or ’exp2’ fog types. Not used in linear mode but param must still be there as a placeholder</td></tr>
    <tr><td class="paramname">start</td><td>The start distance from the camera of linear fog. Must still be present in other modes, even though it is not used.</td></tr>
    <tr><td class="paramname">end</td><td>The end distance from the camera of linear fog. Must still be present in other modes, even though it is not used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd>Example: fog_override true exp 1 1 1 0.002 100 10000</dd></dl>
<p><a class="anchor" id="colour_005fwrite"></a><a class="anchor" id="colour_005fwrite-1"></a></p>
<h2><a class="anchor" id="autotoc_md151"></a>
colour_write</h2>
<p>Sets whether this pass renders with colour writing on or not. Alternatively, it can also be used to enable/disable colour writing specific channels. In the second format, the parameters are in the red, green, blue, alpha order.</p>
<dl class="section user"><dt></dt><dd>Format 1: colour_write &lt;on|off&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Format 2: colour_write &lt;on|off&gt; &lt;on|off&gt; &lt;on|off&gt; &lt;on|off&gt;</dd></dl>
<p>If colour writing is off no visible pixels are written to the screen during this pass. You might think this is useless, but if you render with colour writing off, and with very minimal other settings, you can use this pass to initialise the depth buffer before subsequently rendering other passes which fill in the colour data. This can give you significant performance boosts on some newer cards, especially when using complex fragment programs, because if the depth check fails then the fragment program is never run.</p>
<dl class="section user"><dt></dt><dd>Default: colour_write on<br  />
</dd></dl>
<p><a class="anchor" id="colour_005fmask"></a><a class="anchor" id="colour_005fmask-1"></a></p>
<h2><a class="anchor" id="autotoc_md152"></a>
start_light</h2>
<p>Sets the first light which will be considered for use with this pass. </p><dl class="section user"><dt></dt><dd>Format: start_light &lt;number&gt;</dd></dl>
<p>Normally the lights passed to a pass will start from the beginning of the light list for this object. This option allows you to make this pass start from a higher light index, for example if one of your earlier passes could deal with lights 0-3, and this pass dealt with lights 4+. This option also has an interaction with pass iteration, in that if you choose to iterate this pass per light too, the iteration will only begin from light 4.</p>
<dl class="section user"><dt></dt><dd>Default: start_light 0<br  />
</dd></dl>
<p><a class="anchor" id="max_005flights"></a><a class="anchor" id="max_005flights-1"></a></p>
<h2><a class="anchor" id="autotoc_md153"></a>
max_lights</h2>
<p>Sets the maximum number of lights which will be considered for use with this pass. </p><dl class="section user"><dt></dt><dd>Format: max_lights &lt;number&gt;</dd></dl>
<p>The maximum number of lights which can be used when rendering fixed-function materials is set by the rendering system, and is typically set at 8. When you are using the programmable pipeline (See <a class="el" href="_material-_scripts.html#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass">Using Vertex/Geometry/Fragment Programs in a Pass</a>) this limit is dependent on the program you are running, or, if you use ’iteration once_per_light’ or a variant (See <a class="el" href="_material-_scripts.html#iteration">iteration</a>), it effectively only bounded by the number of passes you are willing to use. If you are not using pass iteration, the light limit applies once for this pass. If you are using pass iteration, the light limit applies across all iterations of this pass - for example if you have 12 lights in range with an ’iteration once_per_light’ setup but your max_lights is set to 4 for that pass, the pass will only iterate 4 times. </p><dl class="section user"><dt></dt><dd>Default: max_lights 8<br  />
</dd></dl>
<h2><a class="anchor" id="iteration"></a>
iteration</h2>
<p>Sets whether or not this pass is iterated, i.e. issued more than once. </p><dl class="section user"><dt></dt><dd>Format 1: iteration &lt;once | once_per_light&gt; [lightType]</dd></dl>
<dl class="section user"><dt></dt><dd>Format 2: iteration &lt;number&gt; [&lt;per_light&gt; [lightType]</dd></dl>
<dl class="section user"><dt></dt><dd>Format 3: iteration &lt;number&gt; [&lt;per_n_lights&gt; &lt;num_lights&gt; [lightType]</dd></dl>
<dl class="section user"><dt></dt><dd>Examples:</dd></dl>
<dl compact="compact">
<dt>iteration once </dt>
<dd><p class="startdd"></p>
<p class="interdd">The pass is only executed once which is the default behaviour.</p>
<p class="enddd"></p>
</dd>
<dt>iteration once_per_light point </dt>
<dd><p class="startdd"></p>
<p class="interdd">The pass is executed once for each point light.</p>
<p class="enddd"></p>
</dd>
<dt>iteration 5 </dt>
<dd><p class="startdd"></p>
<p class="interdd">The render state for the pass will be setup and then the draw call will execute 5 times.</p>
<p class="enddd"></p>
</dd>
<dt>iteration 5 per_light point </dt>
<dd><p class="startdd"></p>
<p class="interdd">The render state for the pass will be setup and then the draw call will execute 5 times. This will be done for each point light.</p>
<p class="enddd"></p>
</dd>
<dt>iteration 1 per_n_lights 2 point </dt>
<dd><p class="startdd"></p>
<p class="interdd">The render state for the pass will be setup and the draw call executed once for every 2 lights.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><br  />
</p>
<p>By default, passes are only issued once. However, if you use the programmable pipeline, or you wish to exceed the normal limits on the number of lights which are supported, you might want to use the once_per_light option. In this case, only light index 0 is ever used, and the pass is issued multiple times, each time with a different light in light index 0. Clearly this will make the pass more expensive, but it may be the only way to achieve certain effects such as per-pixel lighting effects which take into account 1..n lights.</p>
<p>Using a number instead of "once" instructs the pass to iterate more than once after the render state is setup. The render state is not changed after the initial setup so repeated draw calls are very fast and ideal for passes using programmable shaders that must iterate more than once with the same render state i.e. shaders that do fur, motion blur, special filtering.</p>
<p>If you use once_per_light, you should also add an ambient pass to the technique before this pass, otherwise when no lights are in range of this object it will not get rendered at all; this is important even when you have no ambient light in the scene, because you would still want the objects silhouette to appear.</p>
<p>The lightType parameter to the attribute only applies if you use once_per_light, per_light, or per_n_lights and restricts the pass to being run for lights of a single type (either ’point’, ’directional’ or ’spot’). In the example, the pass will be run once per point light. This can be useful because when you’re writing a vertex / fragment program it is a lot easier if you can assume the kind of lights you’ll be dealing with. However at least point and directional lights can be dealt with in one way. Default: iteration once</p>
<p><a class="anchor" id="fur_005fexample"></a></p>
<p>Example: Simple Fur shader material script that uses a second pass with 10 iterations to grow the fur:</p>
<div class="fragment"><div class="line"><span class="comment">// GLSL simple Fur</span></div>
<div class="line">vertex_program GLSLDemo/FurVS glsl </div>
<div class="line">{</div>
<div class="line">  source fur.vert </div>
<div class="line">  default_params</div>
<div class="line">  {</div>
<div class="line">    param_named_auto lightPosition light_position_object_space 0</div>
<div class="line">    param_named_auto eyePosition camera_position_object_space</div>
<div class="line">    param_named_auto passNumber pass_number</div>
<div class="line">    param_named_auto multiPassNumber pass_iteration_number</div>
<div class="line">    param_named furLength <span class="keywordtype">float</span> 0.15</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment_program GLSLDemo/FurFS glsl </div>
<div class="line">{</div>
<div class="line">  source fur.frag </div>
<div class="line">  default_params</div>
<div class="line">  {</div>
<div class="line">    param_named Ka <span class="keywordtype">float</span> 0.2</div>
<div class="line">    param_named Kd <span class="keywordtype">float</span> 0.5</div>
<div class="line">    param_named Ks <span class="keywordtype">float</span> 0.0</div>
<div class="line">    param_named furTU <span class="keywordtype">int</span> 0</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">material Fur</div>
<div class="line">{</div>
<div class="line">  technique GLSL</div>
<div class="line">  {</div>
<div class="line">    pass base_coat</div>
<div class="line">    {</div>
<div class="line">      ambient 0.7 0.7 0.7</div>
<div class="line">      diffuse 0.5 0.8 0.5</div>
<div class="line">      specular 1.0 1.0 1.0 1.5</div>
<div class="line"> </div>
<div class="line">      vertex_program_ref GLSLDemo/FurVS</div>
<div class="line">      {</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      fragment_program_ref GLSLDemo/FurFS </div>
<div class="line">      {</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      texture_unit</div>
<div class="line">      {</div>
<div class="line">        texture Fur.tga</div>
<div class="line">        tex_coord_set 0</div>
<div class="line">        filtering trilinear</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    pass grow_fur</div>
<div class="line">    {</div>
<div class="line">      ambient 0.7 0.7 0.7</div>
<div class="line">      diffuse 0.8 1.0 0.8</div>
<div class="line">      specular 1.0 1.0 1.0 64</div>
<div class="line">      depth_write off</div>
<div class="line"> </div>
<div class="line">      scene_blend src_alpha one</div>
<div class="line">      iteration 10</div>
<div class="line">      </div>
<div class="line">      vertex_program_ref GLSLDemo/FurVS</div>
<div class="line">      {</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      fragment_program_ref GLSLDemo/FurFS</div>
<div class="line">      {</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      texture_unit</div>
<div class="line">      {</div>
<div class="line">        texture Fur.tga</div>
<div class="line">        tex_coord_set 0</div>
<div class="line">        filtering trilinear</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>use gpu program auto parameters <a href="#pass_005fnumber">pass_number</a> and <a href="#pass_005fiteration_005fnumber">pass_iteration_number</a> to tell the vertex, geometry or fragment program the pass number and iteration number.</dd></dl>
<p><a class="anchor" id="point_005fsize"></a><a class="anchor" id="point_005fsize-1"></a></p>
<h2><a class="anchor" id="autotoc_md154"></a>
point_size</h2>
<p>This setting allows you to change the size of points when rendering a point list, or a list of point sprites. The interpretation of this command depends on the <a class="el" href="class_ogre_1_1_pass.html#a3540a0dab9519f146edad630f3c89c22" title="Sets how points are attenuated with distance.">Ogre::Pass::setPointAttenuation</a> option - if it is off (the default), the point size is in screen pixels, if it is on, it expressed as normalised screen coordinates (1.0 is the height of the screen) when the point is at the origin. </p><dl class="section note"><dt>Note</dt><dd>Some drivers have an upper limit on the size of points they support - this can even vary between APIs on the same card! Don't rely on point sizes that cause the point sprites to get very large on screen, since they may get clamped on some cards. Upper sizes can range from 64 to 256 pixels.</dd></dl>
<dl class="section user"><dt></dt><dd>Format: point_size &lt;size&gt; Default: point_size 1.0</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only has an effect with the fixed-function pipeline or the <a class="el" href="rtss.html">Runtime Shader Generation</a></dd></dl>
<p><a class="anchor" id="point_005fsprites"></a><a class="anchor" id="point_005fsprites-1"></a></p>
<h2><a class="anchor" id="autotoc_md155"></a>
point_sprites</h2>
<p>This setting specifies whether or not hardware point sprite rendering is enabled for this pass. Enabling it means that a point list is rendered as a list of quads rather than a list of dots. It is very useful to use this option if you are using a BillboardSet and only need to use point oriented billboards which are all of the same size. You can also use it for any other point list render.</p>
<dl class="section user"><dt></dt><dd>Format: point_sprites &lt;on|off&gt; Default: point_sprites off</dd></dl>
<p><a class="anchor" id="point_005fsize_005fattenuation"></a><a class="anchor" id="point_005fsize_005fattenuation-1"></a></p>
<h2><a class="anchor" id="autotoc_md156"></a>
point_size_attenuation</h2>
<p>Defines whether point size is attenuated with view space distance, and in what fashion.</p>
<dl class="section user"><dt></dt><dd>Format: point_size_attenuation &lt;enabled&gt; [constant linear quadratic] Default: point_size_attenuation off</dd></dl>
<p>When performing point rendering or point sprite rendering, point size can be attenuated with distance. The equation for doing this is</p>
<p>$$attenuation = 1 / (constant + linear * dist + quadratic * d^2)$$</p>
<p>For example, to disable distance attenuation (constant screensize) you would set constant to 1, and linear and quadratic to 0. A standard perspective attenuation would be 0, 1, 0 respectively.</p>
<p>The resulting size is clamped to the minimum and maximum point size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Whether point attenuation is enabled </td></tr>
    <tr><td class="paramname">constant,linear,quadratic</td><td>Parameters to the attenuation function defined above</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only has an effect with the fixed-function pipeline or the <a class="el" href="rtss.html">Runtime Shader Generation</a></dd></dl>
<p><a class="anchor" id="point_005fsize_005fmin"></a><a class="anchor" id="point_005fsize_005fmin-1"></a></p>
<h2><a class="anchor" id="autotoc_md157"></a>
point_size_min</h2>
<p>Sets the minimum point size after attenuation (<a href="#point_005fsize_005fattenuation">point_size_attenuation</a>). For details on the size metrics, See <a href="#point_005fsize">point_size</a>. </p><dl class="section user"><dt></dt><dd>Format: point_size_min &lt;size&gt; Default: point_size_min 0</dd></dl>
<p><a class="anchor" id="point_005fsize_005fmax"></a><a class="anchor" id="point_005fsize_005fmax-1"></a></p>
<h2><a class="anchor" id="autotoc_md158"></a>
point_size_max</h2>
<p>Sets the maximum point size after attenuation (<a href="#point_005fsize_005fattenuation">point_size_attenuation</a>). For details on the size metrics, See <a href="#point_005fsize">point_size</a>. A value of 0 means the maximum is set to the same as the max size reported by the current card. </p><dl class="section user"><dt></dt><dd>Format: point_size_max &lt;size&gt; Default: point_size_max 0</dd></dl>
<p><a class="anchor" id="line_width"></a> </p>
<h2><a class="anchor" id="autotoc_md159"></a>
line_width</h2>
<p>This property determines what width is used to render lines. </p><dl class="section note"><dt>Note</dt><dd>some drivers only support a value of 1.0 here</dd></dl>
<dl class="section user"><dt></dt><dd>Format: line_width &lt;width&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: line_width 1</dd></dl>
<h1><a class="anchor" id="Texture-Units"></a>
Texture Units</h1>
<p>Here are the attributes you can use in a <code>texture_unit</code> section of a .material script:</p>
<p><a class="anchor" id="Available-Texture-Layer-Attributes"></a></p>
<h2><a class="anchor" id="autotoc_md160"></a>
Available Texture Unit Attributes</h2>
<ul>
<li><a href="#texture_005falias">texture_alias</a></li>
<li><a href="#texture">texture</a></li>
<li><a href="#anim_005ftexture">anim_texture</a></li>
<li><a href="#cubic_005ftexture">cubic_texture</a></li>
<li><a href="#tex_005fcoord_005fset">tex_coord_set</a></li>
<li><a href="#colour_005fop">colour_op</a></li>
<li><a href="#colour_005fop_005fex">colour_op_ex</a></li>
<li><a href="#colour_005fop_005fmultipass_005ffallback">colour_op_multipass_fallback</a></li>
<li><a href="#alpha_005fop_005fex">alpha_op_ex</a></li>
<li><a href="#env_005fmap">env_map</a></li>
<li><a href="#scroll">scroll</a></li>
<li><a href="#scroll_005fanim">scroll_anim</a></li>
<li><a href="#rotate">rotate</a></li>
<li><a href="#rotate_005fanim">rotate_anim</a></li>
<li><a href="#scale">scale</a></li>
<li><a href="#wave_005fxform">wave_xform</a></li>
<li><a href="#transform">transform</a></li>
<li><a href="#content_005ftype">content_type</a></li>
<li><a href="#sampler_ref">sampler_ref</a></li>
<li><a href="#unordered_access_mip">unordered_access_mip</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Furthermore all attributes of <a class="el" href="_material-_scripts.html#Samplers">Samplers</a> are available. Using any of them will create a new <a class="el" href="class_ogre_1_1_sampler.html" title="Class which determines how a TextureUnitState accesses data from a Texture.">Ogre::Sampler</a> local to the texture unit. This means that any changes you made to the Default Sampler e.g. via <a class="el" href="class_ogre_1_1_material_manager.html#a9626875e139f48903af4674b6e555125" title="Sets the default texture filtering to be used for loaded textures, for when textures are loaded autom...">Ogre::MaterialManager::setDefaultTextureFiltering</a> have no effect anymore. If several texture units share the same Sampler settings, you are encouraged to reference the same Sampler via <a href="#sampler_ref">sampler_ref</a> for improved performance.</dd></dl>
<p>You can also use nested section in order to use a special add-ins</p><ul>
<li><code>texture_source</code> as a source of texture data, see <a class="el" href="_external-_texture-_sources.html">External Texture Sources</a> for details</li>
<li><code>rtshader_system</code> for additional layer blending options, see <a class="el" href="rtss.html">Runtime Shader Generation</a> for details.</li>
</ul>
<p><a class="anchor" id="Attribute-Descriptions-1"></a></p>
<h2><a class="anchor" id="autotoc_md161"></a>
Attribute Descriptions</h2>
<p><a class="anchor" id="texture_005falias"></a><a class="anchor" id="texture_005falias-1"></a></p>
<h2><a class="anchor" id="autotoc_md162"></a>
texture_alias</h2>
<p>Sets the alias name for this texture unit. </p><dl class="section user"><dt></dt><dd>Format: texture_alias &lt;name&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: texture_alias NormalMap</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000322">Deprecated:</a></b></dt><dd>texture aliases are a restricted version of <a class="el" href="_scripts.html#Script-Variables">Script Variables</a>, which you should instead.</dd></dl>
<p><a class="anchor" id="texture"></a><a class="anchor" id="texture-1"></a></p>
<h2><a class="anchor" id="autotoc_md163"></a>
texture</h2>
<p>Sets the name of the static texture image this layer will use. </p><dl class="section user"><dt></dt><dd>Format: texture &lt;texturename&gt; [&lt;type&gt;] [unlimited | numMipMaps] [&lt;PixelFormat&gt;] [gamma] </dd></dl>
<dl class="section user"><dt></dt><dd>Example: texture funkywall.jpg</dd></dl>
<p>This setting is mutually exclusive with the anim_texture attribute. Note that the texture file cannot include spaces. Those of you Windows users who like spaces in filenames, please get over it and use underscores instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specify a the type of texture to create - the default is ’2d’, but you can override this; here’s the full list: <dl compact="compact">
<dt>1d </dt>
<dd><p class="startdd"></p>
<p class="interdd">A 1-dimensional texture; that is, a texture which is only 1 pixel high. These kinds of textures can be useful when you need to encode a function in a texture and use it as a simple lookup, perhaps in a fragment program. It is important that you use this setting when you use a fragment program which uses 1-dimensional texture coordinates, since GL requires you to use a texture type that matches (D3D will let you get away with it, but you ought to plan for cross-compatibility). Your texture widths should still be a power of 2 for best compatibility and performance.</p>
<p class="enddd"></p>
</dd>
<dt>2d </dt>
<dd><p class="startdd"></p>
<p class="interdd">The default type which is assumed if you omit it, your texture has a width and a height, both of which should preferably be powers of 2, and if you can, make them square because this will look best on the most hardware. These can be addressed with 2D texture coordinates.</p>
<p class="enddd"></p>
</dd>
<dt>3d </dt>
<dd><p class="startdd"></p>
<p class="interdd">A 3 dimensional texture i.e. volume texture. Your texture has a width, a height, both of which should be powers of 2, and has depth. These can be addressed with 3d texture coordinates i.e. through a pixel shader.</p>
<p class="enddd"></p>
</dd>
<dt>cubic </dt>
<dd><p class="startdd"></p>
<p class="enddd">This texture is made up of 6 2D textures which are pasted around the inside of a cube. Can be addressed with 3D texture coordinates and are useful for cubic reflection maps. If the <code>texturename</code> in this format is something like <code>skybox.jpg</code>, the system will expect <code>skybox_px.jpg, skybox_nx.jpg, skybox_py.jpg, skybox_ny.jpg, skybox_pz.jpg, skybox_nz.jpg</code> for the individual faces. For compatibility, the suffixes <code>_lf, _rt, _up, _dn, _fr, _bk</code> are also supported. Alternatively a single file with all faces can be used, if supported by the texture format (e.g. DDS).  </p>
</dd>
</dl>
</td></tr>
    <tr><td class="paramname">numMipMaps</td><td>specify the number of mipmaps to generate for this texture. The default is ’unlimited’ which means mips down to 1x1 size are generated. You can specify a fixed number (even 0) if you like instead. Note that if you use the same texture in many material scripts, the number of mipmaps generated will conform to the number specified in the first texture_unit used to load the texture - so be consistent with your usage.</td></tr>
    <tr><td class="paramname">PixelFormat</td><td>specify the desired pixel format of the texture to create, which may be different to the pixel format of the texture file being loaded. Bear in mind that the final pixel format will be constrained by hardware capabilities so you may not get exactly what you ask for. Names defined in <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c" title="The pixel format used for images, textures, and render surfaces.">Ogre::PixelFormat</a> are valid values.</td></tr>
    <tr><td class="paramname">gamma</td><td>informs the renderer that you want the graphics hardware to perform gamma correction on the texture values as they are sampled for rendering. This is only applicable for textures which have 8-bit colour channels (e.g.PF_R8G8B8). Often, 8-bit per channel textures will be stored in <a href="http://en.wikipedia.org/wiki/Gamma_correction">gamma space</a> in order to increase the precision of the darker colours but this can throw out blending and filtering calculations since they assume linear space colour values. For the best quality shading, you may want to enable gamma correction so that the hardware converts the texture values to linear space for you automatically when sampling the texture, then the calculations in the pipeline can be done in a reliable linear colour space. When rendering to a final 8-bit per channel display, you’ll also want to convert back to gamma space which can be done in your shader (by raising to the power 1/2.2) or you can enable gamma correction on the texture being rendered to or the render window. Note that the ’gamma’ option on textures is applied on loading the texture so must be specified consistently if you use this texture in multiple places.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="anim_005ftexture"></a><a class="anchor" id="anim_005ftexture-1"></a></p>
<h2><a class="anchor" id="autotoc_md164"></a>
anim_texture</h2>
<p>Sets the images to be used in an animated texture layer. There are 2 formats, one for implicitly determined image names, one for explicitly named images. </p><dl class="section user"><dt></dt><dd>Format1 (short): anim_texture &lt;name&gt; &lt;numFrames&gt; &lt;duration&gt;</dd></dl>
<p>Animated textures are just a series of images making up the frames of the animation. All the images must be the same size, and their names must have a frame number appended before the extension, e.g. if you specify a name of "flame.jpg" with 3 frames, the image names must be "flame_0.jpg", "flame_1.jpg" and "flame_2.jpg".</p>
<p>You can change the active frame on a texture layer by calling the <a class="el" href="class_ogre_1_1_texture_unit_state.html#a040a7a49541296837b3e0a0289b7c4c8" title="Changes the active frame in an animated or multi-image texture.">Ogre::TextureUnitState::setCurrentFrame</a> method. </p><dl class="section note"><dt>Note</dt><dd>If you can't make your texture images conform to the naming standard laid out here, you can call the alternative setAnimatedTextureName method which takes an array of names instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The base name of the textures to use e.g. flame.jpg for frames flame_0.jpg, flame_1.jpg etc. </td></tr>
    <tr><td class="paramname">numFrames</td><td>The number of frames in the sequence. </td></tr>
    <tr><td class="paramname">duration</td><td>The length of time it takes to display the whole animation sequence, in seconds. If 0, no automatic transition occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd>Example: anim_texture flame.jpg 5 2.5</dd></dl>
<dl class="section user"><dt></dt><dd>Format2 (long): anim_texture &lt;frame1&gt; &lt;frame2&gt; ... &lt;duration&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: anim_texture flamestart.jpg flamemore.png flameagain.jpg moreflame.jpg lastflame.tga 2.5</dd></dl>
<p>This sets up the same duration animation but from 5 separately named image files. The first format is more concise, but the second is provided if you cannot make your images conform to the naming standard required for it. </p><dl class="section user"><dt></dt><dd>Default: none</dd></dl>
<p><a class="anchor" id="cubic_005ftexture"></a><a class="anchor" id="cubic_005ftexture-1"></a></p>
<h2><a class="anchor" id="autotoc_md165"></a>
cubic_texture</h2>
<p>Sets the images used in a cubic texture, i.e. one made up of 6 individual images making up the faces of a cube or 1 cube texture if supported by the texture format(DDS for example) and rendersystem.. These kinds of textures are used for reflection maps (if hardware supports cubic reflection maps) or skyboxes. There are 2 formats, a brief format expecting image names of a particular format and a more flexible but longer format for arbitrarily named textures. </p><dl class="section user"><dt></dt><dd>Format1 (short): cubic_texture &lt;base_name&gt; &lt;combinedUVW|separateUV&gt;</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000323">Deprecated:</a></b></dt><dd>use the format '<code>texture &lt;basename&gt; cubic</code>' instead</dd></dl>
<dl class="section user"><dt></dt><dd>Format2 (long): cubic_texture &lt;pz&gt; &lt;nz&gt; &lt;nx&gt; &lt;px&gt; &lt;py&gt; &lt;ny&gt; &lt;combinedUVW|separateUV&gt;</dd></dl>
<p>In this case each face is specified explicitly, in case you don’t want to conform to the image naming standards above.</p>
<p>In both cases the final parameter means the following:</p>
<dl compact="compact">
<dt>combinedUVW </dt>
<dd>The 6 textures are combined into a single ’cubic’ texture map which is then addressed using 3D texture coordinates.  </dd>
<dt>separateUV </dt>
<dd>This is no longer supported and behaves like combinedUVW.  </dd>
</dl>
<p><br  />
</p>
<p><a class="anchor" id="content_005ftype"></a></p>
<h2><a class="anchor" id="autotoc_md166"></a>
content_type</h2>
<p>Tells this texture unit where it should get its content from. The default is to get texture content from a named texture, as defined with the <a href="#texture">texture</a>, <a href="#cubic_005ftexture">cubic_texture</a>, <a href="#anim_005ftexture">anim_texture</a> attributes. However you can also pull texture information from other automated sources.</p>
<dl class="section user"><dt></dt><dd>Format: content_type &lt;type&gt; [&lt;compositorName&gt;] [&lt;textureName&gt;] [&lt;mrtIndex&gt;]</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td><dl compact="compact">
<dt>named </dt>
<dd><p class="startdd"></p>
<p class="interdd">The default option, this derives texture content from a texture name, loaded by ordinary means from a file or having been manually created with a given name.</p>
<p class="enddd"></p>
</dd>
<dt>shadow </dt>
<dd><p class="startdd"></p>
<p class="interdd">This option allows you to pull in a shadow texture, and is only valid when you use texture shadows and one of the ’custom sequence’ shadowing types (See <a class="el" href="_shadows.html">Shadows</a>). The shadow texture in question will be from the ’n’th closest light that casts shadows, unless you use light-based pass iteration or the light_start option which may start the light index higher. When you use this option in multiple texture units within the same pass, each one references the next shadow texture. The shadow texture index is reset in the next pass, in case you want to take into account the same shadow textures again in another pass (e.g. a separate specular / gloss pass). By using this option, the correct light frustum projection is set up for you for use in fixed-function, if you use shaders just reference the texture_viewproj_matrix auto parameter in your shader.</p>
<p class="enddd"></p>
</dd>
<dt>compositor </dt>
<dd><p class="startdd"></p>
<p class="interdd">This option allows you to reference a texture from a compositor, and is only valid when the pass is rendered within a compositor sequence. This can be either in a render_scene directive inside a compositor script, or in a general pass in a viewport that has a compositor attached. Note that this is a reference only, meaning that it does not change the render order. You must make sure that the order is reasonable for what you are trying to achieve (for example, texture pooling might cause the referenced texture to be overwritten by something else by the time it is referenced). This can be either in a render_scene directive inside a compositor script, or in a general pass in a viewport that has a compositor attached. Note that this is a reference only, meaning that it does not change the render order. You must make sure that the order is reasonable for what you are trying to achieve (for example, texture pooling might cause the referenced texture to be overwritten by something else by the time it is referenced).</p>
<p class="enddd"></p>
</dd>
</dl>
</td></tr>
  </table>
  </dd>
</dl>
<p>Only valid when content type is compositor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compositorName</td><td>The name of the compositor to reference. </td></tr>
    <tr><td class="paramname">textureName</td><td>The name of the texture to reference. </td></tr>
    <tr><td class="paramname">mrtIndex</td><td>The index of the wanted texture, if referencing an MRT.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd>Example: content_type compositor DepthCompositor OutputTexture</dd></dl>
<dl class="section user"><dt></dt><dd>Default: content_type named</dd></dl>
<p><a class="anchor" id="tex_005fcoord_005fset"></a><a class="anchor" id="tex_005fcoord_005fset-1"></a></p>
<h2><a class="anchor" id="autotoc_md167"></a>
tex_coord_set</h2>
<p>Sets which texture coordinate set is to be used for this texture layer. A mesh can define multiple sets of texture coordinates, this sets which one this material uses.</p>
<dl class="section user"><dt></dt><dd>Format: tex_coord_set &lt;set_num&gt;</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only has an effect with the fixed-function pipeline or the <a class="el" href="rtss.html">Runtime Shader Generation</a></dd></dl>
<dl class="section user"><dt></dt><dd>Example: tex_coord_set 2 </dd></dl>
<dl class="section user"><dt></dt><dd>Default: tex_coord_set 0</dd></dl>
<p><a class="anchor" id="colour_005fop"></a><a class="anchor" id="colour_005fop-1"></a></p>
<h2><a class="anchor" id="autotoc_md168"></a>
colour_op</h2>
<dl class="section note"><dt>Note</dt><dd>Only has an effect with the fixed-function pipeline or the <a class="el" href="rtss.html">Runtime Shader Generation</a></dd></dl>
<p>Determines how the colour of this texture layer is combined with the one below it (or the lighting effect on the geometry if this is the first layer). </p><dl class="section user"><dt></dt><dd>Format: colour_op &lt;op&gt;</dd></dl>
<p>This method is the simplest way to blend texture layers, because it requires only one parameter, gives you the most common blending types, and automatically sets up 2 blending methods: one for if single-pass multitexturing hardware is available, and another for if it is not and the blending must be achieved through multiple rendering passes. It is, however, quite limited and does not expose the more flexible multitexturing operations, simply because these can't be automatically supported in multipass fallback mode. If want to use the fancier options, use <a class="el" href="class_ogre_1_1_texture_unit_state.html#a5f3994ce2f61c6c6fee6fe8f89c9e369" title="Setting advanced blending options.">Ogre::TextureUnitState::setColourOperationEx</a>, but you'll either have to be sure that enough multitexturing units will be available, or you should explicitly set a fallback using <a class="el" href="class_ogre_1_1_texture_unit_state.html#a1c4dcca2a0d343dc6660b9071cd4c79f" title="Sets the multipass fallback operation for this layer, if you used TextureUnitState::setColourOperatio...">Ogre::TextureUnitState::setColourOpMultipassFallback</a>. </p><dl class="section note"><dt>Note</dt><dd>The default method is <a class="el" href="group___materials.html#ggabcbb38d1ac195e4be401f85b7ab0da8fa20815cab41c35f08f3520fb404b95efd" title="Multiply colour components together.">Ogre::LBO_MODULATE</a> for all layers. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>One of the <a class="el" href="group___materials.html#gabcbb38d1ac195e4be401f85b7ab0da8f" title="List of valid texture blending operations, for use with TextureUnitState::setColourOperation.">Ogre::LayerBlendOperation</a> enumerated blending types. Without the <code>LBO_</code> prefix. E.g. <code>LBO_REPLACE</code> becomes <code>replace</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd>Default: colour_op modulate</dd></dl>
<p><a class="anchor" id="colour_005fop_005fex"></a><a class="anchor" id="colour_005fop_005fex-1"></a></p>
<h2><a class="anchor" id="autotoc_md169"></a>
colour_op_ex</h2>
<dl class="section note"><dt>Note</dt><dd>Only has an effect with the fixed-function pipeline or the <a class="el" href="rtss.html">Runtime Shader Generation</a> </dd></dl>
<dl class="section user"><dt></dt><dd>Format: colour_op_ex &lt;op&gt; &lt;source1&gt; &lt;source2&gt; [&lt;manualBlend&gt;] [&lt;arg1&gt;] [&lt;arg2&gt;] </dd></dl>
<dl class="section user"><dt></dt><dd>Example colour_op_ex add_signed src_manual src_current 0.5</dd></dl>
<p>This is an extended version of the <a class="el" href="class_ogre_1_1_texture_unit_state.html#aa47f44936c3090c97d8b4179333a208b" title="Determines how this texture layer is combined with the one below it (or the diffuse colour of the geo...">Ogre::TextureUnitState::setColourOperation</a> method which allows extremely detailed control over the blending applied between this and earlier layers. See the Warning below about the issues between mulitpass and multitexturing that using this method can create.</p>
<p>Texture colour operations determine how the final colour of the surface appears when rendered. Texture units are used to combine colour values from various sources (ie. the diffuse colour of the surface from lighting calculations, combined with the colour of the texture). This method allows you to specify the 'operation' to be used, ie. the calculation such as adds or multiplies, and which values to use as arguments, such as a fixed value or a value from a previous calculation.</p>
<p>The defaults for each layer are:</p><ul>
<li>op = <a class="el" href="group___materials.html#gga264ecab38a04d01e2c3158fa05ec1ee2a985f2ec53a477d7c19b41700589cb519" title="multiply source1 and source2 together">Ogre::LBX_MODULATE</a></li>
<li>source1 = <a class="el" href="group___materials.html#ggae2ad78de344f35307ce35157c175625ea45f1a14042993f460992b3253ce6ae80" title="the colour derived from the texture assigned to this layer">Ogre::LBS_TEXTURE</a></li>
<li>source2 = <a class="el" href="group___materials.html#ggae2ad78de344f35307ce35157c175625ea370f25da69381c74ca1fc51fde81e659" title="the colour as built up from previous stages">Ogre::LBS_CURRENT</a></li>
</ul>
<p>ie. each layer takes the colour results of the previous layer, and multiplies them with the new texture being applied. Bear in mind that colours are RGB values from 0.0 - 1.0 so multiplying them together will result in values in the same range, 'tinted' by the multiply. Note however that a straight multiply normally has the effect of darkening the textures - for this reason there are brightening operations like <a class="el" href="group___materials.html#gga264ecab38a04d01e2c3158fa05ec1ee2a83964282d9ea36a25f4718ae962f8d1c" title="as LBX_MODULATE but brighten afterwards (x2)">Ogre::LBX_MODULATE_X2</a>. See the <a class="el" href="group___materials.html#gabcbb38d1ac195e4be401f85b7ab0da8f" title="List of valid texture blending operations, for use with TextureUnitState::setColourOperation.">Ogre::LayerBlendOperation</a> and <a class="el" href="group___materials.html#gae2ad78de344f35307ce35157c175625e" title="List of valid sources of values for blending operations used in TextureUnitState::setColourOperation ...">Ogre::LayerBlendSource</a> enumerated types for full details.</p>
<p>The final 3 parameters are only required if you decide to pass values manually into the operation, i.e. you want one or more of the inputs to the colour calculation to come from a fixed value that you supply. Hence you only need to fill these in if you supply <a class="el" href="group___materials.html#ggae2ad78de344f35307ce35157c175625ea9aad692ea2c7081237095c3ab4044f17" title="a colour supplied manually as a separate argument">Ogre::LBS_MANUAL</a> to the corresponding source, or use the <a class="el" href="group___materials.html#gga264ecab38a04d01e2c3158fa05ec1ee2adbe5957a946513e0f8be8c571f9b73fe" title="as LBX_BLEND_DIFFUSE_ALPHA but use a constant manual blend value (0.0-1.0)">Ogre::LBX_BLEND_MANUAL</a> operation. </p><dl class="section warning"><dt>Warning</dt><dd><a class="el" href="namespace_ogre.html">Ogre</a> tries to use multitexturing hardware to blend texture layers together. However, if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a GeForce3) it has to fall back on multipass rendering, i.e. rendering the same object multiple times with different textures. This is both less efficient and there is a smaller range of blending operations which can be performed. For this reason, if you use this method you MUST also call <a class="el" href="class_ogre_1_1_texture_unit_state.html#a1c4dcca2a0d343dc6660b9071cd4c79f" title="Sets the multipass fallback operation for this layer, if you used TextureUnitState::setColourOperatio...">Ogre::TextureUnitState::setColourOpMultipassFallback</a> to specify which effect you want to fall back on if sufficient hardware is not available. </dd>
<dd>
If you wish to avoid having to do this, use the simpler <a class="el" href="class_ogre_1_1_texture_unit_state.html#aa47f44936c3090c97d8b4179333a208b" title="Determines how this texture layer is combined with the one below it (or the diffuse colour of the geo...">Ogre::TextureUnitState::setColourOperation</a> method which allows less flexible blending options but sets up the multipass fallback automatically, since it only allows operations which have direct multipass equivalents. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to be used, e.g. modulate (multiply), add, subtract. </td></tr>
    <tr><td class="paramname">source1</td><td>The source of the first colour to the operation e.g. texture colour. </td></tr>
    <tr><td class="paramname">source2</td><td>The source of the second colour to the operation e.g. current surface colour. </td></tr>
    <tr><td class="paramname">arg1</td><td>Manually supplied colour value (only required if source1 = LBS_MANUAL). </td></tr>
    <tr><td class="paramname">arg2</td><td>Manually supplied colour value (only required if source2 = LBS_MANUAL). </td></tr>
    <tr><td class="paramname">manualBlend</td><td>Manually supplied 'blend' value - only required for operations which require manual blend e.g. LBX_BLEND_MANUAL.</td></tr>
  </table>
  </dd>
</dl>
<p>Each parameter can be one of <a class="el" href="group___materials.html#ga264ecab38a04d01e2c3158fa05ec1ee2" title="Expert list of valid texture blending operations, for use with TextureUnitState::setColourOperationEx...">Ogre::LayerBlendOperationEx</a> or <a class="el" href="group___materials.html#gae2ad78de344f35307ce35157c175625e" title="List of valid sources of values for blending operations used in TextureUnitState::setColourOperation ...">Ogre::LayerBlendSource</a> without the prefix. E.g. <code>LBX_MODULATE_X4</code> becomes <code>modulate_x4</code>.</p>
<dl class="section user"><dt></dt><dd>Default: none (colour_op modulate)<br  />
</dd></dl>
<p><a class="anchor" id="colour_005fop_005fmultipass_005ffallback"></a><a class="anchor" id="colour_005fop_005fmultipass_005ffallback-1"></a></p>
<h2><a class="anchor" id="autotoc_md170"></a>
colour_op_multipass_fallback</h2>
<p>Sets the multipass fallback operation for this layer, if you used colour_op_ex and not enough multitexturing hardware is available. </p><dl class="section user"><dt></dt><dd>Format: colour_op_multipass_fallback &lt;src_factor&gt; &lt;dest_factor&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: colour_op_multipass_fallback one one_minus_dest_alpha</dd></dl>
<p>Because some effects exposed using <a class="el" href="class_ogre_1_1_texture_unit_state.html#a5f3994ce2f61c6c6fee6fe8f89c9e369" title="Setting advanced blending options.">Ogre::TextureUnitState::setColourOperationEx</a> are only supported under multitexturing hardware, if the hardware is lacking the system must fallback on multipass rendering, which unfortunately doesn't support as many effects. This method is for you to specify the fallback operation which most suits you.</p>
<p>You'll notice that the interface is the same as the Ogre::TMaterial::setSceneBlending method; this is because multipass rendering IS effectively scene blending, since each layer is rendered on top of the last using the same mechanism as making an object transparent, it's just being rendered in the same place repeatedly to get the multitexture effect.</p>
<p>If you use the simpler (and hence less flexible) <a class="el" href="class_ogre_1_1_texture_unit_state.html#aa47f44936c3090c97d8b4179333a208b" title="Determines how this texture layer is combined with the one below it (or the diffuse colour of the geo...">Ogre::TextureUnitState::setColourOperation</a> method you don't need to call this as the system sets up the fallback for you. </p><dl class="section note"><dt>Note</dt><dd>This option has no effect in the programmable pipeline, because there is no multipass fallback and multitexture blending is handled by the fragment shader.</dd></dl>
<p><a class="anchor" id="alpha_005fop_005fex"></a><a class="anchor" id="alpha_005fop_005fex-1"></a></p>
<h2><a class="anchor" id="autotoc_md171"></a>
alpha_op_ex</h2>
<dl class="section note"><dt>Note</dt><dd>Only has an effect with the fixed-function pipeline or the <a class="el" href="rtss.html">Runtime Shader Generation</a></dd></dl>
<dl class="section user"><dt></dt><dd>Format: alpha_op_ex &lt;op&gt; &lt;source1&gt; &lt;source2&gt; [&lt;manualBlend&gt;] [&lt;arg1&gt;] [&lt;arg2&gt;]</dd></dl>
<p>This works in exactly the same way as setColourOperationEx, except that the effect is applied to the level of alpha (i.e. transparency) of the texture rather than its colour. When the alpha of a texel (a pixel on a texture) is 1.0, it is opaque, whereas it is fully transparent if the alpha is 0.0. Please refer to the <a class="el" href="class_ogre_1_1_texture_unit_state.html#a5f3994ce2f61c6c6fee6fe8f89c9e369" title="Setting advanced blending options.">Ogre::TextureUnitState::setColourOperationEx</a> method for more info. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to be used, e.g. modulate (multiply), add, subtract </td></tr>
    <tr><td class="paramname">source1</td><td>The source of the first alpha value to the operation e.g. texture alpha </td></tr>
    <tr><td class="paramname">source2</td><td>The source of the second alpha value to the operation e.g. current surface alpha </td></tr>
    <tr><td class="paramname">arg1</td><td>Manually supplied alpha value (only required if source1 = <a class="el" href="group___materials.html#ggae2ad78de344f35307ce35157c175625ea9aad692ea2c7081237095c3ab4044f17" title="a colour supplied manually as a separate argument">Ogre::LBS_MANUAL</a>) </td></tr>
    <tr><td class="paramname">arg2</td><td>Manually supplied alpha value (only required if source2 = <a class="el" href="group___materials.html#ggae2ad78de344f35307ce35157c175625ea9aad692ea2c7081237095c3ab4044f17" title="a colour supplied manually as a separate argument">Ogre::LBS_MANUAL</a>) </td></tr>
    <tr><td class="paramname">manualBlend</td><td>Manually supplied 'blend' value - only required for operations which require manual blend e.g. <a class="el" href="group___materials.html#gga264ecab38a04d01e2c3158fa05ec1ee2adbe5957a946513e0f8be8c571f9b73fe" title="as LBX_BLEND_DIFFUSE_ALPHA but use a constant manual blend value (0.0-1.0)">Ogre::LBX_BLEND_MANUAL</a></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="env_005fmap"></a><a class="anchor" id="env_005fmap-1"></a></p>
<h2><a class="anchor" id="autotoc_md172"></a>
env_map</h2>
<dl class="section note"><dt>Note</dt><dd>Only has an effect with the fixed-function pipeline or the <a class="el" href="rtss.html">Runtime Shader Generation</a></dd></dl>
<p>Turns on/off texture coordinate effect that makes this layer an environment map.</p>
<dl class="section user"><dt></dt><dd>Format: env_map &lt;off|spherical|planar|cubic_reflection|cubic_normal&gt;</dd></dl>
<p>Environment maps make an object look reflective by using automatic texture coordinate generation depending on the relationship between the objects vertices or normals and the eye.</p>
<dl compact="compact">
<dt>spherical </dt>
<dd><p class="startdd"></p>
<p class="interdd">2D texture coordinates using spherical reflection mapping</p>
<p class="interdd">Requires a single texture which is either a fish-eye lens view of the reflected scene, or some other texture which looks good as a spherical map (a texture of glossy highlights is popular especially in car sims). This effect is based on the relationship between the eye direction and the vertex normals of the object, so works best when there are a lot of gradually changing normals, i.e. curved objects.</p>
<p class="enddd"></p>
</dd>
<dt>planar </dt>
<dd><p class="startdd"></p>
<p class="interdd">The effect is based on the position of the vertices in the viewport rather than vertex normals. This is useful for planar geometry (where a spherical env_map would not look good because the normals are all the same) or objects without normals.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This was never actually implemented. Same as <code>spherical</code> on all backends.</dd></dl>
</dd>
<dt>cubic_reflection </dt>
<dd><p class="startdd"></p>
<p class="interdd">Cubic texture coordinates using the reflection vector.</p>
<p class="interdd">Uses a group of 6 textures making up the inside of a cube, each of which is a view if the scene down each axis. Works extremely well in all cases but has a higher technical requirement from the card than spherical mapping. Requires that you bind a <a href="#texture">cubic texture</a> to this unit.</p>
<p class="enddd"></p>
</dd>
<dt>cubic_normal </dt>
<dd><p class="startdd"></p>
<p class="interdd">Cubic texture coordinates using the normal vector.</p>
<p class="interdd">Generates 3D texture coordinates containing the camera space normal vector from the normal information held in the vertex data. Again, use of this feature requires a <a href="#texture">cubic texture</a>.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><br  />
 </p><dl class="section user"><dt></dt><dd>Default: env_map off<br  />
</dd></dl>
<p><a class="anchor" id="scroll"></a><a class="anchor" id="scroll-1"></a></p>
<h2><a class="anchor" id="autotoc_md173"></a>
scroll</h2>
<p>Sets the translation offset of the texture, ie scrolls the texture. </p><dl class="section user"><dt></dt><dd>Format: scroll &lt;u&gt; &lt;v&gt;</dd></dl>
<p>This method sets the translation element of the texture transformation, and is easier to use than setTextureTransform if you are combining translation, scaling and rotation in your texture transformation. If you want to animate these values use <a class="el" href="class_ogre_1_1_texture_unit_state.html#a45bd669bcc64ec417fe4208aa5cfd685" title="Sets up an animated scroll for the texture layer.">Ogre::TextureUnitState::setScrollAnimation</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The amount the texture should be moved horizontally (u direction). </td></tr>
    <tr><td class="paramname">v</td><td>The amount the texture should be moved vertically (v direction).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When using shader programs, you have to explicitely forward this property in the <a class="el" href="_high-level-_programs.html#Program-Parameter-Specification">Parameter specification</a></dd></dl>
<p><a class="anchor" id="scroll_005fanim"></a><a class="anchor" id="scroll_005fanim-1"></a></p>
<h2><a class="anchor" id="autotoc_md174"></a>
scroll_anim</h2>
<p>Sets up an animated scroll for the texture layer. </p><dl class="section user"><dt></dt><dd>Format: scroll_anim &lt;uSpeed&gt; &lt;vSpeed&gt;<br  />
</dd></dl>
<p>Useful for creating constant scrolling effects on a texture layer (for varying scrolls, see <a class="el" href="class_ogre_1_1_texture_unit_state.html#af56112cb1e6d144b8fd63b280d8ae350" title="Sets up a general time-relative texture modification effect.">Ogre::TextureUnitState::setTransformAnimation</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uSpeed</td><td>The number of horizontal loops per second (+ve=moving right, -ve = moving left). </td></tr>
    <tr><td class="paramname">vSpeed</td><td>The number of vertical loops per second (+ve=moving up, -ve= moving down).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When using shader programs, you have to explicitely forward this property in the <a class="el" href="_high-level-_programs.html#Program-Parameter-Specification">Parameter specification</a> <a class="anchor" id="rotate"></a><a class="anchor" id="rotate-1"></a></dd></dl>
<h2><a class="anchor" id="autotoc_md175"></a>
rotate</h2>
<p>Sets the anticlockwise rotation factor applied to texture coordinates.</p>
<dl class="section user"><dt></dt><dd>Format: rotate &lt;angle_in_deg&gt;</dd></dl>
<p>This sets a fixed rotation angle - if you wish to animate this, use <a class="el" href="class_ogre_1_1_texture_unit_state.html#a72e3695b81f12b32762237c5de202dff" title="Sets up an animated texture rotation for this layer.">Ogre::TextureUnitState::setRotateAnimation</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle of rotation (anticlockwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When using shader programs, you have to explicitely forward this property in the <a class="el" href="_high-level-_programs.html#Program-Parameter-Specification">Parameter specification</a></dd></dl>
<p><a class="anchor" id="rotate_005fanim"></a><a class="anchor" id="rotate_005fanim-1"></a></p>
<h2><a class="anchor" id="autotoc_md176"></a>
rotate_anim</h2>
<p>Sets up an animated texture rotation for this layer.</p>
<dl class="section user"><dt></dt><dd>Format: rotate_anim &lt;speed&gt;</dd></dl>
<p>Useful for constant rotations (for varying rotations, see <a class="el" href="class_ogre_1_1_texture_unit_state.html#af56112cb1e6d144b8fd63b280d8ae350" title="Sets up a general time-relative texture modification effect.">Ogre::TextureUnitState::setTransformAnimation</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>The number of complete anticlockwise revolutions per second (use -ve for clockwise)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When using shader programs, you have to explicitely forward this property in the <a class="el" href="_high-level-_programs.html#Program-Parameter-Specification">Parameter specification</a></dd></dl>
<p><a class="anchor" id="scale"></a><a class="anchor" id="scale-1"></a></p>
<h2><a class="anchor" id="autotoc_md177"></a>
scale</h2>
<p>Sets the scaling factor applied to texture coordinates.</p>
<dl class="section user"><dt></dt><dd>Format: scale &lt;uScale&gt; &lt;vScale&gt;</dd></dl>
<p>This method sets the scale element of the texture transformation, and is easier to use than setTextureTransform if you are combining translation, scaling and rotation in your texture transformation.</p>
<p>If you want to animate these values use <a class="el" href="class_ogre_1_1_texture_unit_state.html#af56112cb1e6d144b8fd63b280d8ae350" title="Sets up a general time-relative texture modification effect.">Ogre::TextureUnitState::setTransformAnimation</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uScale</td><td>The value by which the texture is to be scaled horizontally. </td></tr>
    <tr><td class="paramname">vScale</td><td>The value by which the texture is to be scaled vertically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When using shader programs, you have to explicitely forward this property in the <a class="el" href="_high-level-_programs.html#Program-Parameter-Specification">Parameter specification</a></dd></dl>
<p><a class="anchor" id="wave_005fxform"></a><a class="anchor" id="wave_005fxform-1"></a></p>
<h2><a class="anchor" id="autotoc_md178"></a>
wave_xform</h2>
<p>Sets up a general time-relative texture modification effect.</p>
<dl class="section user"><dt></dt><dd>Format: wave_xform &lt;ttype&gt; &lt;waveType&gt; &lt;base&gt; &lt;frequency&gt; &lt;phase&gt; &lt;amplitude&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Example: wave_xform scale_x sine 1.0 0.2 0.0 5.0</dd></dl>
<p>This can be called multiple times for different values of ttype, but only the latest effect applies if called multiple time for the same ttype. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ttype</td><td>The type of transform, either translate (scroll), scale (stretch) or rotate (spin). </td></tr>
    <tr><td class="paramname">waveType</td><td>The shape of the wave, see <a class="el" href="group___general.html#gabf2e0412a783a6f708ca1a58abb45c1b" title="Enumerates the wave types usable with the Ogre engine.">Ogre::WaveformType</a> enum for details. </td></tr>
    <tr><td class="paramname">base</td><td>The base value for the function (range of output = {base, base + amplitude}). </td></tr>
    <tr><td class="paramname">frequency</td><td>The speed of the wave in cycles per second. </td></tr>
    <tr><td class="paramname">phase</td><td>The offset of the start of the wave, e.g. 0.5 to start half-way through the wave. </td></tr>
    <tr><td class="paramname">amplitude</td><td>Scales the output so that instead of lying within 0..1 it lies within 0..1*amplitude for exaggerated effects.</td></tr>
  </table>
  </dd>
</dl>
<p>ttype is one of </p><dl compact="compact">
<dt>scroll_x </dt>
<dd><p class="startdd"></p>
<p class="interdd">Animate the u scroll value</p>
<p class="enddd"></p>
</dd>
<dt>scroll_y </dt>
<dd><p class="startdd"></p>
<p class="interdd">Animate the v scroll value</p>
<p class="enddd"></p>
</dd>
<dt>rotate </dt>
<dd><p class="startdd"></p>
<p class="interdd">Animate the rotate value</p>
<p class="enddd"></p>
</dd>
<dt>scale_x </dt>
<dd><p class="startdd"></p>
<p class="interdd">Animate the u scale value</p>
<p class="enddd"></p>
</dd>
<dt>scale_y </dt>
<dd><p class="startdd"></p>
<p class="interdd">Animate the v scale value</p>
<p class="enddd"></p>
</dd>
</dl>
<p>waveType is one of <a class="el" href="group___general.html#gabf2e0412a783a6f708ca1a58abb45c1b" title="Enumerates the wave types usable with the Ogre engine.">Ogre::WaveformType</a> without the <code>WFT_</code> prefix. E.g. <code>WFT_SQUARE</code> becomes <code>square</code>.</p>
<dl class="section note"><dt>Note</dt><dd>When using shader programs, you have to explicitely forward this property in the <a class="el" href="_high-level-_programs.html#Program-Parameter-Specification">Parameter specification</a></dd></dl>
<p><a class="anchor" id="transform"></a><a class="anchor" id="transform-1"></a></p>
<h2><a class="anchor" id="autotoc_md179"></a>
transform</h2>
<p>This attribute allows you to specify a static 4x4 transformation matrix for the texture unit, thus replacing the individual scroll, rotate and scale attributes mentioned above. </p><dl class="section user"><dt></dt><dd>Format: transform m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33</dd></dl>
<p>The indexes of the 4x4 matrix value above are expressed as m&lt;row&gt;&lt;col&gt;.</p>
<dl class="section note"><dt>Note</dt><dd>When using shader programs, you have to explicitely forward this property in the <a class="el" href="_high-level-_programs.html#Program-Parameter-Specification">Parameter specification</a></dd></dl>
<p><a class="anchor" id="sampler_ref"></a> </p>
<h2><a class="anchor" id="autotoc_md180"></a>
sampler_ref</h2>
<p>By default all texture units use a shared default Sampler object. This parameter allows you to explicitly set a different one.</p>
<dl class="section user"><dt></dt><dd>Format: sampler_ref &lt;name&gt;</dd></dl>
<dl class="section user"><dt></dt><dd>Example: sampler_ref mySampler</dd></dl>
<p><a class="anchor" id="unordered_access_mip"></a> </p>
<h2><a class="anchor" id="autotoc_md181"></a>
unordered_access_mip</h2>
<p>Enables Unordered Access to the provided mipLevel of the texture.</p>
<dl class="section user"><dt></dt><dd>Format: unordered_access_mip &lt;mipLevel&gt;</dd></dl>
<dl class="section user"><dt></dt><dd>Example: unordered_access_mip 0</dd></dl>
<h1><a class="anchor" id="Samplers"></a>
Samplers</h1>
<p>Samplers allow you to quickly change the settings for all associated Textures. Typically you have many Textures but only a few sampling states in your application.</p>
<div class="fragment"><div class="line">sampler mySampler</div>
<div class="line">{</div>
<div class="line">    filtering bilinear</div>
<div class="line">    max_anisotropy 16</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">    texture_unit</div>
<div class="line">    {</div>
<div class="line">        texture myTexture.dds</div>
<div class="line">        sampler_ref mySampler</div>
<div class="line">    }</div>
<div class="line">...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md182"></a>
Available parameters</h2>
<ul>
<li><a href="#filtering">filtering</a></li>
<li><a href="#max_005fanisotropy">max_anisotropy</a></li>
<li><a href="#tex_005faddress_005fmode">tex_address_mode</a></li>
<li><a href="#tex_005fborder_005fcolour">tex_border_colour</a></li>
<li><a href="#mipmap_005fbias">mipmap_bias</a></li>
<li><a href="#compare_test">compare_test</a></li>
<li><a href="#comp_func">comp_func</a></li>
</ul>
<p><a class="anchor" id="tex_005faddress_005fmode"></a><a class="anchor" id="tex_005faddress_005fmode-1"></a></p>
<h2><a class="anchor" id="autotoc_md183"></a>
tex_address_mode</h2>
<p>Defines what happens when texture coordinates exceed 1.0 for this texture layer.You can use the simple format to specify the addressing mode for all 3 potential texture coordinates at once, or you can use the 2/3 parameter extended format to specify a different mode per texture coordinate. </p><dl class="section user"><dt></dt><dd>Simple Format: tex_address_mode &lt;uvw_mode&gt; <br  />
 Extended Format: tex_address_mode &lt;u_mode&gt; &lt;v_mode&gt; [&lt;w_mode&gt;]</dd></dl>
<p>Valid values for both are one of <a class="el" href="group___general.html#ga6e4f6ebb1193d0e099b2058a451e1126" title="Texture addressing modes - default is TAM_WRAP.">Ogre::TextureAddressingMode</a> without the <code>TAM_</code> prefix. E.g. <code>TAM_WRAP</code> becomes <code>wrap</code>.</p>
<dl class="section user"><dt></dt><dd>Default: tex_address_mode wrap</dd></dl>
<p><a class="anchor" id="tex_005fborder_005fcolour"></a><a class="anchor" id="tex_005fborder_005fcolour-1"></a></p>
<h2><a class="anchor" id="autotoc_md184"></a>
tex_border_colour</h2>
<p>Sets the border colour of border texture address mode (see <a href="#tex_005faddress_005fmode">tex_address_mode</a>). </p><dl class="section user"><dt></dt><dd>Format: tex_border_colour &lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]<br  />
 NB valid colour values are between 0.0 and 1.0. </dd></dl>
<dl class="section user"><dt></dt><dd>Example: tex_border_colour 0.0 1.0 0.3 </dd></dl>
<dl class="section user"><dt></dt><dd>Default: tex_border_colour 0.0 0.0 0.0 1.0</dd></dl>
<p><a class="anchor" id="filtering"></a><a class="anchor" id="filtering-1"></a></p>
<h2><a class="anchor" id="autotoc_md185"></a>
filtering</h2>
<p>Sets the type of texture filtering used when magnifying or minifying a texture. There are 2 formats to this attribute, the simple format where you simply specify the name of a predefined set of filtering options, and the complex format, where you individually set the minification, magnification, and mip filters yourself.</p>
<h3><a class="anchor" id="autotoc_md186"></a>
Simple Format</h3>
<p>With this format, you only need to provide a single parameter</p>
<dl class="section user"><dt></dt><dd>Format: filtering &lt;none|bilinear|trilinear|anisotropic&gt;<br  />
 Default: filtering bilinear</dd></dl>
<dl compact="compact">
<dt>none </dt>
<dd><p class="startdd"></p>
<p class="enddd">No filtering or mipmapping is used. Equal to: min=<a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1ad299986d6ba4f220cc628a1b9a4f6a52" title="Use the closest pixel.">Ogre::FO_POINT</a>, mag=<a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1ad299986d6ba4f220cc628a1b9a4f6a52" title="Use the closest pixel.">Ogre::FO_POINT</a>, mip=<a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a0be36e268ed5d2d25fe91ba5b5f769b5" title="No filtering, used for FT_MIP to turn off mipmapping.">Ogre::FO_NONE</a>  </p>
</dd>
<dt>bilinear </dt>
<dd><p class="startdd"></p>
<p class="enddd">2x2 box filtering is performed when magnifying or reducing a texture, and a mipmap is picked from the list but no filtering is done between the levels of the mipmaps. Equal to: min=<a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a6b0e1f92a9531879e2f0acfe5e5183c6" title="Average of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP.">Ogre::FO_LINEAR</a>, mag=<a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a6b0e1f92a9531879e2f0acfe5e5183c6" title="Average of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP.">Ogre::FO_LINEAR</a>, mip=<a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1ad299986d6ba4f220cc628a1b9a4f6a52" title="Use the closest pixel.">Ogre::FO_POINT</a>  </p>
</dd>
<dt>trilinear </dt>
<dd><p class="startdd"></p>
<p class="enddd">2x2 box filtering is performed when magnifying and reducing a texture, and the closest 2 mipmaps are filtered together. Equal to: min=<a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a6b0e1f92a9531879e2f0acfe5e5183c6" title="Average of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP.">Ogre::FO_LINEAR</a>, mag=<a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a6b0e1f92a9531879e2f0acfe5e5183c6" title="Average of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP.">Ogre::FO_LINEAR</a>, mip=<a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a6b0e1f92a9531879e2f0acfe5e5183c6" title="Average of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP.">Ogre::FO_LINEAR</a>  </p>
</dd>
<dt>anisotropic </dt>
<dd><p class="startdd"></p>
<p class="enddd">This is the same as ’trilinear’, except the filtering algorithm takes account of the slope of the triangle in relation to the camera rather than simply doing a 2x2 pixel filter in all cases. Equal to: min=<a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a0ced0c8e18f83505a73c7275563d4372" title="Similar to FO_LINEAR, but compensates for the angle of the texture plane.">Ogre::FO_ANISOTROPIC</a>, max=<a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a0ced0c8e18f83505a73c7275563d4372" title="Similar to FO_LINEAR, but compensates for the angle of the texture plane.">Ogre::FO_ANISOTROPIC</a>, mip=<a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a6b0e1f92a9531879e2f0acfe5e5183c6" title="Average of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP.">Ogre::FO_LINEAR</a>  </p>
</dd>
</dl>
<h3><a class="anchor" id="autotoc_md187"></a>
Complex Format</h3>
<p>This format gives you complete control over the minification, magnification, and mip filters.</p>
<dl class="section user"><dt></dt><dd>Format: filtering &lt;minFilter&gt; &lt;magFilter&gt; &lt;mipFilter&gt; </dd></dl>
<dl class="section user"><dt></dt><dd>Default: filtering linear linear point</dd></dl>
<p>Each parameter can be one of <a class="el" href="group___general.html#ga30b6cb697e01ba6f02be12c7b40674c1" title="Filtering options for textures / mipmaps.">Ogre::FilterOptions</a> without the <code>FO_</code> prefix. E.g. <code>FO_LINEAR</code> becomes <code>linear</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minFilter</td><td>The filtering to use when reducing the size of the texture. Can be <a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1ad299986d6ba4f220cc628a1b9a4f6a52" title="Use the closest pixel.">Ogre::FO_POINT</a>, <a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a6b0e1f92a9531879e2f0acfe5e5183c6" title="Average of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP.">Ogre::FO_LINEAR</a> or <a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a0ced0c8e18f83505a73c7275563d4372" title="Similar to FO_LINEAR, but compensates for the angle of the texture plane.">Ogre::FO_ANISOTROPIC</a>. </td></tr>
    <tr><td class="paramname">magFilter</td><td>The filtering to use when increasing the size of the texture. Can be <a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1ad299986d6ba4f220cc628a1b9a4f6a52" title="Use the closest pixel.">Ogre::FO_POINT</a>, <a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a6b0e1f92a9531879e2f0acfe5e5183c6" title="Average of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP.">Ogre::FO_LINEAR</a> or <a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a0ced0c8e18f83505a73c7275563d4372" title="Similar to FO_LINEAR, but compensates for the angle of the texture plane.">Ogre::FO_ANISOTROPIC</a>. </td></tr>
    <tr><td class="paramname">mipFilter</td><td>The filtering to use between mip levels. Can be <a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a0be36e268ed5d2d25fe91ba5b5f769b5" title="No filtering, used for FT_MIP to turn off mipmapping.">Ogre::FO_NONE</a> (turns off mipmapping), <a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1ad299986d6ba4f220cc628a1b9a4f6a52" title="Use the closest pixel.">Ogre::FO_POINT</a> or <a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a6b0e1f92a9531879e2f0acfe5e5183c6" title="Average of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP.">Ogre::FO_LINEAR</a> (trilinear filtering).</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="max_005fanisotropy"></a><a class="anchor" id="max_005fanisotropy-1"></a></p>
<h2><a class="anchor" id="autotoc_md188"></a>
max_anisotropy</h2>
<p>Sets the anisotropy level to be used for this texture level.</p>
<dl class="section user"><dt></dt><dd>Format: max_anisotropy &lt;maxAniso&gt;<br  />
 Default: max_anisotropy 1</dd></dl>
<p>The degree of anisotropy is the ratio between the height of the texture segment visible in a screen space region versus the width - so for example a floor plane, which stretches on into the distance and thus the vertical texture coordinates change much faster than the horizontal ones, has a higher anisotropy than a wall which is facing you head on (which has an anisotropy of 1 if your line of sight is perfectly perpendicular to it).The maximum value is determined by the hardware, but it is usually 8 or 16.</p>
<p>In order for this to be used, you have to set the minification and/or the magnification option on this texture to <a class="el" href="group___general.html#gga30b6cb697e01ba6f02be12c7b40674c1a0ced0c8e18f83505a73c7275563d4372" title="Similar to FO_LINEAR, but compensates for the angle of the texture plane.">Ogre::FO_ANISOTROPIC</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxAniso</td><td>The maximal anisotropy level, should be between 2 and the maximum supported by hardware (1 is the default, ie. no anisotropy).</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="mipmap_005fbias"></a><a class="anchor" id="mipmap_005fbias-1"></a></p>
<h2><a class="anchor" id="autotoc_md189"></a>
mipmap_bias</h2>
<p>You can alter the mipmap calculation by biasing the result with a single floating point value. After the mip level has been calculated, this bias value is added to the result to give the final mip level. Lower mip levels are larger (higher detail), so a negative bias will force the larger mip levels to be used, and a positive bias will cause smaller mip levels to be used. The bias values are in mip levels, so a -1 bias will force mip levels one larger than by the default calculation.</p>
<p>In order for this option to be used, your hardware has to support mipmap biasing (exposed through <a class="el" href="group___render_system.html#gga3d2965b7f378ebdcfe8a4a6cf74c3de7a059362950c064bfe870e5fe60b56a3ca" title="Supports mipmap LOD biasing.">Ogre::RSC_MIPMAP_LOD_BIAS</a>), and your minification filtering has to be set to point or linear.</p>
<dl class="section user"><dt></dt><dd>Format: mipmap_bias &lt;value&gt;<br  />
 Default: mipmap_bias 0</dd></dl>
<p><a class="anchor" id="compare_test"></a> </p>
<h2><a class="anchor" id="autotoc_md190"></a>
compare_test</h2>
<p>Enables or disables the comparison test for depth textures. When enabled, sampling the texture returns how the sampled value compares against a reference value instead of the sampled value itself. Combined with linear filtering this can be used to implement hardware PCF for shadow maps.</p>
<dl class="section user"><dt></dt><dd>Format: compare_test on</dd></dl>
<dl class="section user"><dt></dt><dd>Default: compare_test off</dd></dl>
<p><a class="anchor" id="comp_func"></a></p>
<h2><a class="anchor" id="autotoc_md191"></a>
comp_func</h2>
<p>The comparison func to use when <code>compare_test</code> is enabled </p><dl class="section user"><dt></dt><dd>Format: comp_func &lt;func&gt;</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>one of <a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6" title="Comparison functions used for the depth/stencil buffer operations and others.">Ogre::CompareFunction</a> without the <code>CMPF_</code> prefix. E.g. <code>CMPF_LESS_EQUAL</code> becomes <code>less_equal</code>.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass"></a>
Using GPU Programs in a Pass</h1>
<p>Within a pass section of a material script, you can reference a vertex, geometry and / or a fragment program which is been defined in a .program script (See <a class="el" href="_high-level-_programs.html#Declaring-Vertex_002fGeometry_002fFragment-Programs">GPU Program Scripts</a>). The programs are defined separately from the usage of them in the pass, since the programs are very likely to be reused between many separate materials, probably across many different .material scripts, so this approach lets you define the program only once and use it many times.</p>
<p>As well as naming the program in question, you can also provide parameters to it. Here’s a simple example:</p>
<div class="fragment"><div class="line">vertex_program_ref myVertexProgram</div>
<div class="line">{</div>
<div class="line">    param_indexed_auto 0 worldviewproj_matrix</div>
<div class="line">    param_indexed      4 float4  10.0 0 0 0</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this example, we bind a vertex program called ’myVertexProgram’ (which will be defined elsewhere) to the pass, and give it 2 parameters, one is an ’auto’ parameter, meaning we do not have to supply a value as such, just a recognised code (in this case it’s the world/view/projection matrix which is kept up to date automatically by <a class="el" href="namespace_ogre.html">Ogre</a>). The second parameter is a manually specified parameter, a 4-element float. The indexes are described later.</p>
<p>The syntax of the link to a vertex program and a fragment or geometry program are identical, the only difference is that ’fragment_program_ref’ and ’geometry_program_ref’ are used respectively instead of ’vertex_program_ref’.</p>
<p>For many situations vertex, geometry and fragment programs are associated with each other in a pass but this is not cast in stone. You could have a vertex program that can be used by several different fragment programs. Another situation that arises is that you can mix fixed pipeline and programmable pipeline (shaders) together. You could use the non-programmable vertex fixed function pipeline and then provide a fragment_program_ref in a pass i.e. there would be no vertex_program_ref section in the pass. The fragment program referenced in the pass must meet the requirements as defined in the related API in order to read from the outputs of the vertex fixed pipeline. You could also just have a vertex program that outputs to the fragment fixed function pipeline.</p>
<p>The requirements to read from or write to the fixed function pipeline are similar between rendering API’s (DirectX and OpenGL) but how its actually done in each type of shader (vertex, geometry or fragment) depends on the shader language. For HLSL (DirectX API) and associated asm consult MSDN at <a href="http://msdn.microsoft.com/library/">http://msdn.microsoft.com/library/</a>. For GLSL (OpenGL), consult section 7.6 of the GLSL spec 1.1 available at <a href="http://www.opengl.org/registry/">http://www.opengl.org/registry/</a>. The built in varying variables provided in GLSL allow your program to read/write to the fixed function pipeline varyings. For Cg consult the Language Profiles section in CgUsersManual.pdf that comes with the Cg Toolkit available at <a href="https://developer.nvidia.com/cg-toolkit">https://developer.nvidia.com/cg-toolkit</a>. For HLSL and Cg its the varying bindings that allow your shader programs to read/write to the fixed function pipeline varyings.</p>
<h1><a class="anchor" id="Adding-new-Techniques_002c-Passes_002c-to-copied-materials_003a"></a>
Adding new Techniques, Passes, to copied materials</h1>
<p>If a new technique or pass needs to be added to a copied material then use a unique name for the technique or pass that does not exist in the parent material. Using an index for the name that is one greater than the last index in the parent will do the same thing. The new technique/pass will be added to the end of the techniques/passes copied from the parent material.</p>
<dl class="section note"><dt>Note</dt><dd>if passes or techniques aren’t given a name, they will take on a default name based on their index. For example the first pass has index 0 so its name will be 0.</dd></dl>
<h1><a class="anchor" id="Identifying-Texture-Units-to-override-values"></a>
Identifying Texture Units to override values</h1>
<p>A specific texture unit state (TUS) can be given a unique name within a pass of a material so that it can be identified later in cloned materials that need to override specified texture unit states in the pass without declaring previous texture units. Using a unique name for a Texture unit in a pass of a cloned material adds a new texture unit at the end of the texture unit list for the pass.</p>
<div class="fragment"><div class="line">material BumpMap2 : BumpMap1</div>
<div class="line">{</div>
<div class="line">  technique ati8500</div>
<div class="line">  {</div>
<div class="line">    pass 0</div>
<div class="line">    {</div>
<div class="line">      texture_unit NormalMap</div>
<div class="line">      {</div>
<div class="line">        texture BumpyMetalNM.png</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li><li class="navelem"><a class="el" href="_scripts.html">Scripts</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
