<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::VertexData Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">13.6</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_vertex_data.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_ogre_1_1_vertex_data-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::VertexData Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___render_system.html">RenderSystem</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>collects together all the vertex-related information used to render geometry.  
 <a href="class_ogre_1_1_vertex_data.html#details">More...</a></p>

<p><code>#include &lt;OgreVertexIndexData.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::VertexData:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_vertex_data__inherit__graph.svg" width="146" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_vertex_data_1_1_hardware_animation_data.html">HardwareAnimationData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used to hold hardware morph / pose vertex data information.  <a href="struct_ogre_1_1_vertex_data_1_1_hardware_animation_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9b0be9ce516c0b04e3565317e6186b15"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="struct_ogre_1_1_vertex_data_1_1_hardware_animation_data.html">HardwareAnimationData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a9b0be9ce516c0b04e3565317e6186b15">HardwareAnimationDataList</a></td></tr>
<tr class="separator:a9b0be9ce516c0b04e3565317e6186b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2396c78b8d5353f2f0f0fa24467550ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a2396c78b8d5353f2f0f0fa24467550ac">VertexData</a> (<a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> *mgr=0)</td></tr>
<tr class="memdesc:a2396c78b8d5353f2f0f0fa24467550ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_ogre_1_1_vertex_data.html#a2396c78b8d5353f2f0f0fa24467550ac">More...</a><br /></td></tr>
<tr class="separator:a2396c78b8d5353f2f0f0fa24467550ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a588ae595eadd30f8f245afed2a5734"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a7a588ae595eadd30f8f245afed2a5734">VertexData</a> (<a class="el" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a> *dcl, <a class="el" href="class_ogre_1_1_vertex_buffer_binding.html">VertexBufferBinding</a> *bind)</td></tr>
<tr class="memdesc:a7a588ae595eadd30f8f245afed2a5734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_ogre_1_1_vertex_data.html#a7a588ae595eadd30f8f245afed2a5734">More...</a><br /></td></tr>
<tr class="separator:a7a588ae595eadd30f8f245afed2a5734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2f442725d39e33a39f4d07f317fdc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#acb2f442725d39e33a39f4d07f317fdc0">~VertexData</a> ()</td></tr>
<tr class="separator:acb2f442725d39e33a39f4d07f317fdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6b2032e4d62b2333cff08792cddd60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vertex_data.html">VertexData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#abb6b2032e4d62b2333cff08792cddd60">_cloneRemovingBlendData</a> () const</td></tr>
<tr class="memdesc:abb6b2032e4d62b2333cff08792cddd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method to clone vertex data definitions but to remove blend buffers.  <a href="class_ogre_1_1_vertex_data.html#abb6b2032e4d62b2333cff08792cddd60">More...</a><br /></td></tr>
<tr class="separator:abb6b2032e4d62b2333cff08792cddd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f88995ea6fd3d8aeabd4b0cc90abc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#ad6f88995ea6fd3d8aeabd4b0cc90abc4">allocateHardwareAnimationElements</a> (<a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a> count, bool animateNormals)</td></tr>
<tr class="memdesc:ad6f88995ea6fd3d8aeabd4b0cc90abc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate elements to serve a holder of morph / pose target data for hardware morphing / pose blending.  <a href="class_ogre_1_1_vertex_data.html#ad6f88995ea6fd3d8aeabd4b0cc90abc4">More...</a><br /></td></tr>
<tr class="separator:ad6f88995ea6fd3d8aeabd4b0cc90abc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7567e0629a018f1a88c8939fb2920e61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vertex_data.html">VertexData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a7567e0629a018f1a88c8939fb2920e61">clone</a> (bool copyData=true, <a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> *mgr=0) const</td></tr>
<tr class="memdesc:a7567e0629a018f1a88c8939fb2920e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this vertex data, potentially including replicating any vertex buffers.  <a href="class_ogre_1_1_vertex_data.html#a7567e0629a018f1a88c8939fb2920e61">More...</a><br /></td></tr>
<tr class="separator:a7567e0629a018f1a88c8939fb2920e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155a22e5f5cf3cc46c8890a81383ee19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a155a22e5f5cf3cc46c8890a81383ee19">closeGapsInBindings</a> (void)</td></tr>
<tr class="memdesc:a155a22e5f5cf3cc46c8890a81383ee19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any gaps in the vertex buffer bindings.  <a href="class_ogre_1_1_vertex_data.html#a155a22e5f5cf3cc46c8890a81383ee19">More...</a><br /></td></tr>
<tr class="separator:a155a22e5f5cf3cc46c8890a81383ee19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6c57d776f87c08bb6fd6515f26270e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a0f6c57d776f87c08bb6fd6515f26270e">convertPackedColour</a> (<a class="el" href="group___render_system.html#ga027109503a988ba85f4c63b55082907f">VertexElementType</a> srcType, <a class="el" href="group___render_system.html#ga027109503a988ba85f4c63b55082907f">VertexElementType</a> destType)</td></tr>
<tr class="memdesc:a0f6c57d776f87c08bb6fd6515f26270e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all packed colour values (VET_COLOUR_*) in buffers used to another type.  <a href="class_ogre_1_1_vertex_data.html#a0f6c57d776f87c08bb6fd6515f26270e">More...</a><br /></td></tr>
<tr class="separator:a0f6c57d776f87c08bb6fd6515f26270e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac577d5d263134103a731d659926a6b58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#ac577d5d263134103a731d659926a6b58">convertVertexElement</a> (<a class="el" href="group___render_system.html#ga0a62b3f2ede8992ff365bb013a8bc00d">VertexElementSemantic</a> semantic, <a class="el" href="group___render_system.html#ga027109503a988ba85f4c63b55082907f">VertexElementType</a> dstType)</td></tr>
<tr class="memdesc:ac577d5d263134103a731d659926a6b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts between <a class="el" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa9ccf920d2572b15896f75ccf30fb150c">VET_FLOAT3</a> or <a class="el" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa7f1dd8dd0e61ef81a53f5b315d096325">VET_FLOAT4</a> and <a class="el" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa54e62ebe6dac47619185d713a7692356" title="signed int (normalized to 0..1)">VET_INT_10_10_10_2_NORM</a>  <a href="class_ogre_1_1_vertex_data.html#ac577d5d263134103a731d659926a6b58">More...</a><br /></td></tr>
<tr class="separator:ac577d5d263134103a731d659926a6b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35751c0e63acf6def8a1cf101abd1b28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a35751c0e63acf6def8a1cf101abd1b28">prepareForShadowVolume</a> (void)</td></tr>
<tr class="memdesc:a35751c0e63acf6def8a1cf101abd1b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the vertex data to be suitable for use for rendering shadow geometry as in <a class="el" href="citelist.html#CITEREF_mcguire2003fast">[10]</a>.  <a href="class_ogre_1_1_vertex_data.html#a35751c0e63acf6def8a1cf101abd1b28">More...</a><br /></td></tr>
<tr class="separator:a35751c0e63acf6def8a1cf101abd1b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8caba4952eb43bced5051c3e3bff1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a9c8caba4952eb43bced5051c3e3bff1f">removeUnusedBuffers</a> (void)</td></tr>
<tr class="memdesc:a9c8caba4952eb43bced5051c3e3bff1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all vertex buffers that never used by the vertex declaration.  <a href="class_ogre_1_1_vertex_data.html#a9c8caba4952eb43bced5051c3e3bff1f">More...</a><br /></td></tr>
<tr class="separator:a9c8caba4952eb43bced5051c3e3bff1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106603d9d4d6c2f6e0d5eb6c25eb7c32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a106603d9d4d6c2f6e0d5eb6c25eb7c32">reorganiseBuffers</a> (<a class="el" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a> *newDeclaration, const <a class="el" href="group___render_system.html#gadefdc0dd104d75039087a1e50eb84773">BufferUsageList</a> &amp;bufferUsage, <a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> *mgr=0)</td></tr>
<tr class="memdesc:a106603d9d4d6c2f6e0d5eb6c25eb7c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorganises the data in the vertex buffers according to the new vertex declaration passed in.  <a href="class_ogre_1_1_vertex_data.html#a106603d9d4d6c2f6e0d5eb6c25eb7c32">More...</a><br /></td></tr>
<tr class="separator:a106603d9d4d6c2f6e0d5eb6c25eb7c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c61a5203430f896579775636e23d25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#ad1c61a5203430f896579775636e23d25">reorganiseBuffers</a> (<a class="el" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a> *newDeclaration, <a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> *mgr=0)</td></tr>
<tr class="memdesc:ad1c61a5203430f896579775636e23d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorganises the data in the vertex buffers according to the new vertex declaration passed in.  <a href="class_ogre_1_1_vertex_data.html#ad1c61a5203430f896579775636e23d25">More...</a><br /></td></tr>
<tr class="separator:ad1c61a5203430f896579775636e23d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a154124cc2848e3eae62e9d508f45e921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a154124cc2848e3eae62e9d508f45e921">hardwareShadowVolWBuffer</a></td></tr>
<tr class="memdesc:a154124cc2848e3eae62e9d508f45e921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional shadow volume vertex buffer storage.  <a href="class_ogre_1_1_vertex_data.html#a154124cc2848e3eae62e9d508f45e921">More...</a><br /></td></tr>
<tr class="separator:a154124cc2848e3eae62e9d508f45e921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43acb3f735c2d4bdfdfbfdebc26dc52e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vertex_data.html#a9b0be9ce516c0b04e3565317e6186b15">HardwareAnimationDataList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a43acb3f735c2d4bdfdfbfdebc26dc52e">hwAnimationDataList</a></td></tr>
<tr class="memdesc:a43acb3f735c2d4bdfdfbfdebc26dc52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">VertexElements used for hardware morph / pose animation.  <a href="class_ogre_1_1_vertex_data.html#a43acb3f735c2d4bdfdfbfdebc26dc52e">More...</a><br /></td></tr>
<tr class="separator:a43acb3f735c2d4bdfdfbfdebc26dc52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24c57003d9fa3d717ca16e7f5becb41"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#af24c57003d9fa3d717ca16e7f5becb41">hwAnimDataItemsUsed</a></td></tr>
<tr class="memdesc:af24c57003d9fa3d717ca16e7f5becb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of hardware animation data items used.  <a href="class_ogre_1_1_vertex_data.html#af24c57003d9fa3d717ca16e7f5becb41">More...</a><br /></td></tr>
<tr class="separator:af24c57003d9fa3d717ca16e7f5becb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cad19bf7cc1610d24d62f06149f9107"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a4cad19bf7cc1610d24d62f06149f9107">mDeleteDclBinding</a></td></tr>
<tr class="memdesc:a4cad19bf7cc1610d24d62f06149f9107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this class should delete the declaration and binding.  <a href="class_ogre_1_1_vertex_data.html#a4cad19bf7cc1610d24d62f06149f9107">More...</a><br /></td></tr>
<tr class="separator:a4cad19bf7cc1610d24d62f06149f9107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf7dacb2a133d71620abd59cb3180b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vertex_buffer_binding.html">VertexBufferBinding</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a1cf7dacb2a133d71620abd59cb3180b0">vertexBufferBinding</a></td></tr>
<tr class="memdesc:a1cf7dacb2a133d71620abd59cb3180b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines which vertex buffers are bound to which sources.  <a href="class_ogre_1_1_vertex_data.html#a1cf7dacb2a133d71620abd59cb3180b0">More...</a><br /></td></tr>
<tr class="separator:a1cf7dacb2a133d71620abd59cb3180b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b59b63cc2dbede1c5fc6a932fd2c10d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#a0b59b63cc2dbede1c5fc6a932fd2c10d">vertexCount</a></td></tr>
<tr class="memdesc:a0b59b63cc2dbede1c5fc6a932fd2c10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of vertices to process in this particular rendering group.  <a href="class_ogre_1_1_vertex_data.html#a0b59b63cc2dbede1c5fc6a932fd2c10d">More...</a><br /></td></tr>
<tr class="separator:a0b59b63cc2dbede1c5fc6a932fd2c10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac9cde9c001b97cf1fea7fd05b79cf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#abac9cde9c001b97cf1fea7fd05b79cf4">vertexDeclaration</a></td></tr>
<tr class="memdesc:abac9cde9c001b97cf1fea7fd05b79cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the the format of the vertex input.  <a href="class_ogre_1_1_vertex_data.html#abac9cde9c001b97cf1fea7fd05b79cf4">More...</a><br /></td></tr>
<tr class="separator:abac9cde9c001b97cf1fea7fd05b79cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dca90128a99a8cdcd68201ad2c2f93"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vertex_data.html#aa3dca90128a99a8cdcd68201ad2c2f93">vertexStart</a></td></tr>
<tr class="memdesc:aa3dca90128a99a8cdcd68201ad2c2f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position in the bound buffers to start reading vertex data from. This allows you to use a single buffer for many different renderables.  <a href="class_ogre_1_1_vertex_data.html#aa3dca90128a99a8cdcd68201ad2c2f93">More...</a><br /></td></tr>
<tr class="separator:aa3dca90128a99a8cdcd68201ad2c2f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>collects together all the vertex-related information used to render geometry. </p>
<p>The <a class="el" href="class_ogre_1_1_render_operation.html" title="&#39;New&#39; rendering operation using vertex buffers.">RenderOperation</a> requires a pointer to a <a class="el" href="class_ogre_1_1_vertex_data.html" title="collects together all the vertex-related information used to render geometry.">VertexData</a> object, and it is also used in <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Mesh</a> and <a class="el" href="class_ogre_1_1_sub_mesh.html" title="Defines a part of a complete mesh.">SubMesh</a> to store the vertex positions, normals, texture coordinates etc. <a class="el" href="class_ogre_1_1_vertex_data.html" title="collects together all the vertex-related information used to render geometry.">VertexData</a> can either be used alone (in order to render unindexed geometry, where the stream of vertices defines the triangles), or in combination with <a class="el" href="class_ogre_1_1_index_data.html" title="Summary class collecting together index data source information.">IndexData</a> where the triangles are defined by indexes which refer to the entries in <a class="el" href="class_ogre_1_1_vertex_data.html" title="collects together all the vertex-related information used to render geometry.">VertexData</a>. It’s worth noting that you don’t necessarily have to use <a class="el" href="class_ogre_1_1_vertex_data.html" title="collects together all the vertex-related information used to render geometry.">VertexData</a> to store your applications geometry; all that is required is that you can build a <a class="el" href="class_ogre_1_1_vertex_data.html" title="collects together all the vertex-related information used to render geometry.">VertexData</a> structure when it comes to rendering. This is pretty easy since all of VertexData’s members are pointers, so you could maintain your vertex buffers and declarations in alternative structures if you like, so long as you can convert them for rendering. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9b0be9ce516c0b04e3565317e6186b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0be9ce516c0b04e3565317e6186b15">&#9670;&nbsp;</a></span>HardwareAnimationDataList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_ogre_1_1_vertex_data_1_1_hardware_animation_data.html">HardwareAnimationData</a>&gt; <a class="el" href="class_ogre_1_1_vertex_data.html#a9b0be9ce516c0b04e3565317e6186b15">Ogre::VertexData::HardwareAnimationDataList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2396c78b8d5353f2f0f0fa24467550ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2396c78b8d5353f2f0f0fa24467550ac">&#9670;&nbsp;</a></span>VertexData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::VertexData::VertexData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> *&#160;</td>
          <td class="paramname"><em>mgr</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor creates the <a class="el" href="class_ogre_1_1_vertex_declaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">VertexDeclaration</a> and <a class="el" href="class_ogre_1_1_vertex_buffer_binding.html" title="Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...">VertexBufferBinding</a> automatically, and arranges for their deletion afterwards. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr</td><td>Optional <a class="el" href="class_ogre_1_1_hardware_buffer_manager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> from which to create resources </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a588ae595eadd30f8f245afed2a5734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a588ae595eadd30f8f245afed2a5734">&#9670;&nbsp;</a></span>VertexData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::VertexData::VertexData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a> *&#160;</td>
          <td class="paramname"><em>dcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vertex_buffer_binding.html">VertexBufferBinding</a> *&#160;</td>
          <td class="paramname"><em>bind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor receives the <a class="el" href="class_ogre_1_1_vertex_declaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">VertexDeclaration</a> and <a class="el" href="class_ogre_1_1_vertex_buffer_binding.html" title="Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...">VertexBufferBinding</a> from the caller, and as such does not arrange for their deletion afterwards, the caller remains responsible for that. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dcl</td><td>The <a class="el" href="class_ogre_1_1_vertex_declaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">VertexDeclaration</a> to use </td></tr>
    <tr><td class="paramname">bind</td><td>The <a class="el" href="class_ogre_1_1_vertex_buffer_binding.html" title="Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...">VertexBufferBinding</a> to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb2f442725d39e33a39f4d07f317fdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2f442725d39e33a39f4d07f317fdc0">&#9670;&nbsp;</a></span>~VertexData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::VertexData::~VertexData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7567e0629a018f1a88c8939fb2920e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7567e0629a018f1a88c8939fb2920e61">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vertex_data.html">VertexData</a>* Ogre::VertexData::clone </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copyData</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> *&#160;</td>
          <td class="paramname"><em>mgr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones this vertex data, potentially including replicating any vertex buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copyData</td><td>Whether to create new vertex buffers too or just reference the existing ones </td></tr>
    <tr><td class="paramname">mgr</td><td>If supplied, the buffer manager through which copies should be made </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The caller is expected to delete the returned pointer when ready </dd></dl>

</div>
</div>
<a id="a35751c0e63acf6def8a1cf101abd1b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35751c0e63acf6def8a1cf101abd1b28">&#9670;&nbsp;</a></span>prepareForShadowVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VertexData::prepareForShadowVolume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the vertex data to be suitable for use for rendering shadow geometry as in <a class="el" href="citelist.html#CITEREF_mcguire2003fast">[10]</a>. </p>
<p>Preparing vertex data to generate a shadow volume involves firstly ensuring that the vertex buffer containing the positions is a standalone vertex buffer, with no other components in it. This method will therefore break apart any existing vertex buffers if position is sharing a vertex buffer. Secondly, it will double the size of this vertex buffer so that there are 2 copies of the position data for the mesh. The first half is used for the original, and the second half is used for the 'extruded' version. The vertex count used to render will remain the same though, so as not to add any overhead to regular rendering of the object. Both copies of the position are required in one buffer because shadow volumes stretch from the original mesh to the extruded version.</p>
<p>It's important to appreciate that this method can fundamentally change the structure of your vertex buffers, although in reality they will be new buffers. As it happens, if other objects are using the original buffers then they will be unaffected because the reference counting will keep them intact. However, if you have made any assumptions about the structure of the vertex data in the buffers of this object, you may have to rethink them.</p>
<p>Because shadow volumes are rendered in turn, no additional index buffer space is allocated by this method, a shared index buffer allocated by the shadow rendering algorithm is used for addressing this extended vertex buffer. </p>

</div>
</div>
<a id="ac577d5d263134103a731d659926a6b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac577d5d263134103a731d659926a6b58">&#9670;&nbsp;</a></span>convertVertexElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VertexData::convertVertexElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___render_system.html#ga0a62b3f2ede8992ff365bb013a8bc00d">VertexElementSemantic</a>&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___render_system.html#ga027109503a988ba85f4c63b55082907f">VertexElementType</a>&#160;</td>
          <td class="paramname"><em>dstType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts between <a class="el" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa9ccf920d2572b15896f75ccf30fb150c">VET_FLOAT3</a> or <a class="el" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa7f1dd8dd0e61ef81a53f5b315d096325">VET_FLOAT4</a> and <a class="el" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa54e62ebe6dac47619185d713a7692356" title="signed int (normalized to 0..1)">VET_INT_10_10_10_2_NORM</a> </p>

</div>
</div>
<a id="a106603d9d4d6c2f6e0d5eb6c25eb7c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106603d9d4d6c2f6e0d5eb6c25eb7c32">&#9670;&nbsp;</a></span>reorganiseBuffers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VertexData::reorganiseBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a> *&#160;</td>
          <td class="paramname"><em>newDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___render_system.html#gadefdc0dd104d75039087a1e50eb84773">BufferUsageList</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferUsage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> *&#160;</td>
          <td class="paramname"><em>mgr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorganises the data in the vertex buffers according to the new vertex declaration passed in. </p>
<p>Note that new vertex buffers are created and written to, so if the buffers being referenced by this vertex data object are also used by others, then the original buffers will not be damaged by this operation. Once this operation has completed, the new declaration passed in will overwrite the current one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newDeclaration</td><td>The vertex declaration which will be used for the reorganised buffer state. Note that the new declaration must not include any elements which do not already exist in the current declaration; you can drop elements by excluding them from the declaration if you wish, however. </td></tr>
    <tr><td class="paramname">bufferUsage</td><td><a class="el" href="class_ogre_1_1_vector.html" title="Standard N-dimensional vector.">Vector</a> of usage flags which indicate the usage options for each new vertex buffer created. The indexes of the entries must correspond to the buffer binding values referenced in the declaration. </td></tr>
    <tr><td class="paramname">mgr</td><td>Optional pointer to the manager to use to create new declarations and buffers etc. If not supplied, the <a class="el" href="class_ogre_1_1_hardware_buffer_manager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> singleton will be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1c61a5203430f896579775636e23d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c61a5203430f896579775636e23d25">&#9670;&nbsp;</a></span>reorganiseBuffers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VertexData::reorganiseBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a> *&#160;</td>
          <td class="paramname"><em>newDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> *&#160;</td>
          <td class="paramname"><em>mgr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorganises the data in the vertex buffers according to the new vertex declaration passed in. </p>
<p>Note that new vertex buffers are created and written to, so if the buffers being referenced by this vertex data object are also used by others, then the original buffers will not be damaged by this operation. Once this operation has completed, the new declaration passed in will overwrite the current one. This version of the method derives the buffer usages from the existing buffers, by using the 'most flexible' usage from the equivalent sources. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newDeclaration</td><td>The vertex declaration which will be used for the reorganised buffer state. Note that the new delcaration must not include any elements which do not already exist in the current declaration; you can drop elements by excluding them from the declaration if you wish, however. </td></tr>
    <tr><td class="paramname">mgr</td><td>Optional pointer to the manager to use to create new declarations and buffers etc. If not supplied, the <a class="el" href="class_ogre_1_1_hardware_buffer_manager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> singleton will be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a155a22e5f5cf3cc46c8890a81383ee19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155a22e5f5cf3cc46c8890a81383ee19">&#9670;&nbsp;</a></span>closeGapsInBindings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VertexData::closeGapsInBindings </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove any gaps in the vertex buffer bindings. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is useful if you've removed elements and buffers from this vertex data and want to remove any gaps in the vertex buffer bindings. This method is mainly useful when reorganising vertex data manually. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This will cause binding index of the elements in the vertex declaration to be altered to new binding index. </dd></dl>

</div>
</div>
<a id="a9c8caba4952eb43bced5051c3e3bff1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8caba4952eb43bced5051c3e3bff1f">&#9670;&nbsp;</a></span>removeUnusedBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VertexData::removeUnusedBuffers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all vertex buffers that never used by the vertex declaration. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is useful if you've removed elements from the vertex declaration and want to unreference buffers that never used any more. This method is mainly useful when reorganising vertex data manually. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This also remove any gaps in the vertex buffer bindings. </dd></dl>

</div>
</div>
<a id="a0f6c57d776f87c08bb6fd6515f26270e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6c57d776f87c08bb6fd6515f26270e">&#9670;&nbsp;</a></span>convertPackedColour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VertexData::convertPackedColour </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___render_system.html#ga027109503a988ba85f4c63b55082907f">VertexElementType</a>&#160;</td>
          <td class="paramname"><em>srcType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___render_system.html#ga027109503a988ba85f4c63b55082907f">VertexElementType</a>&#160;</td>
          <td class="paramname"><em>destType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all packed colour values (VET_COLOUR_*) in buffers used to another type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcType</td><td>The source colour type to assume if the ambiguous VET_COLOUR is encountered. </td></tr>
    <tr><td class="paramname">destType</td><td>The destination colour type, must be VET_COLOUR_ABGR or VET_COLOUR_ARGB. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6f88995ea6fd3d8aeabd4b0cc90abc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f88995ea6fd3d8aeabd4b0cc90abc4">&#9670;&nbsp;</a></span>allocateHardwareAnimationElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a> Ogre::VertexData::allocateHardwareAnimationElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>animateNormals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate elements to serve a holder of morph / pose target data for hardware morphing / pose blending. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method will allocate the given number of 3D texture coordinate sets for use as a morph target or target pose offset (3D position). These elements will be saved in hwAnimationDataList. It will also assume that the source of these new elements will be new buffers which are not bound at this time, so will start the sources to 1 higher than the current highest binding source. The caller is expected to bind these new buffers when appropriate. For morph animation the original position buffer will be the 'from' keyframe data, whilst for pose animation it will be the original vertex data. If normals are animated, then twice the number of 3D texture coordinates are required </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of sets that were supported </dd></dl>

</div>
</div>
<a id="abb6b2032e4d62b2333cff08792cddd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6b2032e4d62b2333cff08792cddd60">&#9670;&nbsp;</a></span>_cloneRemovingBlendData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vertex_data.html">VertexData</a>* Ogre::VertexData::_cloneRemovingBlendData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method to clone vertex data definitions but to remove blend buffers. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abac9cde9c001b97cf1fea7fd05b79cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac9cde9c001b97cf1fea7fd05b79cf4">&#9670;&nbsp;</a></span>vertexDeclaration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vertex_declaration.html">VertexDeclaration</a>* Ogre::VertexData::vertexDeclaration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declaration of the the format of the vertex input. </p>
<p>Note that this is created for you on construction. </p>

</div>
</div>
<a id="a1cf7dacb2a133d71620abd59cb3180b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf7dacb2a133d71620abd59cb3180b0">&#9670;&nbsp;</a></span>vertexBufferBinding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vertex_buffer_binding.html">VertexBufferBinding</a>* Ogre::VertexData::vertexBufferBinding</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines which vertex buffers are bound to which sources. </p>
<p>Note that this is created for you on construction. </p>

</div>
</div>
<a id="a4cad19bf7cc1610d24d62f06149f9107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cad19bf7cc1610d24d62f06149f9107">&#9670;&nbsp;</a></span>mDeleteDclBinding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::VertexData::mDeleteDclBinding</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this class should delete the declaration and binding. </p>

</div>
</div>
<a id="aa3dca90128a99a8cdcd68201ad2c2f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dca90128a99a8cdcd68201ad2c2f93">&#9670;&nbsp;</a></span>vertexStart</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::VertexData::vertexStart</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The position in the bound buffers to start reading vertex data from. This allows you to use a single buffer for many different renderables. </p>

</div>
</div>
<a id="a0b59b63cc2dbede1c5fc6a932fd2c10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b59b63cc2dbede1c5fc6a932fd2c10d">&#9670;&nbsp;</a></span>vertexCount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::VertexData::vertexCount</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of vertices to process in this particular rendering group. </p>

</div>
</div>
<a id="a43acb3f735c2d4bdfdfbfdebc26dc52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43acb3f735c2d4bdfdfbfdebc26dc52e">&#9670;&nbsp;</a></span>hwAnimationDataList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vertex_data.html#a9b0be9ce516c0b04e3565317e6186b15">HardwareAnimationDataList</a> Ogre::VertexData::hwAnimationDataList</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VertexElements used for hardware morph / pose animation. </p>

</div>
</div>
<a id="af24c57003d9fa3d717ca16e7f5becb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24c57003d9fa3d717ca16e7f5becb41">&#9670;&nbsp;</a></span>hwAnimDataItemsUsed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::VertexData::hwAnimDataItemsUsed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of hardware animation data items used. </p>

</div>
</div>
<a id="a154124cc2848e3eae62e9d508f45e921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154124cc2848e3eae62e9d508f45e921">&#9670;&nbsp;</a></span>hardwareShadowVolWBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aab7b2d2585219692cd912d3b497802d5">HardwareVertexBufferSharedPtr</a> Ogre::VertexData::hardwareShadowVolWBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Additional shadow volume vertex buffer storage. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This additional buffer is only used where we have prepared this <a class="el" href="class_ogre_1_1_vertex_data.html" title="collects together all the vertex-related information used to render geometry.">VertexData</a> for use in shadow volume construction, and where the current render system supports vertex programs. This buffer contains the 'w' vertex position component which will be used by that program to differentiate between extruded and non-extruded vertices. This 'w' component cannot be included in the original position buffer because DirectX does not allow 4-component positions in the fixed-function pipeline, and the original position buffer must still be usable for fixed-function rendering. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that we don't store any vertex declaration or vertex buffer binding here because this can be reused in the shadow algorithm. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_vertex_index_data_8h.html">OgreVertexIndexData.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_vertex_data.html">VertexData</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
