<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Manual mesh creation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.11.6</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('manual-mesh-creation.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Manual mesh creation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>There are two ways to create your own mesh. The first way is to create a <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Ogre::Mesh</a> instance and provide it with the vertex and index buffers directly.</p>
<p>The second way is the high level <a class="el" href="class_ogre_1_1_manual_object.html" title="Class providing a much simplified interface to generating manual objects with custom geometry...">Ogre::ManualObject</a> interface. Instead of filling position and color buffers, you simply call the "position" and "colour" functions.</p>
<h1>Using Manual Object</h1>
<p>Building one-off geometry objects manually usually requires getting down and dirty with the vertex buffer and vertex declaration API, which some people find a steep learning curve. This class gives you a simpler interface specifically for the purpose of building a 3D object simply and quickly. Note that if you intend to instance your object you will still need to become familiar with the Mesh class.</p>
<p>This class draws heavily on the interface for OpenGL immediate-mode (<code>glBegin</code>, <code>glVertex</code>, <code>glNormal</code> etc), since this is generally well-liked by people. There are a couple of differences in the results though - internally this class still builds hardware buffers which can be re-used, so you can render the resulting object multiple times without re-issuing all the same commands again. Secondly, the rendering is not immediate, it is still queued just like all OGRE objects. This makes this object more efficient than the equivalent GL immediate-mode commands, so it's feasible to use it for large objects if you really want to.</p>
<p>To construct some geometry with this object:</p><ol type="1">
<li>If you know roughly how many vertices (and indices, if you use them) you're going to submit, call estimateVertexCount() and estimateIndexCount(). This is not essential but will make the process more efficient by saving memory reallocations.</li>
<li>Call begin() to begin entering data</li>
<li>For each vertex, call position(), normal(), textureCoord(), colour() to define your vertex data. Note that each time you call position() you start a new vertex. Note that the first vertex defines the components of the vertex - you can't add more after that. For example if you didn't call normal() in the first vertex, you cannot call it in any others. You ought to call the same combination of methods per vertex.</li>
<li>If you want to define triangles (or lines/points) by indexing into the vertex list, you can call index() as many times as you need to define them. If you don't do this, the class will assume you want triangles drawn directly as defined by the vertex list, i.e. non-indexed geometry. Note that stencil shadows are only supported on indexed geometry, and that indexed geometry is a little faster; so you should try to use it.</li>
<li>Call end() to finish entering data.</li>
<li>Optionally repeat the begin-end cycle if you want more geometry using different rendering operation types, or different materials After calling end(), the class will organise the data for that section internally and make it ready to render with. Like any other MovableObject you should attach the object to a SceneNode to make it visible. Other aspects like the relative render order can be controlled using standard MovableObject methods like setRenderQueueGroup.</li>
</ol>
<p>You can also use beginUpdate() to alter the geometry later on if you wish. If you do this, you should call setDynamic(true) before your first call to begin(), and also consider using estimateVertexCount() / estimateIndexCount() if your geometry is going to be growing, to avoid buffer recreation during growth.</p>
<dl class="section note"><dt>Note</dt><dd>like all OGRE geometry, triangles should be specified in anti-clockwise winding order (whether you're doing it with just vertices, or using indexes too). That is to say that the front of the face is the one where the vertices are listed in anti-clockwise order.</dd></dl>
<h2>Example</h2>
<p>We will use the ManualObject to create a single textured plane. After creating the object, we start a new geometry block that will use the given material</p>
<div class="fragment"><div class="line">    <a class="code" href="class_ogre_1_1_manual_object.html">Ogre::ManualObject</a>* man = mSceneMgr-&gt;createManualObject(<span class="stringliteral">&quot;test&quot;</span>);</div><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a70d5945478fbc7fa056cecd88fdf2781">begin</a>(<span class="stringliteral">&quot;Examples/OgreLogo&quot;</span>, <a class="code" href="class_ogre_1_1_render_operation.html#a7a272218dae54048c87f31176c19e10da8c00ee152b44fe8000c2fd675437c087">Ogre::RenderOperation::OT_TRIANGLE_LIST</a>);</div></div><!-- fragment --><p> Next we specify the vertices of the plane</p>
<div class="fragment"><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a9986bd2627b75deeba14636c81efcde0">position</a>(-20, 20, 20);</div><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a59c0b0a41e2a4ced5ff89589c9a924a1">normal</a>(0, 0, 1);</div><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a64854d64967680d2294788768ebbd1d7">textureCoord</a>(0, 0);</div><div class="line"></div><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a9986bd2627b75deeba14636c81efcde0">position</a>(-20, -20, 20);</div><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a59c0b0a41e2a4ced5ff89589c9a924a1">normal</a>(0, 0, 1);</div><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a64854d64967680d2294788768ebbd1d7">textureCoord</a>(0, 1);</div><div class="line"></div><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a9986bd2627b75deeba14636c81efcde0">position</a>(20, -20, 20);</div><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a59c0b0a41e2a4ced5ff89589c9a924a1">normal</a>(0, 0, 1);</div><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a64854d64967680d2294788768ebbd1d7">textureCoord</a>(1, 1);</div><div class="line"></div><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a9986bd2627b75deeba14636c81efcde0">position</a>(20, 20, 20);</div><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a59c0b0a41e2a4ced5ff89589c9a924a1">normal</a>(0, 0, 1);</div><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a64854d64967680d2294788768ebbd1d7">textureCoord</a>(1, 0);</div></div><!-- fragment --><p> Now we can define the face. Ogre will split the quad into triangles for us.</p>
<div class="fragment"><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a1ac70dbc6f35180d5c8bab671c3f2257">quad</a>(0, 1, 2, 3);</div></div><!-- fragment --><p> Calling <code>end()</code> creates the actual Hardware Buffers to be used for rendering and we can attach the Object to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>.</p>
<div class="fragment"><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a49d6bfe460ff1e0178c6d77b95d3dc5a">end</a>();</div><div class="line">    mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode()-&gt;attachObject(man);</div></div><!-- fragment --><p> In case you need multiple Ogre::Entities of the plane, you should call <a class="el" href="class_ogre_1_1_manual_object.html#a657275e617d9558951a3037f02b07efe" title="Convert this object to a Mesh. ">Ogre::ManualObject::convertToMesh</a> first and then use <a class="el" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185" title="Create an Entity (instance of a discrete mesh). ">Ogre::SceneManager::createEntity</a> as usual.</p>
<h1>Using vertex and index buffers directly</h1>
<p>This time we are going to create a plane using the lower level <a class="el" href="class_ogre_1_1_hardware_buffer.html" title="Abstract class defining common features of hardware buffers. ">Ogre::HardwareBuffer</a> primitives.</p>
<p>We start by creating a Mesh object. As this is a manual Mesh, we have to set the bounds of it explicitly. </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_ogre.html">Ogre</a>;</div><div class="line"></div><div class="line">        <a class="code" href="class_ogre_1_1_shared_ptr.html">MeshPtr</a> mesh = <a class="code" href="class_ogre_1_1_mesh_manager.html#a2efefa307b7987c5fcff7e8c47f79758">MeshManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_mesh_manager.html#ad99f5f2e2d045e5a4af301974e45c918">createManual</a>(yourMeshName, <a class="code" href="group___resources.html#gaa9ab155dab741621494def41928e03ae">RGN_DEFAULT</a>);</div><div class="line">        mesh-&gt;<a class="code" href="class_ogre_1_1_mesh.html#a8c40c34ec7c32009904c0cd730f68b5d">_setBounds</a>(<a class="code" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>({-100,-100,0}, {100,100,0});</div></div><!-- fragment --><p>Next we define what should end up in our vertex and index buffer. We will store all data interleaved in one buffer. This typically has some advantages due to cache coherency and also is what ManualObject does automatically for us.</p>
<div class="fragment"><div class="line">        <span class="keywordtype">float</span> vertices[32] = {</div><div class="line">            -100, -100, 0,  <span class="comment">// pos</span></div><div class="line">            0,0,1,          <span class="comment">// normal</span></div><div class="line">            0,1,            <span class="comment">// texcoord</span></div><div class="line">            100, -100, 0,</div><div class="line">            0,0,1,</div><div class="line">            1,1,</div><div class="line">            100,  100, 0,</div><div class="line">            0,0,1,</div><div class="line">            1,0,</div><div class="line">            -100,  100, 0 ,</div><div class="line">            0,0,1,</div><div class="line">            0,0 </div><div class="line">        };</div><div class="line"></div><div class="line">        <a class="code" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> faces[6] = {0,1,2,</div><div class="line">                           0,2,3 };</div></div><!-- fragment --><p> However we could also split the data into multiple buffers with lower precision to save some bytes on texture coordinates and normals.</p>
<p>To describe the vertex sources, we have to create a <a class="el" href="class_ogre_1_1_vertex_data.html" title="Summary class collecting together vertex source information. ">Ogre::VertexData</a> object. Notably it stores how many vertices we have.</p>
<div class="fragment"><div class="line">        mesh-&gt;<a class="code" href="class_ogre_1_1_mesh.html#a1fd9968ccd424f913a7f3f68639f3ecf">sharedVertexData</a> = <span class="keyword">new</span> VertexData();</div><div class="line">        mesh-&gt;<a class="code" href="class_ogre_1_1_mesh.html#a1fd9968ccd424f913a7f3f68639f3ecf">sharedVertexData</a>-&gt;<a class="code" href="class_ogre_1_1_vertex_data.html#a0b59b63cc2dbede1c5fc6a932fd2c10d">vertexCount</a> = 4;</div><div class="line">        VertexDeclaration* decl = mesh-&gt;<a class="code" href="class_ogre_1_1_mesh.html#a1fd9968ccd424f913a7f3f68639f3ecf">sharedVertexData</a>-&gt;<a class="code" href="class_ogre_1_1_vertex_data.html#abac9cde9c001b97cf1fea7fd05b79cf4">vertexDeclaration</a>;</div><div class="line">        VertexBufferBinding* bind = mesh-&gt;<a class="code" href="class_ogre_1_1_mesh.html#a1fd9968ccd424f913a7f3f68639f3ecf">sharedVertexData</a>-&gt;<a class="code" href="class_ogre_1_1_vertex_data.html#a1cf7dacb2a133d71620abd59cb3180b0">vertexBufferBinding</a>;</div></div><!-- fragment --><p> The actual description of our vertex buffer however is stored inside the <a class="el" href="class_ogre_1_1_vertex_declaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">Ogre::VertexDeclaration</a>.</p>
<div class="fragment"><div class="line">        <span class="keywordtype">size_t</span> offset = 0;</div><div class="line">        decl-&gt;addElement(0, offset, <a class="code" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa9ccf920d2572b15896f75ccf30fb150c">VET_FLOAT3</a>, <a class="code" href="group___render_system.html#gga0a62b3f2ede8992ff365bb013a8bc00dad04d50e91c2ec5377e610b3f5b9b07f2">VES_POSITION</a>);</div><div class="line">        offset += VertexElement::getTypeSize(<a class="code" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa9ccf920d2572b15896f75ccf30fb150c">VET_FLOAT3</a>);</div><div class="line">        decl-&gt;addElement(0, offset, <a class="code" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa9ccf920d2572b15896f75ccf30fb150c">VET_FLOAT3</a>, <a class="code" href="group___render_system.html#gga0a62b3f2ede8992ff365bb013a8bc00da1dec7d36a64625348e23af26c9231227">VES_NORMAL</a>);</div><div class="line">        offset += VertexElement::getTypeSize(<a class="code" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa9ccf920d2572b15896f75ccf30fb150c">VET_FLOAT3</a>);</div><div class="line">        decl-&gt;addElement(0, offset, <a class="code" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa0993ccf616ec6e7bf60fff2ef1705ce6">VET_FLOAT2</a>, <a class="code" href="group___render_system.html#gga0a62b3f2ede8992ff365bb013a8bc00da17abb855311f3a67bc31414cad8d6212">VES_TEXTURE_COORDINATES</a>, 0);</div><div class="line">        offset += VertexElement::getTypeSize(<a class="code" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa0993ccf616ec6e7bf60fff2ef1705ce6">VET_FLOAT2</a>);</div></div><!-- fragment --><p> Now we can continue to create the Hardware Buffers and upload our data.</p>
<div class="fragment"><div class="line">        <a class="code" href="namespace_ogre.html#a05ef9b65d4ed446b994636e371bf5aab">HardwareVertexBufferSharedPtr</a> vbuf =</div><div class="line">            HardwareBufferManager::getSingleton().createVertexBuffer(</div><div class="line">                offset, 4, HardwareBuffer::HBU_STATIC_WRITE_ONLY);</div><div class="line">        vbuf-&gt;<a class="code" href="class_ogre_1_1_hardware_buffer.html#a8c313688a0df3c28a36738c31fcbc3ee">writeData</a>(0, vbuf-&gt;getSizeInBytes(), vertices, <span class="keyword">true</span>);</div><div class="line">        bind-&gt;setBinding(0, vbuf);</div><div class="line"></div><div class="line">        <a class="code" href="namespace_ogre.html#ae906cf8e579ba8ade19879ec05b1a456">HardwareIndexBufferSharedPtr</a> ibuf = HardwareBufferManager::getSingleton().createIndexBuffer(</div><div class="line">            HardwareIndexBuffer::IT_16BIT, 6, HardwareBuffer::HBU_STATIC_WRITE_ONLY);</div><div class="line">        ibuf-&gt;<a class="code" href="class_ogre_1_1_hardware_buffer.html#a8c313688a0df3c28a36738c31fcbc3ee">writeData</a>(0, ibuf-&gt;getSizeInBytes(), faces, <span class="keyword">true</span>);</div></div><!-- fragment --><p> Note how we used the symbolical constant <code>0</code> to link the <a class="el" href="class_ogre_1_1_hardware_vertex_buffer.html" title="Specialisation of HardwareBuffer for a vertex buffer. ">Ogre::HardwareVertexBuffer</a> to the <a class="el" href="class_ogre_1_1_vertex_declaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">Ogre::VertexDeclaration</a>. This allows the underlying RenderSystem to swap VertexBuffers without changing the VertexDeclaration. i.e. render different Meshes that share the same vertex layout, without changing the state.</p>
<p>Finally we create the <a class="el" href="class_ogre_1_1_sub_mesh.html" title="Defines a part of a complete mesh. ">Ogre::SubMesh</a> that will be ultimately rendered.</p>
<div class="fragment"><div class="line">        SubMesh* sub = mesh-&gt;<a class="code" href="class_ogre_1_1_mesh.html#a23d5c021503b8fac8938be4ba956f2ce">createSubMesh</a>();</div><div class="line">        sub-&gt;<a class="code" href="class_ogre_1_1_sub_mesh.html#a931e3764e3bf1c3ef7431fc852770fb1">useSharedVertices</a> = <span class="keyword">true</span>;</div><div class="line">        sub-&gt;indexData-&gt;indexBuffer = ibuf;</div><div class="line">        sub-&gt;indexData-&gt;indexCount = 6;</div><div class="line">        sub-&gt;indexData-&gt;indexStart = 0;</div></div><!-- fragment --><p> Note that while our VertexBuffer is shared, the IndexBuffer is not. This allows rendering different faces of the same object using different Materials. Here each SubMesh links the faces (IndexBuffer) to the according material. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
