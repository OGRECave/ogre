
//#include "SyntaxHighlightingMisc.h"

@property( use_planar_reflections )

@property( syntax == glsl )
	@piece( DeclPlanarReflTextures )
		uniform sampler2D planarReflectionTex;
	@end
@end
@property( syntax == hlsl )
	@piece( DeclPlanarReflTextures )
		Texture2D<float4> planarReflectionTex	: register(t@value(planarReflectionReg));
		SamplerState planarReflectionSampler	: register(s@value(planarReflectionReg));
	@end
@end
@property( syntax == metal )
	@piece( DeclPlanarReflTextures )
		, texture2d<float> planarReflectionTex	[[texture(@value(planarReflectionReg))]]
		, sampler planarReflectionSampler		[[sampler(@value(planarReflectionReg))]]
	@end
@end

@piece( DoPlanarReflectionsPS )
	@property( syntax == glsl )
		uint planarReflectionIdx = floatBitsToUint( instance.worldMaterialIdx[inPs.drawId].w );
	@end
	@property( syntax == hlsl )
		uint planarReflectionIdx = asuint( worldMaterialIdx[inPs.drawId].w );
	@end
	@property( syntax == metal )
		ushort planarReflectionIdx = inPs.planarReflectionIdx;
	@end

	float4 planarReflection = passBuf.planarReflections[planarReflectionIdx];
	float distanceToPlanarReflPlane = dot( planarReflection.xyz, inPs.pos.xyz ) + planarReflection.w;
	float3 pointInPlane = inPs.pos.xyz - nNormal * distanceToPlanarReflPlane;
	float3 projPointInPlane = mul( float4( pointInPlane.xyz, 1.0 ), passBuf.planarReflProjectionMat ).xyw;
	float2 planarReflUVs = projPointInPlane.xy /= projPointInPlane.z;

	float3 planarReflectionS = textureLod( planarReflectionTex, planarReflUVs.xy, ROUGHNESS * 12.0 ).xyz;

	//Fade out as our surface gets away from the reflection plane (planarWeight = 0 means fully faded out)
	float planarWeight = max( 1.0 - abs( distanceToPlanarReflPlane ) * passBuf.invMaxDistanceToPlanarRefl.x, 0.0 );
	planarWeight = sqrt( planarWeight );
	planarWeight = smoothstep( 0.0, 1.0, planarWeight );
	//Fade out if projecting pointInPlane failed (we landed outside the screen, we have no information)
	float2 boundary = abs( planarReflUVs.xy - float2(0.5, 0.5) ) * 2.0;
	float fadeOnBorder = 1.0 - saturate( (boundary.x - 0.975) * 40 );
	fadeOnBorder *= 1.0 - saturate( (boundary.y - 0.975) * 40 );
	fadeOnBorder = smoothstep( 0.0, 1.0, fadeOnBorder );
	planarWeight *= lerp( fadeOnBorder, 1.0, 1.0 - min( abs(distanceToPlanarReflPlane) * 1000.0, 1.0 ) );
	@property( hlms_use_ssr || use_envprobe_map )
		envColourS = lerp( envColourS, planarReflectionS, planarWeight );
	@end @property( !hlms_use_ssr && !use_envprobe_map )
		float3 envColourS = planarReflectionS * planarWeight;
		float3 envColourD = vec3( 0, 0, 0 );
	@end
@end

@end ///use_planar_reflections
